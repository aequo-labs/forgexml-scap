// Code generated by forgexml UI generator. DO NOT EDIT.
package handlers

import (
	"embed"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	_ "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5"
	"github.com/aequo-labs/webserver-core-ui/pkg/webserver"

	"github.com/aequo-labs/forgexml-scap/cmd/ui/internal/state"
)

// Handlers provides HTTP handlers for the UI application.
type Handlers struct {
	srv      *webserver.UIServer
	state    *state.XMLDocumentState
	schemaFS embed.FS
}

// NewHandlers creates a new Handlers instance.
func NewHandlers(srv *webserver.UIServer, state *state.XMLDocumentState, schemaFS embed.FS) *Handlers {
	return &Handlers{
		srv:      srv,
		state:    state,
		schemaFS: schemaFS,
	}
}

// HomePageData extends PageData with home page specific fields.
type HomePageData struct {
	webserver.PageData
	RootElementTypes []string
}

// HandleHome renders the home page.
func (h *Handlers) HandleHome(w http.ResponseWriter, r *http.Request) {
	baseData := h.srv.GetBasePageData("home")
	baseData.Title = "Xmlschema Editor - Home"
	h.srv.EnrichPageData(&baseData)
	data := HomePageData{
		PageData:         baseData,
		RootElementTypes: h.state.GetRootElementTypes(),
	}
	h.srv.RenderPageWithContent(w, "home-content", data)
}

// HandleTreeView renders the tree navigation view.
func (h *Handlers) HandleTreeView(w http.ResponseWriter, r *http.Request) {
	data := h.srv.GetBasePageData("tree")
	data.Title = "Xmlschema Editor - Tree View"
	h.srv.EnrichPageData(&data)
	h.srv.RenderPageWithContent(w, "tree-content", data)
}

// HandleEditElement renders the edit form for an element.
func (h *Handlers) HandleEditElement(w http.ResponseWriter, r *http.Request) {
	path := r.URL.Query().Get("path")
	if path == "" {
		http.Error(w, "path parameter required", http.StatusBadRequest)
		return
	}

	data := h.srv.GetBasePageData("edit")
	data.Title = "Xmlschema Editor - Edit Element"
	h.srv.EnrichPageData(&data)
	h.srv.RenderPageWithContent(w, "edit-content", data)
}

// HandleCreateElement renders the create form for a new element.
func (h *Handlers) HandleCreateElement(w http.ResponseWriter, r *http.Request) {
	typeName := r.URL.Query().Get("type")
	if typeName == "" {
		http.Error(w, "type parameter required", http.StatusBadRequest)
		return
	}

	data := h.srv.GetBasePageData("create")
	data.Title = "Xmlschema Editor - Create Element"
	h.srv.EnrichPageData(&data)
	h.srv.RenderPageWithContent(w, "edit-content", data)
}

// HandleExportPage renders the export page.
func (h *Handlers) HandleExportPage(w http.ResponseWriter, r *http.Request) {
	data := h.srv.GetBasePageData("export")
	data.Title = "Xmlschema Editor - Export"
	h.srv.EnrichPageData(&data)
	h.srv.RenderPageWithContent(w, "export-content", data)
}

// Tree API handlers

// HandleTreeRoot returns the root elements of the XML tree.
func (h *Handlers) HandleTreeRoot(w http.ResponseWriter, r *http.Request) {
	nodes, err := h.state.GetRootNodes()
	if err != nil {
		h.jsonError(w, "Failed to get root nodes", err, http.StatusInternalServerError)
		return
	}
	h.jsonResponse(w, nodes)
}

// HandleTreeChildren returns child elements of a given path.
func (h *Handlers) HandleTreeChildren(w http.ResponseWriter, r *http.Request) {
	path := r.URL.Query().Get("path")
	if path == "" {
		h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
		return
	}

	nodes, err := h.state.GetChildNodes(path)
	if err != nil {
		h.jsonError(w, "Failed to get child nodes", err, http.StatusInternalServerError)
		return
	}
	h.jsonResponse(w, nodes)
}

// HandleTreeElement returns details for a specific element.
func (h *Handlers) HandleTreeElement(w http.ResponseWriter, r *http.Request) {
	path := r.URL.Query().Get("path")
	if path == "" {
		h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
		return
	}

	element, err := h.state.GetElement(path)
	if err != nil {
		h.jsonError(w, "Failed to get element", err, http.StatusInternalServerError)
		return
	}
	h.jsonResponse(w, element)
}

// CRUD API handlers

// HandleListElements returns all elements of a given type.
func (h *Handlers) HandleListElements(w http.ResponseWriter, r *http.Request) {
	typeName := r.PathValue("type")
	if typeName == "" {
		h.jsonError(w, "type parameter required", nil, http.StatusBadRequest)
		return
	}

	elements, err := h.state.ListElementsByType(typeName)
	if err != nil {
		h.jsonError(w, "Failed to list elements", err, http.StatusInternalServerError)
		return
	}
	h.jsonResponse(w, elements)
}

// HandleGetElement returns a single element by path.
func (h *Handlers) HandleGetElement(w http.ResponseWriter, r *http.Request) {
	path := r.URL.Query().Get("path")
	if path == "" {
		h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
		return
	}

	element, err := h.state.GetElement(path)
	if err != nil {
		h.jsonError(w, "Failed to get element", err, http.StatusInternalServerError)
		return
	}
	h.jsonResponse(w, element)
}

// HandleCreateElementAPI creates a new element.
func (h *Handlers) HandleCreateElementAPI(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Type       string          `json:"type"`
		ParentPath string          `json:"parentPath"`
		Data       json.RawMessage `json:"data"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.jsonError(w, "Invalid request body", err, http.StatusBadRequest)
		return
	}

	path, err := h.state.CreateElement(req.Type, req.ParentPath, req.Data)
	if err != nil {
		h.jsonError(w, "Failed to create element", err, http.StatusInternalServerError)
		return
	}

	h.jsonResponse(w, map[string]string{"path": path})
}

// HandleUpdateElement updates an existing element.
func (h *Handlers) HandleUpdateElement(w http.ResponseWriter, r *http.Request) {
	path := r.URL.Query().Get("path")
	if path == "" {
		h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
		return
	}

	var data json.RawMessage
	if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
		h.jsonError(w, "Invalid request body", err, http.StatusBadRequest)
		return
	}

	if err := h.state.UpdateElement(path, data); err != nil {
		h.jsonError(w, "Failed to update element", err, http.StatusInternalServerError)
		return
	}

	h.jsonResponse(w, map[string]string{"status": "updated"})
}

// HandleDeleteElement deletes an element.
func (h *Handlers) HandleDeleteElement(w http.ResponseWriter, r *http.Request) {
	path := r.URL.Query().Get("path")
	if path == "" {
		h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
		return
	}

	if err := h.state.DeleteElement(path); err != nil {
		h.jsonError(w, "Failed to delete element", err, http.StatusInternalServerError)
		return
	}

	h.jsonResponse(w, map[string]string{"status": "deleted"})
}

// Import/Export handlers

// HandleImport imports an XML file.
func (h *Handlers) HandleImport(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		h.jsonError(w, "Failed to parse form", err, http.StatusBadRequest)
		return
	}

	file, header, err := r.FormFile("file")
	if err != nil {
		h.jsonError(w, "Failed to get uploaded file", err, http.StatusBadRequest)
		return
	}
	defer file.Close()

	content, err := io.ReadAll(file)
	if err != nil {
		h.jsonError(w, "Failed to read file", err, http.StatusInternalServerError)
		return
	}

	if err := h.state.LoadFromBytes(content, header.Filename); err != nil {
		h.jsonError(w, "Failed to parse XML", err, http.StatusBadRequest)
		return
	}

	h.jsonResponse(w, map[string]string{
		"status":   "imported",
		"filename": header.Filename,
	})
}

// HandleExport exports the current document as XML.
func (h *Handlers) HandleExport(w http.ResponseWriter, r *http.Request) {
	content, filename, err := h.state.ExportToBytes()
	if err != nil {
		h.jsonError(w, "Failed to export XML", err, http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/xml")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", filename))
	w.Write(content)
}

// HandleExportPreview returns the XML content without downloading.
func (h *Handlers) HandleExportPreview(w http.ResponseWriter, r *http.Request) {
	content, _, err := h.state.ExportToBytes()
	if err != nil {
		h.jsonError(w, "Failed to export XML", err, http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/xml")
	w.Write(content)
}

// HandleValidate validates the current document against the XSD.
func (h *Handlers) HandleValidate(w http.ResponseWriter, r *http.Request) {
	errors, err := h.state.Validate()
	if err != nil {
		h.jsonError(w, "Validation failed", err, http.StatusInternalServerError)
		return
	}

	h.jsonResponse(w, map[string]interface{}{
		"valid":  len(errors) == 0,
		"errors": errors,
	})
}

// Type information handlers

// HandleListTypes returns all available element types.
func (h *Handlers) HandleListTypes(w http.ResponseWriter, r *http.Request) {
	types := h.state.GetAvailableTypes()
	h.jsonResponse(w, types)
}

// HandleGetType returns metadata for a specific type.
func (h *Handlers) HandleGetType(w http.ResponseWriter, r *http.Request) {
	name := r.PathValue("name")
	if name == "" {
		h.jsonError(w, "name parameter required", nil, http.StatusBadRequest)
		return
	}

	typeInfo, err := h.state.GetTypeMetadata(name)
	if err != nil {
		h.jsonError(w, "Type not found", err, http.StatusNotFound)
		return
	}
	h.jsonResponse(w, typeInfo)
}

// HandleGetConcreteTypes returns concrete types for an abstract type.
func (h *Handlers) HandleGetConcreteTypes(w http.ResponseWriter, r *http.Request) {
	name := r.PathValue("name")
	if name == "" {
		h.jsonError(w, "name parameter required", nil, http.StatusBadRequest)
		return
	}

	types, err := h.state.GetConcreteTypes(name)
	if err != nil {
		h.jsonError(w, "Failed to get concrete types", err, http.StatusInternalServerError)
		return
	}
	h.jsonResponse(w, types)
}

// HandleGetValidChildTypes returns valid child types for a parent type.
func (h *Handlers) HandleGetValidChildTypes(w http.ResponseWriter, r *http.Request) {
	name := r.PathValue("name")
	if name == "" {
		h.jsonError(w, "name parameter required", nil, http.StatusBadRequest)
		return
	}

	types := h.state.GetValidChildTypes(name)
	h.jsonResponse(w, types)
}

// HandleGetRootTypes returns types that can be used as document roots.
func (h *Handlers) HandleGetRootTypes(w http.ResponseWriter, r *http.Request) {
	types := h.state.GetRootElementTypes()
	h.jsonResponse(w, types)
}

// HandleHealth returns health status for the status indicator.
func (h *Handlers) HandleHealth(w http.ResponseWriter, r *http.Request) {
	h.jsonResponse(w, map[string]interface{}{
		"status":    "healthy",
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	})
}

// HandleInstanceDiagram generates a Mermaid diagram from the current XML document.
func (h *Handlers) HandleInstanceDiagram(w http.ResponseWriter, r *http.Request) {
	diagramType := r.URL.Query().Get("type")
	if diagramType == "" {
		diagramType = "flowchart"
	}

	diagram, err := h.state.GenerateInstanceDiagram(diagramType)
	if err != nil {
		h.jsonError(w, "Failed to generate diagram", err, http.StatusInternalServerError)
		return
	}

	h.jsonResponse(w, map[string]string{
		"diagram": diagram,
		"type":    diagramType,
	})
}

// Helper methods

func (h *Handlers) jsonResponse(w http.ResponseWriter, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(data)
}

func (h *Handlers) jsonError(w http.ResponseWriter, message string, err error, status int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)

	response := map[string]string{"error": message}
	if err != nil {
		response["details"] = err.Error()
	}
	json.NewEncoder(w).Encode(response)
}
