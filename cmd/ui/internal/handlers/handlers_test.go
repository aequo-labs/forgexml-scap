// Code generated by forgexml UI generator. DO NOT EDIT.
package handlers

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/aequo-labs/forgexml-scap/cmd/ui/internal/state"
)

// TestSuite holds shared test resources.
type TestSuite struct {
	handlers *Handlers
	state    *state.XMLDocumentState
}

// setupTestSuite creates a test suite with initialized state.
func setupTestSuite(t *testing.T) *TestSuite {
	t.Helper()

	xmlState := state.NewXMLDocumentState()

	// We can't easily create a full UIServer in tests, so we'll test handlers
	// that don't require template rendering by using nil server (API handlers only)
	handlers := &Handlers{
		srv:   nil,
		state: xmlState,
	}

	return &TestSuite{
		handlers: handlers,
		state:    xmlState,
	}
}

// makeRequest is a helper to create and execute HTTP requests.
func (ts *TestSuite) makeRequest(t *testing.T, method, path string, body interface{}) *httptest.ResponseRecorder {
	t.Helper()

	var reqBody io.Reader
	if body != nil {
		jsonBytes, err := json.Marshal(body)
		if err != nil {
			t.Fatalf("Failed to marshal request body: %v", err)
		}
		reqBody = bytes.NewReader(jsonBytes)
	}

	req := httptest.NewRequest(method, path, reqBody)
	if body != nil {
		req.Header.Set("Content-Type", "application/json")
	}

	rr := httptest.NewRecorder()
	return rr
}

// assertJSONResponse checks that the response is valid JSON.
func assertJSONResponse(t *testing.T, rr *httptest.ResponseRecorder) map[string]interface{} {
	t.Helper()

	if rr.Header().Get("Content-Type") != "application/json" {
		t.Errorf("Expected Content-Type application/json, got %s", rr.Header().Get("Content-Type"))
	}

	var result map[string]interface{}
	if err := json.Unmarshal(rr.Body.Bytes(), &result); err != nil {
		// Try array response
		var arr []interface{}
		if err2 := json.Unmarshal(rr.Body.Bytes(), &arr); err2 != nil {
			t.Fatalf("Response is not valid JSON: %v\nBody: %s", err, rr.Body.String())
		}
		return map[string]interface{}{"items": arr}
	}
	return result
}

// assertStatusCode checks the HTTP status code.
func assertStatusCode(t *testing.T, rr *httptest.ResponseRecorder, expected int) {
	t.Helper()
	if rr.Code != expected {
		t.Errorf("Expected status %d, got %d. Body: %s", expected, rr.Code, rr.Body.String())
	}
}

// =============================================================================
// Health API Tests
// =============================================================================

func TestHandleHealth(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/health", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleHealth(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
	result := assertJSONResponse(t, rr)

	if result["status"] != "healthy" {
		t.Errorf("Expected status 'healthy', got %v", result["status"])
	}
	if result["timestamp"] == nil {
		t.Error("Expected timestamp in response")
	}
}

// =============================================================================
// Tree API Tests
// =============================================================================

func TestHandleTreeRoot_Empty(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/tree/root", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleTreeRoot(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
	// Empty state should return empty array or null
}

func TestHandleTreeChildren_MissingPath(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/tree/children", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleTreeChildren(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
	result := assertJSONResponse(t, rr)

	if result["error"] == nil {
		t.Error("Expected error message in response")
	}
}

func TestHandleTreeChildren_WithPath(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/tree/children?path=/root", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleTreeChildren(rr, req)

	// Should return OK even if path doesn't exist (empty children)
	// or error if state requires valid path
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d", rr.Code)
	}
}

func TestHandleTreeElement_MissingPath(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/tree/element", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleTreeElement(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

// =============================================================================
// Type Information API Tests
// =============================================================================

func TestHandleListTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleListTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

func TestHandleGetRootTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/root", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetRootTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

func TestHandleGetType_MissingName(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

func TestHandleGetConcreteTypes_MissingName(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types//concrete", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetConcreteTypes(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

func TestHandleGetValidChildTypes_MissingName(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types//children", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

// =============================================================================
// CRUD API Tests - Create
// =============================================================================

func TestHandleCreateElementAPI_InvalidJSON(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("POST", "/api/elements", strings.NewReader("invalid json"))
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

func TestHandleCreateElementAPI_ValidRequest(t *testing.T) {
	ts := setupTestSuite(t)

	body := map[string]interface{}{
		"type":       "TestElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(body)

	req := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(rr, req)

	// May fail if type doesn't exist, but should not panic
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// =============================================================================
// CRUD API Tests - Read
// =============================================================================

func TestHandleGetElement_MissingPath(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetElement(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

func TestHandleGetElement_WithPath(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements?path=/nonexistent", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetElement(rr, req)

	// Should return error for non-existent path
	if rr.Code != http.StatusInternalServerError && rr.Code != http.StatusNotFound {
		t.Logf("Got status %d for non-existent element (may be expected)", rr.Code)
	}
}

func TestHandleListElements_MissingType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

// =============================================================================
// CRUD API Tests - Update
// =============================================================================

func TestHandleUpdateElement_MissingPath(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("PUT", "/api/elements", strings.NewReader("{}"))
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	ts.handlers.HandleUpdateElement(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

func TestHandleUpdateElement_InvalidJSON(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("PUT", "/api/elements?path=/test", strings.NewReader("invalid"))
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	ts.handlers.HandleUpdateElement(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

// =============================================================================
// CRUD API Tests - Delete
// =============================================================================

func TestHandleDeleteElement_MissingPath(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("DELETE", "/api/elements", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleDeleteElement(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

func TestHandleDeleteElement_NonExistent(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("DELETE", "/api/elements?path=/nonexistent", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleDeleteElement(rr, req)

	// Should fail for non-existent path
	if rr.Code == http.StatusOK {
		t.Log("Delete of non-existent path succeeded (may be expected behavior)")
	}
}

// =============================================================================
// Import/Export API Tests
// =============================================================================

func TestHandleExport_EmptyDocument(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/export", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleExport(rr, req)

	// Should return error or empty XML for empty state
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d", rr.Code)
	}
}

func TestHandleExportPreview_EmptyDocument(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/export/preview", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleExportPreview(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d", rr.Code)
	}
}

func TestHandleValidate_EmptyDocument(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("POST", "/api/validate", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleValidate(rr, req)

	// Validation of empty doc may succeed (valid=true) or fail
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d", rr.Code)
	}
}

// TestHandleValidate_ResponseStructure tests that validation returns proper structure.
func TestHandleValidate_ResponseStructure(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("POST", "/api/validate", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleValidate(rr, req)

	if rr.Code != http.StatusOK {
		t.Errorf("Expected status 200, got %d", rr.Code)
		return
	}

	var result map[string]interface{}
	if err := json.Unmarshal(rr.Body.Bytes(), &result); err != nil {
		t.Fatalf("Failed to parse response: %v", err)
	}

	// Check response has required fields
	if _, ok := result["valid"]; !ok {
		t.Error("Response missing 'valid' field")
	}
	if _, ok := result["errors"]; !ok {
		t.Error("Response missing 'errors' field")
	}
}

// TestHandleValidate_WithDocument tests validation after creating a document.
func TestHandleValidate_WithDocument(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types to find a root type
	typesReq := httptest.NewRequest("GET", "/api/types", nil)
	typesRR := httptest.NewRecorder()
	ts.handlers.HandleListTypes(typesRR, typesReq)

	if typesRR.Code != http.StatusOK {
		t.Skipf("Could not get types: %d", typesRR.Code)
	}

	var types []map[string]interface{}
	if err := json.Unmarshal(typesRR.Body.Bytes(), &types); err != nil {
		t.Skipf("Failed to parse types: %v", err)
	}

	if len(types) == 0 {
		t.Skip("No types available")
	}

	// Find a root type
	var rootType string
	for _, typeInfo := range types {
		if isRoot, ok := typeInfo["isRoot"].(bool); ok && isRoot {
			if name, ok := typeInfo["name"].(string); ok {
				rootType = name
				break
			}
		}
	}

	if rootType == "" {
		t.Skip("No root type found")
	}

	// Create a document with the root type
	createBody := fmt.Sprintf(`{"type":"%s"}`, rootType)
	createReq := httptest.NewRequest("POST", "/api/elements", strings.NewReader(createBody))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()
	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code != http.StatusOK && createRR.Code != http.StatusCreated {
		t.Skipf("Could not create element: %d - %s", createRR.Code, createRR.Body.String())
	}

	// Now validate
	validateReq := httptest.NewRequest("POST", "/api/validate", nil)
	validateRR := httptest.NewRecorder()
	ts.handlers.HandleValidate(validateRR, validateReq)

	if validateRR.Code != http.StatusOK {
		t.Errorf("Validation failed: %d - %s", validateRR.Code, validateRR.Body.String())
		return
	}

	var result map[string]interface{}
	if err := json.Unmarshal(validateRR.Body.Bytes(), &result); err != nil {
		t.Fatalf("Failed to parse validation response: %v", err)
	}

	// Check that errors is an array (may be empty or contain validation errors)
	errors, ok := result["errors"].([]interface{})
	if !ok {
		t.Error("Expected 'errors' to be an array")
		return
	}

	// If there are errors, verify they have the correct structure
	for i, errItem := range errors {
		errMap, ok := errItem.(map[string]interface{})
		if !ok {
			t.Errorf("Error %d is not an object", i)
			continue
		}
		if _, ok := errMap["path"]; !ok {
			t.Errorf("Error %d missing 'path' field", i)
		}
		if _, ok := errMap["message"]; !ok {
			t.Errorf("Error %d missing 'message' field", i)
		}
	}

	t.Logf("Validation result: valid=%v, errors=%d", result["valid"], len(errors))
}

// TestHandleValidate_ErrorPaths tests that validation errors include proper XPath paths.
func TestHandleValidate_ErrorPaths(t *testing.T) {
	ts := setupTestSuite(t)

	// Create an empty document first
	req := httptest.NewRequest("POST", "/api/validate", nil)
	rr := httptest.NewRecorder()
	ts.handlers.HandleValidate(rr, req)

	if rr.Code != http.StatusOK {
		t.Skipf("Validation endpoint error: %d", rr.Code)
	}

	var result map[string]interface{}
	if err := json.Unmarshal(rr.Body.Bytes(), &result); err != nil {
		t.Fatalf("Failed to parse response: %v", err)
	}

	errors, ok := result["errors"].([]interface{})
	if !ok {
		t.Skip("No errors array in response")
	}

	// Verify error path format if errors exist
	for i, errItem := range errors {
		errMap, ok := errItem.(map[string]interface{})
		if !ok {
			continue
		}
		path, ok := errMap["path"].(string)
		if !ok {
			t.Errorf("Error %d path is not a string", i)
			continue
		}
		// Paths should start with / for XPath format
		if path != "" && path[0] != '/' {
			t.Errorf("Error %d path '%s' should start with /", i, path)
		}
	}
}

func TestHandleImport_NoFile(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("POST", "/api/import", nil)
	rr := httptest.NewRecorder()

	ts.handlers.HandleImport(rr, req)

	assertStatusCode(t, rr, http.StatusBadRequest)
}

func TestHandleImport_WithFile(t *testing.T) {
	ts := setupTestSuite(t)

	// Create multipart form with XML file
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	part, err := writer.CreateFormFile("file", "test.xml")
	if err != nil {
		t.Fatalf("Failed to create form file: %v", err)
	}

	// Write minimal XML content
	xmlContent := `<?xml version="1.0" encoding="UTF-8"?><root></root>`
	part.Write([]byte(xmlContent))
	writer.Close()

	req := httptest.NewRequest("POST", "/api/import", &buf)
	req.Header.Set("Content-Type", writer.FormDataContentType())
	rr := httptest.NewRecorder()

	ts.handlers.HandleImport(rr, req)

	// May fail if XML doesn't match expected schema, but should process the request
	if rr.Code != http.StatusOK && rr.Code != http.StatusBadRequest && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// =============================================================================
// CRUD Integration Tests - Full Lifecycle per Type
// =============================================================================

// TestActuateType_CRUD tests Create, Read, Update, Delete for ActuateType.
func TestActuateType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ActuateType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ActuateType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestActuateType_ListByType tests listing elements of type ActuateType.
func TestActuateType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ActuateType", nil)
	req.SetPathValue("type", "ActuateType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestActuateType_GetTypeMetadata tests getting type metadata for ActuateType.
func TestActuateType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ActuateType", nil)
	req.SetPathValue("name", "ActuateType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressDetails_CRUD tests Create, Read, Update, Delete for AddressDetails.
func TestAddressDetails_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressDetails",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressDetails returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressDetails_ListByType tests listing elements of type AddressDetails.
func TestAddressDetails_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressDetails", nil)
	req.SetPathValue("type", "AddressDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressDetails_GetTypeMetadata tests getting type metadata for AddressDetails.
func TestAddressDetails_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressDetails", nil)
	req.SetPathValue("name", "AddressDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressDetails_GetValidChildTypes tests getting valid child types for AddressDetails.
func TestAddressDetails_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressDetails/children", nil)
	req.SetPathValue("name", "AddressDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAddressDetailsElement_CRUD tests Create, Read, Update, Delete for AddressDetailsElement.
func TestAddressDetailsElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressDetailsElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressDetailsElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressDetailsElement_ListByType tests listing elements of type AddressDetailsElement.
func TestAddressDetailsElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressDetailsElement", nil)
	req.SetPathValue("type", "AddressDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressDetailsElement_GetTypeMetadata tests getting type metadata for AddressDetailsElement.
func TestAddressDetailsElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressDetailsElement", nil)
	req.SetPathValue("name", "AddressDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressDetailsElement_GetValidChildTypes tests getting valid child types for AddressDetailsElement.
func TestAddressDetailsElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressDetailsElement/children", nil)
	req.SetPathValue("name", "AddressDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAddressElementType_CRUD tests Create, Read, Update, Delete for AddressElementType.
func TestAddressElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressElementType_ListByType tests listing elements of type AddressElementType.
func TestAddressElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressElementType", nil)
	req.SetPathValue("type", "AddressElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressElementType_GetTypeMetadata tests getting type metadata for AddressElementType.
func TestAddressElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressElementType", nil)
	req.SetPathValue("name", "AddressElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressIdentifierElementType_CRUD tests Create, Read, Update, Delete for AddressIdentifierElementType.
func TestAddressIdentifierElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressIdentifierElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressIdentifierElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressIdentifierElementType_ListByType tests listing elements of type AddressIdentifierElementType.
func TestAddressIdentifierElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressIdentifierElementType", nil)
	req.SetPathValue("type", "AddressIdentifierElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressIdentifierElementType_GetTypeMetadata tests getting type metadata for AddressIdentifierElementType.
func TestAddressIdentifierElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressIdentifierElementType", nil)
	req.SetPathValue("name", "AddressIdentifierElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLatitudeDirectionElementType_CRUD tests Create, Read, Update, Delete for AddressLatitudeDirectionElementType.
func TestAddressLatitudeDirectionElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressLatitudeDirectionElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressLatitudeDirectionElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressLatitudeDirectionElementType_ListByType tests listing elements of type AddressLatitudeDirectionElementType.
func TestAddressLatitudeDirectionElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressLatitudeDirectionElementType", nil)
	req.SetPathValue("type", "AddressLatitudeDirectionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLatitudeDirectionElementType_GetTypeMetadata tests getting type metadata for AddressLatitudeDirectionElementType.
func TestAddressLatitudeDirectionElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressLatitudeDirectionElementType", nil)
	req.SetPathValue("name", "AddressLatitudeDirectionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLatitudeElementType_CRUD tests Create, Read, Update, Delete for AddressLatitudeElementType.
func TestAddressLatitudeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressLatitudeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressLatitudeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressLatitudeElementType_ListByType tests listing elements of type AddressLatitudeElementType.
func TestAddressLatitudeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressLatitudeElementType", nil)
	req.SetPathValue("type", "AddressLatitudeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLatitudeElementType_GetTypeMetadata tests getting type metadata for AddressLatitudeElementType.
func TestAddressLatitudeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressLatitudeElementType", nil)
	req.SetPathValue("name", "AddressLatitudeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLineElement_CRUD tests Create, Read, Update, Delete for AddressLineElement.
func TestAddressLineElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressLineElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressLineElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressLineElement_ListByType tests listing elements of type AddressLineElement.
func TestAddressLineElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressLineElement", nil)
	req.SetPathValue("type", "AddressLineElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLineElement_GetTypeMetadata tests getting type metadata for AddressLineElement.
func TestAddressLineElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressLineElement", nil)
	req.SetPathValue("name", "AddressLineElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLineElementType_CRUD tests Create, Read, Update, Delete for AddressLineElementType.
func TestAddressLineElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressLineElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressLineElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressLineElementType_ListByType tests listing elements of type AddressLineElementType.
func TestAddressLineElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressLineElementType", nil)
	req.SetPathValue("type", "AddressLineElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLineElementType_GetTypeMetadata tests getting type metadata for AddressLineElementType.
func TestAddressLineElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressLineElementType", nil)
	req.SetPathValue("name", "AddressLineElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLinesType_CRUD tests Create, Read, Update, Delete for AddressLinesType.
func TestAddressLinesType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressLinesType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressLinesType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressLinesType_ListByType tests listing elements of type AddressLinesType.
func TestAddressLinesType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressLinesType", nil)
	req.SetPathValue("type", "AddressLinesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLinesType_GetTypeMetadata tests getting type metadata for AddressLinesType.
func TestAddressLinesType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressLinesType", nil)
	req.SetPathValue("name", "AddressLinesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLinesType_GetValidChildTypes tests getting valid child types for AddressLinesType.
func TestAddressLinesType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressLinesType/children", nil)
	req.SetPathValue("name", "AddressLinesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAddressLongitudeDirectionElementType_CRUD tests Create, Read, Update, Delete for AddressLongitudeDirectionElementType.
func TestAddressLongitudeDirectionElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressLongitudeDirectionElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressLongitudeDirectionElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressLongitudeDirectionElementType_ListByType tests listing elements of type AddressLongitudeDirectionElementType.
func TestAddressLongitudeDirectionElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressLongitudeDirectionElementType", nil)
	req.SetPathValue("type", "AddressLongitudeDirectionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLongitudeDirectionElementType_GetTypeMetadata tests getting type metadata for AddressLongitudeDirectionElementType.
func TestAddressLongitudeDirectionElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressLongitudeDirectionElementType", nil)
	req.SetPathValue("name", "AddressLongitudeDirectionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLongitudeElementType_CRUD tests Create, Read, Update, Delete for AddressLongitudeElementType.
func TestAddressLongitudeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddressLongitudeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddressLongitudeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddressLongitudeElementType_ListByType tests listing elements of type AddressLongitudeElementType.
func TestAddressLongitudeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddressLongitudeElementType", nil)
	req.SetPathValue("type", "AddressLongitudeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddressLongitudeElementType_GetTypeMetadata tests getting type metadata for AddressLongitudeElementType.
func TestAddressLongitudeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddressLongitudeElementType", nil)
	req.SetPathValue("name", "AddressLongitudeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddresseeIndicatorElementType_CRUD tests Create, Read, Update, Delete for AddresseeIndicatorElementType.
func TestAddresseeIndicatorElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AddresseeIndicatorElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AddresseeIndicatorElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAddresseeIndicatorElementType_ListByType tests listing elements of type AddresseeIndicatorElementType.
func TestAddresseeIndicatorElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AddresseeIndicatorElementType", nil)
	req.SetPathValue("type", "AddresseeIndicatorElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAddresseeIndicatorElementType_GetTypeMetadata tests getting type metadata for AddresseeIndicatorElementType.
func TestAddresseeIndicatorElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AddresseeIndicatorElementType", nil)
	req.SetPathValue("name", "AddresseeIndicatorElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAdministrativeAreaElement_CRUD tests Create, Read, Update, Delete for AdministrativeAreaElement.
func TestAdministrativeAreaElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AdministrativeAreaElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AdministrativeAreaElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAdministrativeAreaElement_ListByType tests listing elements of type AdministrativeAreaElement.
func TestAdministrativeAreaElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AdministrativeAreaElement", nil)
	req.SetPathValue("type", "AdministrativeAreaElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAdministrativeAreaElement_GetTypeMetadata tests getting type metadata for AdministrativeAreaElement.
func TestAdministrativeAreaElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AdministrativeAreaElement", nil)
	req.SetPathValue("name", "AdministrativeAreaElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAdministrativeAreaElement_GetValidChildTypes tests getting valid child types for AdministrativeAreaElement.
func TestAdministrativeAreaElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AdministrativeAreaElement/children", nil)
	req.SetPathValue("name", "AdministrativeAreaElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAdministrativeAreaElementType_CRUD tests Create, Read, Update, Delete for AdministrativeAreaElementType.
func TestAdministrativeAreaElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AdministrativeAreaElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AdministrativeAreaElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAdministrativeAreaElementType_ListByType tests listing elements of type AdministrativeAreaElementType.
func TestAdministrativeAreaElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AdministrativeAreaElementType", nil)
	req.SetPathValue("type", "AdministrativeAreaElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAdministrativeAreaElementType_GetTypeMetadata tests getting type metadata for AdministrativeAreaElementType.
func TestAdministrativeAreaElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AdministrativeAreaElementType", nil)
	req.SetPathValue("name", "AdministrativeAreaElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAdministrativeAreaElementType_GetValidChildTypes tests getting valid child types for AdministrativeAreaElementType.
func TestAdministrativeAreaElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AdministrativeAreaElementType/children", nil)
	req.SetPathValue("name", "AdministrativeAreaElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAdministrativeAreaNameElementType_CRUD tests Create, Read, Update, Delete for AdministrativeAreaNameElementType.
func TestAdministrativeAreaNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AdministrativeAreaNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AdministrativeAreaNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAdministrativeAreaNameElementType_ListByType tests listing elements of type AdministrativeAreaNameElementType.
func TestAdministrativeAreaNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AdministrativeAreaNameElementType", nil)
	req.SetPathValue("type", "AdministrativeAreaNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAdministrativeAreaNameElementType_GetTypeMetadata tests getting type metadata for AdministrativeAreaNameElementType.
func TestAdministrativeAreaNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AdministrativeAreaNameElementType", nil)
	req.SetPathValue("name", "AdministrativeAreaNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAffectedType_CRUD tests Create, Read, Update, Delete for AffectedType.
func TestAffectedType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AffectedType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AffectedType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAffectedType_ListByType tests listing elements of type AffectedType.
func TestAffectedType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AffectedType", nil)
	req.SetPathValue("type", "AffectedType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAffectedType_GetTypeMetadata tests getting type metadata for AffectedType.
func TestAffectedType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AffectedType", nil)
	req.SetPathValue("name", "AffectedType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAliasElementType_CRUD tests Create, Read, Update, Delete for AliasElementType.
func TestAliasElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AliasElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AliasElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAliasElementType_ListByType tests listing elements of type AliasElementType.
func TestAliasElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AliasElementType", nil)
	req.SetPathValue("type", "AliasElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAliasElementType_GetTypeMetadata tests getting type metadata for AliasElementType.
func TestAliasElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AliasElementType", nil)
	req.SetPathValue("name", "AliasElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArcElement_CRUD tests Create, Read, Update, Delete for ArcElement.
func TestArcElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ArcElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ArcElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestArcElement_ListByType tests listing elements of type ArcElement.
func TestArcElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ArcElement", nil)
	req.SetPathValue("type", "ArcElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArcElement_GetTypeMetadata tests getting type metadata for ArcElement.
func TestArcElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ArcElement", nil)
	req.SetPathValue("name", "ArcElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArcType_CRUD tests Create, Read, Update, Delete for ArcType.
func TestArcType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ArcType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ArcType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestArcType_ListByType tests listing elements of type ArcType.
func TestArcType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ArcType", nil)
	req.SetPathValue("type", "ArcType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArcType_GetTypeMetadata tests getting type metadata for ArcType.
func TestArcType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ArcType", nil)
	req.SetPathValue("name", "ArcType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArcroleType_CRUD tests Create, Read, Update, Delete for ArcroleType.
func TestArcroleType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ArcroleType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ArcroleType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestArcroleType_ListByType tests listing elements of type ArcroleType.
func TestArcroleType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ArcroleType", nil)
	req.SetPathValue("type", "ArcroleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArcroleType_GetTypeMetadata tests getting type metadata for ArcroleType.
func TestArcroleType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ArcroleType", nil)
	req.SetPathValue("name", "ArcroleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArithmeticEnumeration_CRUD tests Create, Read, Update, Delete for ArithmeticEnumeration.
func TestArithmeticEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ArithmeticEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ArithmeticEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestArithmeticEnumeration_ListByType tests listing elements of type ArithmeticEnumeration.
func TestArithmeticEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ArithmeticEnumeration", nil)
	req.SetPathValue("type", "ArithmeticEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArithmeticEnumeration_GetTypeMetadata tests getting type metadata for ArithmeticEnumeration.
func TestArithmeticEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ArithmeticEnumeration", nil)
	req.SetPathValue("name", "ArithmeticEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArithmeticFunctionType_CRUD tests Create, Read, Update, Delete for ArithmeticFunctionType.
func TestArithmeticFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ArithmeticFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ArithmeticFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestArithmeticFunctionType_ListByType tests listing elements of type ArithmeticFunctionType.
func TestArithmeticFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ArithmeticFunctionType", nil)
	req.SetPathValue("type", "ArithmeticFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestArithmeticFunctionType_GetTypeMetadata tests getting type metadata for ArithmeticFunctionType.
func TestArithmeticFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ArithmeticFunctionType", nil)
	req.SetPathValue("name", "ArithmeticFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetElement_CRUD tests Create, Read, Update, Delete for AssetElement.
func TestAssetElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetElement_ListByType tests listing elements of type AssetElement.
func TestAssetElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetElement", nil)
	req.SetPathValue("type", "AssetElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetElement_GetTypeMetadata tests getting type metadata for AssetElement.
func TestAssetElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetElement", nil)
	req.SetPathValue("name", "AssetElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetElement_GetValidChildTypes tests getting valid child types for AssetElement.
func TestAssetElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetElement/children", nil)
	req.SetPathValue("name", "AssetElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAssetElementType_CRUD tests Create, Read, Update, Delete for AssetElementType.
func TestAssetElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetElementType_ListByType tests listing elements of type AssetElementType.
func TestAssetElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetElementType", nil)
	req.SetPathValue("type", "AssetElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetElementType_GetTypeMetadata tests getting type metadata for AssetElementType.
func TestAssetElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetElementType", nil)
	req.SetPathValue("name", "AssetElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetElementType_GetValidChildTypes tests getting valid child types for AssetElementType.
func TestAssetElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetElementType/children", nil)
	req.SetPathValue("name", "AssetElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAssetIdentificationType_CRUD tests Create, Read, Update, Delete for AssetIdentificationType.
func TestAssetIdentificationType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetIdentificationType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetIdentificationType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetIdentificationType_ListByType tests listing elements of type AssetIdentificationType.
func TestAssetIdentificationType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetIdentificationType", nil)
	req.SetPathValue("type", "AssetIdentificationType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetIdentificationType_GetTypeMetadata tests getting type metadata for AssetIdentificationType.
func TestAssetIdentificationType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetIdentificationType", nil)
	req.SetPathValue("name", "AssetIdentificationType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetRelatedElement_CRUD tests Create, Read, Update, Delete for AssetRelatedElement.
func TestAssetRelatedElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetRelatedElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetRelatedElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetRelatedElement_ListByType tests listing elements of type AssetRelatedElement.
func TestAssetRelatedElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetRelatedElement", nil)
	req.SetPathValue("type", "AssetRelatedElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetRelatedElement_GetTypeMetadata tests getting type metadata for AssetRelatedElement.
func TestAssetRelatedElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetRelatedElement", nil)
	req.SetPathValue("name", "AssetRelatedElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetReportCollectionElement_CRUD tests Create, Read, Update, Delete for AssetReportCollectionElement.
func TestAssetReportCollectionElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetReportCollectionElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetReportCollectionElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetReportCollectionElement_ListByType tests listing elements of type AssetReportCollectionElement.
func TestAssetReportCollectionElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetReportCollectionElement", nil)
	req.SetPathValue("type", "AssetReportCollectionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetReportCollectionElement_GetTypeMetadata tests getting type metadata for AssetReportCollectionElement.
func TestAssetReportCollectionElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetReportCollectionElement", nil)
	req.SetPathValue("name", "AssetReportCollectionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetReportCollectionElement_GetValidChildTypes tests getting valid child types for AssetReportCollectionElement.
func TestAssetReportCollectionElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetReportCollectionElement/children", nil)
	req.SetPathValue("name", "AssetReportCollectionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAssetReportCollectionElementType_CRUD tests Create, Read, Update, Delete for AssetReportCollectionElementType.
func TestAssetReportCollectionElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetReportCollectionElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetReportCollectionElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetReportCollectionElementType_ListByType tests listing elements of type AssetReportCollectionElementType.
func TestAssetReportCollectionElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetReportCollectionElementType", nil)
	req.SetPathValue("type", "AssetReportCollectionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetReportCollectionElementType_GetTypeMetadata tests getting type metadata for AssetReportCollectionElementType.
func TestAssetReportCollectionElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetReportCollectionElementType", nil)
	req.SetPathValue("name", "AssetReportCollectionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetReportCollectionElementType_GetValidChildTypes tests getting valid child types for AssetReportCollectionElementType.
func TestAssetReportCollectionElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetReportCollectionElementType/children", nil)
	req.SetPathValue("name", "AssetReportCollectionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAssetsElement_CRUD tests Create, Read, Update, Delete for AssetsElement.
func TestAssetsElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetsElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetsElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetsElement_ListByType tests listing elements of type AssetsElement.
func TestAssetsElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetsElement", nil)
	req.SetPathValue("type", "AssetsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetsElement_GetTypeMetadata tests getting type metadata for AssetsElement.
func TestAssetsElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetsElement", nil)
	req.SetPathValue("name", "AssetsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetsElement_GetValidChildTypes tests getting valid child types for AssetsElement.
func TestAssetsElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetsElement/children", nil)
	req.SetPathValue("name", "AssetsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAssetsElementType_CRUD tests Create, Read, Update, Delete for AssetsElementType.
func TestAssetsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetsElementType_ListByType tests listing elements of type AssetsElementType.
func TestAssetsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetsElementType", nil)
	req.SetPathValue("type", "AssetsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetsElementType_GetTypeMetadata tests getting type metadata for AssetsElementType.
func TestAssetsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetsElementType", nil)
	req.SetPathValue("name", "AssetsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetsElementType_GetValidChildTypes tests getting valid child types for AssetsElementType.
func TestAssetsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetsElementType/children", nil)
	req.SetPathValue("name", "AssetsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestAssetsType_CRUD tests Create, Read, Update, Delete for AssetsType.
func TestAssetsType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "AssetsType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create AssetsType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestAssetsType_ListByType tests listing elements of type AssetsType.
func TestAssetsType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/AssetsType", nil)
	req.SetPathValue("type", "AssetsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetsType_GetTypeMetadata tests getting type metadata for AssetsType.
func TestAssetsType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetsType", nil)
	req.SetPathValue("name", "AssetsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestAssetsType_GetValidChildTypes tests getting valid child types for AssetsType.
func TestAssetsType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/AssetsType/children", nil)
	req.SetPathValue("name", "AssetsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestBarcodeElementType_CRUD tests Create, Read, Update, Delete for BarcodeElementType.
func TestBarcodeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "BarcodeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create BarcodeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestBarcodeElementType_ListByType tests listing elements of type BarcodeElementType.
func TestBarcodeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/BarcodeElementType", nil)
	req.SetPathValue("type", "BarcodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBarcodeElementType_GetTypeMetadata tests getting type metadata for BarcodeElementType.
func TestBarcodeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BarcodeElementType", nil)
	req.SetPathValue("name", "BarcodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBeginFunctionType_CRUD tests Create, Read, Update, Delete for BeginFunctionType.
func TestBeginFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "BeginFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create BeginFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestBeginFunctionType_ListByType tests listing elements of type BeginFunctionType.
func TestBeginFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/BeginFunctionType", nil)
	req.SetPathValue("type", "BeginFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBeginFunctionType_GetTypeMetadata tests getting type metadata for BeginFunctionType.
func TestBeginFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BeginFunctionType", nil)
	req.SetPathValue("name", "BeginFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBenchmarkElement_CRUD tests Create, Read, Update, Delete for BenchmarkElement.
func TestBenchmarkElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "BenchmarkElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create BenchmarkElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestBenchmarkElement_ListByType tests listing elements of type BenchmarkElement.
func TestBenchmarkElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/BenchmarkElement", nil)
	req.SetPathValue("type", "BenchmarkElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBenchmarkElement_GetTypeMetadata tests getting type metadata for BenchmarkElement.
func TestBenchmarkElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BenchmarkElement", nil)
	req.SetPathValue("name", "BenchmarkElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBenchmarkElement_GetValidChildTypes tests getting valid child types for BenchmarkElement.
func TestBenchmarkElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BenchmarkElement/children", nil)
	req.SetPathValue("name", "BenchmarkElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestBenchmarkElementType_CRUD tests Create, Read, Update, Delete for BenchmarkElementType.
func TestBenchmarkElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "BenchmarkElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create BenchmarkElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestBenchmarkElementType_ListByType tests listing elements of type BenchmarkElementType.
func TestBenchmarkElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/BenchmarkElementType", nil)
	req.SetPathValue("type", "BenchmarkElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBenchmarkElementType_GetTypeMetadata tests getting type metadata for BenchmarkElementType.
func TestBenchmarkElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BenchmarkElementType", nil)
	req.SetPathValue("name", "BenchmarkElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBenchmarkElementType_GetValidChildTypes tests getting valid child types for BenchmarkElementType.
func TestBenchmarkElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BenchmarkElementType/children", nil)
	req.SetPathValue("name", "BenchmarkElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestBenchmarkIdType_CRUD tests Create, Read, Update, Delete for BenchmarkIdType.
func TestBenchmarkIdType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "BenchmarkIdType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create BenchmarkIdType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestBenchmarkIdType_ListByType tests listing elements of type BenchmarkIdType.
func TestBenchmarkIdType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/BenchmarkIdType", nil)
	req.SetPathValue("type", "BenchmarkIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBenchmarkIdType_GetTypeMetadata tests getting type metadata for BenchmarkIdType.
func TestBenchmarkIdType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BenchmarkIdType", nil)
	req.SetPathValue("name", "BenchmarkIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBenchmarkReferenceType_CRUD tests Create, Read, Update, Delete for BenchmarkReferenceType.
func TestBenchmarkReferenceType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "BenchmarkReferenceType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create BenchmarkReferenceType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestBenchmarkReferenceType_ListByType tests listing elements of type BenchmarkReferenceType.
func TestBenchmarkReferenceType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/BenchmarkReferenceType", nil)
	req.SetPathValue("type", "BenchmarkReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBenchmarkReferenceType_GetTypeMetadata tests getting type metadata for BenchmarkReferenceType.
func TestBenchmarkReferenceType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BenchmarkReferenceType", nil)
	req.SetPathValue("name", "BenchmarkReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBirthdateElementType_CRUD tests Create, Read, Update, Delete for BirthdateElementType.
func TestBirthdateElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "BirthdateElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create BirthdateElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestBirthdateElementType_ListByType tests listing elements of type BirthdateElementType.
func TestBirthdateElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/BirthdateElementType", nil)
	req.SetPathValue("type", "BirthdateElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBirthdateElementType_GetTypeMetadata tests getting type metadata for BirthdateElementType.
func TestBirthdateElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BirthdateElementType", nil)
	req.SetPathValue("name", "BirthdateElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBuildingNameType_CRUD tests Create, Read, Update, Delete for BuildingNameType.
func TestBuildingNameType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "BuildingNameType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create BuildingNameType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestBuildingNameType_ListByType tests listing elements of type BuildingNameType.
func TestBuildingNameType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/BuildingNameType", nil)
	req.SetPathValue("type", "BuildingNameType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestBuildingNameType_GetTypeMetadata tests getting type metadata for BuildingNameType.
func TestBuildingNameType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/BuildingNameType", nil)
	req.SetPathValue("name", "BuildingNameType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCPE2idrefType_CRUD tests Create, Read, Update, Delete for CPE2idrefType.
func TestCPE2idrefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CPE2idrefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CPE2idrefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCPE2idrefType_ListByType tests listing elements of type CPE2idrefType.
func TestCPE2idrefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CPE2idrefType", nil)
	req.SetPathValue("type", "CPE2idrefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCPE2idrefType_GetTypeMetadata tests getting type metadata for CPE2idrefType.
func TestCPE2idrefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CPE2idrefType", nil)
	req.SetPathValue("name", "CPE2idrefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCanonicalizationMethodElement_CRUD tests Create, Read, Update, Delete for CanonicalizationMethodElement.
func TestCanonicalizationMethodElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CanonicalizationMethodElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CanonicalizationMethodElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCanonicalizationMethodElement_ListByType tests listing elements of type CanonicalizationMethodElement.
func TestCanonicalizationMethodElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CanonicalizationMethodElement", nil)
	req.SetPathValue("type", "CanonicalizationMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCanonicalizationMethodElement_GetTypeMetadata tests getting type metadata for CanonicalizationMethodElement.
func TestCanonicalizationMethodElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CanonicalizationMethodElement", nil)
	req.SetPathValue("name", "CanonicalizationMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCanonicalizationMethodType_CRUD tests Create, Read, Update, Delete for CanonicalizationMethodType.
func TestCanonicalizationMethodType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CanonicalizationMethodType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CanonicalizationMethodType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCanonicalizationMethodType_ListByType tests listing elements of type CanonicalizationMethodType.
func TestCanonicalizationMethodType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CanonicalizationMethodType", nil)
	req.SetPathValue("type", "CanonicalizationMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCanonicalizationMethodType_GetTypeMetadata tests getting type metadata for CanonicalizationMethodType.
func TestCanonicalizationMethodType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CanonicalizationMethodType", nil)
	req.SetPathValue("name", "CanonicalizationMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCcOperatorEnumType_CRUD tests Create, Read, Update, Delete for CcOperatorEnumType.
func TestCcOperatorEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CcOperatorEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CcOperatorEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCcOperatorEnumType_ListByType tests listing elements of type CcOperatorEnumType.
func TestCcOperatorEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CcOperatorEnumType", nil)
	req.SetPathValue("type", "CcOperatorEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCcOperatorEnumType_GetTypeMetadata tests getting type metadata for CcOperatorEnumType.
func TestCcOperatorEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CcOperatorEnumType", nil)
	req.SetPathValue("name", "CcOperatorEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckContentRefType_CRUD tests Create, Read, Update, Delete for CheckContentRefType.
func TestCheckContentRefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CheckContentRefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CheckContentRefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCheckContentRefType_ListByType tests listing elements of type CheckContentRefType.
func TestCheckContentRefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CheckContentRefType", nil)
	req.SetPathValue("type", "CheckContentRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckContentRefType_GetTypeMetadata tests getting type metadata for CheckContentRefType.
func TestCheckContentRefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CheckContentRefType", nil)
	req.SetPathValue("name", "CheckContentRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckContentType_CRUD tests Create, Read, Update, Delete for CheckContentType.
func TestCheckContentType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CheckContentType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CheckContentType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCheckContentType_ListByType tests listing elements of type CheckContentType.
func TestCheckContentType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CheckContentType", nil)
	req.SetPathValue("type", "CheckContentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckContentType_GetTypeMetadata tests getting type metadata for CheckContentType.
func TestCheckContentType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CheckContentType", nil)
	req.SetPathValue("name", "CheckContentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckEnumeration_CRUD tests Create, Read, Update, Delete for CheckEnumeration.
func TestCheckEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CheckEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CheckEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCheckEnumeration_ListByType tests listing elements of type CheckEnumeration.
func TestCheckEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CheckEnumeration", nil)
	req.SetPathValue("type", "CheckEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckEnumeration_GetTypeMetadata tests getting type metadata for CheckEnumeration.
func TestCheckEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CheckEnumeration", nil)
	req.SetPathValue("name", "CheckEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckExportType_CRUD tests Create, Read, Update, Delete for CheckExportType.
func TestCheckExportType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CheckExportType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CheckExportType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCheckExportType_ListByType tests listing elements of type CheckExportType.
func TestCheckExportType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CheckExportType", nil)
	req.SetPathValue("type", "CheckExportType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckExportType_GetTypeMetadata tests getting type metadata for CheckExportType.
func TestCheckExportType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CheckExportType", nil)
	req.SetPathValue("name", "CheckExportType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckImportType_CRUD tests Create, Read, Update, Delete for CheckImportType.
func TestCheckImportType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CheckImportType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CheckImportType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCheckImportType_ListByType tests listing elements of type CheckImportType.
func TestCheckImportType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CheckImportType", nil)
	req.SetPathValue("type", "CheckImportType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckImportType_GetTypeMetadata tests getting type metadata for CheckImportType.
func TestCheckImportType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CheckImportType", nil)
	req.SetPathValue("name", "CheckImportType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckType_CRUD tests Create, Read, Update, Delete for CheckType.
func TestCheckType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CheckType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CheckType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCheckType_ListByType tests listing elements of type CheckType.
func TestCheckType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CheckType", nil)
	req.SetPathValue("type", "CheckType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckType_GetTypeMetadata tests getting type metadata for CheckType.
func TestCheckType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CheckType", nil)
	req.SetPathValue("name", "CheckType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCheckType_GetValidChildTypes tests getting valid child types for CheckType.
func TestCheckType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CheckType/children", nil)
	req.SetPathValue("name", "CheckType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestCidrElementType_CRUD tests Create, Read, Update, Delete for CidrElementType.
func TestCidrElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CidrElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CidrElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCidrElementType_ListByType tests listing elements of type CidrElementType.
func TestCidrElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CidrElementType", nil)
	req.SetPathValue("type", "CidrElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCidrElementType_GetTypeMetadata tests getting type metadata for CidrElementType.
func TestCidrElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CidrElementType", nil)
	req.SetPathValue("name", "CidrElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCidrType_CRUD tests Create, Read, Update, Delete for CidrType.
func TestCidrType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CidrType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CidrType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCidrType_ListByType tests listing elements of type CidrType.
func TestCidrType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CidrType", nil)
	req.SetPathValue("type", "CidrType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCidrType_GetTypeMetadata tests getting type metadata for CidrType.
func TestCidrType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CidrType", nil)
	req.SetPathValue("name", "CidrType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCircuitElement_CRUD tests Create, Read, Update, Delete for CircuitElement.
func TestCircuitElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CircuitElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CircuitElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCircuitElement_ListByType tests listing elements of type CircuitElement.
func TestCircuitElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CircuitElement", nil)
	req.SetPathValue("type", "CircuitElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCircuitElement_GetTypeMetadata tests getting type metadata for CircuitElement.
func TestCircuitElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CircuitElement", nil)
	req.SetPathValue("name", "CircuitElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCircuitElement_GetValidChildTypes tests getting valid child types for CircuitElement.
func TestCircuitElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CircuitElement/children", nil)
	req.SetPathValue("name", "CircuitElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestCircuitNameElementType_CRUD tests Create, Read, Update, Delete for CircuitNameElementType.
func TestCircuitNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CircuitNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CircuitNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCircuitNameElementType_ListByType tests listing elements of type CircuitNameElementType.
func TestCircuitNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CircuitNameElementType", nil)
	req.SetPathValue("type", "CircuitNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCircuitNameElementType_GetTypeMetadata tests getting type metadata for CircuitNameElementType.
func TestCircuitNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CircuitNameElementType", nil)
	req.SetPathValue("name", "CircuitNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCircuitType_CRUD tests Create, Read, Update, Delete for CircuitType.
func TestCircuitType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CircuitType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CircuitType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCircuitType_ListByType tests listing elements of type CircuitType.
func TestCircuitType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CircuitType", nil)
	req.SetPathValue("type", "CircuitType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCircuitType_GetTypeMetadata tests getting type metadata for CircuitType.
func TestCircuitType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CircuitType", nil)
	req.SetPathValue("name", "CircuitType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCircuitType_GetValidChildTypes tests getting valid child types for CircuitType.
func TestCircuitType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CircuitType/children", nil)
	req.SetPathValue("name", "CircuitType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestClassEnumeration_CRUD tests Create, Read, Update, Delete for ClassEnumeration.
func TestClassEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ClassEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ClassEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestClassEnumeration_ListByType tests listing elements of type ClassEnumeration.
func TestClassEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ClassEnumeration", nil)
	req.SetPathValue("type", "ClassEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestClassEnumeration_GetTypeMetadata tests getting type metadata for ClassEnumeration.
func TestClassEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ClassEnumeration", nil)
	req.SetPathValue("name", "ClassEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComplexCheckType_CRUD tests Create, Read, Update, Delete for ComplexCheckType.
func TestComplexCheckType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ComplexCheckType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ComplexCheckType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestComplexCheckType_ListByType tests listing elements of type ComplexCheckType.
func TestComplexCheckType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ComplexCheckType", nil)
	req.SetPathValue("type", "ComplexCheckType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComplexCheckType_GetTypeMetadata tests getting type metadata for ComplexCheckType.
func TestComplexCheckType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ComplexCheckType", nil)
	req.SetPathValue("name", "ComplexCheckType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComplexCheckType_GetValidChildTypes tests getting valid child types for ComplexCheckType.
func TestComplexCheckType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ComplexCheckType/children", nil)
	req.SetPathValue("name", "ComplexCheckType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestComplexDatatypeEnumeration_CRUD tests Create, Read, Update, Delete for ComplexDatatypeEnumeration.
func TestComplexDatatypeEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ComplexDatatypeEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ComplexDatatypeEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestComplexDatatypeEnumeration_ListByType tests listing elements of type ComplexDatatypeEnumeration.
func TestComplexDatatypeEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ComplexDatatypeEnumeration", nil)
	req.SetPathValue("type", "ComplexDatatypeEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComplexDatatypeEnumeration_GetTypeMetadata tests getting type metadata for ComplexDatatypeEnumeration.
func TestComplexDatatypeEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ComplexDatatypeEnumeration", nil)
	req.SetPathValue("name", "ComplexDatatypeEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComplexValueType_CRUD tests Create, Read, Update, Delete for ComplexValueType.
func TestComplexValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ComplexValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ComplexValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestComplexValueType_ListByType tests listing elements of type ComplexValueType.
func TestComplexValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ComplexValueType", nil)
	req.SetPathValue("type", "ComplexValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComplexValueType_GetTypeMetadata tests getting type metadata for ComplexValueType.
func TestComplexValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ComplexValueType", nil)
	req.SetPathValue("name", "ComplexValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComputingDeviceElement_CRUD tests Create, Read, Update, Delete for ComputingDeviceElement.
func TestComputingDeviceElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ComputingDeviceElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ComputingDeviceElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestComputingDeviceElement_ListByType tests listing elements of type ComputingDeviceElement.
func TestComputingDeviceElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ComputingDeviceElement", nil)
	req.SetPathValue("type", "ComputingDeviceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComputingDeviceElement_GetTypeMetadata tests getting type metadata for ComputingDeviceElement.
func TestComputingDeviceElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ComputingDeviceElement", nil)
	req.SetPathValue("name", "ComputingDeviceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComputingDeviceElement_GetValidChildTypes tests getting valid child types for ComputingDeviceElement.
func TestComputingDeviceElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ComputingDeviceElement/children", nil)
	req.SetPathValue("name", "ComputingDeviceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestComputingDeviceType_CRUD tests Create, Read, Update, Delete for ComputingDeviceType.
func TestComputingDeviceType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ComputingDeviceType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ComputingDeviceType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestComputingDeviceType_ListByType tests listing elements of type ComputingDeviceType.
func TestComputingDeviceType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ComputingDeviceType", nil)
	req.SetPathValue("type", "ComputingDeviceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComputingDeviceType_GetTypeMetadata tests getting type metadata for ComputingDeviceType.
func TestComputingDeviceType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ComputingDeviceType", nil)
	req.SetPathValue("name", "ComputingDeviceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestComputingDeviceType_GetValidChildTypes tests getting valid child types for ComputingDeviceType.
func TestComputingDeviceType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ComputingDeviceType/children", nil)
	req.SetPathValue("name", "ComputingDeviceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestConcatFunctionType_CRUD tests Create, Read, Update, Delete for ConcatFunctionType.
func TestConcatFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ConcatFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ConcatFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestConcatFunctionType_ListByType tests listing elements of type ConcatFunctionType.
func TestConcatFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ConcatFunctionType", nil)
	req.SetPathValue("type", "ConcatFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestConcatFunctionType_GetTypeMetadata tests getting type metadata for ConcatFunctionType.
func TestConcatFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ConcatFunctionType", nil)
	req.SetPathValue("name", "ConcatFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestConnectionsElementType_CRUD tests Create, Read, Update, Delete for ConnectionsElementType.
func TestConnectionsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ConnectionsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ConnectionsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestConnectionsElementType_ListByType tests listing elements of type ConnectionsElementType.
func TestConnectionsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ConnectionsElementType", nil)
	req.SetPathValue("type", "ConnectionsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestConnectionsElementType_GetTypeMetadata tests getting type metadata for ConnectionsElementType.
func TestConnectionsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ConnectionsElementType", nil)
	req.SetPathValue("name", "ConnectionsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestConnectionsElementType_GetValidChildTypes tests getting valid child types for ConnectionsElementType.
func TestConnectionsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ConnectionsElementType/children", nil)
	req.SetPathValue("name", "ConnectionsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestConstant_variableElement_CRUD tests Create, Read, Update, Delete for Constant_variableElement.
func TestConstant_variableElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Constant_variableElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Constant_variableElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestConstant_variableElement_ListByType tests listing elements of type Constant_variableElement.
func TestConstant_variableElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Constant_variableElement", nil)
	req.SetPathValue("type", "Constant_variableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestConstant_variableElement_GetTypeMetadata tests getting type metadata for Constant_variableElement.
func TestConstant_variableElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Constant_variableElement", nil)
	req.SetPathValue("name", "Constant_variableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestConstant_variableElement_GetValidChildTypes tests getting valid child types for Constant_variableElement.
func TestConstant_variableElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Constant_variableElement/children", nil)
	req.SetPathValue("name", "Constant_variableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestConstant_variableElementType_CRUD tests Create, Read, Update, Delete for Constant_variableElementType.
func TestConstant_variableElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Constant_variableElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Constant_variableElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestConstant_variableElementType_ListByType tests listing elements of type Constant_variableElementType.
func TestConstant_variableElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Constant_variableElementType", nil)
	req.SetPathValue("type", "Constant_variableElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestConstant_variableElementType_GetTypeMetadata tests getting type metadata for Constant_variableElementType.
func TestConstant_variableElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Constant_variableElementType", nil)
	req.SetPathValue("name", "Constant_variableElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestConstant_variableElementType_GetValidChildTypes tests getting valid child types for Constant_variableElementType.
func TestConstant_variableElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Constant_variableElementType/children", nil)
	req.SetPathValue("name", "Constant_variableElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestContentElementType_CRUD tests Create, Read, Update, Delete for ContentElementType.
func TestContentElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ContentElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ContentElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestContentElementType_ListByType tests listing elements of type ContentElementType.
func TestContentElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ContentElementType", nil)
	req.SetPathValue("type", "ContentElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestContentElementType_GetTypeMetadata tests getting type metadata for ContentElementType.
func TestContentElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ContentElementType", nil)
	req.SetPathValue("name", "ContentElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestContentElementType1_CRUD tests Create, Read, Update, Delete for ContentElementType1.
func TestContentElementType1_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ContentElementType1",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ContentElementType1 returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestContentElementType1_ListByType tests listing elements of type ContentElementType1.
func TestContentElementType1_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ContentElementType1", nil)
	req.SetPathValue("type", "ContentElementType1")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestContentElementType1_GetTypeMetadata tests getting type metadata for ContentElementType1.
func TestContentElementType1_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ContentElementType1", nil)
	req.SetPathValue("name", "ContentElementType1")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountFunctionType_CRUD tests Create, Read, Update, Delete for CountFunctionType.
func TestCountFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CountFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CountFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCountFunctionType_ListByType tests listing elements of type CountFunctionType.
func TestCountFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CountFunctionType", nil)
	req.SetPathValue("type", "CountFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountFunctionType_GetTypeMetadata tests getting type metadata for CountFunctionType.
func TestCountFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CountFunctionType", nil)
	req.SetPathValue("name", "CountFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountryElementType_CRUD tests Create, Read, Update, Delete for CountryElementType.
func TestCountryElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CountryElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CountryElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCountryElementType_ListByType tests listing elements of type CountryElementType.
func TestCountryElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CountryElementType", nil)
	req.SetPathValue("type", "CountryElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountryElementType_GetTypeMetadata tests getting type metadata for CountryElementType.
func TestCountryElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CountryElementType", nil)
	req.SetPathValue("name", "CountryElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountryElementType_GetValidChildTypes tests getting valid child types for CountryElementType.
func TestCountryElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CountryElementType/children", nil)
	req.SetPathValue("name", "CountryElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestCountryNameCodeElementType_CRUD tests Create, Read, Update, Delete for CountryNameCodeElementType.
func TestCountryNameCodeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CountryNameCodeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CountryNameCodeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCountryNameCodeElementType_ListByType tests listing elements of type CountryNameCodeElementType.
func TestCountryNameCodeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CountryNameCodeElementType", nil)
	req.SetPathValue("type", "CountryNameCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountryNameCodeElementType_GetTypeMetadata tests getting type metadata for CountryNameCodeElementType.
func TestCountryNameCodeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CountryNameCodeElementType", nil)
	req.SetPathValue("name", "CountryNameCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountryNameElement_CRUD tests Create, Read, Update, Delete for CountryNameElement.
func TestCountryNameElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CountryNameElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CountryNameElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCountryNameElement_ListByType tests listing elements of type CountryNameElement.
func TestCountryNameElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CountryNameElement", nil)
	req.SetPathValue("type", "CountryNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountryNameElement_GetTypeMetadata tests getting type metadata for CountryNameElement.
func TestCountryNameElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CountryNameElement", nil)
	req.SetPathValue("name", "CountryNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountryNameElementType_CRUD tests Create, Read, Update, Delete for CountryNameElementType.
func TestCountryNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CountryNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CountryNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCountryNameElementType_ListByType tests listing elements of type CountryNameElementType.
func TestCountryNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CountryNameElementType", nil)
	req.SetPathValue("type", "CountryNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCountryNameElementType_GetTypeMetadata tests getting type metadata for CountryNameElementType.
func TestCountryNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CountryNameElementType", nil)
	req.SetPathValue("name", "CountryNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeElement_CRUD tests Create, Read, Update, Delete for CpeElement.
func TestCpeElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CpeElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CpeElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCpeElement_ListByType tests listing elements of type CpeElement.
func TestCpeElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CpeElement", nil)
	req.SetPathValue("type", "CpeElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeElement_GetTypeMetadata tests getting type metadata for CpeElement.
func TestCpeElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CpeElement", nil)
	req.SetPathValue("name", "CpeElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeElementType_CRUD tests Create, Read, Update, Delete for CpeElementType.
func TestCpeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CpeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CpeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCpeElementType_ListByType tests listing elements of type CpeElementType.
func TestCpeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CpeElementType", nil)
	req.SetPathValue("type", "CpeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeElementType_GetTypeMetadata tests getting type metadata for CpeElementType.
func TestCpeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CpeElementType", nil)
	req.SetPathValue("name", "CpeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeItemElement_CRUD tests Create, Read, Update, Delete for CpeItemElement.
func TestCpeItemElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CpeItemElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CpeItemElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCpeItemElement_ListByType tests listing elements of type CpeItemElement.
func TestCpeItemElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CpeItemElement", nil)
	req.SetPathValue("type", "CpeItemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeItemElement_GetTypeMetadata tests getting type metadata for CpeItemElement.
func TestCpeItemElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CpeItemElement", nil)
	req.SetPathValue("name", "CpeItemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeItemElement_GetValidChildTypes tests getting valid child types for CpeItemElement.
func TestCpeItemElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CpeItemElement/children", nil)
	req.SetPathValue("name", "CpeItemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestCpeListElement_CRUD tests Create, Read, Update, Delete for CpeListElement.
func TestCpeListElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CpeListElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CpeListElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCpeListElement_ListByType tests listing elements of type CpeListElement.
func TestCpeListElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CpeListElement", nil)
	req.SetPathValue("type", "CpeListElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeListElement_GetTypeMetadata tests getting type metadata for CpeListElement.
func TestCpeListElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CpeListElement", nil)
	req.SetPathValue("name", "CpeListElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeListElement_GetValidChildTypes tests getting valid child types for CpeListElement.
func TestCpeListElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CpeListElement/children", nil)
	req.SetPathValue("name", "CpeListElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestCpeType_CRUD tests Create, Read, Update, Delete for CpeType.
func TestCpeType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CpeType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CpeType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCpeType_ListByType tests listing elements of type CpeType.
func TestCpeType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CpeType", nil)
	req.SetPathValue("type", "CpeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCpeType_GetTypeMetadata tests getting type metadata for CpeType.
func TestCpeType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CpeType", nil)
	req.SetPathValue("name", "CpeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCriteriaType_CRUD tests Create, Read, Update, Delete for CriteriaType.
func TestCriteriaType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CriteriaType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CriteriaType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCriteriaType_ListByType tests listing elements of type CriteriaType.
func TestCriteriaType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CriteriaType", nil)
	req.SetPathValue("type", "CriteriaType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCriteriaType_GetTypeMetadata tests getting type metadata for CriteriaType.
func TestCriteriaType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CriteriaType", nil)
	req.SetPathValue("name", "CriteriaType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCriteriaType_GetValidChildTypes tests getting valid child types for CriteriaType.
func TestCriteriaType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CriteriaType/children", nil)
	req.SetPathValue("name", "CriteriaType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestCriterionType_CRUD tests Create, Read, Update, Delete for CriterionType.
func TestCriterionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CriterionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CriterionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCriterionType_ListByType tests listing elements of type CriterionType.
func TestCriterionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CriterionType", nil)
	req.SetPathValue("type", "CriterionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCriterionType_GetTypeMetadata tests getting type metadata for CriterionType.
func TestCriterionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CriterionType", nil)
	req.SetPathValue("name", "CriterionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCryptoBinary_CRUD tests Create, Read, Update, Delete for CryptoBinary.
func TestCryptoBinary_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "CryptoBinary",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create CryptoBinary returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestCryptoBinary_ListByType tests listing elements of type CryptoBinary.
func TestCryptoBinary_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/CryptoBinary", nil)
	req.SetPathValue("type", "CryptoBinary")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestCryptoBinary_GetTypeMetadata tests getting type metadata for CryptoBinary.
func TestCryptoBinary_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/CryptoBinary", nil)
	req.SetPathValue("name", "CryptoBinary")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDSAKeyValueElement_CRUD tests Create, Read, Update, Delete for DSAKeyValueElement.
func TestDSAKeyValueElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DSAKeyValueElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DSAKeyValueElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDSAKeyValueElement_ListByType tests listing elements of type DSAKeyValueElement.
func TestDSAKeyValueElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DSAKeyValueElement", nil)
	req.SetPathValue("type", "DSAKeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDSAKeyValueElement_GetTypeMetadata tests getting type metadata for DSAKeyValueElement.
func TestDSAKeyValueElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DSAKeyValueElement", nil)
	req.SetPathValue("name", "DSAKeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDSAKeyValueElement_GetValidChildTypes tests getting valid child types for DSAKeyValueElement.
func TestDSAKeyValueElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DSAKeyValueElement/children", nil)
	req.SetPathValue("name", "DSAKeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDSAKeyValueType_CRUD tests Create, Read, Update, Delete for DSAKeyValueType.
func TestDSAKeyValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DSAKeyValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DSAKeyValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDSAKeyValueType_ListByType tests listing elements of type DSAKeyValueType.
func TestDSAKeyValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DSAKeyValueType", nil)
	req.SetPathValue("type", "DSAKeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDSAKeyValueType_GetTypeMetadata tests getting type metadata for DSAKeyValueType.
func TestDSAKeyValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DSAKeyValueType", nil)
	req.SetPathValue("name", "DSAKeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDSAKeyValueType_GetValidChildTypes tests getting valid child types for DSAKeyValueType.
func TestDSAKeyValueType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DSAKeyValueType/children", nil)
	req.SetPathValue("name", "DSAKeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDataElement_CRUD tests Create, Read, Update, Delete for DataElement.
func TestDataElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DataElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DataElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDataElement_ListByType tests listing elements of type DataElement.
func TestDataElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DataElement", nil)
	req.SetPathValue("type", "DataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDataElement_GetTypeMetadata tests getting type metadata for DataElement.
func TestDataElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DataElement", nil)
	req.SetPathValue("name", "DataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDataType_CRUD tests Create, Read, Update, Delete for DataType.
func TestDataType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DataType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DataType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDataType_ListByType tests listing elements of type DataType.
func TestDataType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DataType", nil)
	req.SetPathValue("type", "DataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDataType_GetTypeMetadata tests getting type metadata for DataType.
func TestDataType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DataType", nil)
	req.SetPathValue("name", "DataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDatabaseElement_CRUD tests Create, Read, Update, Delete for DatabaseElement.
func TestDatabaseElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DatabaseElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DatabaseElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDatabaseElement_ListByType tests listing elements of type DatabaseElement.
func TestDatabaseElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DatabaseElement", nil)
	req.SetPathValue("type", "DatabaseElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDatabaseElement_GetTypeMetadata tests getting type metadata for DatabaseElement.
func TestDatabaseElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DatabaseElement", nil)
	req.SetPathValue("name", "DatabaseElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDatabaseElement_GetValidChildTypes tests getting valid child types for DatabaseElement.
func TestDatabaseElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DatabaseElement/children", nil)
	req.SetPathValue("name", "DatabaseElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDatabaseType_CRUD tests Create, Read, Update, Delete for DatabaseType.
func TestDatabaseType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DatabaseType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DatabaseType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDatabaseType_ListByType tests listing elements of type DatabaseType.
func TestDatabaseType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DatabaseType", nil)
	req.SetPathValue("type", "DatabaseType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDatabaseType_GetTypeMetadata tests getting type metadata for DatabaseType.
func TestDatabaseType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DatabaseType", nil)
	req.SetPathValue("name", "DatabaseType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDatabaseType_GetValidChildTypes tests getting valid child types for DatabaseType.
func TestDatabaseType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DatabaseType/children", nil)
	req.SetPathValue("name", "DatabaseType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDatatypeEnumeration_CRUD tests Create, Read, Update, Delete for DatatypeEnumeration.
func TestDatatypeEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DatatypeEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DatatypeEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDatatypeEnumeration_ListByType tests listing elements of type DatatypeEnumeration.
func TestDatatypeEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DatatypeEnumeration", nil)
	req.SetPathValue("type", "DatatypeEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDatatypeEnumeration_GetTypeMetadata tests getting type metadata for DatatypeEnumeration.
func TestDatatypeEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DatatypeEnumeration", nil)
	req.SetPathValue("name", "DatatypeEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDateTimeFormatEnumeration_CRUD tests Create, Read, Update, Delete for DateTimeFormatEnumeration.
func TestDateTimeFormatEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DateTimeFormatEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DateTimeFormatEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDateTimeFormatEnumeration_ListByType tests listing elements of type DateTimeFormatEnumeration.
func TestDateTimeFormatEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DateTimeFormatEnumeration", nil)
	req.SetPathValue("type", "DateTimeFormatEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDateTimeFormatEnumeration_GetTypeMetadata tests getting type metadata for DateTimeFormatEnumeration.
func TestDateTimeFormatEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DateTimeFormatEnumeration", nil)
	req.SetPathValue("name", "DateTimeFormatEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDcStatusType_CRUD tests Create, Read, Update, Delete for DcStatusType.
func TestDcStatusType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DcStatusType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DcStatusType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDcStatusType_ListByType tests listing elements of type DcStatusType.
func TestDcStatusType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DcStatusType", nil)
	req.SetPathValue("type", "DcStatusType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDcStatusType_GetTypeMetadata tests getting type metadata for DcStatusType.
func TestDcStatusType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DcStatusType", nil)
	req.SetPathValue("name", "DcStatusType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionElement_CRUD tests Create, Read, Update, Delete for DefinitionElement.
func TestDefinitionElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DefinitionElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DefinitionElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDefinitionElement_ListByType tests listing elements of type DefinitionElement.
func TestDefinitionElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DefinitionElement", nil)
	req.SetPathValue("type", "DefinitionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionElement_GetTypeMetadata tests getting type metadata for DefinitionElement.
func TestDefinitionElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DefinitionElement", nil)
	req.SetPathValue("name", "DefinitionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionElement_GetValidChildTypes tests getting valid child types for DefinitionElement.
func TestDefinitionElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DefinitionElement/children", nil)
	req.SetPathValue("name", "DefinitionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDefinitionIDPattern_CRUD tests Create, Read, Update, Delete for DefinitionIDPattern.
func TestDefinitionIDPattern_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DefinitionIDPattern",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DefinitionIDPattern returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDefinitionIDPattern_ListByType tests listing elements of type DefinitionIDPattern.
func TestDefinitionIDPattern_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DefinitionIDPattern", nil)
	req.SetPathValue("type", "DefinitionIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionIDPattern_GetTypeMetadata tests getting type metadata for DefinitionIDPattern.
func TestDefinitionIDPattern_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DefinitionIDPattern", nil)
	req.SetPathValue("name", "DefinitionIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionType_CRUD tests Create, Read, Update, Delete for DefinitionType.
func TestDefinitionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DefinitionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DefinitionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDefinitionType_ListByType tests listing elements of type DefinitionType.
func TestDefinitionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DefinitionType", nil)
	req.SetPathValue("type", "DefinitionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionType_GetTypeMetadata tests getting type metadata for DefinitionType.
func TestDefinitionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DefinitionType", nil)
	req.SetPathValue("name", "DefinitionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionType_GetValidChildTypes tests getting valid child types for DefinitionType.
func TestDefinitionType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DefinitionType/children", nil)
	req.SetPathValue("name", "DefinitionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDefinitionsType_CRUD tests Create, Read, Update, Delete for DefinitionsType.
func TestDefinitionsType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DefinitionsType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DefinitionsType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDefinitionsType_ListByType tests listing elements of type DefinitionsType.
func TestDefinitionsType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DefinitionsType", nil)
	req.SetPathValue("type", "DefinitionsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionsType_GetTypeMetadata tests getting type metadata for DefinitionsType.
func TestDefinitionsType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DefinitionsType", nil)
	req.SetPathValue("name", "DefinitionsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDefinitionsType_GetValidChildTypes tests getting valid child types for DefinitionsType.
func TestDefinitionsType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DefinitionsType/children", nil)
	req.SetPathValue("name", "DefinitionsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDepartmentElement_CRUD tests Create, Read, Update, Delete for DepartmentElement.
func TestDepartmentElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DepartmentElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DepartmentElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDepartmentElement_ListByType tests listing elements of type DepartmentElement.
func TestDepartmentElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DepartmentElement", nil)
	req.SetPathValue("type", "DepartmentElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDepartmentElement_GetTypeMetadata tests getting type metadata for DepartmentElement.
func TestDepartmentElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DepartmentElement", nil)
	req.SetPathValue("name", "DepartmentElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDepartmentElement_GetValidChildTypes tests getting valid child types for DepartmentElement.
func TestDepartmentElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DepartmentElement/children", nil)
	req.SetPathValue("name", "DepartmentElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDepartmentElementType_CRUD tests Create, Read, Update, Delete for DepartmentElementType.
func TestDepartmentElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DepartmentElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DepartmentElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDepartmentElementType_ListByType tests listing elements of type DepartmentElementType.
func TestDepartmentElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DepartmentElementType", nil)
	req.SetPathValue("type", "DepartmentElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDepartmentElementType_GetTypeMetadata tests getting type metadata for DepartmentElementType.
func TestDepartmentElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DepartmentElementType", nil)
	req.SetPathValue("name", "DepartmentElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDepartmentElementType_GetValidChildTypes tests getting valid child types for DepartmentElementType.
func TestDepartmentElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DepartmentElementType/children", nil)
	req.SetPathValue("name", "DepartmentElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDepartmentNameElementType_CRUD tests Create, Read, Update, Delete for DepartmentNameElementType.
func TestDepartmentNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DepartmentNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DepartmentNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDepartmentNameElementType_ListByType tests listing elements of type DepartmentNameElementType.
func TestDepartmentNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DepartmentNameElementType", nil)
	req.SetPathValue("type", "DepartmentNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDepartmentNameElementType_GetTypeMetadata tests getting type metadata for DepartmentNameElementType.
func TestDepartmentNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DepartmentNameElementType", nil)
	req.SetPathValue("name", "DepartmentNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependencyNameElementType_CRUD tests Create, Read, Update, Delete for DependencyNameElementType.
func TestDependencyNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DependencyNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DependencyNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDependencyNameElementType_ListByType tests listing elements of type DependencyNameElementType.
func TestDependencyNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DependencyNameElementType", nil)
	req.SetPathValue("type", "DependencyNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependencyNameElementType_GetTypeMetadata tests getting type metadata for DependencyNameElementType.
func TestDependencyNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DependencyNameElementType", nil)
	req.SetPathValue("name", "DependencyNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentLocalityNameElementType_CRUD tests Create, Read, Update, Delete for DependentLocalityNameElementType.
func TestDependentLocalityNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DependentLocalityNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DependentLocalityNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDependentLocalityNameElementType_ListByType tests listing elements of type DependentLocalityNameElementType.
func TestDependentLocalityNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DependentLocalityNameElementType", nil)
	req.SetPathValue("type", "DependentLocalityNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentLocalityNameElementType_GetTypeMetadata tests getting type metadata for DependentLocalityNameElementType.
func TestDependentLocalityNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DependentLocalityNameElementType", nil)
	req.SetPathValue("name", "DependentLocalityNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentLocalityNumberElementType_CRUD tests Create, Read, Update, Delete for DependentLocalityNumberElementType.
func TestDependentLocalityNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DependentLocalityNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DependentLocalityNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDependentLocalityNumberElementType_ListByType tests listing elements of type DependentLocalityNumberElementType.
func TestDependentLocalityNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DependentLocalityNumberElementType", nil)
	req.SetPathValue("type", "DependentLocalityNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentLocalityNumberElementType_GetTypeMetadata tests getting type metadata for DependentLocalityNumberElementType.
func TestDependentLocalityNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DependentLocalityNumberElementType", nil)
	req.SetPathValue("name", "DependentLocalityNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentLocalityType_CRUD tests Create, Read, Update, Delete for DependentLocalityType.
func TestDependentLocalityType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DependentLocalityType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DependentLocalityType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDependentLocalityType_ListByType tests listing elements of type DependentLocalityType.
func TestDependentLocalityType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DependentLocalityType", nil)
	req.SetPathValue("type", "DependentLocalityType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentLocalityType_GetTypeMetadata tests getting type metadata for DependentLocalityType.
func TestDependentLocalityType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DependentLocalityType", nil)
	req.SetPathValue("name", "DependentLocalityType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentLocalityType_GetValidChildTypes tests getting valid child types for DependentLocalityType.
func TestDependentLocalityType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DependentLocalityType/children", nil)
	req.SetPathValue("name", "DependentLocalityType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDependentThoroughfareElementType_CRUD tests Create, Read, Update, Delete for DependentThoroughfareElementType.
func TestDependentThoroughfareElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DependentThoroughfareElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DependentThoroughfareElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDependentThoroughfareElementType_ListByType tests listing elements of type DependentThoroughfareElementType.
func TestDependentThoroughfareElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DependentThoroughfareElementType", nil)
	req.SetPathValue("type", "DependentThoroughfareElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentThoroughfareElementType_GetTypeMetadata tests getting type metadata for DependentThoroughfareElementType.
func TestDependentThoroughfareElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DependentThoroughfareElementType", nil)
	req.SetPathValue("name", "DependentThoroughfareElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDependentThoroughfareElementType_GetValidChildTypes tests getting valid child types for DependentThoroughfareElementType.
func TestDependentThoroughfareElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DependentThoroughfareElementType/children", nil)
	req.SetPathValue("name", "DependentThoroughfareElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDeprecatedInfoType_CRUD tests Create, Read, Update, Delete for DeprecatedInfoType.
func TestDeprecatedInfoType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DeprecatedInfoType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DeprecatedInfoType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDeprecatedInfoType_ListByType tests listing elements of type DeprecatedInfoType.
func TestDeprecatedInfoType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DeprecatedInfoType", nil)
	req.SetPathValue("type", "DeprecatedInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDeprecatedInfoType_GetTypeMetadata tests getting type metadata for DeprecatedInfoType.
func TestDeprecatedInfoType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DeprecatedInfoType", nil)
	req.SetPathValue("name", "DeprecatedInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDeprecatedInfoType_GetValidChildTypes tests getting valid child types for DeprecatedInfoType.
func TestDeprecatedInfoType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DeprecatedInfoType/children", nil)
	req.SetPathValue("name", "DeprecatedInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDeprecated_infoElement_CRUD tests Create, Read, Update, Delete for Deprecated_infoElement.
func TestDeprecated_infoElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Deprecated_infoElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Deprecated_infoElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDeprecated_infoElement_ListByType tests listing elements of type Deprecated_infoElement.
func TestDeprecated_infoElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Deprecated_infoElement", nil)
	req.SetPathValue("type", "Deprecated_infoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDeprecated_infoElement_GetTypeMetadata tests getting type metadata for Deprecated_infoElement.
func TestDeprecated_infoElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Deprecated_infoElement", nil)
	req.SetPathValue("name", "Deprecated_infoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDeprecated_infoElement_GetValidChildTypes tests getting valid child types for Deprecated_infoElement.
func TestDeprecated_infoElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Deprecated_infoElement/children", nil)
	req.SetPathValue("name", "Deprecated_infoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestDigestMethodElement_CRUD tests Create, Read, Update, Delete for DigestMethodElement.
func TestDigestMethodElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DigestMethodElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DigestMethodElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDigestMethodElement_ListByType tests listing elements of type DigestMethodElement.
func TestDigestMethodElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DigestMethodElement", nil)
	req.SetPathValue("type", "DigestMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDigestMethodElement_GetTypeMetadata tests getting type metadata for DigestMethodElement.
func TestDigestMethodElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DigestMethodElement", nil)
	req.SetPathValue("name", "DigestMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDigestMethodType_CRUD tests Create, Read, Update, Delete for DigestMethodType.
func TestDigestMethodType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DigestMethodType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DigestMethodType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDigestMethodType_ListByType tests listing elements of type DigestMethodType.
func TestDigestMethodType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DigestMethodType", nil)
	req.SetPathValue("type", "DigestMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDigestMethodType_GetTypeMetadata tests getting type metadata for DigestMethodType.
func TestDigestMethodType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DigestMethodType", nil)
	req.SetPathValue("name", "DigestMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDigestValueElement_CRUD tests Create, Read, Update, Delete for DigestValueElement.
func TestDigestValueElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DigestValueElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DigestValueElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDigestValueElement_ListByType tests listing elements of type DigestValueElement.
func TestDigestValueElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DigestValueElement", nil)
	req.SetPathValue("type", "DigestValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDigestValueElement_GetTypeMetadata tests getting type metadata for DigestValueElement.
func TestDigestValueElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DigestValueElement", nil)
	req.SetPathValue("name", "DigestValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDigestValueType_CRUD tests Create, Read, Update, Delete for DigestValueType.
func TestDigestValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DigestValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DigestValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDigestValueType_ListByType tests listing elements of type DigestValueType.
func TestDigestValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DigestValueType", nil)
	req.SetPathValue("type", "DigestValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDigestValueType_GetTypeMetadata tests getting type metadata for DigestValueType.
func TestDigestValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DigestValueType", nil)
	req.SetPathValue("name", "DigestValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDistinguishedNameElementType_CRUD tests Create, Read, Update, Delete for DistinguishedNameElementType.
func TestDistinguishedNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DistinguishedNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DistinguishedNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDistinguishedNameElementType_ListByType tests listing elements of type DistinguishedNameElementType.
func TestDistinguishedNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DistinguishedNameElementType", nil)
	req.SetPathValue("type", "DistinguishedNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDistinguishedNameElementType_GetTypeMetadata tests getting type metadata for DistinguishedNameElementType.
func TestDistinguishedNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DistinguishedNameElementType", nil)
	req.SetPathValue("name", "DistinguishedNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDocumentRootElementType_CRUD tests Create, Read, Update, Delete for DocumentRootElementType.
func TestDocumentRootElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "DocumentRootElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create DocumentRootElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestDocumentRootElementType_ListByType tests listing elements of type DocumentRootElementType.
func TestDocumentRootElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/DocumentRootElementType", nil)
	req.SetPathValue("type", "DocumentRootElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestDocumentRootElementType_GetTypeMetadata tests getting type metadata for DocumentRootElementType.
func TestDocumentRootElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/DocumentRootElementType", nil)
	req.SetPathValue("name", "DocumentRootElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestElementMapItemType_CRUD tests Create, Read, Update, Delete for ElementMapItemType.
func TestElementMapItemType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ElementMapItemType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ElementMapItemType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestElementMapItemType_ListByType tests listing elements of type ElementMapItemType.
func TestElementMapItemType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ElementMapItemType", nil)
	req.SetPathValue("type", "ElementMapItemType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestElementMapItemType_GetTypeMetadata tests getting type metadata for ElementMapItemType.
func TestElementMapItemType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ElementMapItemType", nil)
	req.SetPathValue("name", "ElementMapItemType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestElementMapType_CRUD tests Create, Read, Update, Delete for ElementMapType.
func TestElementMapType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ElementMapType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ElementMapType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestElementMapType_ListByType tests listing elements of type ElementMapType.
func TestElementMapType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ElementMapType", nil)
	req.SetPathValue("type", "ElementMapType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestElementMapType_GetTypeMetadata tests getting type metadata for ElementMapType.
func TestElementMapType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ElementMapType", nil)
	req.SetPathValue("name", "ElementMapType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestElementMapType_GetValidChildTypes tests getting valid child types for ElementMapType.
func TestElementMapType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ElementMapType/children", nil)
	req.SetPathValue("name", "ElementMapType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestElement_mappingElement_CRUD tests Create, Read, Update, Delete for Element_mappingElement.
func TestElement_mappingElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Element_mappingElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Element_mappingElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestElement_mappingElement_ListByType tests listing elements of type Element_mappingElement.
func TestElement_mappingElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Element_mappingElement", nil)
	req.SetPathValue("type", "Element_mappingElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestElement_mappingElement_GetTypeMetadata tests getting type metadata for Element_mappingElement.
func TestElement_mappingElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Element_mappingElement", nil)
	req.SetPathValue("name", "Element_mappingElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestElement_mappingElement_GetValidChildTypes tests getting valid child types for Element_mappingElement.
func TestElement_mappingElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Element_mappingElement/children", nil)
	req.SetPathValue("name", "Element_mappingElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestEmailAddressElement_CRUD tests Create, Read, Update, Delete for EmailAddressElement.
func TestEmailAddressElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EmailAddressElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EmailAddressElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEmailAddressElement_ListByType tests listing elements of type EmailAddressElement.
func TestEmailAddressElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EmailAddressElement", nil)
	req.SetPathValue("type", "EmailAddressElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEmailAddressElement_GetTypeMetadata tests getting type metadata for EmailAddressElement.
func TestEmailAddressElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EmailAddressElement", nil)
	req.SetPathValue("name", "EmailAddressElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEmailAddressElementType_CRUD tests Create, Read, Update, Delete for EmailAddressElementType.
func TestEmailAddressElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EmailAddressElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EmailAddressElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEmailAddressElementType_ListByType tests listing elements of type EmailAddressElementType.
func TestEmailAddressElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EmailAddressElementType", nil)
	req.SetPathValue("type", "EmailAddressElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEmailAddressElementType_GetTypeMetadata tests getting type metadata for EmailAddressElementType.
func TestEmailAddressElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EmailAddressElementType", nil)
	req.SetPathValue("name", "EmailAddressElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEmptyStringType_CRUD tests Create, Read, Update, Delete for EmptyStringType.
func TestEmptyStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EmptyStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EmptyStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEmptyStringType_ListByType tests listing elements of type EmptyStringType.
func TestEmptyStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EmptyStringType", nil)
	req.SetPathValue("type", "EmptyStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEmptyStringType_GetTypeMetadata tests getting type metadata for EmptyStringType.
func TestEmptyStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EmptyStringType", nil)
	req.SetPathValue("name", "EmptyStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEndFunctionType_CRUD tests Create, Read, Update, Delete for EndFunctionType.
func TestEndFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EndFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EndFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEndFunctionType_ListByType tests listing elements of type EndFunctionType.
func TestEndFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EndFunctionType", nil)
	req.SetPathValue("type", "EndFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEndFunctionType_GetTypeMetadata tests getting type metadata for EndFunctionType.
func TestEndFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EndFunctionType", nil)
	req.SetPathValue("name", "EndFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEndorsementLineCodeElementType_CRUD tests Create, Read, Update, Delete for EndorsementLineCodeElementType.
func TestEndorsementLineCodeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EndorsementLineCodeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EndorsementLineCodeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEndorsementLineCodeElementType_ListByType tests listing elements of type EndorsementLineCodeElementType.
func TestEndorsementLineCodeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EndorsementLineCodeElementType", nil)
	req.SetPathValue("type", "EndorsementLineCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEndorsementLineCodeElementType_GetTypeMetadata tests getting type metadata for EndorsementLineCodeElementType.
func TestEndorsementLineCodeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EndorsementLineCodeElementType", nil)
	req.SetPathValue("name", "EndorsementLineCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectAnySimpleType_CRUD tests Create, Read, Update, Delete for EntityObjectAnySimpleType.
func TestEntityObjectAnySimpleType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectAnySimpleType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectAnySimpleType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectAnySimpleType_ListByType tests listing elements of type EntityObjectAnySimpleType.
func TestEntityObjectAnySimpleType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectAnySimpleType", nil)
	req.SetPathValue("type", "EntityObjectAnySimpleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectAnySimpleType_GetTypeMetadata tests getting type metadata for EntityObjectAnySimpleType.
func TestEntityObjectAnySimpleType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectAnySimpleType", nil)
	req.SetPathValue("name", "EntityObjectAnySimpleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectBinaryType_CRUD tests Create, Read, Update, Delete for EntityObjectBinaryType.
func TestEntityObjectBinaryType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectBinaryType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectBinaryType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectBinaryType_ListByType tests listing elements of type EntityObjectBinaryType.
func TestEntityObjectBinaryType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectBinaryType", nil)
	req.SetPathValue("type", "EntityObjectBinaryType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectBinaryType_GetTypeMetadata tests getting type metadata for EntityObjectBinaryType.
func TestEntityObjectBinaryType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectBinaryType", nil)
	req.SetPathValue("name", "EntityObjectBinaryType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectBoolType_CRUD tests Create, Read, Update, Delete for EntityObjectBoolType.
func TestEntityObjectBoolType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectBoolType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectBoolType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectBoolType_ListByType tests listing elements of type EntityObjectBoolType.
func TestEntityObjectBoolType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectBoolType", nil)
	req.SetPathValue("type", "EntityObjectBoolType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectBoolType_GetTypeMetadata tests getting type metadata for EntityObjectBoolType.
func TestEntityObjectBoolType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectBoolType", nil)
	req.SetPathValue("name", "EntityObjectBoolType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectFieldType_CRUD tests Create, Read, Update, Delete for EntityObjectFieldType.
func TestEntityObjectFieldType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectFieldType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectFieldType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectFieldType_ListByType tests listing elements of type EntityObjectFieldType.
func TestEntityObjectFieldType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectFieldType", nil)
	req.SetPathValue("type", "EntityObjectFieldType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectFieldType_GetTypeMetadata tests getting type metadata for EntityObjectFieldType.
func TestEntityObjectFieldType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectFieldType", nil)
	req.SetPathValue("name", "EntityObjectFieldType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectFloatType_CRUD tests Create, Read, Update, Delete for EntityObjectFloatType.
func TestEntityObjectFloatType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectFloatType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectFloatType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectFloatType_ListByType tests listing elements of type EntityObjectFloatType.
func TestEntityObjectFloatType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectFloatType", nil)
	req.SetPathValue("type", "EntityObjectFloatType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectFloatType_GetTypeMetadata tests getting type metadata for EntityObjectFloatType.
func TestEntityObjectFloatType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectFloatType", nil)
	req.SetPathValue("name", "EntityObjectFloatType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectIPAddressStringType_CRUD tests Create, Read, Update, Delete for EntityObjectIPAddressStringType.
func TestEntityObjectIPAddressStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectIPAddressStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectIPAddressStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectIPAddressStringType_ListByType tests listing elements of type EntityObjectIPAddressStringType.
func TestEntityObjectIPAddressStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectIPAddressStringType", nil)
	req.SetPathValue("type", "EntityObjectIPAddressStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectIPAddressStringType_GetTypeMetadata tests getting type metadata for EntityObjectIPAddressStringType.
func TestEntityObjectIPAddressStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectIPAddressStringType", nil)
	req.SetPathValue("name", "EntityObjectIPAddressStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectIPAddressType_CRUD tests Create, Read, Update, Delete for EntityObjectIPAddressType.
func TestEntityObjectIPAddressType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectIPAddressType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectIPAddressType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectIPAddressType_ListByType tests listing elements of type EntityObjectIPAddressType.
func TestEntityObjectIPAddressType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectIPAddressType", nil)
	req.SetPathValue("type", "EntityObjectIPAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectIPAddressType_GetTypeMetadata tests getting type metadata for EntityObjectIPAddressType.
func TestEntityObjectIPAddressType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectIPAddressType", nil)
	req.SetPathValue("name", "EntityObjectIPAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectIntType_CRUD tests Create, Read, Update, Delete for EntityObjectIntType.
func TestEntityObjectIntType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectIntType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectIntType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectIntType_ListByType tests listing elements of type EntityObjectIntType.
func TestEntityObjectIntType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectIntType", nil)
	req.SetPathValue("type", "EntityObjectIntType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectIntType_GetTypeMetadata tests getting type metadata for EntityObjectIntType.
func TestEntityObjectIntType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectIntType", nil)
	req.SetPathValue("name", "EntityObjectIntType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectRecordType_CRUD tests Create, Read, Update, Delete for EntityObjectRecordType.
func TestEntityObjectRecordType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectRecordType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectRecordType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectRecordType_ListByType tests listing elements of type EntityObjectRecordType.
func TestEntityObjectRecordType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectRecordType", nil)
	req.SetPathValue("type", "EntityObjectRecordType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectRecordType_GetTypeMetadata tests getting type metadata for EntityObjectRecordType.
func TestEntityObjectRecordType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectRecordType", nil)
	req.SetPathValue("name", "EntityObjectRecordType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectRecordType_GetValidChildTypes tests getting valid child types for EntityObjectRecordType.
func TestEntityObjectRecordType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectRecordType/children", nil)
	req.SetPathValue("name", "EntityObjectRecordType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestEntityObjectStringType_CRUD tests Create, Read, Update, Delete for EntityObjectStringType.
func TestEntityObjectStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectStringType_ListByType tests listing elements of type EntityObjectStringType.
func TestEntityObjectStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectStringType", nil)
	req.SetPathValue("type", "EntityObjectStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectStringType_GetTypeMetadata tests getting type metadata for EntityObjectStringType.
func TestEntityObjectStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectStringType", nil)
	req.SetPathValue("name", "EntityObjectStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectVersionType_CRUD tests Create, Read, Update, Delete for EntityObjectVersionType.
func TestEntityObjectVersionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityObjectVersionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityObjectVersionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityObjectVersionType_ListByType tests listing elements of type EntityObjectVersionType.
func TestEntityObjectVersionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityObjectVersionType", nil)
	req.SetPathValue("type", "EntityObjectVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityObjectVersionType_GetTypeMetadata tests getting type metadata for EntityObjectVersionType.
func TestEntityObjectVersionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityObjectVersionType", nil)
	req.SetPathValue("name", "EntityObjectVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateAnySimpleType_CRUD tests Create, Read, Update, Delete for EntityStateAnySimpleType.
func TestEntityStateAnySimpleType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateAnySimpleType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateAnySimpleType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateAnySimpleType_ListByType tests listing elements of type EntityStateAnySimpleType.
func TestEntityStateAnySimpleType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateAnySimpleType", nil)
	req.SetPathValue("type", "EntityStateAnySimpleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateAnySimpleType_GetTypeMetadata tests getting type metadata for EntityStateAnySimpleType.
func TestEntityStateAnySimpleType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateAnySimpleType", nil)
	req.SetPathValue("name", "EntityStateAnySimpleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateBinaryType_CRUD tests Create, Read, Update, Delete for EntityStateBinaryType.
func TestEntityStateBinaryType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateBinaryType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateBinaryType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateBinaryType_ListByType tests listing elements of type EntityStateBinaryType.
func TestEntityStateBinaryType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateBinaryType", nil)
	req.SetPathValue("type", "EntityStateBinaryType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateBinaryType_GetTypeMetadata tests getting type metadata for EntityStateBinaryType.
func TestEntityStateBinaryType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateBinaryType", nil)
	req.SetPathValue("name", "EntityStateBinaryType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateBoolType_CRUD tests Create, Read, Update, Delete for EntityStateBoolType.
func TestEntityStateBoolType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateBoolType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateBoolType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateBoolType_ListByType tests listing elements of type EntityStateBoolType.
func TestEntityStateBoolType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateBoolType", nil)
	req.SetPathValue("type", "EntityStateBoolType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateBoolType_GetTypeMetadata tests getting type metadata for EntityStateBoolType.
func TestEntityStateBoolType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateBoolType", nil)
	req.SetPathValue("name", "EntityStateBoolType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateDebianEVRStringType_CRUD tests Create, Read, Update, Delete for EntityStateDebianEVRStringType.
func TestEntityStateDebianEVRStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateDebianEVRStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateDebianEVRStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateDebianEVRStringType_ListByType tests listing elements of type EntityStateDebianEVRStringType.
func TestEntityStateDebianEVRStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateDebianEVRStringType", nil)
	req.SetPathValue("type", "EntityStateDebianEVRStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateDebianEVRStringType_GetTypeMetadata tests getting type metadata for EntityStateDebianEVRStringType.
func TestEntityStateDebianEVRStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateDebianEVRStringType", nil)
	req.SetPathValue("name", "EntityStateDebianEVRStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateEVRStringType_CRUD tests Create, Read, Update, Delete for EntityStateEVRStringType.
func TestEntityStateEVRStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateEVRStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateEVRStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateEVRStringType_ListByType tests listing elements of type EntityStateEVRStringType.
func TestEntityStateEVRStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateEVRStringType", nil)
	req.SetPathValue("type", "EntityStateEVRStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateEVRStringType_GetTypeMetadata tests getting type metadata for EntityStateEVRStringType.
func TestEntityStateEVRStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateEVRStringType", nil)
	req.SetPathValue("name", "EntityStateEVRStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateFieldType_CRUD tests Create, Read, Update, Delete for EntityStateFieldType.
func TestEntityStateFieldType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateFieldType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateFieldType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateFieldType_ListByType tests listing elements of type EntityStateFieldType.
func TestEntityStateFieldType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateFieldType", nil)
	req.SetPathValue("type", "EntityStateFieldType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateFieldType_GetTypeMetadata tests getting type metadata for EntityStateFieldType.
func TestEntityStateFieldType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateFieldType", nil)
	req.SetPathValue("name", "EntityStateFieldType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateFileSetRevisionType_CRUD tests Create, Read, Update, Delete for EntityStateFileSetRevisionType.
func TestEntityStateFileSetRevisionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateFileSetRevisionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateFileSetRevisionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateFileSetRevisionType_ListByType tests listing elements of type EntityStateFileSetRevisionType.
func TestEntityStateFileSetRevisionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateFileSetRevisionType", nil)
	req.SetPathValue("type", "EntityStateFileSetRevisionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateFileSetRevisionType_GetTypeMetadata tests getting type metadata for EntityStateFileSetRevisionType.
func TestEntityStateFileSetRevisionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateFileSetRevisionType", nil)
	req.SetPathValue("name", "EntityStateFileSetRevisionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateFloatType_CRUD tests Create, Read, Update, Delete for EntityStateFloatType.
func TestEntityStateFloatType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateFloatType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateFloatType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateFloatType_ListByType tests listing elements of type EntityStateFloatType.
func TestEntityStateFloatType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateFloatType", nil)
	req.SetPathValue("type", "EntityStateFloatType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateFloatType_GetTypeMetadata tests getting type metadata for EntityStateFloatType.
func TestEntityStateFloatType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateFloatType", nil)
	req.SetPathValue("name", "EntityStateFloatType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateIOSVersionType_CRUD tests Create, Read, Update, Delete for EntityStateIOSVersionType.
func TestEntityStateIOSVersionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateIOSVersionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateIOSVersionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateIOSVersionType_ListByType tests listing elements of type EntityStateIOSVersionType.
func TestEntityStateIOSVersionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateIOSVersionType", nil)
	req.SetPathValue("type", "EntityStateIOSVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateIOSVersionType_GetTypeMetadata tests getting type metadata for EntityStateIOSVersionType.
func TestEntityStateIOSVersionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateIOSVersionType", nil)
	req.SetPathValue("name", "EntityStateIOSVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateIPAddressStringType_CRUD tests Create, Read, Update, Delete for EntityStateIPAddressStringType.
func TestEntityStateIPAddressStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateIPAddressStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateIPAddressStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateIPAddressStringType_ListByType tests listing elements of type EntityStateIPAddressStringType.
func TestEntityStateIPAddressStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateIPAddressStringType", nil)
	req.SetPathValue("type", "EntityStateIPAddressStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateIPAddressStringType_GetTypeMetadata tests getting type metadata for EntityStateIPAddressStringType.
func TestEntityStateIPAddressStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateIPAddressStringType", nil)
	req.SetPathValue("name", "EntityStateIPAddressStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateIPAddressType_CRUD tests Create, Read, Update, Delete for EntityStateIPAddressType.
func TestEntityStateIPAddressType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateIPAddressType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateIPAddressType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateIPAddressType_ListByType tests listing elements of type EntityStateIPAddressType.
func TestEntityStateIPAddressType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateIPAddressType", nil)
	req.SetPathValue("type", "EntityStateIPAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateIPAddressType_GetTypeMetadata tests getting type metadata for EntityStateIPAddressType.
func TestEntityStateIPAddressType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateIPAddressType", nil)
	req.SetPathValue("name", "EntityStateIPAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateIntType_CRUD tests Create, Read, Update, Delete for EntityStateIntType.
func TestEntityStateIntType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateIntType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateIntType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateIntType_ListByType tests listing elements of type EntityStateIntType.
func TestEntityStateIntType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateIntType", nil)
	req.SetPathValue("type", "EntityStateIntType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateIntType_GetTypeMetadata tests getting type metadata for EntityStateIntType.
func TestEntityStateIntType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateIntType", nil)
	req.SetPathValue("name", "EntityStateIntType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateRecordType_CRUD tests Create, Read, Update, Delete for EntityStateRecordType.
func TestEntityStateRecordType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateRecordType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateRecordType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateRecordType_ListByType tests listing elements of type EntityStateRecordType.
func TestEntityStateRecordType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateRecordType", nil)
	req.SetPathValue("type", "EntityStateRecordType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateRecordType_GetTypeMetadata tests getting type metadata for EntityStateRecordType.
func TestEntityStateRecordType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateRecordType", nil)
	req.SetPathValue("name", "EntityStateRecordType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateRecordType_GetValidChildTypes tests getting valid child types for EntityStateRecordType.
func TestEntityStateRecordType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateRecordType/children", nil)
	req.SetPathValue("name", "EntityStateRecordType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestEntityStateStringType_CRUD tests Create, Read, Update, Delete for EntityStateStringType.
func TestEntityStateStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateStringType_ListByType tests listing elements of type EntityStateStringType.
func TestEntityStateStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateStringType", nil)
	req.SetPathValue("type", "EntityStateStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateStringType_GetTypeMetadata tests getting type metadata for EntityStateStringType.
func TestEntityStateStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateStringType", nil)
	req.SetPathValue("name", "EntityStateStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateVersionType_CRUD tests Create, Read, Update, Delete for EntityStateVersionType.
func TestEntityStateVersionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EntityStateVersionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EntityStateVersionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEntityStateVersionType_ListByType tests listing elements of type EntityStateVersionType.
func TestEntityStateVersionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EntityStateVersionType", nil)
	req.SetPathValue("type", "EntityStateVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEntityStateVersionType_GetTypeMetadata tests getting type metadata for EntityStateVersionType.
func TestEntityStateVersionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EntityStateVersionType", nil)
	req.SetPathValue("name", "EntityStateVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEscapeRegexFunctionType_CRUD tests Create, Read, Update, Delete for EscapeRegexFunctionType.
func TestEscapeRegexFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "EscapeRegexFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create EscapeRegexFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestEscapeRegexFunctionType_ListByType tests listing elements of type EscapeRegexFunctionType.
func TestEscapeRegexFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/EscapeRegexFunctionType", nil)
	req.SetPathValue("type", "EscapeRegexFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestEscapeRegexFunctionType_GetTypeMetadata tests getting type metadata for EscapeRegexFunctionType.
func TestEscapeRegexFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/EscapeRegexFunctionType", nil)
	req.SetPathValue("name", "EscapeRegexFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExistenceEnumeration_CRUD tests Create, Read, Update, Delete for ExistenceEnumeration.
func TestExistenceEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ExistenceEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ExistenceEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestExistenceEnumeration_ListByType tests listing elements of type ExistenceEnumeration.
func TestExistenceEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ExistenceEnumeration", nil)
	req.SetPathValue("type", "ExistenceEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExistenceEnumeration_GetTypeMetadata tests getting type metadata for ExistenceEnumeration.
func TestExistenceEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ExistenceEnumeration", nil)
	req.SetPathValue("name", "ExistenceEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendDefinitionType_CRUD tests Create, Read, Update, Delete for ExtendDefinitionType.
func TestExtendDefinitionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ExtendDefinitionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ExtendDefinitionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestExtendDefinitionType_ListByType tests listing elements of type ExtendDefinitionType.
func TestExtendDefinitionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ExtendDefinitionType", nil)
	req.SetPathValue("type", "ExtendDefinitionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendDefinitionType_GetTypeMetadata tests getting type metadata for ExtendDefinitionType.
func TestExtendDefinitionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ExtendDefinitionType", nil)
	req.SetPathValue("name", "ExtendDefinitionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtended_CRUD tests Create, Read, Update, Delete for Extended.
func TestExtended_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Extended",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Extended returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestExtended_ListByType tests listing elements of type Extended.
func TestExtended_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Extended", nil)
	req.SetPathValue("type", "Extended")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtended_GetTypeMetadata tests getting type metadata for Extended.
func TestExtended_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Extended", nil)
	req.SetPathValue("name", "Extended")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendedInfoElementType_CRUD tests Create, Read, Update, Delete for ExtendedInfoElementType.
func TestExtendedInfoElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ExtendedInfoElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ExtendedInfoElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestExtendedInfoElementType_ListByType tests listing elements of type ExtendedInfoElementType.
func TestExtendedInfoElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ExtendedInfoElementType", nil)
	req.SetPathValue("type", "ExtendedInfoElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendedInfoElementType_GetTypeMetadata tests getting type metadata for ExtendedInfoElementType.
func TestExtendedInfoElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ExtendedInfoElementType", nil)
	req.SetPathValue("name", "ExtendedInfoElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendedInformationElementType_CRUD tests Create, Read, Update, Delete for ExtendedInformationElementType.
func TestExtendedInformationElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ExtendedInformationElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ExtendedInformationElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestExtendedInformationElementType_ListByType tests listing elements of type ExtendedInformationElementType.
func TestExtendedInformationElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ExtendedInformationElementType", nil)
	req.SetPathValue("type", "ExtendedInformationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendedInformationElementType_GetTypeMetadata tests getting type metadata for ExtendedInformationElementType.
func TestExtendedInformationElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ExtendedInformationElementType", nil)
	req.SetPathValue("name", "ExtendedInformationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendedInfosElementType_CRUD tests Create, Read, Update, Delete for ExtendedInfosElementType.
func TestExtendedInfosElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ExtendedInfosElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ExtendedInfosElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestExtendedInfosElementType_ListByType tests listing elements of type ExtendedInfosElementType.
func TestExtendedInfosElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ExtendedInfosElementType", nil)
	req.SetPathValue("type", "ExtendedInfosElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendedInfosElementType_GetTypeMetadata tests getting type metadata for ExtendedInfosElementType.
func TestExtendedInfosElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ExtendedInfosElementType", nil)
	req.SetPathValue("name", "ExtendedInfosElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExtendedInfosElementType_GetValidChildTypes tests getting valid child types for ExtendedInfosElementType.
func TestExtendedInfosElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ExtendedInfosElementType/children", nil)
	req.SetPathValue("name", "ExtendedInfosElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestExternal_variableElement_CRUD tests Create, Read, Update, Delete for External_variableElement.
func TestExternal_variableElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "External_variableElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create External_variableElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestExternal_variableElement_ListByType tests listing elements of type External_variableElement.
func TestExternal_variableElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/External_variableElement", nil)
	req.SetPathValue("type", "External_variableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExternal_variableElement_GetTypeMetadata tests getting type metadata for External_variableElement.
func TestExternal_variableElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/External_variableElement", nil)
	req.SetPathValue("name", "External_variableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExternal_variableElement_GetValidChildTypes tests getting valid child types for External_variableElement.
func TestExternal_variableElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/External_variableElement/children", nil)
	req.SetPathValue("name", "External_variableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestExternal_variableElementType_CRUD tests Create, Read, Update, Delete for External_variableElementType.
func TestExternal_variableElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "External_variableElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create External_variableElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestExternal_variableElementType_ListByType tests listing elements of type External_variableElementType.
func TestExternal_variableElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/External_variableElementType", nil)
	req.SetPathValue("type", "External_variableElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExternal_variableElementType_GetTypeMetadata tests getting type metadata for External_variableElementType.
func TestExternal_variableElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/External_variableElementType", nil)
	req.SetPathValue("name", "External_variableElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestExternal_variableElementType_GetValidChildTypes tests getting valid child types for External_variableElementType.
func TestExternal_variableElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/External_variableElementType/children", nil)
	req.SetPathValue("name", "External_variableElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestFactRefType_CRUD tests Create, Read, Update, Delete for FactRefType.
func TestFactRefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FactRefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FactRefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFactRefType_ListByType tests listing elements of type FactRefType.
func TestFactRefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FactRefType", nil)
	req.SetPathValue("type", "FactRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFactRefType_GetTypeMetadata tests getting type metadata for FactRefType.
func TestFactRefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FactRefType", nil)
	req.SetPathValue("name", "FactRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFactType_CRUD tests Create, Read, Update, Delete for FactType.
func TestFactType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FactType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FactType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFactType_ListByType tests listing elements of type FactType.
func TestFactType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FactType", nil)
	req.SetPathValue("type", "FactType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFactType_GetTypeMetadata tests getting type metadata for FactType.
func TestFactType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FactType", nil)
	req.SetPathValue("name", "FactType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFamilyEnumeration_CRUD tests Create, Read, Update, Delete for FamilyEnumeration.
func TestFamilyEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FamilyEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FamilyEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFamilyEnumeration_ListByType tests listing elements of type FamilyEnumeration.
func TestFamilyEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FamilyEnumeration", nil)
	req.SetPathValue("type", "FamilyEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFamilyEnumeration_GetTypeMetadata tests getting type metadata for FamilyEnumeration.
func TestFamilyEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FamilyEnumeration", nil)
	req.SetPathValue("name", "FamilyEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFilterActionEnumeration_CRUD tests Create, Read, Update, Delete for FilterActionEnumeration.
func TestFilterActionEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FilterActionEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FilterActionEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFilterActionEnumeration_ListByType tests listing elements of type FilterActionEnumeration.
func TestFilterActionEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FilterActionEnumeration", nil)
	req.SetPathValue("type", "FilterActionEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFilterActionEnumeration_GetTypeMetadata tests getting type metadata for FilterActionEnumeration.
func TestFilterActionEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FilterActionEnumeration", nil)
	req.SetPathValue("name", "FilterActionEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFilterElement_CRUD tests Create, Read, Update, Delete for FilterElement.
func TestFilterElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FilterElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FilterElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFilterElement_ListByType tests listing elements of type FilterElement.
func TestFilterElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FilterElement", nil)
	req.SetPathValue("type", "FilterElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFilterElement_GetTypeMetadata tests getting type metadata for FilterElement.
func TestFilterElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FilterElement", nil)
	req.SetPathValue("name", "FilterElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFilterElementType_CRUD tests Create, Read, Update, Delete for FilterElementType.
func TestFilterElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FilterElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FilterElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFilterElementType_ListByType tests listing elements of type FilterElementType.
func TestFilterElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FilterElementType", nil)
	req.SetPathValue("type", "FilterElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFilterElementType_GetTypeMetadata tests getting type metadata for FilterElementType.
func TestFilterElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FilterElementType", nil)
	req.SetPathValue("name", "FilterElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFirmNameElementType_CRUD tests Create, Read, Update, Delete for FirmNameElementType.
func TestFirmNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FirmNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FirmNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFirmNameElementType_ListByType tests listing elements of type FirmNameElementType.
func TestFirmNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FirmNameElementType", nil)
	req.SetPathValue("type", "FirmNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFirmNameElementType_GetTypeMetadata tests getting type metadata for FirmNameElementType.
func TestFirmNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FirmNameElementType", nil)
	req.SetPathValue("name", "FirmNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFirmType_CRUD tests Create, Read, Update, Delete for FirmType.
func TestFirmType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FirmType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FirmType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFirmType_ListByType tests listing elements of type FirmType.
func TestFirmType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FirmType", nil)
	req.SetPathValue("type", "FirmType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFirmType_GetTypeMetadata tests getting type metadata for FirmType.
func TestFirmType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FirmType", nil)
	req.SetPathValue("name", "FirmType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFirmType_GetValidChildTypes tests getting valid child types for FirmType.
func TestFirmType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FirmType/children", nil)
	req.SetPathValue("name", "FirmType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestFirstNameElementType_CRUD tests Create, Read, Update, Delete for FirstNameElementType.
func TestFirstNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FirstNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FirstNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFirstNameElementType_ListByType tests listing elements of type FirstNameElementType.
func TestFirstNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FirstNameElementType", nil)
	req.SetPathValue("type", "FirstNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFirstNameElementType_GetTypeMetadata tests getting type metadata for FirstNameElementType.
func TestFirstNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FirstNameElementType", nil)
	req.SetPathValue("name", "FirstNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFixStrategyEnumType_CRUD tests Create, Read, Update, Delete for FixStrategyEnumType.
func TestFixStrategyEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FixStrategyEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FixStrategyEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFixStrategyEnumType_ListByType tests listing elements of type FixStrategyEnumType.
func TestFixStrategyEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FixStrategyEnumType", nil)
	req.SetPathValue("type", "FixStrategyEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFixStrategyEnumType_GetTypeMetadata tests getting type metadata for FixStrategyEnumType.
func TestFixStrategyEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FixStrategyEnumType", nil)
	req.SetPathValue("name", "FixStrategyEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFixTextType_CRUD tests Create, Read, Update, Delete for FixTextType.
func TestFixTextType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FixTextType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FixTextType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFixTextType_ListByType tests listing elements of type FixTextType.
func TestFixTextType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FixTextType", nil)
	req.SetPathValue("type", "FixTextType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFixTextType_GetTypeMetadata tests getting type metadata for FixTextType.
func TestFixTextType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FixTextType", nil)
	req.SetPathValue("name", "FixTextType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFixType_CRUD tests Create, Read, Update, Delete for FixType.
func TestFixType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FixType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FixType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFixType_ListByType tests listing elements of type FixType.
func TestFixType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FixType", nil)
	req.SetPathValue("type", "FixType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFixType_GetTypeMetadata tests getting type metadata for FixType.
func TestFixType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FixType", nil)
	req.SetPathValue("name", "FixType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFixType_GetValidChildTypes tests getting valid child types for FixType.
func TestFixType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FixType/children", nil)
	req.SetPathValue("name", "FixType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestFormerNameElementType_CRUD tests Create, Read, Update, Delete for FormerNameElementType.
func TestFormerNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FormerNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FormerNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFormerNameElementType_ListByType tests listing elements of type FormerNameElementType.
func TestFormerNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FormerNameElementType", nil)
	req.SetPathValue("type", "FormerNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFormerNameElementType_GetTypeMetadata tests getting type metadata for FormerNameElementType.
func TestFormerNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FormerNameElementType", nil)
	req.SetPathValue("name", "FormerNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFqdnElement_CRUD tests Create, Read, Update, Delete for FqdnElement.
func TestFqdnElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FqdnElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FqdnElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFqdnElement_ListByType tests listing elements of type FqdnElement.
func TestFqdnElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FqdnElement", nil)
	req.SetPathValue("type", "FqdnElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFqdnElement_GetTypeMetadata tests getting type metadata for FqdnElement.
func TestFqdnElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FqdnElement", nil)
	req.SetPathValue("name", "FqdnElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFqdnElementType_CRUD tests Create, Read, Update, Delete for FqdnElementType.
func TestFqdnElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FqdnElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FqdnElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFqdnElementType_ListByType tests listing elements of type FqdnElementType.
func TestFqdnElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FqdnElementType", nil)
	req.SetPathValue("type", "FqdnElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFqdnElementType_GetTypeMetadata tests getting type metadata for FqdnElementType.
func TestFqdnElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FqdnElementType", nil)
	req.SetPathValue("name", "FqdnElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFromType_CRUD tests Create, Read, Update, Delete for FromType.
func TestFromType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FromType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FromType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFromType_ListByType tests listing elements of type FromType.
func TestFromType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FromType", nil)
	req.SetPathValue("type", "FromType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFromType_GetTypeMetadata tests getting type metadata for FromType.
func TestFromType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FromType", nil)
	req.SetPathValue("name", "FromType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFunction_CRUD tests Create, Read, Update, Delete for Function.
func TestFunction_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Function",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Function returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFunction_ListByType tests listing elements of type Function.
func TestFunction_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Function", nil)
	req.SetPathValue("type", "Function")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFunction_GetTypeMetadata tests getting type metadata for Function.
func TestFunction_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Function", nil)
	req.SetPathValue("name", "Function")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFunctionElement_CRUD tests Create, Read, Update, Delete for FunctionElement.
func TestFunctionElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "FunctionElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create FunctionElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestFunctionElement_ListByType tests listing elements of type FunctionElement.
func TestFunctionElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/FunctionElement", nil)
	req.SetPathValue("type", "FunctionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestFunctionElement_GetTypeMetadata tests getting type metadata for FunctionElement.
func TestFunctionElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/FunctionElement", nil)
	req.SetPathValue("name", "FunctionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGeneralSuffixElementType_CRUD tests Create, Read, Update, Delete for GeneralSuffixElementType.
func TestGeneralSuffixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "GeneralSuffixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create GeneralSuffixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestGeneralSuffixElementType_ListByType tests listing elements of type GeneralSuffixElementType.
func TestGeneralSuffixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/GeneralSuffixElementType", nil)
	req.SetPathValue("type", "GeneralSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGeneralSuffixElementType_GetTypeMetadata tests getting type metadata for GeneralSuffixElementType.
func TestGeneralSuffixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GeneralSuffixElementType", nil)
	req.SetPathValue("name", "GeneralSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGenerationIdentifierElementType_CRUD tests Create, Read, Update, Delete for GenerationIdentifierElementType.
func TestGenerationIdentifierElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "GenerationIdentifierElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create GenerationIdentifierElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestGenerationIdentifierElementType_ListByType tests listing elements of type GenerationIdentifierElementType.
func TestGenerationIdentifierElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/GenerationIdentifierElementType", nil)
	req.SetPathValue("type", "GenerationIdentifierElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGenerationIdentifierElementType_GetTypeMetadata tests getting type metadata for GenerationIdentifierElementType.
func TestGenerationIdentifierElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GenerationIdentifierElementType", nil)
	req.SetPathValue("name", "GenerationIdentifierElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGeneratorType_CRUD tests Create, Read, Update, Delete for GeneratorType.
func TestGeneratorType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "GeneratorType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create GeneratorType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestGeneratorType_ListByType tests listing elements of type GeneratorType.
func TestGeneratorType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/GeneratorType", nil)
	req.SetPathValue("type", "GeneratorType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGeneratorType_GetTypeMetadata tests getting type metadata for GeneratorType.
func TestGeneratorType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GeneratorType", nil)
	req.SetPathValue("name", "GeneratorType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGeneratorType_GetValidChildTypes tests getting valid child types for GeneratorType.
func TestGeneratorType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GeneratorType/children", nil)
	req.SetPathValue("name", "GeneratorType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestGlobToRegexFunctionType_CRUD tests Create, Read, Update, Delete for GlobToRegexFunctionType.
func TestGlobToRegexFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "GlobToRegexFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create GlobToRegexFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestGlobToRegexFunctionType_ListByType tests listing elements of type GlobToRegexFunctionType.
func TestGlobToRegexFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/GlobToRegexFunctionType", nil)
	req.SetPathValue("type", "GlobToRegexFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGlobToRegexFunctionType_GetTypeMetadata tests getting type metadata for GlobToRegexFunctionType.
func TestGlobToRegexFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GlobToRegexFunctionType", nil)
	req.SetPathValue("name", "GlobToRegexFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGroupElement_CRUD tests Create, Read, Update, Delete for GroupElement.
func TestGroupElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "GroupElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create GroupElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestGroupElement_ListByType tests listing elements of type GroupElement.
func TestGroupElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/GroupElement", nil)
	req.SetPathValue("type", "GroupElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGroupElement_GetTypeMetadata tests getting type metadata for GroupElement.
func TestGroupElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GroupElement", nil)
	req.SetPathValue("name", "GroupElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGroupElement_GetValidChildTypes tests getting valid child types for GroupElement.
func TestGroupElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GroupElement/children", nil)
	req.SetPathValue("name", "GroupElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestGroupIdType_CRUD tests Create, Read, Update, Delete for GroupIdType.
func TestGroupIdType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "GroupIdType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create GroupIdType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestGroupIdType_ListByType tests listing elements of type GroupIdType.
func TestGroupIdType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/GroupIdType", nil)
	req.SetPathValue("type", "GroupIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGroupIdType_GetTypeMetadata tests getting type metadata for GroupIdType.
func TestGroupIdType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GroupIdType", nil)
	req.SetPathValue("name", "GroupIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGroupType_CRUD tests Create, Read, Update, Delete for GroupType.
func TestGroupType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "GroupType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create GroupType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestGroupType_ListByType tests listing elements of type GroupType.
func TestGroupType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/GroupType", nil)
	req.SetPathValue("type", "GroupType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGroupType_GetTypeMetadata tests getting type metadata for GroupType.
func TestGroupType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GroupType", nil)
	req.SetPathValue("name", "GroupType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestGroupType_GetValidChildTypes tests getting valid child types for GroupType.
func TestGroupType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/GroupType/children", nil)
	req.SetPathValue("name", "GroupType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestHMACOutputLengthType_CRUD tests Create, Read, Update, Delete for HMACOutputLengthType.
func TestHMACOutputLengthType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "HMACOutputLengthType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create HMACOutputLengthType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestHMACOutputLengthType_ListByType tests listing elements of type HMACOutputLengthType.
func TestHMACOutputLengthType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/HMACOutputLengthType", nil)
	req.SetPathValue("type", "HMACOutputLengthType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHMACOutputLengthType_GetTypeMetadata tests getting type metadata for HMACOutputLengthType.
func TestHMACOutputLengthType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HMACOutputLengthType", nil)
	req.SetPathValue("name", "HMACOutputLengthType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHostElementType_CRUD tests Create, Read, Update, Delete for HostElementType.
func TestHostElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "HostElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create HostElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestHostElementType_ListByType tests listing elements of type HostElementType.
func TestHostElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/HostElementType", nil)
	req.SetPathValue("type", "HostElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHostElementType_GetTypeMetadata tests getting type metadata for HostElementType.
func TestHostElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HostElementType", nil)
	req.SetPathValue("name", "HostElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHostElementType_GetValidChildTypes tests getting valid child types for HostElementType.
func TestHostElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HostElementType/children", nil)
	req.SetPathValue("name", "HostElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestHostnameElementType_CRUD tests Create, Read, Update, Delete for HostnameElementType.
func TestHostnameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "HostnameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create HostnameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestHostnameElementType_ListByType tests listing elements of type HostnameElementType.
func TestHostnameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/HostnameElementType", nil)
	req.SetPathValue("type", "HostnameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHostnameElementType_GetTypeMetadata tests getting type metadata for HostnameElementType.
func TestHostnameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HostnameElementType", nil)
	req.SetPathValue("name", "HostnameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHostnameType_CRUD tests Create, Read, Update, Delete for HostnameType.
func TestHostnameType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "HostnameType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create HostnameType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestHostnameType_ListByType tests listing elements of type HostnameType.
func TestHostnameType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/HostnameType", nil)
	req.SetPathValue("type", "HostnameType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHostnameType_GetTypeMetadata tests getting type metadata for HostnameType.
func TestHostnameType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HostnameType", nil)
	req.SetPathValue("name", "HostnameType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHrefType_CRUD tests Create, Read, Update, Delete for HrefType.
func TestHrefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "HrefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create HrefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestHrefType_ListByType tests listing elements of type HrefType.
func TestHrefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/HrefType", nil)
	req.SetPathValue("type", "HrefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHrefType_GetTypeMetadata tests getting type metadata for HrefType.
func TestHrefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HrefType", nil)
	req.SetPathValue("name", "HrefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHtmlTextType_CRUD tests Create, Read, Update, Delete for HtmlTextType.
func TestHtmlTextType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "HtmlTextType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create HtmlTextType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestHtmlTextType_ListByType tests listing elements of type HtmlTextType.
func TestHtmlTextType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/HtmlTextType", nil)
	req.SetPathValue("type", "HtmlTextType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHtmlTextType_GetTypeMetadata tests getting type metadata for HtmlTextType.
func TestHtmlTextType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HtmlTextType", nil)
	req.SetPathValue("name", "HtmlTextType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHtmlTextWithSubType_CRUD tests Create, Read, Update, Delete for HtmlTextWithSubType.
func TestHtmlTextWithSubType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "HtmlTextWithSubType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create HtmlTextWithSubType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestHtmlTextWithSubType_ListByType tests listing elements of type HtmlTextWithSubType.
func TestHtmlTextWithSubType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/HtmlTextWithSubType", nil)
	req.SetPathValue("type", "HtmlTextWithSubType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHtmlTextWithSubType_GetTypeMetadata tests getting type metadata for HtmlTextWithSubType.
func TestHtmlTextWithSubType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HtmlTextWithSubType", nil)
	req.SetPathValue("name", "HtmlTextWithSubType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestHtmlTextWithSubType_GetValidChildTypes tests getting valid child types for HtmlTextWithSubType.
func TestHtmlTextWithSubType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/HtmlTextWithSubType/children", nil)
	req.SetPathValue("name", "HtmlTextWithSubType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestIdentType_CRUD tests Create, Read, Update, Delete for IdentType.
func TestIdentType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IdentType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IdentType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIdentType_ListByType tests listing elements of type IdentType.
func TestIdentType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IdentType", nil)
	req.SetPathValue("type", "IdentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIdentType_GetTypeMetadata tests getting type metadata for IdentType.
func TestIdentType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IdentType", nil)
	req.SetPathValue("name", "IdentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIdentityType_CRUD tests Create, Read, Update, Delete for IdentityType.
func TestIdentityType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IdentityType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IdentityType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIdentityType_ListByType tests listing elements of type IdentityType.
func TestIdentityType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IdentityType", nil)
	req.SetPathValue("type", "IdentityType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIdentityType_GetTypeMetadata tests getting type metadata for IdentityType.
func TestIdentityType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IdentityType", nil)
	req.SetPathValue("name", "IdentityType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIdrefListType_CRUD tests Create, Read, Update, Delete for IdrefListType.
func TestIdrefListType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IdrefListType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IdrefListType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIdrefListType_ListByType tests listing elements of type IdrefListType.
func TestIdrefListType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IdrefListType", nil)
	req.SetPathValue("type", "IdrefListType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIdrefListType_GetTypeMetadata tests getting type metadata for IdrefListType.
func TestIdrefListType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IdrefListType", nil)
	req.SetPathValue("name", "IdrefListType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIdrefType_CRUD tests Create, Read, Update, Delete for IdrefType.
func TestIdrefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IdrefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IdrefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIdrefType_ListByType tests listing elements of type IdrefType.
func TestIdrefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IdrefType", nil)
	req.SetPathValue("type", "IdrefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIdrefType_GetTypeMetadata tests getting type metadata for IdrefType.
func TestIdrefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IdrefType", nil)
	req.SetPathValue("name", "IdrefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInstallationIdElementType_CRUD tests Create, Read, Update, Delete for InstallationIdElementType.
func TestInstallationIdElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "InstallationIdElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create InstallationIdElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestInstallationIdElementType_ListByType tests listing elements of type InstallationIdElementType.
func TestInstallationIdElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/InstallationIdElementType", nil)
	req.SetPathValue("type", "InstallationIdElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInstallationIdElementType_GetTypeMetadata tests getting type metadata for InstallationIdElementType.
func TestInstallationIdElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/InstallationIdElementType", nil)
	req.SetPathValue("name", "InstallationIdElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInstanceFixType_CRUD tests Create, Read, Update, Delete for InstanceFixType.
func TestInstanceFixType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "InstanceFixType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create InstanceFixType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestInstanceFixType_ListByType tests listing elements of type InstanceFixType.
func TestInstanceFixType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/InstanceFixType", nil)
	req.SetPathValue("type", "InstanceFixType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInstanceFixType_GetTypeMetadata tests getting type metadata for InstanceFixType.
func TestInstanceFixType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/InstanceFixType", nil)
	req.SetPathValue("name", "InstanceFixType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInstanceNameElementType_CRUD tests Create, Read, Update, Delete for InstanceNameElementType.
func TestInstanceNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "InstanceNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create InstanceNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestInstanceNameElementType_ListByType tests listing elements of type InstanceNameElementType.
func TestInstanceNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/InstanceNameElementType", nil)
	req.SetPathValue("type", "InstanceNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInstanceNameElementType_GetTypeMetadata tests getting type metadata for InstanceNameElementType.
func TestInstanceNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/InstanceNameElementType", nil)
	req.SetPathValue("name", "InstanceNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInstanceResultType_CRUD tests Create, Read, Update, Delete for InstanceResultType.
func TestInstanceResultType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "InstanceResultType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create InstanceResultType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestInstanceResultType_ListByType tests listing elements of type InstanceResultType.
func TestInstanceResultType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/InstanceResultType", nil)
	req.SetPathValue("type", "InstanceResultType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInstanceResultType_GetTypeMetadata tests getting type metadata for InstanceResultType.
func TestInstanceResultType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/InstanceResultType", nil)
	req.SetPathValue("name", "InstanceResultType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInterfaceHintType_CRUD tests Create, Read, Update, Delete for InterfaceHintType.
func TestInterfaceHintType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "InterfaceHintType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create InterfaceHintType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestInterfaceHintType_ListByType tests listing elements of type InterfaceHintType.
func TestInterfaceHintType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/InterfaceHintType", nil)
	req.SetPathValue("type", "InterfaceHintType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestInterfaceHintType_GetTypeMetadata tests getting type metadata for InterfaceHintType.
func TestInterfaceHintType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/InterfaceHintType", nil)
	req.SetPathValue("name", "InterfaceHintType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpAddressElement_CRUD tests Create, Read, Update, Delete for IpAddressElement.
func TestIpAddressElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IpAddressElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IpAddressElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIpAddressElement_ListByType tests listing elements of type IpAddressElement.
func TestIpAddressElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IpAddressElement", nil)
	req.SetPathValue("type", "IpAddressElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpAddressElement_GetTypeMetadata tests getting type metadata for IpAddressElement.
func TestIpAddressElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IpAddressElement", nil)
	req.SetPathValue("name", "IpAddressElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpAddressElement_GetValidChildTypes tests getting valid child types for IpAddressElement.
func TestIpAddressElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IpAddressElement/children", nil)
	req.SetPathValue("name", "IpAddressElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestIpAddressType_CRUD tests Create, Read, Update, Delete for IpAddressType.
func TestIpAddressType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IpAddressType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IpAddressType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIpAddressType_ListByType tests listing elements of type IpAddressType.
func TestIpAddressType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IpAddressType", nil)
	req.SetPathValue("type", "IpAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpAddressType_GetTypeMetadata tests getting type metadata for IpAddressType.
func TestIpAddressType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IpAddressType", nil)
	req.SetPathValue("name", "IpAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpAddressType_GetValidChildTypes tests getting valid child types for IpAddressType.
func TestIpAddressType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IpAddressType/children", nil)
	req.SetPathValue("name", "IpAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestIpNetRangeElementType_CRUD tests Create, Read, Update, Delete for IpNetRangeElementType.
func TestIpNetRangeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IpNetRangeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IpNetRangeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIpNetRangeElementType_ListByType tests listing elements of type IpNetRangeElementType.
func TestIpNetRangeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IpNetRangeElementType", nil)
	req.SetPathValue("type", "IpNetRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpNetRangeElementType_GetTypeMetadata tests getting type metadata for IpNetRangeElementType.
func TestIpNetRangeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IpNetRangeElementType", nil)
	req.SetPathValue("name", "IpNetRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpNetRangeElementType_GetValidChildTypes tests getting valid child types for IpNetRangeElementType.
func TestIpNetRangeElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IpNetRangeElementType/children", nil)
	req.SetPathValue("name", "IpNetRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestIpV4ElementType_CRUD tests Create, Read, Update, Delete for IpV4ElementType.
func TestIpV4ElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IpV4ElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IpV4ElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIpV4ElementType_ListByType tests listing elements of type IpV4ElementType.
func TestIpV4ElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IpV4ElementType", nil)
	req.SetPathValue("type", "IpV4ElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpV4ElementType_GetTypeMetadata tests getting type metadata for IpV4ElementType.
func TestIpV4ElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IpV4ElementType", nil)
	req.SetPathValue("name", "IpV4ElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpV6ElementType_CRUD tests Create, Read, Update, Delete for IpV6ElementType.
func TestIpV6ElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "IpV6ElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create IpV6ElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIpV6ElementType_ListByType tests listing elements of type IpV6ElementType.
func TestIpV6ElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/IpV6ElementType", nil)
	req.SetPathValue("type", "IpV6ElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpV6ElementType_GetTypeMetadata tests getting type metadata for IpV6ElementType.
func TestIpV6ElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/IpV6ElementType", nil)
	req.SetPathValue("name", "IpV6ElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpv4Type_CRUD tests Create, Read, Update, Delete for Ipv4Type.
func TestIpv4Type_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Ipv4Type",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Ipv4Type returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIpv4Type_ListByType tests listing elements of type Ipv4Type.
func TestIpv4Type_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Ipv4Type", nil)
	req.SetPathValue("type", "Ipv4Type")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpv4Type_GetTypeMetadata tests getting type metadata for Ipv4Type.
func TestIpv4Type_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Ipv4Type", nil)
	req.SetPathValue("name", "Ipv4Type")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpv6Type_CRUD tests Create, Read, Update, Delete for Ipv6Type.
func TestIpv6Type_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Ipv6Type",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Ipv6Type returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestIpv6Type_ListByType tests listing elements of type Ipv6Type.
func TestIpv6Type_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Ipv6Type", nil)
	req.SetPathValue("type", "Ipv6Type")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestIpv6Type_GetTypeMetadata tests getting type metadata for Ipv6Type.
func TestIpv6Type_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Ipv6Type", nil)
	req.SetPathValue("name", "Ipv6Type")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestItAssetElement_CRUD tests Create, Read, Update, Delete for ItAssetElement.
func TestItAssetElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ItAssetElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ItAssetElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestItAssetElement_ListByType tests listing elements of type ItAssetElement.
func TestItAssetElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ItAssetElement", nil)
	req.SetPathValue("type", "ItAssetElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestItAssetElement_GetTypeMetadata tests getting type metadata for ItAssetElement.
func TestItAssetElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ItAssetElement", nil)
	req.SetPathValue("name", "ItAssetElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestItemElement_CRUD tests Create, Read, Update, Delete for ItemElement.
func TestItemElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ItemElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ItemElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestItemElement_ListByType tests listing elements of type ItemElement.
func TestItemElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ItemElement", nil)
	req.SetPathValue("type", "ItemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestItemElement_GetTypeMetadata tests getting type metadata for ItemElement.
func TestItemElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ItemElement", nil)
	req.SetPathValue("name", "ItemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestItemElement_GetValidChildTypes tests getting valid child types for ItemElement.
func TestItemElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ItemElement/children", nil)
	req.SetPathValue("name", "ItemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestItemIDPattern_CRUD tests Create, Read, Update, Delete for ItemIDPattern.
func TestItemIDPattern_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ItemIDPattern",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ItemIDPattern returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestItemIDPattern_ListByType tests listing elements of type ItemIDPattern.
func TestItemIDPattern_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ItemIDPattern", nil)
	req.SetPathValue("type", "ItemIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestItemIDPattern_GetTypeMetadata tests getting type metadata for ItemIDPattern.
func TestItemIDPattern_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ItemIDPattern", nil)
	req.SetPathValue("name", "ItemIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestJointPersonNameElement_CRUD tests Create, Read, Update, Delete for JointPersonNameElement.
func TestJointPersonNameElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "JointPersonNameElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create JointPersonNameElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestJointPersonNameElement_ListByType tests listing elements of type JointPersonNameElement.
func TestJointPersonNameElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/JointPersonNameElement", nil)
	req.SetPathValue("type", "JointPersonNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestJointPersonNameElement_GetTypeMetadata tests getting type metadata for JointPersonNameElement.
func TestJointPersonNameElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/JointPersonNameElement", nil)
	req.SetPathValue("name", "JointPersonNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestJointPersonNameElement_GetValidChildTypes tests getting valid child types for JointPersonNameElement.
func TestJointPersonNameElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/JointPersonNameElement/children", nil)
	req.SetPathValue("name", "JointPersonNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestJointPersonNameElementType_CRUD tests Create, Read, Update, Delete for JointPersonNameElementType.
func TestJointPersonNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "JointPersonNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create JointPersonNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestJointPersonNameElementType_ListByType tests listing elements of type JointPersonNameElementType.
func TestJointPersonNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/JointPersonNameElementType", nil)
	req.SetPathValue("type", "JointPersonNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestJointPersonNameElementType_GetTypeMetadata tests getting type metadata for JointPersonNameElementType.
func TestJointPersonNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/JointPersonNameElementType", nil)
	req.SetPathValue("name", "JointPersonNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestJointPersonNameElementType_GetValidChildTypes tests getting valid child types for JointPersonNameElementType.
func TestJointPersonNameElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/JointPersonNameElementType/children", nil)
	req.SetPathValue("name", "JointPersonNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestKeyInfoElement_CRUD tests Create, Read, Update, Delete for KeyInfoElement.
func TestKeyInfoElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "KeyInfoElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create KeyInfoElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestKeyInfoElement_ListByType tests listing elements of type KeyInfoElement.
func TestKeyInfoElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/KeyInfoElement", nil)
	req.SetPathValue("type", "KeyInfoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyInfoElement_GetTypeMetadata tests getting type metadata for KeyInfoElement.
func TestKeyInfoElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyInfoElement", nil)
	req.SetPathValue("name", "KeyInfoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyInfoElement_GetValidChildTypes tests getting valid child types for KeyInfoElement.
func TestKeyInfoElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyInfoElement/children", nil)
	req.SetPathValue("name", "KeyInfoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestKeyInfoType_CRUD tests Create, Read, Update, Delete for KeyInfoType.
func TestKeyInfoType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "KeyInfoType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create KeyInfoType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestKeyInfoType_ListByType tests listing elements of type KeyInfoType.
func TestKeyInfoType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/KeyInfoType", nil)
	req.SetPathValue("type", "KeyInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyInfoType_GetTypeMetadata tests getting type metadata for KeyInfoType.
func TestKeyInfoType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyInfoType", nil)
	req.SetPathValue("name", "KeyInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyInfoType_GetValidChildTypes tests getting valid child types for KeyInfoType.
func TestKeyInfoType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyInfoType/children", nil)
	req.SetPathValue("name", "KeyInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestKeyLineCodeElementType_CRUD tests Create, Read, Update, Delete for KeyLineCodeElementType.
func TestKeyLineCodeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "KeyLineCodeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create KeyLineCodeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestKeyLineCodeElementType_ListByType tests listing elements of type KeyLineCodeElementType.
func TestKeyLineCodeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/KeyLineCodeElementType", nil)
	req.SetPathValue("type", "KeyLineCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyLineCodeElementType_GetTypeMetadata tests getting type metadata for KeyLineCodeElementType.
func TestKeyLineCodeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyLineCodeElementType", nil)
	req.SetPathValue("name", "KeyLineCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyNameElement_CRUD tests Create, Read, Update, Delete for KeyNameElement.
func TestKeyNameElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "KeyNameElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create KeyNameElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestKeyNameElement_ListByType tests listing elements of type KeyNameElement.
func TestKeyNameElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/KeyNameElement", nil)
	req.SetPathValue("type", "KeyNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyNameElement_GetTypeMetadata tests getting type metadata for KeyNameElement.
func TestKeyNameElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyNameElement", nil)
	req.SetPathValue("name", "KeyNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyValueElement_CRUD tests Create, Read, Update, Delete for KeyValueElement.
func TestKeyValueElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "KeyValueElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create KeyValueElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestKeyValueElement_ListByType tests listing elements of type KeyValueElement.
func TestKeyValueElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/KeyValueElement", nil)
	req.SetPathValue("type", "KeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyValueElement_GetTypeMetadata tests getting type metadata for KeyValueElement.
func TestKeyValueElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyValueElement", nil)
	req.SetPathValue("name", "KeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyValueElement_GetValidChildTypes tests getting valid child types for KeyValueElement.
func TestKeyValueElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyValueElement/children", nil)
	req.SetPathValue("name", "KeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestKeyValueType_CRUD tests Create, Read, Update, Delete for KeyValueType.
func TestKeyValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "KeyValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create KeyValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestKeyValueType_ListByType tests listing elements of type KeyValueType.
func TestKeyValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/KeyValueType", nil)
	req.SetPathValue("type", "KeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyValueType_GetTypeMetadata tests getting type metadata for KeyValueType.
func TestKeyValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyValueType", nil)
	req.SetPathValue("name", "KeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKeyValueType_GetValidChildTypes tests getting valid child types for KeyValueType.
func TestKeyValueType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KeyValueType/children", nil)
	req.SetPathValue("name", "KeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestKnownAsElementType_CRUD tests Create, Read, Update, Delete for KnownAsElementType.
func TestKnownAsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "KnownAsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create KnownAsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestKnownAsElementType_ListByType tests listing elements of type KnownAsElementType.
func TestKnownAsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/KnownAsElementType", nil)
	req.SetPathValue("type", "KnownAsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestKnownAsElementType_GetTypeMetadata tests getting type metadata for KnownAsElementType.
func TestKnownAsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/KnownAsElementType", nil)
	req.SetPathValue("name", "KnownAsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLabelType_CRUD tests Create, Read, Update, Delete for LabelType.
func TestLabelType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LabelType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LabelType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLabelType_ListByType tests listing elements of type LabelType.
func TestLabelType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LabelType", nil)
	req.SetPathValue("type", "LabelType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLabelType_GetTypeMetadata tests getting type metadata for LabelType.
func TestLabelType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LabelType", nil)
	req.SetPathValue("name", "LabelType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLargeMailUserIdentifierElementType_CRUD tests Create, Read, Update, Delete for LargeMailUserIdentifierElementType.
func TestLargeMailUserIdentifierElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LargeMailUserIdentifierElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LargeMailUserIdentifierElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLargeMailUserIdentifierElementType_ListByType tests listing elements of type LargeMailUserIdentifierElementType.
func TestLargeMailUserIdentifierElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LargeMailUserIdentifierElementType", nil)
	req.SetPathValue("type", "LargeMailUserIdentifierElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLargeMailUserIdentifierElementType_GetTypeMetadata tests getting type metadata for LargeMailUserIdentifierElementType.
func TestLargeMailUserIdentifierElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LargeMailUserIdentifierElementType", nil)
	req.SetPathValue("name", "LargeMailUserIdentifierElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLargeMailUserNameElementType_CRUD tests Create, Read, Update, Delete for LargeMailUserNameElementType.
func TestLargeMailUserNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LargeMailUserNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LargeMailUserNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLargeMailUserNameElementType_ListByType tests listing elements of type LargeMailUserNameElementType.
func TestLargeMailUserNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LargeMailUserNameElementType", nil)
	req.SetPathValue("type", "LargeMailUserNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLargeMailUserNameElementType_GetTypeMetadata tests getting type metadata for LargeMailUserNameElementType.
func TestLargeMailUserNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LargeMailUserNameElementType", nil)
	req.SetPathValue("name", "LargeMailUserNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLargeMailUserType_CRUD tests Create, Read, Update, Delete for LargeMailUserType.
func TestLargeMailUserType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LargeMailUserType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LargeMailUserType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLargeMailUserType_ListByType tests listing elements of type LargeMailUserType.
func TestLargeMailUserType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LargeMailUserType", nil)
	req.SetPathValue("type", "LargeMailUserType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLargeMailUserType_GetTypeMetadata tests getting type metadata for LargeMailUserType.
func TestLargeMailUserType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LargeMailUserType", nil)
	req.SetPathValue("name", "LargeMailUserType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLargeMailUserType_GetValidChildTypes tests getting valid child types for LargeMailUserType.
func TestLargeMailUserType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LargeMailUserType/children", nil)
	req.SetPathValue("name", "LargeMailUserType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestLastNameElementType_CRUD tests Create, Read, Update, Delete for LastNameElementType.
func TestLastNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LastNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LastNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLastNameElementType_ListByType tests listing elements of type LastNameElementType.
func TestLastNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LastNameElementType", nil)
	req.SetPathValue("type", "LastNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLastNameElementType_GetTypeMetadata tests getting type metadata for LastNameElementType.
func TestLastNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LastNameElementType", nil)
	req.SetPathValue("name", "LastNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLicenseElementType_CRUD tests Create, Read, Update, Delete for LicenseElementType.
func TestLicenseElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LicenseElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LicenseElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLicenseElementType_ListByType tests listing elements of type LicenseElementType.
func TestLicenseElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LicenseElementType", nil)
	req.SetPathValue("type", "LicenseElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLicenseElementType_GetTypeMetadata tests getting type metadata for LicenseElementType.
func TestLicenseElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LicenseElementType", nil)
	req.SetPathValue("name", "LicenseElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestListType_CRUD tests Create, Read, Update, Delete for ListType.
func TestListType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ListType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ListType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestListType_ListByType tests listing elements of type ListType.
func TestListType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ListType", nil)
	req.SetPathValue("type", "ListType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestListType_GetTypeMetadata tests getting type metadata for ListType.
func TestListType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ListType", nil)
	req.SetPathValue("name", "ListType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestListType_GetValidChildTypes tests getting valid child types for ListType.
func TestListType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ListType/children", nil)
	req.SetPathValue("name", "ListType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestLiteralComponentType_CRUD tests Create, Read, Update, Delete for LiteralComponentType.
func TestLiteralComponentType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LiteralComponentType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LiteralComponentType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLiteralComponentType_ListByType tests listing elements of type LiteralComponentType.
func TestLiteralComponentType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LiteralComponentType", nil)
	req.SetPathValue("type", "LiteralComponentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLiteralComponentType_GetTypeMetadata tests getting type metadata for LiteralComponentType.
func TestLiteralComponentType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LiteralComponentType", nil)
	req.SetPathValue("name", "LiteralComponentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocal_variableElement_CRUD tests Create, Read, Update, Delete for Local_variableElement.
func TestLocal_variableElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Local_variableElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Local_variableElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocal_variableElement_ListByType tests listing elements of type Local_variableElement.
func TestLocal_variableElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Local_variableElement", nil)
	req.SetPathValue("type", "Local_variableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocal_variableElement_GetTypeMetadata tests getting type metadata for Local_variableElement.
func TestLocal_variableElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Local_variableElement", nil)
	req.SetPathValue("name", "Local_variableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocal_variableElementType_CRUD tests Create, Read, Update, Delete for Local_variableElementType.
func TestLocal_variableElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Local_variableElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Local_variableElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocal_variableElementType_ListByType tests listing elements of type Local_variableElementType.
func TestLocal_variableElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Local_variableElementType", nil)
	req.SetPathValue("type", "Local_variableElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocal_variableElementType_GetTypeMetadata tests getting type metadata for Local_variableElementType.
func TestLocal_variableElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Local_variableElementType", nil)
	req.SetPathValue("name", "Local_variableElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocaleElementType_CRUD tests Create, Read, Update, Delete for LocaleElementType.
func TestLocaleElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocaleElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocaleElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocaleElementType_ListByType tests listing elements of type LocaleElementType.
func TestLocaleElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocaleElementType", nil)
	req.SetPathValue("type", "LocaleElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocaleElementType_GetTypeMetadata tests getting type metadata for LocaleElementType.
func TestLocaleElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocaleElementType", nil)
	req.SetPathValue("name", "LocaleElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocaleType_CRUD tests Create, Read, Update, Delete for LocaleType.
func TestLocaleType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocaleType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocaleType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocaleType_ListByType tests listing elements of type LocaleType.
func TestLocaleType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocaleType", nil)
	req.SetPathValue("type", "LocaleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocaleType_GetTypeMetadata tests getting type metadata for LocaleType.
func TestLocaleType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocaleType", nil)
	req.SetPathValue("name", "LocaleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocalityElement_CRUD tests Create, Read, Update, Delete for LocalityElement.
func TestLocalityElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocalityElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocalityElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocalityElement_ListByType tests listing elements of type LocalityElement.
func TestLocalityElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocalityElement", nil)
	req.SetPathValue("type", "LocalityElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocalityElement_GetTypeMetadata tests getting type metadata for LocalityElement.
func TestLocalityElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocalityElement", nil)
	req.SetPathValue("name", "LocalityElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocalityElement_GetValidChildTypes tests getting valid child types for LocalityElement.
func TestLocalityElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocalityElement/children", nil)
	req.SetPathValue("name", "LocalityElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestLocalityElementType_CRUD tests Create, Read, Update, Delete for LocalityElementType.
func TestLocalityElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocalityElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocalityElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocalityElementType_ListByType tests listing elements of type LocalityElementType.
func TestLocalityElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocalityElementType", nil)
	req.SetPathValue("type", "LocalityElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocalityElementType_GetTypeMetadata tests getting type metadata for LocalityElementType.
func TestLocalityElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocalityElementType", nil)
	req.SetPathValue("name", "LocalityElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocalityElementType_GetValidChildTypes tests getting valid child types for LocalityElementType.
func TestLocalityElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocalityElementType/children", nil)
	req.SetPathValue("name", "LocalityElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestLocalityNameElementType_CRUD tests Create, Read, Update, Delete for LocalityNameElementType.
func TestLocalityNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocalityNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocalityNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocalityNameElementType_ListByType tests listing elements of type LocalityNameElementType.
func TestLocalityNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocalityNameElementType", nil)
	req.SetPathValue("type", "LocalityNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocalityNameElementType_GetTypeMetadata tests getting type metadata for LocalityNameElementType.
func TestLocalityNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocalityNameElementType", nil)
	req.SetPathValue("name", "LocalityNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationAddressElement_CRUD tests Create, Read, Update, Delete for LocationAddressElement.
func TestLocationAddressElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocationAddressElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocationAddressElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocationAddressElement_ListByType tests listing elements of type LocationAddressElement.
func TestLocationAddressElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocationAddressElement", nil)
	req.SetPathValue("type", "LocationAddressElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationAddressElement_GetTypeMetadata tests getting type metadata for LocationAddressElement.
func TestLocationAddressElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationAddressElement", nil)
	req.SetPathValue("name", "LocationAddressElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationElement_CRUD tests Create, Read, Update, Delete for LocationElement.
func TestLocationElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocationElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocationElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocationElement_ListByType tests listing elements of type LocationElement.
func TestLocationElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocationElement", nil)
	req.SetPathValue("type", "LocationElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationElement_GetTypeMetadata tests getting type metadata for LocationElement.
func TestLocationElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationElement", nil)
	req.SetPathValue("name", "LocationElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationPointElement_CRUD tests Create, Read, Update, Delete for LocationPointElement.
func TestLocationPointElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocationPointElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocationPointElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocationPointElement_ListByType tests listing elements of type LocationPointElement.
func TestLocationPointElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocationPointElement", nil)
	req.SetPathValue("type", "LocationPointElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationPointElement_GetTypeMetadata tests getting type metadata for LocationPointElement.
func TestLocationPointElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationPointElement", nil)
	req.SetPathValue("name", "LocationPointElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationPointElementType_CRUD tests Create, Read, Update, Delete for LocationPointElementType.
func TestLocationPointElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocationPointElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocationPointElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocationPointElementType_ListByType tests listing elements of type LocationPointElementType.
func TestLocationPointElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocationPointElementType", nil)
	req.SetPathValue("type", "LocationPointElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationPointElementType_GetTypeMetadata tests getting type metadata for LocationPointElementType.
func TestLocationPointElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationPointElementType", nil)
	req.SetPathValue("name", "LocationPointElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationRegionElement_CRUD tests Create, Read, Update, Delete for LocationRegionElement.
func TestLocationRegionElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocationRegionElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocationRegionElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocationRegionElement_ListByType tests listing elements of type LocationRegionElement.
func TestLocationRegionElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocationRegionElement", nil)
	req.SetPathValue("type", "LocationRegionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationRegionElement_GetTypeMetadata tests getting type metadata for LocationRegionElement.
func TestLocationRegionElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationRegionElement", nil)
	req.SetPathValue("name", "LocationRegionElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationRegionElementType_CRUD tests Create, Read, Update, Delete for LocationRegionElementType.
func TestLocationRegionElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocationRegionElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocationRegionElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocationRegionElementType_ListByType tests listing elements of type LocationRegionElementType.
func TestLocationRegionElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocationRegionElementType", nil)
	req.SetPathValue("type", "LocationRegionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationRegionElementType_GetTypeMetadata tests getting type metadata for LocationRegionElementType.
func TestLocationRegionElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationRegionElementType", nil)
	req.SetPathValue("name", "LocationRegionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationsElement_CRUD tests Create, Read, Update, Delete for LocationsElement.
func TestLocationsElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocationsElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocationsElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocationsElement_ListByType tests listing elements of type LocationsElement.
func TestLocationsElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocationsElement", nil)
	req.SetPathValue("type", "LocationsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationsElement_GetTypeMetadata tests getting type metadata for LocationsElement.
func TestLocationsElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationsElement", nil)
	req.SetPathValue("name", "LocationsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationsElement_GetValidChildTypes tests getting valid child types for LocationsElement.
func TestLocationsElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationsElement/children", nil)
	req.SetPathValue("name", "LocationsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestLocationsElementType_CRUD tests Create, Read, Update, Delete for LocationsElementType.
func TestLocationsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocationsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocationsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocationsElementType_ListByType tests listing elements of type LocationsElementType.
func TestLocationsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocationsElementType", nil)
	req.SetPathValue("type", "LocationsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationsElementType_GetTypeMetadata tests getting type metadata for LocationsElementType.
func TestLocationsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationsElementType", nil)
	req.SetPathValue("name", "LocationsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocationsElementType_GetValidChildTypes tests getting valid child types for LocationsElementType.
func TestLocationsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocationsElementType/children", nil)
	req.SetPathValue("name", "LocationsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestLocatorElement_CRUD tests Create, Read, Update, Delete for LocatorElement.
func TestLocatorElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocatorElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocatorElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocatorElement_ListByType tests listing elements of type LocatorElement.
func TestLocatorElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocatorElement", nil)
	req.SetPathValue("type", "LocatorElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocatorElement_GetTypeMetadata tests getting type metadata for LocatorElement.
func TestLocatorElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocatorElement", nil)
	req.SetPathValue("name", "LocatorElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocatorType_CRUD tests Create, Read, Update, Delete for LocatorType.
func TestLocatorType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LocatorType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LocatorType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLocatorType_ListByType tests listing elements of type LocatorType.
func TestLocatorType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LocatorType", nil)
	req.SetPathValue("type", "LocatorType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLocatorType_GetTypeMetadata tests getting type metadata for LocatorType.
func TestLocatorType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LocatorType", nil)
	req.SetPathValue("name", "LocatorType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLogicalTestType_CRUD tests Create, Read, Update, Delete for LogicalTestType.
func TestLogicalTestType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "LogicalTestType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create LogicalTestType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestLogicalTestType_ListByType tests listing elements of type LogicalTestType.
func TestLogicalTestType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/LogicalTestType", nil)
	req.SetPathValue("type", "LogicalTestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLogicalTestType_GetTypeMetadata tests getting type metadata for LogicalTestType.
func TestLogicalTestType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LogicalTestType", nil)
	req.SetPathValue("name", "LogicalTestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestLogicalTestType_GetValidChildTypes tests getting valid child types for LogicalTestType.
func TestLogicalTestType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/LogicalTestType/children", nil)
	req.SetPathValue("name", "LogicalTestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestMacAddressElementType_CRUD tests Create, Read, Update, Delete for MacAddressElementType.
func TestMacAddressElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MacAddressElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MacAddressElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMacAddressElementType_ListByType tests listing elements of type MacAddressElementType.
func TestMacAddressElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MacAddressElementType", nil)
	req.SetPathValue("type", "MacAddressElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMacAddressElementType_GetTypeMetadata tests getting type metadata for MacAddressElementType.
func TestMacAddressElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MacAddressElementType", nil)
	req.SetPathValue("name", "MacAddressElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMacAddressType_CRUD tests Create, Read, Update, Delete for MacAddressType.
func TestMacAddressType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MacAddressType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MacAddressType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMacAddressType_ListByType tests listing elements of type MacAddressType.
func TestMacAddressType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MacAddressType", nil)
	req.SetPathValue("type", "MacAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMacAddressType_GetTypeMetadata tests getting type metadata for MacAddressType.
func TestMacAddressType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MacAddressType", nil)
	req.SetPathValue("name", "MacAddressType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMailStopNameElementType_CRUD tests Create, Read, Update, Delete for MailStopNameElementType.
func TestMailStopNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MailStopNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MailStopNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMailStopNameElementType_ListByType tests listing elements of type MailStopNameElementType.
func TestMailStopNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MailStopNameElementType", nil)
	req.SetPathValue("type", "MailStopNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMailStopNameElementType_GetTypeMetadata tests getting type metadata for MailStopNameElementType.
func TestMailStopNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MailStopNameElementType", nil)
	req.SetPathValue("name", "MailStopNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMailStopNumberElementType_CRUD tests Create, Read, Update, Delete for MailStopNumberElementType.
func TestMailStopNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MailStopNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MailStopNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMailStopNumberElementType_ListByType tests listing elements of type MailStopNumberElementType.
func TestMailStopNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MailStopNumberElementType", nil)
	req.SetPathValue("type", "MailStopNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMailStopNumberElementType_GetTypeMetadata tests getting type metadata for MailStopNumberElementType.
func TestMailStopNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MailStopNumberElementType", nil)
	req.SetPathValue("name", "MailStopNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMailStopType_CRUD tests Create, Read, Update, Delete for MailStopType.
func TestMailStopType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MailStopType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MailStopType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMailStopType_ListByType tests listing elements of type MailStopType.
func TestMailStopType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MailStopType", nil)
	req.SetPathValue("type", "MailStopType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMailStopType_GetTypeMetadata tests getting type metadata for MailStopType.
func TestMailStopType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MailStopType", nil)
	req.SetPathValue("name", "MailStopType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMailStopType_GetValidChildTypes tests getting valid child types for MailStopType.
func TestMailStopType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MailStopType/children", nil)
	req.SetPathValue("name", "MailStopType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestManifestElement_CRUD tests Create, Read, Update, Delete for ManifestElement.
func TestManifestElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ManifestElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ManifestElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestManifestElement_ListByType tests listing elements of type ManifestElement.
func TestManifestElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ManifestElement", nil)
	req.SetPathValue("type", "ManifestElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestManifestElement_GetTypeMetadata tests getting type metadata for ManifestElement.
func TestManifestElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ManifestElement", nil)
	req.SetPathValue("name", "ManifestElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestManifestElement_GetValidChildTypes tests getting valid child types for ManifestElement.
func TestManifestElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ManifestElement/children", nil)
	req.SetPathValue("name", "ManifestElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestManifestType_CRUD tests Create, Read, Update, Delete for ManifestType.
func TestManifestType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ManifestType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ManifestType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestManifestType_ListByType tests listing elements of type ManifestType.
func TestManifestType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ManifestType", nil)
	req.SetPathValue("type", "ManifestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestManifestType_GetTypeMetadata tests getting type metadata for ManifestType.
func TestManifestType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ManifestType", nil)
	req.SetPathValue("name", "ManifestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestManifestType_GetValidChildTypes tests getting valid child types for ManifestType.
func TestManifestType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ManifestType/children", nil)
	req.SetPathValue("name", "ManifestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestMessageLevelEnumeration_CRUD tests Create, Read, Update, Delete for MessageLevelEnumeration.
func TestMessageLevelEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MessageLevelEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MessageLevelEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMessageLevelEnumeration_ListByType tests listing elements of type MessageLevelEnumeration.
func TestMessageLevelEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MessageLevelEnumeration", nil)
	req.SetPathValue("type", "MessageLevelEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMessageLevelEnumeration_GetTypeMetadata tests getting type metadata for MessageLevelEnumeration.
func TestMessageLevelEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MessageLevelEnumeration", nil)
	req.SetPathValue("name", "MessageLevelEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMessageType_CRUD tests Create, Read, Update, Delete for MessageType.
func TestMessageType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MessageType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MessageType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMessageType_ListByType tests listing elements of type MessageType.
func TestMessageType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MessageType", nil)
	req.SetPathValue("type", "MessageType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMessageType_GetTypeMetadata tests getting type metadata for MessageType.
func TestMessageType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MessageType", nil)
	req.SetPathValue("name", "MessageType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMetadataType_CRUD tests Create, Read, Update, Delete for MetadataType.
func TestMetadataType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MetadataType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MetadataType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMetadataType_ListByType tests listing elements of type MetadataType.
func TestMetadataType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MetadataType", nil)
	req.SetPathValue("type", "MetadataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMetadataType_GetTypeMetadata tests getting type metadata for MetadataType.
func TestMetadataType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MetadataType", nil)
	req.SetPathValue("name", "MetadataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMgmtDataElement_CRUD tests Create, Read, Update, Delete for MgmtDataElement.
func TestMgmtDataElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MgmtDataElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MgmtDataElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMgmtDataElement_ListByType tests listing elements of type MgmtDataElement.
func TestMgmtDataElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MgmtDataElement", nil)
	req.SetPathValue("type", "MgmtDataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMgmtDataElement_GetTypeMetadata tests getting type metadata for MgmtDataElement.
func TestMgmtDataElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MgmtDataElement", nil)
	req.SetPathValue("name", "MgmtDataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMiddleNameElementType_CRUD tests Create, Read, Update, Delete for MiddleNameElementType.
func TestMiddleNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MiddleNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MiddleNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMiddleNameElementType_ListByType tests listing elements of type MiddleNameElementType.
func TestMiddleNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MiddleNameElementType", nil)
	req.SetPathValue("type", "MiddleNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMiddleNameElementType_GetTypeMetadata tests getting type metadata for MiddleNameElementType.
func TestMiddleNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MiddleNameElementType", nil)
	req.SetPathValue("name", "MiddleNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestModelElement_CRUD tests Create, Read, Update, Delete for ModelElement.
func TestModelElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ModelElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ModelElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestModelElement_ListByType tests listing elements of type ModelElement.
func TestModelElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ModelElement", nil)
	req.SetPathValue("type", "ModelElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestModelElement_GetTypeMetadata tests getting type metadata for ModelElement.
func TestModelElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ModelElement", nil)
	req.SetPathValue("name", "ModelElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestModelElement_GetValidChildTypes tests getting valid child types for ModelElement.
func TestModelElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ModelElement/children", nil)
	req.SetPathValue("name", "ModelElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestModelElementType_CRUD tests Create, Read, Update, Delete for ModelElementType.
func TestModelElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ModelElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ModelElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestModelElementType_ListByType tests listing elements of type ModelElementType.
func TestModelElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ModelElementType", nil)
	req.SetPathValue("type", "ModelElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestModelElementType_GetTypeMetadata tests getting type metadata for ModelElementType.
func TestModelElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ModelElementType", nil)
	req.SetPathValue("name", "ModelElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestModelElementType_GetValidChildTypes tests getting valid child types for ModelElementType.
func TestModelElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ModelElementType/children", nil)
	req.SetPathValue("name", "ModelElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestMotherboardGuidElementType_CRUD tests Create, Read, Update, Delete for MotherboardGuidElementType.
func TestMotherboardGuidElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MotherboardGuidElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MotherboardGuidElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMotherboardGuidElementType_ListByType tests listing elements of type MotherboardGuidElementType.
func TestMotherboardGuidElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MotherboardGuidElementType", nil)
	req.SetPathValue("type", "MotherboardGuidElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMotherboardGuidElementType_GetTypeMetadata tests getting type metadata for MotherboardGuidElementType.
func TestMotherboardGuidElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MotherboardGuidElementType", nil)
	req.SetPathValue("name", "MotherboardGuidElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMsgSevEnumType_CRUD tests Create, Read, Update, Delete for MsgSevEnumType.
func TestMsgSevEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "MsgSevEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create MsgSevEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestMsgSevEnumType_ListByType tests listing elements of type MsgSevEnumType.
func TestMsgSevEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/MsgSevEnumType", nil)
	req.SetPathValue("type", "MsgSevEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestMsgSevEnumType_GetTypeMetadata tests getting type metadata for MsgSevEnumType.
func TestMsgSevEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/MsgSevEnumType", nil)
	req.SetPathValue("name", "MsgSevEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNameDetails_CRUD tests Create, Read, Update, Delete for NameDetails.
func TestNameDetails_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NameDetails",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NameDetails returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNameDetails_ListByType tests listing elements of type NameDetails.
func TestNameDetails_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NameDetails", nil)
	req.SetPathValue("type", "NameDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNameDetails_GetTypeMetadata tests getting type metadata for NameDetails.
func TestNameDetails_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NameDetails", nil)
	req.SetPathValue("name", "NameDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNameDetails_GetValidChildTypes tests getting valid child types for NameDetails.
func TestNameDetails_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NameDetails/children", nil)
	req.SetPathValue("name", "NameDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestNameDetailsElement_CRUD tests Create, Read, Update, Delete for NameDetailsElement.
func TestNameDetailsElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NameDetailsElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NameDetailsElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNameDetailsElement_ListByType tests listing elements of type NameDetailsElement.
func TestNameDetailsElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NameDetailsElement", nil)
	req.SetPathValue("type", "NameDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNameDetailsElement_GetTypeMetadata tests getting type metadata for NameDetailsElement.
func TestNameDetailsElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NameDetailsElement", nil)
	req.SetPathValue("name", "NameDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNameDetailsElement_GetValidChildTypes tests getting valid child types for NameDetailsElement.
func TestNameDetailsElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NameDetailsElement/children", nil)
	req.SetPathValue("name", "NameDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestNameDetailsElementType_CRUD tests Create, Read, Update, Delete for NameDetailsElementType.
func TestNameDetailsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NameDetailsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NameDetailsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNameDetailsElementType_ListByType tests listing elements of type NameDetailsElementType.
func TestNameDetailsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NameDetailsElementType", nil)
	req.SetPathValue("type", "NameDetailsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNameDetailsElementType_GetTypeMetadata tests getting type metadata for NameDetailsElementType.
func TestNameDetailsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NameDetailsElementType", nil)
	req.SetPathValue("name", "NameDetailsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNameDetailsElementType_GetValidChildTypes tests getting valid child types for NameDetailsElementType.
func TestNameDetailsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NameDetailsElementType/children", nil)
	req.SetPathValue("name", "NameDetailsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestNameLineType_CRUD tests Create, Read, Update, Delete for NameLineType.
func TestNameLineType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NameLineType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NameLineType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNameLineType_ListByType tests listing elements of type NameLineType.
func TestNameLineType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NameLineType", nil)
	req.SetPathValue("type", "NameLineType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNameLineType_GetTypeMetadata tests getting type metadata for NameLineType.
func TestNameLineType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NameLineType", nil)
	req.SetPathValue("name", "NameLineType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNamePattern_CRUD tests Create, Read, Update, Delete for NamePattern.
func TestNamePattern_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NamePattern",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NamePattern returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNamePattern_ListByType tests listing elements of type NamePattern.
func TestNamePattern_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NamePattern", nil)
	req.SetPathValue("type", "NamePattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNamePattern_GetTypeMetadata tests getting type metadata for NamePattern.
func TestNamePattern_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NamePattern", nil)
	req.SetPathValue("name", "NamePattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNamePrefixElementType_CRUD tests Create, Read, Update, Delete for NamePrefixElementType.
func TestNamePrefixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NamePrefixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NamePrefixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNamePrefixElementType_ListByType tests listing elements of type NamePrefixElementType.
func TestNamePrefixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NamePrefixElementType", nil)
	req.SetPathValue("type", "NamePrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNamePrefixElementType_GetTypeMetadata tests getting type metadata for NamePrefixElementType.
func TestNamePrefixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NamePrefixElementType", nil)
	req.SetPathValue("name", "NamePrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkElement_CRUD tests Create, Read, Update, Delete for NetworkElement.
func TestNetworkElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NetworkElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NetworkElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNetworkElement_ListByType tests listing elements of type NetworkElement.
func TestNetworkElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NetworkElement", nil)
	req.SetPathValue("type", "NetworkElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkElement_GetTypeMetadata tests getting type metadata for NetworkElement.
func TestNetworkElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NetworkElement", nil)
	req.SetPathValue("name", "NetworkElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkElement_GetValidChildTypes tests getting valid child types for NetworkElement.
func TestNetworkElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NetworkElement/children", nil)
	req.SetPathValue("name", "NetworkElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestNetworkInterfaceType_CRUD tests Create, Read, Update, Delete for NetworkInterfaceType.
func TestNetworkInterfaceType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NetworkInterfaceType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NetworkInterfaceType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNetworkInterfaceType_ListByType tests listing elements of type NetworkInterfaceType.
func TestNetworkInterfaceType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NetworkInterfaceType", nil)
	req.SetPathValue("type", "NetworkInterfaceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkInterfaceType_GetTypeMetadata tests getting type metadata for NetworkInterfaceType.
func TestNetworkInterfaceType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NetworkInterfaceType", nil)
	req.SetPathValue("name", "NetworkInterfaceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkInterfaceType_GetValidChildTypes tests getting valid child types for NetworkInterfaceType.
func TestNetworkInterfaceType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NetworkInterfaceType/children", nil)
	req.SetPathValue("name", "NetworkInterfaceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestNetworkNameElementType_CRUD tests Create, Read, Update, Delete for NetworkNameElementType.
func TestNetworkNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NetworkNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NetworkNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNetworkNameElementType_ListByType tests listing elements of type NetworkNameElementType.
func TestNetworkNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NetworkNameElementType", nil)
	req.SetPathValue("type", "NetworkNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkNameElementType_GetTypeMetadata tests getting type metadata for NetworkNameElementType.
func TestNetworkNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NetworkNameElementType", nil)
	req.SetPathValue("name", "NetworkNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkType_CRUD tests Create, Read, Update, Delete for NetworkType.
func TestNetworkType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NetworkType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NetworkType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNetworkType_ListByType tests listing elements of type NetworkType.
func TestNetworkType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NetworkType", nil)
	req.SetPathValue("type", "NetworkType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkType_GetTypeMetadata tests getting type metadata for NetworkType.
func TestNetworkType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NetworkType", nil)
	req.SetPathValue("name", "NetworkType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNetworkType_GetValidChildTypes tests getting valid child types for NetworkType.
func TestNetworkType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NetworkType/children", nil)
	req.SetPathValue("name", "NetworkType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestNonEmptyStringType_CRUD tests Create, Read, Update, Delete for NonEmptyStringType.
func TestNonEmptyStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NonEmptyStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NonEmptyStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNonEmptyStringType_ListByType tests listing elements of type NonEmptyStringType.
func TestNonEmptyStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NonEmptyStringType", nil)
	req.SetPathValue("type", "NonEmptyStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNonEmptyStringType_GetTypeMetadata tests getting type metadata for NonEmptyStringType.
func TestNonEmptyStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NonEmptyStringType", nil)
	req.SetPathValue("name", "NonEmptyStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNotesElement_CRUD tests Create, Read, Update, Delete for NotesElement.
func TestNotesElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NotesElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NotesElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNotesElement_ListByType tests listing elements of type NotesElement.
func TestNotesElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NotesElement", nil)
	req.SetPathValue("type", "NotesElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNotesElement_GetTypeMetadata tests getting type metadata for NotesElement.
func TestNotesElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NotesElement", nil)
	req.SetPathValue("name", "NotesElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNotesElementType_CRUD tests Create, Read, Update, Delete for NotesElementType.
func TestNotesElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NotesElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NotesElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNotesElementType_ListByType tests listing elements of type NotesElementType.
func TestNotesElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NotesElementType", nil)
	req.SetPathValue("type", "NotesElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNotesElementType_GetTypeMetadata tests getting type metadata for NotesElementType.
func TestNotesElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NotesElementType", nil)
	req.SetPathValue("name", "NotesElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNotesType_CRUD tests Create, Read, Update, Delete for NotesType.
func TestNotesType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NotesType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NotesType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNotesType_ListByType tests listing elements of type NotesType.
func TestNotesType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NotesType", nil)
	req.SetPathValue("type", "NotesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNotesType_GetTypeMetadata tests getting type metadata for NotesType.
func TestNotesType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NotesType", nil)
	req.SetPathValue("name", "NotesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNoticeType_CRUD tests Create, Read, Update, Delete for NoticeType.
func TestNoticeType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "NoticeType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create NoticeType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestNoticeType_ListByType tests listing elements of type NoticeType.
func TestNoticeType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/NoticeType", nil)
	req.SetPathValue("type", "NoticeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestNoticeType_GetTypeMetadata tests getting type metadata for NoticeType.
func TestNoticeType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/NoticeType", nil)
	req.SetPathValue("name", "NoticeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectComponentType_CRUD tests Create, Read, Update, Delete for ObjectComponentType.
func TestObjectComponentType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ObjectComponentType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ObjectComponentType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestObjectComponentType_ListByType tests listing elements of type ObjectComponentType.
func TestObjectComponentType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ObjectComponentType", nil)
	req.SetPathValue("type", "ObjectComponentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectComponentType_GetTypeMetadata tests getting type metadata for ObjectComponentType.
func TestObjectComponentType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectComponentType", nil)
	req.SetPathValue("name", "ObjectComponentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectElement_CRUD tests Create, Read, Update, Delete for ObjectElement.
func TestObjectElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ObjectElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ObjectElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestObjectElement_ListByType tests listing elements of type ObjectElement.
func TestObjectElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ObjectElement", nil)
	req.SetPathValue("type", "ObjectElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectElement_GetTypeMetadata tests getting type metadata for ObjectElement.
func TestObjectElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectElement", nil)
	req.SetPathValue("name", "ObjectElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectElement_GetValidChildTypes tests getting valid child types for ObjectElement.
func TestObjectElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectElement/children", nil)
	req.SetPathValue("name", "ObjectElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestObjectIDPattern_CRUD tests Create, Read, Update, Delete for ObjectIDPattern.
func TestObjectIDPattern_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ObjectIDPattern",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ObjectIDPattern returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestObjectIDPattern_ListByType tests listing elements of type ObjectIDPattern.
func TestObjectIDPattern_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ObjectIDPattern", nil)
	req.SetPathValue("type", "ObjectIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectIDPattern_GetTypeMetadata tests getting type metadata for ObjectIDPattern.
func TestObjectIDPattern_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectIDPattern", nil)
	req.SetPathValue("name", "ObjectIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectRefElement_CRUD tests Create, Read, Update, Delete for ObjectRefElement.
func TestObjectRefElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ObjectRefElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ObjectRefElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestObjectRefElement_ListByType tests listing elements of type ObjectRefElement.
func TestObjectRefElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ObjectRefElement", nil)
	req.SetPathValue("type", "ObjectRefElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectRefElement_GetTypeMetadata tests getting type metadata for ObjectRefElement.
func TestObjectRefElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectRefElement", nil)
	req.SetPathValue("name", "ObjectRefElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectRefElementType_CRUD tests Create, Read, Update, Delete for ObjectRefElementType.
func TestObjectRefElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ObjectRefElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ObjectRefElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestObjectRefElementType_ListByType tests listing elements of type ObjectRefElementType.
func TestObjectRefElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ObjectRefElementType", nil)
	req.SetPathValue("type", "ObjectRefElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectRefElementType_GetTypeMetadata tests getting type metadata for ObjectRefElementType.
func TestObjectRefElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectRefElementType", nil)
	req.SetPathValue("name", "ObjectRefElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectRefType_CRUD tests Create, Read, Update, Delete for ObjectRefType.
func TestObjectRefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ObjectRefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ObjectRefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestObjectRefType_ListByType tests listing elements of type ObjectRefType.
func TestObjectRefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ObjectRefType", nil)
	req.SetPathValue("type", "ObjectRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectRefType_GetTypeMetadata tests getting type metadata for ObjectRefType.
func TestObjectRefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectRefType", nil)
	req.SetPathValue("name", "ObjectRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectType_CRUD tests Create, Read, Update, Delete for ObjectType.
func TestObjectType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ObjectType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ObjectType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestObjectType_ListByType tests listing elements of type ObjectType.
func TestObjectType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ObjectType", nil)
	req.SetPathValue("type", "ObjectType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectType_GetTypeMetadata tests getting type metadata for ObjectType.
func TestObjectType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectType", nil)
	req.SetPathValue("name", "ObjectType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectsType_CRUD tests Create, Read, Update, Delete for ObjectsType.
func TestObjectsType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ObjectsType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ObjectsType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestObjectsType_ListByType tests listing elements of type ObjectsType.
func TestObjectsType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ObjectsType", nil)
	req.SetPathValue("type", "ObjectsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectsType_GetTypeMetadata tests getting type metadata for ObjectsType.
func TestObjectsType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectsType", nil)
	req.SetPathValue("name", "ObjectsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestObjectsType_GetValidChildTypes tests getting valid child types for ObjectsType.
func TestObjectsType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ObjectsType/children", nil)
	req.SetPathValue("name", "ObjectsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOperationEnumeration_CRUD tests Create, Read, Update, Delete for OperationEnumeration.
func TestOperationEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OperationEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OperationEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOperationEnumeration_ListByType tests listing elements of type OperationEnumeration.
func TestOperationEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OperationEnumeration", nil)
	req.SetPathValue("type", "OperationEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOperationEnumeration_GetTypeMetadata tests getting type metadata for OperationEnumeration.
func TestOperationEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OperationEnumeration", nil)
	req.SetPathValue("name", "OperationEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOperatorEnumeration_CRUD tests Create, Read, Update, Delete for OperatorEnumeration.
func TestOperatorEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OperatorEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OperatorEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOperatorEnumeration_ListByType tests listing elements of type OperatorEnumeration.
func TestOperatorEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OperatorEnumeration", nil)
	req.SetPathValue("type", "OperatorEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOperatorEnumeration_GetTypeMetadata tests getting type metadata for OperatorEnumeration.
func TestOperatorEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OperatorEnumeration", nil)
	req.SetPathValue("name", "OperatorEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationFormerNameElementType_CRUD tests Create, Read, Update, Delete for OrganisationFormerNameElementType.
func TestOrganisationFormerNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganisationFormerNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganisationFormerNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganisationFormerNameElementType_ListByType tests listing elements of type OrganisationFormerNameElementType.
func TestOrganisationFormerNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganisationFormerNameElementType", nil)
	req.SetPathValue("type", "OrganisationFormerNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationFormerNameElementType_GetTypeMetadata tests getting type metadata for OrganisationFormerNameElementType.
func TestOrganisationFormerNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationFormerNameElementType", nil)
	req.SetPathValue("name", "OrganisationFormerNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationKnownAsElementType_CRUD tests Create, Read, Update, Delete for OrganisationKnownAsElementType.
func TestOrganisationKnownAsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganisationKnownAsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganisationKnownAsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganisationKnownAsElementType_ListByType tests listing elements of type OrganisationKnownAsElementType.
func TestOrganisationKnownAsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganisationKnownAsElementType", nil)
	req.SetPathValue("type", "OrganisationKnownAsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationKnownAsElementType_GetTypeMetadata tests getting type metadata for OrganisationKnownAsElementType.
func TestOrganisationKnownAsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationKnownAsElementType", nil)
	req.SetPathValue("name", "OrganisationKnownAsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationNameDetails_CRUD tests Create, Read, Update, Delete for OrganisationNameDetails.
func TestOrganisationNameDetails_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganisationNameDetails",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganisationNameDetails returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganisationNameDetails_ListByType tests listing elements of type OrganisationNameDetails.
func TestOrganisationNameDetails_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganisationNameDetails", nil)
	req.SetPathValue("type", "OrganisationNameDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationNameDetails_GetTypeMetadata tests getting type metadata for OrganisationNameDetails.
func TestOrganisationNameDetails_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationNameDetails", nil)
	req.SetPathValue("name", "OrganisationNameDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationNameDetails_GetValidChildTypes tests getting valid child types for OrganisationNameDetails.
func TestOrganisationNameDetails_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationNameDetails/children", nil)
	req.SetPathValue("name", "OrganisationNameDetails")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOrganisationNameDetailsElement_CRUD tests Create, Read, Update, Delete for OrganisationNameDetailsElement.
func TestOrganisationNameDetailsElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganisationNameDetailsElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganisationNameDetailsElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganisationNameDetailsElement_ListByType tests listing elements of type OrganisationNameDetailsElement.
func TestOrganisationNameDetailsElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganisationNameDetailsElement", nil)
	req.SetPathValue("type", "OrganisationNameDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationNameDetailsElement_GetTypeMetadata tests getting type metadata for OrganisationNameDetailsElement.
func TestOrganisationNameDetailsElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationNameDetailsElement", nil)
	req.SetPathValue("name", "OrganisationNameDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationNameDetailsElement_GetValidChildTypes tests getting valid child types for OrganisationNameDetailsElement.
func TestOrganisationNameDetailsElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationNameDetailsElement/children", nil)
	req.SetPathValue("name", "OrganisationNameDetailsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOrganisationNameDetailsElementType_CRUD tests Create, Read, Update, Delete for OrganisationNameDetailsElementType.
func TestOrganisationNameDetailsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganisationNameDetailsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganisationNameDetailsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganisationNameDetailsElementType_ListByType tests listing elements of type OrganisationNameDetailsElementType.
func TestOrganisationNameDetailsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganisationNameDetailsElementType", nil)
	req.SetPathValue("type", "OrganisationNameDetailsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationNameDetailsElementType_GetTypeMetadata tests getting type metadata for OrganisationNameDetailsElementType.
func TestOrganisationNameDetailsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationNameDetailsElementType", nil)
	req.SetPathValue("name", "OrganisationNameDetailsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationNameDetailsElementType_GetValidChildTypes tests getting valid child types for OrganisationNameDetailsElementType.
func TestOrganisationNameDetailsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationNameDetailsElementType/children", nil)
	req.SetPathValue("name", "OrganisationNameDetailsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOrganisationNameElementType_CRUD tests Create, Read, Update, Delete for OrganisationNameElementType.
func TestOrganisationNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganisationNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganisationNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganisationNameElementType_ListByType tests listing elements of type OrganisationNameElementType.
func TestOrganisationNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganisationNameElementType", nil)
	req.SetPathValue("type", "OrganisationNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationNameElementType_GetTypeMetadata tests getting type metadata for OrganisationNameElementType.
func TestOrganisationNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationNameElementType", nil)
	req.SetPathValue("name", "OrganisationNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationTypeElementType_CRUD tests Create, Read, Update, Delete for OrganisationTypeElementType.
func TestOrganisationTypeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganisationTypeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganisationTypeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganisationTypeElementType_ListByType tests listing elements of type OrganisationTypeElementType.
func TestOrganisationTypeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganisationTypeElementType", nil)
	req.SetPathValue("type", "OrganisationTypeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganisationTypeElementType_GetTypeMetadata tests getting type metadata for OrganisationTypeElementType.
func TestOrganisationTypeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganisationTypeElementType", nil)
	req.SetPathValue("name", "OrganisationTypeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganizationElement_CRUD tests Create, Read, Update, Delete for OrganizationElement.
func TestOrganizationElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganizationElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganizationElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganizationElement_ListByType tests listing elements of type OrganizationElement.
func TestOrganizationElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganizationElement", nil)
	req.SetPathValue("type", "OrganizationElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganizationElement_GetTypeMetadata tests getting type metadata for OrganizationElement.
func TestOrganizationElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganizationElement", nil)
	req.SetPathValue("name", "OrganizationElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganizationElement_GetValidChildTypes tests getting valid child types for OrganizationElement.
func TestOrganizationElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganizationElement/children", nil)
	req.SetPathValue("name", "OrganizationElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOrganizationType_CRUD tests Create, Read, Update, Delete for OrganizationType.
func TestOrganizationType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OrganizationType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OrganizationType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOrganizationType_ListByType tests listing elements of type OrganizationType.
func TestOrganizationType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OrganizationType", nil)
	req.SetPathValue("type", "OrganizationType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganizationType_GetTypeMetadata tests getting type metadata for OrganizationType.
func TestOrganizationType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganizationType", nil)
	req.SetPathValue("name", "OrganizationType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOrganizationType_GetValidChildTypes tests getting valid child types for OrganizationType.
func TestOrganizationType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OrganizationType/children", nil)
	req.SetPathValue("name", "OrganizationType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOtherNameElementType_CRUD tests Create, Read, Update, Delete for OtherNameElementType.
func TestOtherNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OtherNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OtherNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOtherNameElementType_ListByType tests listing elements of type OtherNameElementType.
func TestOtherNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OtherNameElementType", nil)
	req.SetPathValue("type", "OtherNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOtherNameElementType_GetTypeMetadata tests getting type metadata for OtherNameElementType.
func TestOtherNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OtherNameElementType", nil)
	req.SetPathValue("name", "OtherNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOval_definitionsElement_CRUD tests Create, Read, Update, Delete for Oval_definitionsElement.
func TestOval_definitionsElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Oval_definitionsElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Oval_definitionsElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOval_definitionsElement_ListByType tests listing elements of type Oval_definitionsElement.
func TestOval_definitionsElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Oval_definitionsElement", nil)
	req.SetPathValue("type", "Oval_definitionsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOval_definitionsElement_GetTypeMetadata tests getting type metadata for Oval_definitionsElement.
func TestOval_definitionsElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Oval_definitionsElement", nil)
	req.SetPathValue("name", "Oval_definitionsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOval_definitionsElement_GetValidChildTypes tests getting valid child types for Oval_definitionsElement.
func TestOval_definitionsElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Oval_definitionsElement/children", nil)
	req.SetPathValue("name", "Oval_definitionsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOval_definitionsElementType_CRUD tests Create, Read, Update, Delete for Oval_definitionsElementType.
func TestOval_definitionsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Oval_definitionsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Oval_definitionsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOval_definitionsElementType_ListByType tests listing elements of type Oval_definitionsElementType.
func TestOval_definitionsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Oval_definitionsElementType", nil)
	req.SetPathValue("type", "Oval_definitionsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOval_definitionsElementType_GetTypeMetadata tests getting type metadata for Oval_definitionsElementType.
func TestOval_definitionsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Oval_definitionsElementType", nil)
	req.SetPathValue("name", "Oval_definitionsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOval_definitionsElementType_GetValidChildTypes tests getting valid child types for Oval_definitionsElementType.
func TestOval_definitionsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Oval_definitionsElementType/children", nil)
	req.SetPathValue("name", "Oval_definitionsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOverrideType_CRUD tests Create, Read, Update, Delete for OverrideType.
func TestOverrideType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OverrideType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OverrideType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOverrideType_ListByType tests listing elements of type OverrideType.
func TestOverrideType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OverrideType", nil)
	req.SetPathValue("type", "OverrideType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOverrideType_GetTypeMetadata tests getting type metadata for OverrideType.
func TestOverrideType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OverrideType", nil)
	req.SetPathValue("name", "OverrideType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOverrideType_GetValidChildTypes tests getting valid child types for OverrideType.
func TestOverrideType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OverrideType/children", nil)
	req.SetPathValue("name", "OverrideType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestOverrideableCPE2idrefType_CRUD tests Create, Read, Update, Delete for OverrideableCPE2idrefType.
func TestOverrideableCPE2idrefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "OverrideableCPE2idrefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create OverrideableCPE2idrefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestOverrideableCPE2idrefType_ListByType tests listing elements of type OverrideableCPE2idrefType.
func TestOverrideableCPE2idrefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/OverrideableCPE2idrefType", nil)
	req.SetPathValue("type", "OverrideableCPE2idrefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestOverrideableCPE2idrefType_GetTypeMetadata tests getting type metadata for OverrideableCPE2idrefType.
func TestOverrideableCPE2idrefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/OverrideableCPE2idrefType", nil)
	req.SetPathValue("name", "OverrideableCPE2idrefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPGPDataElement_CRUD tests Create, Read, Update, Delete for PGPDataElement.
func TestPGPDataElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PGPDataElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PGPDataElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPGPDataElement_ListByType tests listing elements of type PGPDataElement.
func TestPGPDataElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PGPDataElement", nil)
	req.SetPathValue("type", "PGPDataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPGPDataElement_GetTypeMetadata tests getting type metadata for PGPDataElement.
func TestPGPDataElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PGPDataElement", nil)
	req.SetPathValue("name", "PGPDataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPGPDataType_CRUD tests Create, Read, Update, Delete for PGPDataType.
func TestPGPDataType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PGPDataType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PGPDataType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPGPDataType_ListByType tests listing elements of type PGPDataType.
func TestPGPDataType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PGPDataType", nil)
	req.SetPathValue("type", "PGPDataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPGPDataType_GetTypeMetadata tests getting type metadata for PGPDataType.
func TestPGPDataType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PGPDataType", nil)
	req.SetPathValue("name", "PGPDataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestParamType_CRUD tests Create, Read, Update, Delete for ParamType.
func TestParamType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ParamType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ParamType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestParamType_ListByType tests listing elements of type ParamType.
func TestParamType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ParamType", nil)
	req.SetPathValue("type", "ParamType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestParamType_GetTypeMetadata tests getting type metadata for ParamType.
func TestParamType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ParamType", nil)
	req.SetPathValue("name", "ParamType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonElement_CRUD tests Create, Read, Update, Delete for PersonElement.
func TestPersonElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PersonElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PersonElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPersonElement_ListByType tests listing elements of type PersonElement.
func TestPersonElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PersonElement", nil)
	req.SetPathValue("type", "PersonElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonElement_GetTypeMetadata tests getting type metadata for PersonElement.
func TestPersonElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonElement", nil)
	req.SetPathValue("name", "PersonElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonElement_GetValidChildTypes tests getting valid child types for PersonElement.
func TestPersonElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonElement/children", nil)
	req.SetPathValue("name", "PersonElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPersonName_CRUD tests Create, Read, Update, Delete for PersonName.
func TestPersonName_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PersonName",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PersonName returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPersonName_ListByType tests listing elements of type PersonName.
func TestPersonName_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PersonName", nil)
	req.SetPathValue("type", "PersonName")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonName_GetTypeMetadata tests getting type metadata for PersonName.
func TestPersonName_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonName", nil)
	req.SetPathValue("name", "PersonName")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonName_GetValidChildTypes tests getting valid child types for PersonName.
func TestPersonName_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonName/children", nil)
	req.SetPathValue("name", "PersonName")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPersonNameElement_CRUD tests Create, Read, Update, Delete for PersonNameElement.
func TestPersonNameElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PersonNameElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PersonNameElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPersonNameElement_ListByType tests listing elements of type PersonNameElement.
func TestPersonNameElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PersonNameElement", nil)
	req.SetPathValue("type", "PersonNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonNameElement_GetTypeMetadata tests getting type metadata for PersonNameElement.
func TestPersonNameElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonNameElement", nil)
	req.SetPathValue("name", "PersonNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonNameElement_GetValidChildTypes tests getting valid child types for PersonNameElement.
func TestPersonNameElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonNameElement/children", nil)
	req.SetPathValue("name", "PersonNameElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPersonNameElementType_CRUD tests Create, Read, Update, Delete for PersonNameElementType.
func TestPersonNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PersonNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PersonNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPersonNameElementType_ListByType tests listing elements of type PersonNameElementType.
func TestPersonNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PersonNameElementType", nil)
	req.SetPathValue("type", "PersonNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonNameElementType_GetTypeMetadata tests getting type metadata for PersonNameElementType.
func TestPersonNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonNameElementType", nil)
	req.SetPathValue("name", "PersonNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonNameElementType_GetValidChildTypes tests getting valid child types for PersonNameElementType.
func TestPersonNameElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonNameElementType/children", nil)
	req.SetPathValue("name", "PersonNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPersonType_CRUD tests Create, Read, Update, Delete for PersonType.
func TestPersonType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PersonType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PersonType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPersonType_ListByType tests listing elements of type PersonType.
func TestPersonType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PersonType", nil)
	req.SetPathValue("type", "PersonType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonType_GetTypeMetadata tests getting type metadata for PersonType.
func TestPersonType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonType", nil)
	req.SetPathValue("name", "PersonType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPersonType_GetValidChildTypes tests getting valid child types for PersonType.
func TestPersonType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PersonType/children", nil)
	req.SetPathValue("name", "PersonType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPlainTextType_CRUD tests Create, Read, Update, Delete for PlainTextType.
func TestPlainTextType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PlainTextType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PlainTextType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPlainTextType_ListByType tests listing elements of type PlainTextType.
func TestPlainTextType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PlainTextType", nil)
	req.SetPathValue("type", "PlainTextType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPlainTextType_GetTypeMetadata tests getting type metadata for PlainTextType.
func TestPlainTextType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PlainTextType", nil)
	req.SetPathValue("name", "PlainTextType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPlatformSpecificationElement_CRUD tests Create, Read, Update, Delete for PlatformSpecificationElement.
func TestPlatformSpecificationElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PlatformSpecificationElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PlatformSpecificationElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPlatformSpecificationElement_ListByType tests listing elements of type PlatformSpecificationElement.
func TestPlatformSpecificationElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PlatformSpecificationElement", nil)
	req.SetPathValue("type", "PlatformSpecificationElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPlatformSpecificationElement_GetTypeMetadata tests getting type metadata for PlatformSpecificationElement.
func TestPlatformSpecificationElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PlatformSpecificationElement", nil)
	req.SetPathValue("name", "PlatformSpecificationElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPlatformSpecificationElement_GetValidChildTypes tests getting valid child types for PlatformSpecificationElement.
func TestPlatformSpecificationElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PlatformSpecificationElement/children", nil)
	req.SetPathValue("name", "PlatformSpecificationElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPlatformSpecificationElementType_CRUD tests Create, Read, Update, Delete for PlatformSpecificationElementType.
func TestPlatformSpecificationElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PlatformSpecificationElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PlatformSpecificationElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPlatformSpecificationElementType_ListByType tests listing elements of type PlatformSpecificationElementType.
func TestPlatformSpecificationElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PlatformSpecificationElementType", nil)
	req.SetPathValue("type", "PlatformSpecificationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPlatformSpecificationElementType_GetTypeMetadata tests getting type metadata for PlatformSpecificationElementType.
func TestPlatformSpecificationElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PlatformSpecificationElementType", nil)
	req.SetPathValue("name", "PlatformSpecificationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPlatformSpecificationElementType_GetValidChildTypes tests getting valid child types for PlatformSpecificationElementType.
func TestPlatformSpecificationElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PlatformSpecificationElementType/children", nil)
	req.SetPathValue("name", "PlatformSpecificationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPlatformType_CRUD tests Create, Read, Update, Delete for PlatformType.
func TestPlatformType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PlatformType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PlatformType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPlatformType_ListByType tests listing elements of type PlatformType.
func TestPlatformType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PlatformType", nil)
	req.SetPathValue("type", "PlatformType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPlatformType_GetTypeMetadata tests getting type metadata for PlatformType.
func TestPlatformType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PlatformType", nil)
	req.SetPathValue("name", "PlatformType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPlatformType_GetValidChildTypes tests getting valid child types for PlatformType.
func TestPlatformType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PlatformType/children", nil)
	req.SetPathValue("name", "PlatformType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPortElementType_CRUD tests Create, Read, Update, Delete for PortElementType.
func TestPortElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PortElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PortElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPortElementType_ListByType tests listing elements of type PortElementType.
func TestPortElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PortElementType", nil)
	req.SetPathValue("type", "PortElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPortElementType_GetTypeMetadata tests getting type metadata for PortElementType.
func TestPortElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PortElementType", nil)
	req.SetPathValue("name", "PortElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPortRangeElementType_CRUD tests Create, Read, Update, Delete for PortRangeElementType.
func TestPortRangeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PortRangeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PortRangeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPortRangeElementType_ListByType tests listing elements of type PortRangeElementType.
func TestPortRangeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PortRangeElementType", nil)
	req.SetPathValue("type", "PortRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPortRangeElementType_GetTypeMetadata tests getting type metadata for PortRangeElementType.
func TestPortRangeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PortRangeElementType", nil)
	req.SetPathValue("name", "PortRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPortType_CRUD tests Create, Read, Update, Delete for PortType.
func TestPortType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PortType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PortType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPortType_ListByType tests listing elements of type PortType.
func TestPortType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PortType", nil)
	req.SetPathValue("type", "PortType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPortType_GetTypeMetadata tests getting type metadata for PortType.
func TestPortType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PortType", nil)
	req.SetPathValue("name", "PortType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPossibleRestrictionType_CRUD tests Create, Read, Update, Delete for PossibleRestrictionType.
func TestPossibleRestrictionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PossibleRestrictionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PossibleRestrictionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPossibleRestrictionType_ListByType tests listing elements of type PossibleRestrictionType.
func TestPossibleRestrictionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PossibleRestrictionType", nil)
	req.SetPathValue("type", "PossibleRestrictionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPossibleRestrictionType_GetTypeMetadata tests getting type metadata for PossibleRestrictionType.
func TestPossibleRestrictionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PossibleRestrictionType", nil)
	req.SetPathValue("name", "PossibleRestrictionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPossibleRestrictionType_GetValidChildTypes tests getting valid child types for PossibleRestrictionType.
func TestPossibleRestrictionType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PossibleRestrictionType/children", nil)
	req.SetPathValue("name", "PossibleRestrictionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPossibleValueType_CRUD tests Create, Read, Update, Delete for PossibleValueType.
func TestPossibleValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PossibleValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PossibleValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPossibleValueType_ListByType tests listing elements of type PossibleValueType.
func TestPossibleValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PossibleValueType", nil)
	req.SetPathValue("type", "PossibleValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPossibleValueType_GetTypeMetadata tests getting type metadata for PossibleValueType.
func TestPossibleValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PossibleValueType", nil)
	req.SetPathValue("name", "PossibleValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxElement_CRUD tests Create, Read, Update, Delete for PostBoxElement.
func TestPostBoxElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostBoxElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostBoxElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostBoxElement_ListByType tests listing elements of type PostBoxElement.
func TestPostBoxElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostBoxElement", nil)
	req.SetPathValue("type", "PostBoxElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxElement_GetTypeMetadata tests getting type metadata for PostBoxElement.
func TestPostBoxElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostBoxElement", nil)
	req.SetPathValue("name", "PostBoxElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxElement_GetValidChildTypes tests getting valid child types for PostBoxElement.
func TestPostBoxElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostBoxElement/children", nil)
	req.SetPathValue("name", "PostBoxElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPostBoxElementType_CRUD tests Create, Read, Update, Delete for PostBoxElementType.
func TestPostBoxElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostBoxElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostBoxElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostBoxElementType_ListByType tests listing elements of type PostBoxElementType.
func TestPostBoxElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostBoxElementType", nil)
	req.SetPathValue("type", "PostBoxElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxElementType_GetTypeMetadata tests getting type metadata for PostBoxElementType.
func TestPostBoxElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostBoxElementType", nil)
	req.SetPathValue("name", "PostBoxElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxElementType_GetValidChildTypes tests getting valid child types for PostBoxElementType.
func TestPostBoxElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostBoxElementType/children", nil)
	req.SetPathValue("name", "PostBoxElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPostBoxNumberElementType_CRUD tests Create, Read, Update, Delete for PostBoxNumberElementType.
func TestPostBoxNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostBoxNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostBoxNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostBoxNumberElementType_ListByType tests listing elements of type PostBoxNumberElementType.
func TestPostBoxNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostBoxNumberElementType", nil)
	req.SetPathValue("type", "PostBoxNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxNumberElementType_GetTypeMetadata tests getting type metadata for PostBoxNumberElementType.
func TestPostBoxNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostBoxNumberElementType", nil)
	req.SetPathValue("name", "PostBoxNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxNumberExtensionElementType_CRUD tests Create, Read, Update, Delete for PostBoxNumberExtensionElementType.
func TestPostBoxNumberExtensionElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostBoxNumberExtensionElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostBoxNumberExtensionElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostBoxNumberExtensionElementType_ListByType tests listing elements of type PostBoxNumberExtensionElementType.
func TestPostBoxNumberExtensionElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostBoxNumberExtensionElementType", nil)
	req.SetPathValue("type", "PostBoxNumberExtensionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxNumberExtensionElementType_GetTypeMetadata tests getting type metadata for PostBoxNumberExtensionElementType.
func TestPostBoxNumberExtensionElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostBoxNumberExtensionElementType", nil)
	req.SetPathValue("name", "PostBoxNumberExtensionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxNumberPrefixElementType_CRUD tests Create, Read, Update, Delete for PostBoxNumberPrefixElementType.
func TestPostBoxNumberPrefixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostBoxNumberPrefixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostBoxNumberPrefixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostBoxNumberPrefixElementType_ListByType tests listing elements of type PostBoxNumberPrefixElementType.
func TestPostBoxNumberPrefixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostBoxNumberPrefixElementType", nil)
	req.SetPathValue("type", "PostBoxNumberPrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxNumberPrefixElementType_GetTypeMetadata tests getting type metadata for PostBoxNumberPrefixElementType.
func TestPostBoxNumberPrefixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostBoxNumberPrefixElementType", nil)
	req.SetPathValue("name", "PostBoxNumberPrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxNumberSuffixElementType_CRUD tests Create, Read, Update, Delete for PostBoxNumberSuffixElementType.
func TestPostBoxNumberSuffixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostBoxNumberSuffixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostBoxNumberSuffixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostBoxNumberSuffixElementType_ListByType tests listing elements of type PostBoxNumberSuffixElementType.
func TestPostBoxNumberSuffixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostBoxNumberSuffixElementType", nil)
	req.SetPathValue("type", "PostBoxNumberSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostBoxNumberSuffixElementType_GetTypeMetadata tests getting type metadata for PostBoxNumberSuffixElementType.
func TestPostBoxNumberSuffixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostBoxNumberSuffixElementType", nil)
	req.SetPathValue("name", "PostBoxNumberSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostOfficeElement_CRUD tests Create, Read, Update, Delete for PostOfficeElement.
func TestPostOfficeElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostOfficeElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostOfficeElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostOfficeElement_ListByType tests listing elements of type PostOfficeElement.
func TestPostOfficeElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostOfficeElement", nil)
	req.SetPathValue("type", "PostOfficeElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostOfficeElement_GetTypeMetadata tests getting type metadata for PostOfficeElement.
func TestPostOfficeElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostOfficeElement", nil)
	req.SetPathValue("name", "PostOfficeElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostOfficeElement_GetValidChildTypes tests getting valid child types for PostOfficeElement.
func TestPostOfficeElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostOfficeElement/children", nil)
	req.SetPathValue("name", "PostOfficeElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPostOfficeElementType_CRUD tests Create, Read, Update, Delete for PostOfficeElementType.
func TestPostOfficeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostOfficeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostOfficeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostOfficeElementType_ListByType tests listing elements of type PostOfficeElementType.
func TestPostOfficeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostOfficeElementType", nil)
	req.SetPathValue("type", "PostOfficeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostOfficeElementType_GetTypeMetadata tests getting type metadata for PostOfficeElementType.
func TestPostOfficeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostOfficeElementType", nil)
	req.SetPathValue("name", "PostOfficeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostOfficeElementType_GetValidChildTypes tests getting valid child types for PostOfficeElementType.
func TestPostOfficeElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostOfficeElementType/children", nil)
	req.SetPathValue("name", "PostOfficeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPostOfficeNameElementType_CRUD tests Create, Read, Update, Delete for PostOfficeNameElementType.
func TestPostOfficeNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostOfficeNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostOfficeNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostOfficeNameElementType_ListByType tests listing elements of type PostOfficeNameElementType.
func TestPostOfficeNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostOfficeNameElementType", nil)
	req.SetPathValue("type", "PostOfficeNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostOfficeNameElementType_GetTypeMetadata tests getting type metadata for PostOfficeNameElementType.
func TestPostOfficeNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostOfficeNameElementType", nil)
	req.SetPathValue("name", "PostOfficeNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostOfficeNumberElementType_CRUD tests Create, Read, Update, Delete for PostOfficeNumberElementType.
func TestPostOfficeNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostOfficeNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostOfficeNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostOfficeNumberElementType_ListByType tests listing elements of type PostOfficeNumberElementType.
func TestPostOfficeNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostOfficeNumberElementType", nil)
	req.SetPathValue("type", "PostOfficeNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostOfficeNumberElementType_GetTypeMetadata tests getting type metadata for PostOfficeNumberElementType.
func TestPostOfficeNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostOfficeNumberElementType", nil)
	req.SetPathValue("name", "PostOfficeNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostTownElementType_CRUD tests Create, Read, Update, Delete for PostTownElementType.
func TestPostTownElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostTownElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostTownElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostTownElementType_ListByType tests listing elements of type PostTownElementType.
func TestPostTownElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostTownElementType", nil)
	req.SetPathValue("type", "PostTownElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostTownElementType_GetTypeMetadata tests getting type metadata for PostTownElementType.
func TestPostTownElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostTownElementType", nil)
	req.SetPathValue("name", "PostTownElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostTownElementType_GetValidChildTypes tests getting valid child types for PostTownElementType.
func TestPostTownElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostTownElementType/children", nil)
	req.SetPathValue("name", "PostTownElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPostTownNameElementType_CRUD tests Create, Read, Update, Delete for PostTownNameElementType.
func TestPostTownNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostTownNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostTownNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostTownNameElementType_ListByType tests listing elements of type PostTownNameElementType.
func TestPostTownNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostTownNameElementType", nil)
	req.SetPathValue("type", "PostTownNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostTownNameElementType_GetTypeMetadata tests getting type metadata for PostTownNameElementType.
func TestPostTownNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostTownNameElementType", nil)
	req.SetPathValue("name", "PostTownNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostTownSuffixElementType_CRUD tests Create, Read, Update, Delete for PostTownSuffixElementType.
func TestPostTownSuffixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostTownSuffixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostTownSuffixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostTownSuffixElementType_ListByType tests listing elements of type PostTownSuffixElementType.
func TestPostTownSuffixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostTownSuffixElementType", nil)
	req.SetPathValue("type", "PostTownSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostTownSuffixElementType_GetTypeMetadata tests getting type metadata for PostTownSuffixElementType.
func TestPostTownSuffixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostTownSuffixElementType", nil)
	req.SetPathValue("name", "PostTownSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalCodeElement_CRUD tests Create, Read, Update, Delete for PostalCodeElement.
func TestPostalCodeElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostalCodeElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostalCodeElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostalCodeElement_ListByType tests listing elements of type PostalCodeElement.
func TestPostalCodeElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostalCodeElement", nil)
	req.SetPathValue("type", "PostalCodeElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalCodeElement_GetTypeMetadata tests getting type metadata for PostalCodeElement.
func TestPostalCodeElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalCodeElement", nil)
	req.SetPathValue("name", "PostalCodeElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalCodeElement_GetValidChildTypes tests getting valid child types for PostalCodeElement.
func TestPostalCodeElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalCodeElement/children", nil)
	req.SetPathValue("name", "PostalCodeElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPostalCodeElementType_CRUD tests Create, Read, Update, Delete for PostalCodeElementType.
func TestPostalCodeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostalCodeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostalCodeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostalCodeElementType_ListByType tests listing elements of type PostalCodeElementType.
func TestPostalCodeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostalCodeElementType", nil)
	req.SetPathValue("type", "PostalCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalCodeElementType_GetTypeMetadata tests getting type metadata for PostalCodeElementType.
func TestPostalCodeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalCodeElementType", nil)
	req.SetPathValue("name", "PostalCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalCodeElementType_GetValidChildTypes tests getting valid child types for PostalCodeElementType.
func TestPostalCodeElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalCodeElementType/children", nil)
	req.SetPathValue("name", "PostalCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPostalCodeNumberElementType_CRUD tests Create, Read, Update, Delete for PostalCodeNumberElementType.
func TestPostalCodeNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostalCodeNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostalCodeNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostalCodeNumberElementType_ListByType tests listing elements of type PostalCodeNumberElementType.
func TestPostalCodeNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostalCodeNumberElementType", nil)
	req.SetPathValue("type", "PostalCodeNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalCodeNumberElementType_GetTypeMetadata tests getting type metadata for PostalCodeNumberElementType.
func TestPostalCodeNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalCodeNumberElementType", nil)
	req.SetPathValue("name", "PostalCodeNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalCodeNumberExtensionElementType_CRUD tests Create, Read, Update, Delete for PostalCodeNumberExtensionElementType.
func TestPostalCodeNumberExtensionElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostalCodeNumberExtensionElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostalCodeNumberExtensionElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostalCodeNumberExtensionElementType_ListByType tests listing elements of type PostalCodeNumberExtensionElementType.
func TestPostalCodeNumberExtensionElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostalCodeNumberExtensionElementType", nil)
	req.SetPathValue("type", "PostalCodeNumberExtensionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalCodeNumberExtensionElementType_GetTypeMetadata tests getting type metadata for PostalCodeNumberExtensionElementType.
func TestPostalCodeNumberExtensionElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalCodeNumberExtensionElementType", nil)
	req.SetPathValue("name", "PostalCodeNumberExtensionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalRouteNameElementType_CRUD tests Create, Read, Update, Delete for PostalRouteNameElementType.
func TestPostalRouteNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostalRouteNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostalRouteNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostalRouteNameElementType_ListByType tests listing elements of type PostalRouteNameElementType.
func TestPostalRouteNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostalRouteNameElementType", nil)
	req.SetPathValue("type", "PostalRouteNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalRouteNameElementType_GetTypeMetadata tests getting type metadata for PostalRouteNameElementType.
func TestPostalRouteNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalRouteNameElementType", nil)
	req.SetPathValue("name", "PostalRouteNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalRouteNumberElementType_CRUD tests Create, Read, Update, Delete for PostalRouteNumberElementType.
func TestPostalRouteNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostalRouteNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostalRouteNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostalRouteNumberElementType_ListByType tests listing elements of type PostalRouteNumberElementType.
func TestPostalRouteNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostalRouteNumberElementType", nil)
	req.SetPathValue("type", "PostalRouteNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalRouteNumberElementType_GetTypeMetadata tests getting type metadata for PostalRouteNumberElementType.
func TestPostalRouteNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalRouteNumberElementType", nil)
	req.SetPathValue("name", "PostalRouteNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalRouteType_CRUD tests Create, Read, Update, Delete for PostalRouteType.
func TestPostalRouteType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostalRouteType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostalRouteType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostalRouteType_ListByType tests listing elements of type PostalRouteType.
func TestPostalRouteType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostalRouteType", nil)
	req.SetPathValue("type", "PostalRouteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalRouteType_GetTypeMetadata tests getting type metadata for PostalRouteType.
func TestPostalRouteType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalRouteType", nil)
	req.SetPathValue("name", "PostalRouteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalRouteType_GetValidChildTypes tests getting valid child types for PostalRouteType.
func TestPostalRouteType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalRouteType/children", nil)
	req.SetPathValue("name", "PostalRouteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPostalServiceElementsElementType_CRUD tests Create, Read, Update, Delete for PostalServiceElementsElementType.
func TestPostalServiceElementsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PostalServiceElementsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PostalServiceElementsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPostalServiceElementsElementType_ListByType tests listing elements of type PostalServiceElementsElementType.
func TestPostalServiceElementsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PostalServiceElementsElementType", nil)
	req.SetPathValue("type", "PostalServiceElementsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalServiceElementsElementType_GetTypeMetadata tests getting type metadata for PostalServiceElementsElementType.
func TestPostalServiceElementsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalServiceElementsElementType", nil)
	req.SetPathValue("name", "PostalServiceElementsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPostalServiceElementsElementType_GetValidChildTypes tests getting valid child types for PostalServiceElementsElementType.
func TestPostalServiceElementsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PostalServiceElementsElementType/children", nil)
	req.SetPathValue("name", "PostalServiceElementsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPrecedingTitleElementType_CRUD tests Create, Read, Update, Delete for PrecedingTitleElementType.
func TestPrecedingTitleElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PrecedingTitleElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PrecedingTitleElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPrecedingTitleElementType_ListByType tests listing elements of type PrecedingTitleElementType.
func TestPrecedingTitleElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PrecedingTitleElementType", nil)
	req.SetPathValue("type", "PrecedingTitleElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPrecedingTitleElementType_GetTypeMetadata tests getting type metadata for PrecedingTitleElementType.
func TestPrecedingTitleElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PrecedingTitleElementType", nil)
	req.SetPathValue("name", "PrecedingTitleElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseElement_CRUD tests Create, Read, Update, Delete for PremiseElement.
func TestPremiseElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseElement_ListByType tests listing elements of type PremiseElement.
func TestPremiseElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseElement", nil)
	req.SetPathValue("type", "PremiseElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseElement_GetTypeMetadata tests getting type metadata for PremiseElement.
func TestPremiseElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseElement", nil)
	req.SetPathValue("name", "PremiseElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseElement_GetValidChildTypes tests getting valid child types for PremiseElement.
func TestPremiseElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseElement/children", nil)
	req.SetPathValue("name", "PremiseElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPremiseElementType_CRUD tests Create, Read, Update, Delete for PremiseElementType.
func TestPremiseElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseElementType_ListByType tests listing elements of type PremiseElementType.
func TestPremiseElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseElementType", nil)
	req.SetPathValue("type", "PremiseElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseElementType_GetTypeMetadata tests getting type metadata for PremiseElementType.
func TestPremiseElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseElementType", nil)
	req.SetPathValue("name", "PremiseElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseElementType_GetValidChildTypes tests getting valid child types for PremiseElementType.
func TestPremiseElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseElementType/children", nil)
	req.SetPathValue("name", "PremiseElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPremiseLocationElementType_CRUD tests Create, Read, Update, Delete for PremiseLocationElementType.
func TestPremiseLocationElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseLocationElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseLocationElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseLocationElementType_ListByType tests listing elements of type PremiseLocationElementType.
func TestPremiseLocationElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseLocationElementType", nil)
	req.SetPathValue("type", "PremiseLocationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseLocationElementType_GetTypeMetadata tests getting type metadata for PremiseLocationElementType.
func TestPremiseLocationElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseLocationElementType", nil)
	req.SetPathValue("name", "PremiseLocationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNameElementType_CRUD tests Create, Read, Update, Delete for PremiseNameElementType.
func TestPremiseNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNameElementType_ListByType tests listing elements of type PremiseNameElementType.
func TestPremiseNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNameElementType", nil)
	req.SetPathValue("type", "PremiseNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNameElementType_GetTypeMetadata tests getting type metadata for PremiseNameElementType.
func TestPremiseNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNameElementType", nil)
	req.SetPathValue("name", "PremiseNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberElement_CRUD tests Create, Read, Update, Delete for PremiseNumberElement.
func TestPremiseNumberElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberElement_ListByType tests listing elements of type PremiseNumberElement.
func TestPremiseNumberElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberElement", nil)
	req.SetPathValue("type", "PremiseNumberElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberElement_GetTypeMetadata tests getting type metadata for PremiseNumberElement.
func TestPremiseNumberElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberElement", nil)
	req.SetPathValue("name", "PremiseNumberElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberElementType_CRUD tests Create, Read, Update, Delete for PremiseNumberElementType.
func TestPremiseNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberElementType_ListByType tests listing elements of type PremiseNumberElementType.
func TestPremiseNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberElementType", nil)
	req.SetPathValue("type", "PremiseNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberElementType_GetTypeMetadata tests getting type metadata for PremiseNumberElementType.
func TestPremiseNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberElementType", nil)
	req.SetPathValue("name", "PremiseNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberPrefixElement_CRUD tests Create, Read, Update, Delete for PremiseNumberPrefixElement.
func TestPremiseNumberPrefixElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberPrefixElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberPrefixElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberPrefixElement_ListByType tests listing elements of type PremiseNumberPrefixElement.
func TestPremiseNumberPrefixElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberPrefixElement", nil)
	req.SetPathValue("type", "PremiseNumberPrefixElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberPrefixElement_GetTypeMetadata tests getting type metadata for PremiseNumberPrefixElement.
func TestPremiseNumberPrefixElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberPrefixElement", nil)
	req.SetPathValue("name", "PremiseNumberPrefixElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberPrefixElementType_CRUD tests Create, Read, Update, Delete for PremiseNumberPrefixElementType.
func TestPremiseNumberPrefixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberPrefixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberPrefixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberPrefixElementType_ListByType tests listing elements of type PremiseNumberPrefixElementType.
func TestPremiseNumberPrefixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberPrefixElementType", nil)
	req.SetPathValue("type", "PremiseNumberPrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberPrefixElementType_GetTypeMetadata tests getting type metadata for PremiseNumberPrefixElementType.
func TestPremiseNumberPrefixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberPrefixElementType", nil)
	req.SetPathValue("name", "PremiseNumberPrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberRangeElementType_CRUD tests Create, Read, Update, Delete for PremiseNumberRangeElementType.
func TestPremiseNumberRangeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberRangeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberRangeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberRangeElementType_ListByType tests listing elements of type PremiseNumberRangeElementType.
func TestPremiseNumberRangeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberRangeElementType", nil)
	req.SetPathValue("type", "PremiseNumberRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberRangeElementType_GetTypeMetadata tests getting type metadata for PremiseNumberRangeElementType.
func TestPremiseNumberRangeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberRangeElementType", nil)
	req.SetPathValue("name", "PremiseNumberRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberRangeElementType_GetValidChildTypes tests getting valid child types for PremiseNumberRangeElementType.
func TestPremiseNumberRangeElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberRangeElementType/children", nil)
	req.SetPathValue("name", "PremiseNumberRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPremiseNumberRangeFromElementType_CRUD tests Create, Read, Update, Delete for PremiseNumberRangeFromElementType.
func TestPremiseNumberRangeFromElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberRangeFromElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberRangeFromElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberRangeFromElementType_ListByType tests listing elements of type PremiseNumberRangeFromElementType.
func TestPremiseNumberRangeFromElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberRangeFromElementType", nil)
	req.SetPathValue("type", "PremiseNumberRangeFromElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberRangeFromElementType_GetTypeMetadata tests getting type metadata for PremiseNumberRangeFromElementType.
func TestPremiseNumberRangeFromElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberRangeFromElementType", nil)
	req.SetPathValue("name", "PremiseNumberRangeFromElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberRangeFromElementType_GetValidChildTypes tests getting valid child types for PremiseNumberRangeFromElementType.
func TestPremiseNumberRangeFromElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberRangeFromElementType/children", nil)
	req.SetPathValue("name", "PremiseNumberRangeFromElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPremiseNumberRangeToElementType_CRUD tests Create, Read, Update, Delete for PremiseNumberRangeToElementType.
func TestPremiseNumberRangeToElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberRangeToElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberRangeToElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberRangeToElementType_ListByType tests listing elements of type PremiseNumberRangeToElementType.
func TestPremiseNumberRangeToElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberRangeToElementType", nil)
	req.SetPathValue("type", "PremiseNumberRangeToElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberRangeToElementType_GetTypeMetadata tests getting type metadata for PremiseNumberRangeToElementType.
func TestPremiseNumberRangeToElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberRangeToElementType", nil)
	req.SetPathValue("name", "PremiseNumberRangeToElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberRangeToElementType_GetValidChildTypes tests getting valid child types for PremiseNumberRangeToElementType.
func TestPremiseNumberRangeToElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberRangeToElementType/children", nil)
	req.SetPathValue("name", "PremiseNumberRangeToElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestPremiseNumberSuffixElement_CRUD tests Create, Read, Update, Delete for PremiseNumberSuffixElement.
func TestPremiseNumberSuffixElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberSuffixElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberSuffixElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberSuffixElement_ListByType tests listing elements of type PremiseNumberSuffixElement.
func TestPremiseNumberSuffixElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberSuffixElement", nil)
	req.SetPathValue("type", "PremiseNumberSuffixElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberSuffixElement_GetTypeMetadata tests getting type metadata for PremiseNumberSuffixElement.
func TestPremiseNumberSuffixElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberSuffixElement", nil)
	req.SetPathValue("name", "PremiseNumberSuffixElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberSuffixElementType_CRUD tests Create, Read, Update, Delete for PremiseNumberSuffixElementType.
func TestPremiseNumberSuffixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "PremiseNumberSuffixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create PremiseNumberSuffixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestPremiseNumberSuffixElementType_ListByType tests listing elements of type PremiseNumberSuffixElementType.
func TestPremiseNumberSuffixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/PremiseNumberSuffixElementType", nil)
	req.SetPathValue("type", "PremiseNumberSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestPremiseNumberSuffixElementType_GetTypeMetadata tests getting type metadata for PremiseNumberSuffixElementType.
func TestPremiseNumberSuffixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/PremiseNumberSuffixElementType", nil)
	req.SetPathValue("name", "PremiseNumberSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileElement_CRUD tests Create, Read, Update, Delete for ProfileElement.
func TestProfileElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileElement_ListByType tests listing elements of type ProfileElement.
func TestProfileElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileElement", nil)
	req.SetPathValue("type", "ProfileElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileElement_GetTypeMetadata tests getting type metadata for ProfileElement.
func TestProfileElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileElement", nil)
	req.SetPathValue("name", "ProfileElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileElement_GetValidChildTypes tests getting valid child types for ProfileElement.
func TestProfileElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileElement/children", nil)
	req.SetPathValue("name", "ProfileElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestProfileIdType_CRUD tests Create, Read, Update, Delete for ProfileIdType.
func TestProfileIdType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileIdType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileIdType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileIdType_ListByType tests listing elements of type ProfileIdType.
func TestProfileIdType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileIdType", nil)
	req.SetPathValue("type", "ProfileIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileIdType_GetTypeMetadata tests getting type metadata for ProfileIdType.
func TestProfileIdType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileIdType", nil)
	req.SetPathValue("name", "ProfileIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileNoteType_CRUD tests Create, Read, Update, Delete for ProfileNoteType.
func TestProfileNoteType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileNoteType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileNoteType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileNoteType_ListByType tests listing elements of type ProfileNoteType.
func TestProfileNoteType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileNoteType", nil)
	req.SetPathValue("type", "ProfileNoteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileNoteType_GetTypeMetadata tests getting type metadata for ProfileNoteType.
func TestProfileNoteType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileNoteType", nil)
	req.SetPathValue("name", "ProfileNoteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileNoteType_GetValidChildTypes tests getting valid child types for ProfileNoteType.
func TestProfileNoteType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileNoteType/children", nil)
	req.SetPathValue("name", "ProfileNoteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestProfileRefineRuleType_CRUD tests Create, Read, Update, Delete for ProfileRefineRuleType.
func TestProfileRefineRuleType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileRefineRuleType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileRefineRuleType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileRefineRuleType_ListByType tests listing elements of type ProfileRefineRuleType.
func TestProfileRefineRuleType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileRefineRuleType", nil)
	req.SetPathValue("type", "ProfileRefineRuleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileRefineRuleType_GetTypeMetadata tests getting type metadata for ProfileRefineRuleType.
func TestProfileRefineRuleType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileRefineRuleType", nil)
	req.SetPathValue("name", "ProfileRefineRuleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileRefineRuleType_GetValidChildTypes tests getting valid child types for ProfileRefineRuleType.
func TestProfileRefineRuleType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileRefineRuleType/children", nil)
	req.SetPathValue("name", "ProfileRefineRuleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestProfileRefineValueType_CRUD tests Create, Read, Update, Delete for ProfileRefineValueType.
func TestProfileRefineValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileRefineValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileRefineValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileRefineValueType_ListByType tests listing elements of type ProfileRefineValueType.
func TestProfileRefineValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileRefineValueType", nil)
	req.SetPathValue("type", "ProfileRefineValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileRefineValueType_GetTypeMetadata tests getting type metadata for ProfileRefineValueType.
func TestProfileRefineValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileRefineValueType", nil)
	req.SetPathValue("name", "ProfileRefineValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileRefineValueType_GetValidChildTypes tests getting valid child types for ProfileRefineValueType.
func TestProfileRefineValueType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileRefineValueType/children", nil)
	req.SetPathValue("name", "ProfileRefineValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestProfileSelectType_CRUD tests Create, Read, Update, Delete for ProfileSelectType.
func TestProfileSelectType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileSelectType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileSelectType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileSelectType_ListByType tests listing elements of type ProfileSelectType.
func TestProfileSelectType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileSelectType", nil)
	req.SetPathValue("type", "ProfileSelectType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileSelectType_GetTypeMetadata tests getting type metadata for ProfileSelectType.
func TestProfileSelectType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileSelectType", nil)
	req.SetPathValue("name", "ProfileSelectType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileSelectType_GetValidChildTypes tests getting valid child types for ProfileSelectType.
func TestProfileSelectType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileSelectType/children", nil)
	req.SetPathValue("name", "ProfileSelectType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestProfileSetComplexValueType_CRUD tests Create, Read, Update, Delete for ProfileSetComplexValueType.
func TestProfileSetComplexValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileSetComplexValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileSetComplexValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileSetComplexValueType_ListByType tests listing elements of type ProfileSetComplexValueType.
func TestProfileSetComplexValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileSetComplexValueType", nil)
	req.SetPathValue("type", "ProfileSetComplexValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileSetComplexValueType_GetTypeMetadata tests getting type metadata for ProfileSetComplexValueType.
func TestProfileSetComplexValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileSetComplexValueType", nil)
	req.SetPathValue("name", "ProfileSetComplexValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileSetValueType_CRUD tests Create, Read, Update, Delete for ProfileSetValueType.
func TestProfileSetValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileSetValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileSetValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileSetValueType_ListByType tests listing elements of type ProfileSetValueType.
func TestProfileSetValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileSetValueType", nil)
	req.SetPathValue("type", "ProfileSetValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileSetValueType_GetTypeMetadata tests getting type metadata for ProfileSetValueType.
func TestProfileSetValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileSetValueType", nil)
	req.SetPathValue("name", "ProfileSetValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileType_CRUD tests Create, Read, Update, Delete for ProfileType.
func TestProfileType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProfileType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProfileType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProfileType_ListByType tests listing elements of type ProfileType.
func TestProfileType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProfileType", nil)
	req.SetPathValue("type", "ProfileType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileType_GetTypeMetadata tests getting type metadata for ProfileType.
func TestProfileType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileType", nil)
	req.SetPathValue("name", "ProfileType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProfileType_GetValidChildTypes tests getting valid child types for ProfileType.
func TestProfileType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProfileType/children", nil)
	req.SetPathValue("name", "ProfileType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestProtocolElementType_CRUD tests Create, Read, Update, Delete for ProtocolElementType.
func TestProtocolElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ProtocolElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ProtocolElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestProtocolElementType_ListByType tests listing elements of type ProtocolElementType.
func TestProtocolElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ProtocolElementType", nil)
	req.SetPathValue("type", "ProtocolElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestProtocolElementType_GetTypeMetadata tests getting type metadata for ProtocolElementType.
func TestProtocolElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ProtocolElementType", nil)
	req.SetPathValue("name", "ProtocolElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRSAKeyValueElement_CRUD tests Create, Read, Update, Delete for RSAKeyValueElement.
func TestRSAKeyValueElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RSAKeyValueElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RSAKeyValueElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRSAKeyValueElement_ListByType tests listing elements of type RSAKeyValueElement.
func TestRSAKeyValueElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RSAKeyValueElement", nil)
	req.SetPathValue("type", "RSAKeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRSAKeyValueElement_GetTypeMetadata tests getting type metadata for RSAKeyValueElement.
func TestRSAKeyValueElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RSAKeyValueElement", nil)
	req.SetPathValue("name", "RSAKeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRSAKeyValueElement_GetValidChildTypes tests getting valid child types for RSAKeyValueElement.
func TestRSAKeyValueElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RSAKeyValueElement/children", nil)
	req.SetPathValue("name", "RSAKeyValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRSAKeyValueType_CRUD tests Create, Read, Update, Delete for RSAKeyValueType.
func TestRSAKeyValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RSAKeyValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RSAKeyValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRSAKeyValueType_ListByType tests listing elements of type RSAKeyValueType.
func TestRSAKeyValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RSAKeyValueType", nil)
	req.SetPathValue("type", "RSAKeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRSAKeyValueType_GetTypeMetadata tests getting type metadata for RSAKeyValueType.
func TestRSAKeyValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RSAKeyValueType", nil)
	req.SetPathValue("name", "RSAKeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRSAKeyValueType_GetValidChildTypes tests getting valid child types for RSAKeyValueType.
func TestRSAKeyValueType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RSAKeyValueType/children", nil)
	req.SetPathValue("name", "RSAKeyValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRatingEnumType_CRUD tests Create, Read, Update, Delete for RatingEnumType.
func TestRatingEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RatingEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RatingEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRatingEnumType_ListByType tests listing elements of type RatingEnumType.
func TestRatingEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RatingEnumType", nil)
	req.SetPathValue("type", "RatingEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRatingEnumType_GetTypeMetadata tests getting type metadata for RatingEnumType.
func TestRatingEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RatingEnumType", nil)
	req.SetPathValue("name", "RatingEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferenceElement_CRUD tests Create, Read, Update, Delete for ReferenceElement.
func TestReferenceElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ReferenceElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ReferenceElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestReferenceElement_ListByType tests listing elements of type ReferenceElement.
func TestReferenceElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ReferenceElement", nil)
	req.SetPathValue("type", "ReferenceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferenceElement_GetTypeMetadata tests getting type metadata for ReferenceElement.
func TestReferenceElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReferenceElement", nil)
	req.SetPathValue("name", "ReferenceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferenceElement_GetValidChildTypes tests getting valid child types for ReferenceElement.
func TestReferenceElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReferenceElement/children", nil)
	req.SetPathValue("name", "ReferenceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestReferenceElementType_CRUD tests Create, Read, Update, Delete for ReferenceElementType.
func TestReferenceElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ReferenceElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ReferenceElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestReferenceElementType_ListByType tests listing elements of type ReferenceElementType.
func TestReferenceElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ReferenceElementType", nil)
	req.SetPathValue("type", "ReferenceElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferenceElementType_GetTypeMetadata tests getting type metadata for ReferenceElementType.
func TestReferenceElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReferenceElementType", nil)
	req.SetPathValue("name", "ReferenceElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferenceType_CRUD tests Create, Read, Update, Delete for ReferenceType.
func TestReferenceType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ReferenceType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ReferenceType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestReferenceType_ListByType tests listing elements of type ReferenceType.
func TestReferenceType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ReferenceType", nil)
	req.SetPathValue("type", "ReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferenceType_GetTypeMetadata tests getting type metadata for ReferenceType.
func TestReferenceType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReferenceType", nil)
	req.SetPathValue("name", "ReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferenceType_GetValidChildTypes tests getting valid child types for ReferenceType.
func TestReferenceType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReferenceType/children", nil)
	req.SetPathValue("name", "ReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestReferencesType_CRUD tests Create, Read, Update, Delete for ReferencesType.
func TestReferencesType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ReferencesType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ReferencesType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestReferencesType_ListByType tests listing elements of type ReferencesType.
func TestReferencesType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ReferencesType", nil)
	req.SetPathValue("type", "ReferencesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferencesType_GetTypeMetadata tests getting type metadata for ReferencesType.
func TestReferencesType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReferencesType", nil)
	req.SetPathValue("name", "ReferencesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReferencesType_GetValidChildTypes tests getting valid child types for ReferencesType.
func TestReferencesType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReferencesType/children", nil)
	req.SetPathValue("name", "ReferencesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRegexCaptureFunctionType_CRUD tests Create, Read, Update, Delete for RegexCaptureFunctionType.
func TestRegexCaptureFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RegexCaptureFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RegexCaptureFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRegexCaptureFunctionType_ListByType tests listing elements of type RegexCaptureFunctionType.
func TestRegexCaptureFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RegexCaptureFunctionType", nil)
	req.SetPathValue("type", "RegexCaptureFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRegexCaptureFunctionType_GetTypeMetadata tests getting type metadata for RegexCaptureFunctionType.
func TestRegexCaptureFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RegexCaptureFunctionType", nil)
	req.SetPathValue("name", "RegexCaptureFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRelationshipType_CRUD tests Create, Read, Update, Delete for RelationshipType.
func TestRelationshipType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RelationshipType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RelationshipType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRelationshipType_ListByType tests listing elements of type RelationshipType.
func TestRelationshipType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RelationshipType", nil)
	req.SetPathValue("type", "RelationshipType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRelationshipType_GetTypeMetadata tests getting type metadata for RelationshipType.
func TestRelationshipType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RelationshipType", nil)
	req.SetPathValue("name", "RelationshipType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRelationshipsContainerType_CRUD tests Create, Read, Update, Delete for RelationshipsContainerType.
func TestRelationshipsContainerType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RelationshipsContainerType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RelationshipsContainerType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRelationshipsContainerType_ListByType tests listing elements of type RelationshipsContainerType.
func TestRelationshipsContainerType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RelationshipsContainerType", nil)
	req.SetPathValue("type", "RelationshipsContainerType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRelationshipsContainerType_GetTypeMetadata tests getting type metadata for RelationshipsContainerType.
func TestRelationshipsContainerType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RelationshipsContainerType", nil)
	req.SetPathValue("name", "RelationshipsContainerType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRelationshipsContainerType_GetValidChildTypes tests getting valid child types for RelationshipsContainerType.
func TestRelationshipsContainerType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RelationshipsContainerType/children", nil)
	req.SetPathValue("name", "RelationshipsContainerType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRelationshipsElementType_CRUD tests Create, Read, Update, Delete for RelationshipsElementType.
func TestRelationshipsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RelationshipsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RelationshipsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRelationshipsElementType_ListByType tests listing elements of type RelationshipsElementType.
func TestRelationshipsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RelationshipsElementType", nil)
	req.SetPathValue("type", "RelationshipsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRelationshipsElementType_GetTypeMetadata tests getting type metadata for RelationshipsElementType.
func TestRelationshipsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RelationshipsElementType", nil)
	req.SetPathValue("name", "RelationshipsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRelationshipsElementType_GetValidChildTypes tests getting valid child types for RelationshipsElementType.
func TestRelationshipsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RelationshipsElementType/children", nil)
	req.SetPathValue("name", "RelationshipsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRemoteResourceElement_CRUD tests Create, Read, Update, Delete for RemoteResourceElement.
func TestRemoteResourceElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RemoteResourceElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RemoteResourceElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRemoteResourceElement_ListByType tests listing elements of type RemoteResourceElement.
func TestRemoteResourceElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RemoteResourceElement", nil)
	req.SetPathValue("type", "RemoteResourceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRemoteResourceElement_GetTypeMetadata tests getting type metadata for RemoteResourceElement.
func TestRemoteResourceElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RemoteResourceElement", nil)
	req.SetPathValue("name", "RemoteResourceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRemoteResourceElementType_CRUD tests Create, Read, Update, Delete for RemoteResourceElementType.
func TestRemoteResourceElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RemoteResourceElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RemoteResourceElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRemoteResourceElementType_ListByType tests listing elements of type RemoteResourceElementType.
func TestRemoteResourceElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RemoteResourceElementType", nil)
	req.SetPathValue("type", "RemoteResourceElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRemoteResourceElementType_GetTypeMetadata tests getting type metadata for RemoteResourceElementType.
func TestRemoteResourceElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RemoteResourceElementType", nil)
	req.SetPathValue("name", "RemoteResourceElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportRequestType_CRUD tests Create, Read, Update, Delete for ReportRequestType.
func TestReportRequestType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ReportRequestType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ReportRequestType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestReportRequestType_ListByType tests listing elements of type ReportRequestType.
func TestReportRequestType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ReportRequestType", nil)
	req.SetPathValue("type", "ReportRequestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportRequestType_GetTypeMetadata tests getting type metadata for ReportRequestType.
func TestReportRequestType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReportRequestType", nil)
	req.SetPathValue("name", "ReportRequestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportRequestType_GetValidChildTypes tests getting valid child types for ReportRequestType.
func TestReportRequestType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReportRequestType/children", nil)
	req.SetPathValue("name", "ReportRequestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestReportRequestsElementType_CRUD tests Create, Read, Update, Delete for ReportRequestsElementType.
func TestReportRequestsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ReportRequestsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ReportRequestsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestReportRequestsElementType_ListByType tests listing elements of type ReportRequestsElementType.
func TestReportRequestsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ReportRequestsElementType", nil)
	req.SetPathValue("type", "ReportRequestsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportRequestsElementType_GetTypeMetadata tests getting type metadata for ReportRequestsElementType.
func TestReportRequestsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReportRequestsElementType", nil)
	req.SetPathValue("name", "ReportRequestsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportRequestsElementType_GetValidChildTypes tests getting valid child types for ReportRequestsElementType.
func TestReportRequestsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReportRequestsElementType/children", nil)
	req.SetPathValue("name", "ReportRequestsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestReportType_CRUD tests Create, Read, Update, Delete for ReportType.
func TestReportType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ReportType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ReportType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestReportType_ListByType tests listing elements of type ReportType.
func TestReportType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ReportType", nil)
	req.SetPathValue("type", "ReportType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportType_GetTypeMetadata tests getting type metadata for ReportType.
func TestReportType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReportType", nil)
	req.SetPathValue("name", "ReportType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportType_GetValidChildTypes tests getting valid child types for ReportType.
func TestReportType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReportType/children", nil)
	req.SetPathValue("name", "ReportType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestReportsElementType_CRUD tests Create, Read, Update, Delete for ReportsElementType.
func TestReportsElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ReportsElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ReportsElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestReportsElementType_ListByType tests listing elements of type ReportsElementType.
func TestReportsElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ReportsElementType", nil)
	req.SetPathValue("type", "ReportsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportsElementType_GetTypeMetadata tests getting type metadata for ReportsElementType.
func TestReportsElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReportsElementType", nil)
	req.SetPathValue("name", "ReportsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestReportsElementType_GetValidChildTypes tests getting valid child types for ReportsElementType.
func TestReportsElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ReportsElementType/children", nil)
	req.SetPathValue("name", "ReportsElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestResourceElement_CRUD tests Create, Read, Update, Delete for ResourceElement.
func TestResourceElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ResourceElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ResourceElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestResourceElement_ListByType tests listing elements of type ResourceElement.
func TestResourceElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ResourceElement", nil)
	req.SetPathValue("type", "ResourceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestResourceElement_GetTypeMetadata tests getting type metadata for ResourceElement.
func TestResourceElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ResourceElement", nil)
	req.SetPathValue("name", "ResourceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestResourceType_CRUD tests Create, Read, Update, Delete for ResourceType.
func TestResourceType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ResourceType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ResourceType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestResourceType_ListByType tests listing elements of type ResourceType.
func TestResourceType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ResourceType", nil)
	req.SetPathValue("type", "ResourceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestResourceType_GetTypeMetadata tests getting type metadata for ResourceType.
func TestResourceType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ResourceType", nil)
	req.SetPathValue("name", "ResourceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRestrictionType_CRUD tests Create, Read, Update, Delete for RestrictionType.
func TestRestrictionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RestrictionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RestrictionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRestrictionType_ListByType tests listing elements of type RestrictionType.
func TestRestrictionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RestrictionType", nil)
	req.SetPathValue("type", "RestrictionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRestrictionType_GetTypeMetadata tests getting type metadata for RestrictionType.
func TestRestrictionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RestrictionType", nil)
	req.SetPathValue("name", "RestrictionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestResultEnumType_CRUD tests Create, Read, Update, Delete for ResultEnumType.
func TestResultEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ResultEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ResultEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestResultEnumType_ListByType tests listing elements of type ResultEnumType.
func TestResultEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ResultEnumType", nil)
	req.SetPathValue("type", "ResultEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestResultEnumType_GetTypeMetadata tests getting type metadata for ResultEnumType.
func TestResultEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ResultEnumType", nil)
	req.SetPathValue("name", "ResultEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRetrievalMethodElement_CRUD tests Create, Read, Update, Delete for RetrievalMethodElement.
func TestRetrievalMethodElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RetrievalMethodElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RetrievalMethodElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRetrievalMethodElement_ListByType tests listing elements of type RetrievalMethodElement.
func TestRetrievalMethodElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RetrievalMethodElement", nil)
	req.SetPathValue("type", "RetrievalMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRetrievalMethodElement_GetTypeMetadata tests getting type metadata for RetrievalMethodElement.
func TestRetrievalMethodElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RetrievalMethodElement", nil)
	req.SetPathValue("name", "RetrievalMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRetrievalMethodElement_GetValidChildTypes tests getting valid child types for RetrievalMethodElement.
func TestRetrievalMethodElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RetrievalMethodElement/children", nil)
	req.SetPathValue("name", "RetrievalMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRetrievalMethodType_CRUD tests Create, Read, Update, Delete for RetrievalMethodType.
func TestRetrievalMethodType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RetrievalMethodType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RetrievalMethodType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRetrievalMethodType_ListByType tests listing elements of type RetrievalMethodType.
func TestRetrievalMethodType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RetrievalMethodType", nil)
	req.SetPathValue("type", "RetrievalMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRetrievalMethodType_GetTypeMetadata tests getting type metadata for RetrievalMethodType.
func TestRetrievalMethodType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RetrievalMethodType", nil)
	req.SetPathValue("name", "RetrievalMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRetrievalMethodType_GetValidChildTypes tests getting valid child types for RetrievalMethodType.
func TestRetrievalMethodType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RetrievalMethodType/children", nil)
	req.SetPathValue("name", "RetrievalMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRoleEnumType_CRUD tests Create, Read, Update, Delete for RoleEnumType.
func TestRoleEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RoleEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RoleEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRoleEnumType_ListByType tests listing elements of type RoleEnumType.
func TestRoleEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RoleEnumType", nil)
	req.SetPathValue("type", "RoleEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRoleEnumType_GetTypeMetadata tests getting type metadata for RoleEnumType.
func TestRoleEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RoleEnumType", nil)
	req.SetPathValue("name", "RoleEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRoleType_CRUD tests Create, Read, Update, Delete for RoleType.
func TestRoleType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RoleType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RoleType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRoleType_ListByType tests listing elements of type RoleType.
func TestRoleType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RoleType", nil)
	req.SetPathValue("type", "RoleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRoleType_GetTypeMetadata tests getting type metadata for RoleType.
func TestRoleType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RoleType", nil)
	req.SetPathValue("name", "RoleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleElement_CRUD tests Create, Read, Update, Delete for RuleElement.
func TestRuleElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RuleElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RuleElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRuleElement_ListByType tests listing elements of type RuleElement.
func TestRuleElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RuleElement", nil)
	req.SetPathValue("type", "RuleElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleElement_GetTypeMetadata tests getting type metadata for RuleElement.
func TestRuleElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RuleElement", nil)
	req.SetPathValue("name", "RuleElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleElement_GetValidChildTypes tests getting valid child types for RuleElement.
func TestRuleElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RuleElement/children", nil)
	req.SetPathValue("name", "RuleElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRuleIdType_CRUD tests Create, Read, Update, Delete for RuleIdType.
func TestRuleIdType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RuleIdType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RuleIdType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRuleIdType_ListByType tests listing elements of type RuleIdType.
func TestRuleIdType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RuleIdType", nil)
	req.SetPathValue("type", "RuleIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleIdType_GetTypeMetadata tests getting type metadata for RuleIdType.
func TestRuleIdType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RuleIdType", nil)
	req.SetPathValue("name", "RuleIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleResultType_CRUD tests Create, Read, Update, Delete for RuleResultType.
func TestRuleResultType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RuleResultType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RuleResultType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRuleResultType_ListByType tests listing elements of type RuleResultType.
func TestRuleResultType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RuleResultType", nil)
	req.SetPathValue("type", "RuleResultType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleResultType_GetTypeMetadata tests getting type metadata for RuleResultType.
func TestRuleResultType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RuleResultType", nil)
	req.SetPathValue("name", "RuleResultType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleResultType_GetValidChildTypes tests getting valid child types for RuleResultType.
func TestRuleResultType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RuleResultType/children", nil)
	req.SetPathValue("name", "RuleResultType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestRuleType_CRUD tests Create, Read, Update, Delete for RuleType.
func TestRuleType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "RuleType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create RuleType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestRuleType_ListByType tests listing elements of type RuleType.
func TestRuleType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/RuleType", nil)
	req.SetPathValue("type", "RuleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleType_GetTypeMetadata tests getting type metadata for RuleType.
func TestRuleType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RuleType", nil)
	req.SetPathValue("name", "RuleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestRuleType_GetValidChildTypes tests getting valid child types for RuleType.
func TestRuleType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/RuleType/children", nil)
	req.SetPathValue("name", "RuleType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSPKIDataElement_CRUD tests Create, Read, Update, Delete for SPKIDataElement.
func TestSPKIDataElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SPKIDataElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SPKIDataElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSPKIDataElement_ListByType tests listing elements of type SPKIDataElement.
func TestSPKIDataElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SPKIDataElement", nil)
	req.SetPathValue("type", "SPKIDataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSPKIDataElement_GetTypeMetadata tests getting type metadata for SPKIDataElement.
func TestSPKIDataElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SPKIDataElement", nil)
	req.SetPathValue("name", "SPKIDataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSPKIDataType_CRUD tests Create, Read, Update, Delete for SPKIDataType.
func TestSPKIDataType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SPKIDataType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SPKIDataType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSPKIDataType_ListByType tests listing elements of type SPKIDataType.
func TestSPKIDataType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SPKIDataType", nil)
	req.SetPathValue("type", "SPKIDataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSPKIDataType_GetTypeMetadata tests getting type metadata for SPKIDataType.
func TestSPKIDataType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SPKIDataType", nil)
	req.SetPathValue("name", "SPKIDataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSchemaVersionPattern_CRUD tests Create, Read, Update, Delete for SchemaVersionPattern.
func TestSchemaVersionPattern_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SchemaVersionPattern",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SchemaVersionPattern returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSchemaVersionPattern_ListByType tests listing elements of type SchemaVersionPattern.
func TestSchemaVersionPattern_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SchemaVersionPattern", nil)
	req.SetPathValue("type", "SchemaVersionPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSchemaVersionPattern_GetTypeMetadata tests getting type metadata for SchemaVersionPattern.
func TestSchemaVersionPattern_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SchemaVersionPattern", nil)
	req.SetPathValue("name", "SchemaVersionPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSchemaVersionType_CRUD tests Create, Read, Update, Delete for SchemaVersionType.
func TestSchemaVersionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SchemaVersionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SchemaVersionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSchemaVersionType_ListByType tests listing elements of type SchemaVersionType.
func TestSchemaVersionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SchemaVersionType", nil)
	req.SetPathValue("type", "SchemaVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSchemaVersionType_GetTypeMetadata tests getting type metadata for SchemaVersionType.
func TestSchemaVersionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SchemaVersionType", nil)
	req.SetPathValue("name", "SchemaVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestScoreType_CRUD tests Create, Read, Update, Delete for ScoreType.
func TestScoreType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ScoreType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ScoreType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestScoreType_ListByType tests listing elements of type ScoreType.
func TestScoreType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ScoreType", nil)
	req.SetPathValue("type", "ScoreType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestScoreType_GetTypeMetadata tests getting type metadata for ScoreType.
func TestScoreType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ScoreType", nil)
	req.SetPathValue("name", "ScoreType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSelChoicesType_CRUD tests Create, Read, Update, Delete for SelChoicesType.
func TestSelChoicesType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SelChoicesType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SelChoicesType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSelChoicesType_ListByType tests listing elements of type SelChoicesType.
func TestSelChoicesType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SelChoicesType", nil)
	req.SetPathValue("type", "SelChoicesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSelChoicesType_GetTypeMetadata tests getting type metadata for SelChoicesType.
func TestSelChoicesType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SelChoicesType", nil)
	req.SetPathValue("name", "SelChoicesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSelChoicesType_GetValidChildTypes tests getting valid child types for SelChoicesType.
func TestSelChoicesType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SelChoicesType/children", nil)
	req.SetPathValue("name", "SelChoicesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSelComplexValueType_CRUD tests Create, Read, Update, Delete for SelComplexValueType.
func TestSelComplexValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SelComplexValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SelComplexValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSelComplexValueType_ListByType tests listing elements of type SelComplexValueType.
func TestSelComplexValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SelComplexValueType", nil)
	req.SetPathValue("type", "SelComplexValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSelComplexValueType_GetTypeMetadata tests getting type metadata for SelComplexValueType.
func TestSelComplexValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SelComplexValueType", nil)
	req.SetPathValue("name", "SelComplexValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSelNumType_CRUD tests Create, Read, Update, Delete for SelNumType.
func TestSelNumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SelNumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SelNumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSelNumType_ListByType tests listing elements of type SelNumType.
func TestSelNumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SelNumType", nil)
	req.SetPathValue("type", "SelNumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSelNumType_GetTypeMetadata tests getting type metadata for SelNumType.
func TestSelNumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SelNumType", nil)
	req.SetPathValue("name", "SelNumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSelStringType_CRUD tests Create, Read, Update, Delete for SelStringType.
func TestSelStringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SelStringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SelStringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSelStringType_ListByType tests listing elements of type SelStringType.
func TestSelStringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SelStringType", nil)
	req.SetPathValue("type", "SelStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSelStringType_GetTypeMetadata tests getting type metadata for SelStringType.
func TestSelStringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SelStringType", nil)
	req.SetPathValue("name", "SelStringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestServedByElement_CRUD tests Create, Read, Update, Delete for ServedByElement.
func TestServedByElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ServedByElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ServedByElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestServedByElement_ListByType tests listing elements of type ServedByElement.
func TestServedByElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ServedByElement", nil)
	req.SetPathValue("type", "ServedByElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestServedByElement_GetTypeMetadata tests getting type metadata for ServedByElement.
func TestServedByElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ServedByElement", nil)
	req.SetPathValue("name", "ServedByElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestServedByElement_GetValidChildTypes tests getting valid child types for ServedByElement.
func TestServedByElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ServedByElement/children", nil)
	req.SetPathValue("name", "ServedByElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestServiceElement_CRUD tests Create, Read, Update, Delete for ServiceElement.
func TestServiceElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ServiceElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ServiceElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestServiceElement_ListByType tests listing elements of type ServiceElement.
func TestServiceElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ServiceElement", nil)
	req.SetPathValue("type", "ServiceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestServiceElement_GetTypeMetadata tests getting type metadata for ServiceElement.
func TestServiceElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ServiceElement", nil)
	req.SetPathValue("name", "ServiceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestServiceElement_GetValidChildTypes tests getting valid child types for ServiceElement.
func TestServiceElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ServiceElement/children", nil)
	req.SetPathValue("name", "ServiceElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestServiceType_CRUD tests Create, Read, Update, Delete for ServiceType.
func TestServiceType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ServiceType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ServiceType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestServiceType_ListByType tests listing elements of type ServiceType.
func TestServiceType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ServiceType", nil)
	req.SetPathValue("type", "ServiceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestServiceType_GetTypeMetadata tests getting type metadata for ServiceType.
func TestServiceType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ServiceType", nil)
	req.SetPathValue("name", "ServiceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestServiceType_GetValidChildTypes tests getting valid child types for ServiceType.
func TestServiceType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ServiceType/children", nil)
	req.SetPathValue("name", "ServiceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSetElement_CRUD tests Create, Read, Update, Delete for SetElement.
func TestSetElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SetElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SetElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSetElement_ListByType tests listing elements of type SetElement.
func TestSetElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SetElement", nil)
	req.SetPathValue("type", "SetElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSetElement_GetTypeMetadata tests getting type metadata for SetElement.
func TestSetElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SetElement", nil)
	req.SetPathValue("name", "SetElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSetElement_GetValidChildTypes tests getting valid child types for SetElement.
func TestSetElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SetElement/children", nil)
	req.SetPathValue("name", "SetElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSetElementType_CRUD tests Create, Read, Update, Delete for SetElementType.
func TestSetElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SetElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SetElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSetElementType_ListByType tests listing elements of type SetElementType.
func TestSetElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SetElementType", nil)
	req.SetPathValue("type", "SetElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSetElementType_GetTypeMetadata tests getting type metadata for SetElementType.
func TestSetElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SetElementType", nil)
	req.SetPathValue("name", "SetElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSetElementType_GetValidChildTypes tests getting valid child types for SetElementType.
func TestSetElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SetElementType/children", nil)
	req.SetPathValue("name", "SetElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSetOperatorEnumeration_CRUD tests Create, Read, Update, Delete for SetOperatorEnumeration.
func TestSetOperatorEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SetOperatorEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SetOperatorEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSetOperatorEnumeration_ListByType tests listing elements of type SetOperatorEnumeration.
func TestSetOperatorEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SetOperatorEnumeration", nil)
	req.SetPathValue("type", "SetOperatorEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSetOperatorEnumeration_GetTypeMetadata tests getting type metadata for SetOperatorEnumeration.
func TestSetOperatorEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SetOperatorEnumeration", nil)
	req.SetPathValue("name", "SetOperatorEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSeverityEnumType_CRUD tests Create, Read, Update, Delete for SeverityEnumType.
func TestSeverityEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SeverityEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SeverityEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSeverityEnumType_ListByType tests listing elements of type SeverityEnumType.
func TestSeverityEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SeverityEnumType", nil)
	req.SetPathValue("type", "SeverityEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSeverityEnumType_GetTypeMetadata tests getting type metadata for SeverityEnumType.
func TestSeverityEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SeverityEnumType", nil)
	req.SetPathValue("name", "SeverityEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestShowType_CRUD tests Create, Read, Update, Delete for ShowType.
func TestShowType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ShowType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ShowType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestShowType_ListByType tests listing elements of type ShowType.
func TestShowType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ShowType", nil)
	req.SetPathValue("type", "ShowType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestShowType_GetTypeMetadata tests getting type metadata for ShowType.
func TestShowType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ShowType", nil)
	req.SetPathValue("name", "ShowType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureElement_CRUD tests Create, Read, Update, Delete for SignatureElement.
func TestSignatureElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignatureElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignatureElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignatureElement_ListByType tests listing elements of type SignatureElement.
func TestSignatureElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignatureElement", nil)
	req.SetPathValue("type", "SignatureElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureElement_GetTypeMetadata tests getting type metadata for SignatureElement.
func TestSignatureElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureElement", nil)
	req.SetPathValue("name", "SignatureElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureElement_GetValidChildTypes tests getting valid child types for SignatureElement.
func TestSignatureElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureElement/children", nil)
	req.SetPathValue("name", "SignatureElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSignatureMethodElement_CRUD tests Create, Read, Update, Delete for SignatureMethodElement.
func TestSignatureMethodElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignatureMethodElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignatureMethodElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignatureMethodElement_ListByType tests listing elements of type SignatureMethodElement.
func TestSignatureMethodElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignatureMethodElement", nil)
	req.SetPathValue("type", "SignatureMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureMethodElement_GetTypeMetadata tests getting type metadata for SignatureMethodElement.
func TestSignatureMethodElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureMethodElement", nil)
	req.SetPathValue("name", "SignatureMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureMethodElement_GetValidChildTypes tests getting valid child types for SignatureMethodElement.
func TestSignatureMethodElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureMethodElement/children", nil)
	req.SetPathValue("name", "SignatureMethodElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSignatureMethodType_CRUD tests Create, Read, Update, Delete for SignatureMethodType.
func TestSignatureMethodType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignatureMethodType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignatureMethodType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignatureMethodType_ListByType tests listing elements of type SignatureMethodType.
func TestSignatureMethodType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignatureMethodType", nil)
	req.SetPathValue("type", "SignatureMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureMethodType_GetTypeMetadata tests getting type metadata for SignatureMethodType.
func TestSignatureMethodType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureMethodType", nil)
	req.SetPathValue("name", "SignatureMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureMethodType_GetValidChildTypes tests getting valid child types for SignatureMethodType.
func TestSignatureMethodType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureMethodType/children", nil)
	req.SetPathValue("name", "SignatureMethodType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSignaturePropertiesElement_CRUD tests Create, Read, Update, Delete for SignaturePropertiesElement.
func TestSignaturePropertiesElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignaturePropertiesElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignaturePropertiesElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignaturePropertiesElement_ListByType tests listing elements of type SignaturePropertiesElement.
func TestSignaturePropertiesElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignaturePropertiesElement", nil)
	req.SetPathValue("type", "SignaturePropertiesElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignaturePropertiesElement_GetTypeMetadata tests getting type metadata for SignaturePropertiesElement.
func TestSignaturePropertiesElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignaturePropertiesElement", nil)
	req.SetPathValue("name", "SignaturePropertiesElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignaturePropertiesElement_GetValidChildTypes tests getting valid child types for SignaturePropertiesElement.
func TestSignaturePropertiesElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignaturePropertiesElement/children", nil)
	req.SetPathValue("name", "SignaturePropertiesElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSignaturePropertiesType_CRUD tests Create, Read, Update, Delete for SignaturePropertiesType.
func TestSignaturePropertiesType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignaturePropertiesType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignaturePropertiesType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignaturePropertiesType_ListByType tests listing elements of type SignaturePropertiesType.
func TestSignaturePropertiesType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignaturePropertiesType", nil)
	req.SetPathValue("type", "SignaturePropertiesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignaturePropertiesType_GetTypeMetadata tests getting type metadata for SignaturePropertiesType.
func TestSignaturePropertiesType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignaturePropertiesType", nil)
	req.SetPathValue("name", "SignaturePropertiesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignaturePropertiesType_GetValidChildTypes tests getting valid child types for SignaturePropertiesType.
func TestSignaturePropertiesType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignaturePropertiesType/children", nil)
	req.SetPathValue("name", "SignaturePropertiesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSignaturePropertyElement_CRUD tests Create, Read, Update, Delete for SignaturePropertyElement.
func TestSignaturePropertyElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignaturePropertyElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignaturePropertyElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignaturePropertyElement_ListByType tests listing elements of type SignaturePropertyElement.
func TestSignaturePropertyElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignaturePropertyElement", nil)
	req.SetPathValue("type", "SignaturePropertyElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignaturePropertyElement_GetTypeMetadata tests getting type metadata for SignaturePropertyElement.
func TestSignaturePropertyElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignaturePropertyElement", nil)
	req.SetPathValue("name", "SignaturePropertyElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignaturePropertyType_CRUD tests Create, Read, Update, Delete for SignaturePropertyType.
func TestSignaturePropertyType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignaturePropertyType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignaturePropertyType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignaturePropertyType_ListByType tests listing elements of type SignaturePropertyType.
func TestSignaturePropertyType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignaturePropertyType", nil)
	req.SetPathValue("type", "SignaturePropertyType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignaturePropertyType_GetTypeMetadata tests getting type metadata for SignaturePropertyType.
func TestSignaturePropertyType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignaturePropertyType", nil)
	req.SetPathValue("name", "SignaturePropertyType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureType_CRUD tests Create, Read, Update, Delete for SignatureType.
func TestSignatureType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignatureType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignatureType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignatureType_ListByType tests listing elements of type SignatureType.
func TestSignatureType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignatureType", nil)
	req.SetPathValue("type", "SignatureType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureType_GetTypeMetadata tests getting type metadata for SignatureType.
func TestSignatureType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureType", nil)
	req.SetPathValue("name", "SignatureType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureType_GetValidChildTypes tests getting valid child types for SignatureType.
func TestSignatureType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureType/children", nil)
	req.SetPathValue("name", "SignatureType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSignatureValueElement_CRUD tests Create, Read, Update, Delete for SignatureValueElement.
func TestSignatureValueElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignatureValueElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignatureValueElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignatureValueElement_ListByType tests listing elements of type SignatureValueElement.
func TestSignatureValueElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignatureValueElement", nil)
	req.SetPathValue("type", "SignatureValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureValueElement_GetTypeMetadata tests getting type metadata for SignatureValueElement.
func TestSignatureValueElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureValueElement", nil)
	req.SetPathValue("name", "SignatureValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureValueType_CRUD tests Create, Read, Update, Delete for SignatureValueType.
func TestSignatureValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignatureValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignatureValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignatureValueType_ListByType tests listing elements of type SignatureValueType.
func TestSignatureValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignatureValueType", nil)
	req.SetPathValue("type", "SignatureValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignatureValueType_GetTypeMetadata tests getting type metadata for SignatureValueType.
func TestSignatureValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignatureValueType", nil)
	req.SetPathValue("name", "SignatureValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignedInfoElement_CRUD tests Create, Read, Update, Delete for SignedInfoElement.
func TestSignedInfoElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignedInfoElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignedInfoElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignedInfoElement_ListByType tests listing elements of type SignedInfoElement.
func TestSignedInfoElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignedInfoElement", nil)
	req.SetPathValue("type", "SignedInfoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignedInfoElement_GetTypeMetadata tests getting type metadata for SignedInfoElement.
func TestSignedInfoElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignedInfoElement", nil)
	req.SetPathValue("name", "SignedInfoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignedInfoElement_GetValidChildTypes tests getting valid child types for SignedInfoElement.
func TestSignedInfoElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignedInfoElement/children", nil)
	req.SetPathValue("name", "SignedInfoElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSignedInfoType_CRUD tests Create, Read, Update, Delete for SignedInfoType.
func TestSignedInfoType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SignedInfoType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SignedInfoType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSignedInfoType_ListByType tests listing elements of type SignedInfoType.
func TestSignedInfoType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SignedInfoType", nil)
	req.SetPathValue("type", "SignedInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignedInfoType_GetTypeMetadata tests getting type metadata for SignedInfoType.
func TestSignedInfoType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignedInfoType", nil)
	req.SetPathValue("name", "SignedInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSignedInfoType_GetValidChildTypes tests getting valid child types for SignedInfoType.
func TestSignedInfoType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SignedInfoType/children", nil)
	req.SetPathValue("name", "SignedInfoType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSimple_CRUD tests Create, Read, Update, Delete for Simple.
func TestSimple_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "Simple",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create Simple returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSimple_ListByType tests listing elements of type Simple.
func TestSimple_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/Simple", nil)
	req.SetPathValue("type", "Simple")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSimple_GetTypeMetadata tests getting type metadata for Simple.
func TestSimple_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/Simple", nil)
	req.SetPathValue("name", "Simple")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSimpleDatatypeEnumeration_CRUD tests Create, Read, Update, Delete for SimpleDatatypeEnumeration.
func TestSimpleDatatypeEnumeration_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SimpleDatatypeEnumeration",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SimpleDatatypeEnumeration returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSimpleDatatypeEnumeration_ListByType tests listing elements of type SimpleDatatypeEnumeration.
func TestSimpleDatatypeEnumeration_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SimpleDatatypeEnumeration", nil)
	req.SetPathValue("type", "SimpleDatatypeEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSimpleDatatypeEnumeration_GetTypeMetadata tests getting type metadata for SimpleDatatypeEnumeration.
func TestSimpleDatatypeEnumeration_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SimpleDatatypeEnumeration", nil)
	req.SetPathValue("name", "SimpleDatatypeEnumeration")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSoftwareElement_CRUD tests Create, Read, Update, Delete for SoftwareElement.
func TestSoftwareElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SoftwareElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SoftwareElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSoftwareElement_ListByType tests listing elements of type SoftwareElement.
func TestSoftwareElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SoftwareElement", nil)
	req.SetPathValue("type", "SoftwareElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSoftwareElement_GetTypeMetadata tests getting type metadata for SoftwareElement.
func TestSoftwareElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SoftwareElement", nil)
	req.SetPathValue("name", "SoftwareElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSoftwareElement_GetValidChildTypes tests getting valid child types for SoftwareElement.
func TestSoftwareElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SoftwareElement/children", nil)
	req.SetPathValue("name", "SoftwareElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSoftwareType_CRUD tests Create, Read, Update, Delete for SoftwareType.
func TestSoftwareType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SoftwareType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SoftwareType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSoftwareType_ListByType tests listing elements of type SoftwareType.
func TestSoftwareType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SoftwareType", nil)
	req.SetPathValue("type", "SoftwareType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSoftwareType_GetTypeMetadata tests getting type metadata for SoftwareType.
func TestSoftwareType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SoftwareType", nil)
	req.SetPathValue("name", "SoftwareType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSoftwareType_GetValidChildTypes tests getting valid child types for SoftwareType.
func TestSoftwareType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SoftwareType/children", nil)
	req.SetPathValue("name", "SoftwareType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSortingCodeElementType_CRUD tests Create, Read, Update, Delete for SortingCodeElementType.
func TestSortingCodeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SortingCodeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SortingCodeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSortingCodeElementType_ListByType tests listing elements of type SortingCodeElementType.
func TestSortingCodeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SortingCodeElementType", nil)
	req.SetPathValue("type", "SortingCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSortingCodeElementType_GetTypeMetadata tests getting type metadata for SortingCodeElementType.
func TestSortingCodeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SortingCodeElementType", nil)
	req.SetPathValue("name", "SortingCodeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSplitFunctionType_CRUD tests Create, Read, Update, Delete for SplitFunctionType.
func TestSplitFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SplitFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SplitFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSplitFunctionType_ListByType tests listing elements of type SplitFunctionType.
func TestSplitFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SplitFunctionType", nil)
	req.SetPathValue("type", "SplitFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSplitFunctionType_GetTypeMetadata tests getting type metadata for SplitFunctionType.
func TestSplitFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SplitFunctionType", nil)
	req.SetPathValue("name", "SplitFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateElement_CRUD tests Create, Read, Update, Delete for StateElement.
func TestStateElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "StateElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create StateElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestStateElement_ListByType tests listing elements of type StateElement.
func TestStateElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/StateElement", nil)
	req.SetPathValue("type", "StateElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateElement_GetTypeMetadata tests getting type metadata for StateElement.
func TestStateElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StateElement", nil)
	req.SetPathValue("name", "StateElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateElement_GetValidChildTypes tests getting valid child types for StateElement.
func TestStateElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StateElement/children", nil)
	req.SetPathValue("name", "StateElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestStateIDPattern_CRUD tests Create, Read, Update, Delete for StateIDPattern.
func TestStateIDPattern_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "StateIDPattern",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create StateIDPattern returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestStateIDPattern_ListByType tests listing elements of type StateIDPattern.
func TestStateIDPattern_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/StateIDPattern", nil)
	req.SetPathValue("type", "StateIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateIDPattern_GetTypeMetadata tests getting type metadata for StateIDPattern.
func TestStateIDPattern_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StateIDPattern", nil)
	req.SetPathValue("name", "StateIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateRefType_CRUD tests Create, Read, Update, Delete for StateRefType.
func TestStateRefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "StateRefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create StateRefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestStateRefType_ListByType tests listing elements of type StateRefType.
func TestStateRefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/StateRefType", nil)
	req.SetPathValue("type", "StateRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateRefType_GetTypeMetadata tests getting type metadata for StateRefType.
func TestStateRefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StateRefType", nil)
	req.SetPathValue("name", "StateRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateType_CRUD tests Create, Read, Update, Delete for StateType.
func TestStateType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "StateType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create StateType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestStateType_ListByType tests listing elements of type StateType.
func TestStateType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/StateType", nil)
	req.SetPathValue("type", "StateType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateType_GetTypeMetadata tests getting type metadata for StateType.
func TestStateType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StateType", nil)
	req.SetPathValue("name", "StateType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStateType_GetValidChildTypes tests getting valid child types for StateType.
func TestStateType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StateType/children", nil)
	req.SetPathValue("name", "StateType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestStatesType_CRUD tests Create, Read, Update, Delete for StatesType.
func TestStatesType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "StatesType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create StatesType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestStatesType_ListByType tests listing elements of type StatesType.
func TestStatesType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/StatesType", nil)
	req.SetPathValue("type", "StatesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStatesType_GetTypeMetadata tests getting type metadata for StatesType.
func TestStatesType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StatesType", nil)
	req.SetPathValue("name", "StatesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStatesType_GetValidChildTypes tests getting valid child types for StatesType.
func TestStatesType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StatesType/children", nil)
	req.SetPathValue("name", "StatesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestStatusElement_CRUD tests Create, Read, Update, Delete for StatusElement.
func TestStatusElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "StatusElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create StatusElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestStatusElement_ListByType tests listing elements of type StatusElement.
func TestStatusElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/StatusElement", nil)
	req.SetPathValue("type", "StatusElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStatusElement_GetTypeMetadata tests getting type metadata for StatusElement.
func TestStatusElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StatusElement", nil)
	req.SetPathValue("name", "StatusElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStatusElementType_CRUD tests Create, Read, Update, Delete for StatusElementType.
func TestStatusElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "StatusElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create StatusElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestStatusElementType_ListByType tests listing elements of type StatusElementType.
func TestStatusElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/StatusElementType", nil)
	req.SetPathValue("type", "StatusElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStatusElementType_GetTypeMetadata tests getting type metadata for StatusElementType.
func TestStatusElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StatusElementType", nil)
	req.SetPathValue("name", "StatusElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStatusType_CRUD tests Create, Read, Update, Delete for StatusType.
func TestStatusType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "StatusType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create StatusType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestStatusType_ListByType tests listing elements of type StatusType.
func TestStatusType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/StatusType", nil)
	req.SetPathValue("type", "StatusType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestStatusType_GetTypeMetadata tests getting type metadata for StatusType.
func TestStatusType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/StatusType", nil)
	req.SetPathValue("name", "StatusType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubAdministrativeAreaElementType_CRUD tests Create, Read, Update, Delete for SubAdministrativeAreaElementType.
func TestSubAdministrativeAreaElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubAdministrativeAreaElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubAdministrativeAreaElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubAdministrativeAreaElementType_ListByType tests listing elements of type SubAdministrativeAreaElementType.
func TestSubAdministrativeAreaElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubAdministrativeAreaElementType", nil)
	req.SetPathValue("type", "SubAdministrativeAreaElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubAdministrativeAreaElementType_GetTypeMetadata tests getting type metadata for SubAdministrativeAreaElementType.
func TestSubAdministrativeAreaElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubAdministrativeAreaElementType", nil)
	req.SetPathValue("name", "SubAdministrativeAreaElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubAdministrativeAreaElementType_GetValidChildTypes tests getting valid child types for SubAdministrativeAreaElementType.
func TestSubAdministrativeAreaElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubAdministrativeAreaElementType/children", nil)
	req.SetPathValue("name", "SubAdministrativeAreaElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSubAdministrativeAreaNameElementType_CRUD tests Create, Read, Update, Delete for SubAdministrativeAreaNameElementType.
func TestSubAdministrativeAreaNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubAdministrativeAreaNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubAdministrativeAreaNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubAdministrativeAreaNameElementType_ListByType tests listing elements of type SubAdministrativeAreaNameElementType.
func TestSubAdministrativeAreaNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubAdministrativeAreaNameElementType", nil)
	req.SetPathValue("type", "SubAdministrativeAreaNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubAdministrativeAreaNameElementType_GetTypeMetadata tests getting type metadata for SubAdministrativeAreaNameElementType.
func TestSubAdministrativeAreaNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubAdministrativeAreaNameElementType", nil)
	req.SetPathValue("name", "SubAdministrativeAreaNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseLocationElementType_CRUD tests Create, Read, Update, Delete for SubPremiseLocationElementType.
func TestSubPremiseLocationElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubPremiseLocationElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubPremiseLocationElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubPremiseLocationElementType_ListByType tests listing elements of type SubPremiseLocationElementType.
func TestSubPremiseLocationElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubPremiseLocationElementType", nil)
	req.SetPathValue("type", "SubPremiseLocationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseLocationElementType_GetTypeMetadata tests getting type metadata for SubPremiseLocationElementType.
func TestSubPremiseLocationElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubPremiseLocationElementType", nil)
	req.SetPathValue("name", "SubPremiseLocationElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseNameElementType_CRUD tests Create, Read, Update, Delete for SubPremiseNameElementType.
func TestSubPremiseNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubPremiseNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubPremiseNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubPremiseNameElementType_ListByType tests listing elements of type SubPremiseNameElementType.
func TestSubPremiseNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubPremiseNameElementType", nil)
	req.SetPathValue("type", "SubPremiseNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseNameElementType_GetTypeMetadata tests getting type metadata for SubPremiseNameElementType.
func TestSubPremiseNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubPremiseNameElementType", nil)
	req.SetPathValue("name", "SubPremiseNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseNumberElementType_CRUD tests Create, Read, Update, Delete for SubPremiseNumberElementType.
func TestSubPremiseNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubPremiseNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubPremiseNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubPremiseNumberElementType_ListByType tests listing elements of type SubPremiseNumberElementType.
func TestSubPremiseNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubPremiseNumberElementType", nil)
	req.SetPathValue("type", "SubPremiseNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseNumberElementType_GetTypeMetadata tests getting type metadata for SubPremiseNumberElementType.
func TestSubPremiseNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubPremiseNumberElementType", nil)
	req.SetPathValue("name", "SubPremiseNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseNumberPrefixElementType_CRUD tests Create, Read, Update, Delete for SubPremiseNumberPrefixElementType.
func TestSubPremiseNumberPrefixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubPremiseNumberPrefixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubPremiseNumberPrefixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubPremiseNumberPrefixElementType_ListByType tests listing elements of type SubPremiseNumberPrefixElementType.
func TestSubPremiseNumberPrefixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubPremiseNumberPrefixElementType", nil)
	req.SetPathValue("type", "SubPremiseNumberPrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseNumberPrefixElementType_GetTypeMetadata tests getting type metadata for SubPremiseNumberPrefixElementType.
func TestSubPremiseNumberPrefixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubPremiseNumberPrefixElementType", nil)
	req.SetPathValue("name", "SubPremiseNumberPrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseNumberSuffixElementType_CRUD tests Create, Read, Update, Delete for SubPremiseNumberSuffixElementType.
func TestSubPremiseNumberSuffixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubPremiseNumberSuffixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubPremiseNumberSuffixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubPremiseNumberSuffixElementType_ListByType tests listing elements of type SubPremiseNumberSuffixElementType.
func TestSubPremiseNumberSuffixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubPremiseNumberSuffixElementType", nil)
	req.SetPathValue("type", "SubPremiseNumberSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseNumberSuffixElementType_GetTypeMetadata tests getting type metadata for SubPremiseNumberSuffixElementType.
func TestSubPremiseNumberSuffixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubPremiseNumberSuffixElementType", nil)
	req.SetPathValue("name", "SubPremiseNumberSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseType_CRUD tests Create, Read, Update, Delete for SubPremiseType.
func TestSubPremiseType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubPremiseType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubPremiseType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubPremiseType_ListByType tests listing elements of type SubPremiseType.
func TestSubPremiseType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubPremiseType", nil)
	req.SetPathValue("type", "SubPremiseType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseType_GetTypeMetadata tests getting type metadata for SubPremiseType.
func TestSubPremiseType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubPremiseType", nil)
	req.SetPathValue("name", "SubPremiseType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubPremiseType_GetValidChildTypes tests getting valid child types for SubPremiseType.
func TestSubPremiseType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubPremiseType/children", nil)
	req.SetPathValue("name", "SubPremiseType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSubType_CRUD tests Create, Read, Update, Delete for SubType.
func TestSubType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubType_ListByType tests listing elements of type SubType.
func TestSubType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubType", nil)
	req.SetPathValue("type", "SubType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubType_GetTypeMetadata tests getting type metadata for SubType.
func TestSubType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubType", nil)
	req.SetPathValue("name", "SubType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubUseEnumType_CRUD tests Create, Read, Update, Delete for SubUseEnumType.
func TestSubUseEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubUseEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubUseEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubUseEnumType_ListByType tests listing elements of type SubUseEnumType.
func TestSubUseEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubUseEnumType", nil)
	req.SetPathValue("type", "SubUseEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubUseEnumType_GetTypeMetadata tests getting type metadata for SubUseEnumType.
func TestSubUseEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubUseEnumType", nil)
	req.SetPathValue("name", "SubUseEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubstringFunctionType_CRUD tests Create, Read, Update, Delete for SubstringFunctionType.
func TestSubstringFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SubstringFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SubstringFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSubstringFunctionType_ListByType tests listing elements of type SubstringFunctionType.
func TestSubstringFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SubstringFunctionType", nil)
	req.SetPathValue("type", "SubstringFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSubstringFunctionType_GetTypeMetadata tests getting type metadata for SubstringFunctionType.
func TestSubstringFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SubstringFunctionType", nil)
	req.SetPathValue("name", "SubstringFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSuffixElementType_CRUD tests Create, Read, Update, Delete for SuffixElementType.
func TestSuffixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SuffixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SuffixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSuffixElementType_ListByType tests listing elements of type SuffixElementType.
func TestSuffixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SuffixElementType", nil)
	req.SetPathValue("type", "SuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSuffixElementType_GetTypeMetadata tests getting type metadata for SuffixElementType.
func TestSuffixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SuffixElementType", nil)
	req.SetPathValue("name", "SuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSupplementaryPostalServiceDataElementType_CRUD tests Create, Read, Update, Delete for SupplementaryPostalServiceDataElementType.
func TestSupplementaryPostalServiceDataElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SupplementaryPostalServiceDataElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SupplementaryPostalServiceDataElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSupplementaryPostalServiceDataElementType_ListByType tests listing elements of type SupplementaryPostalServiceDataElementType.
func TestSupplementaryPostalServiceDataElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SupplementaryPostalServiceDataElementType", nil)
	req.SetPathValue("type", "SupplementaryPostalServiceDataElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSupplementaryPostalServiceDataElementType_GetTypeMetadata tests getting type metadata for SupplementaryPostalServiceDataElementType.
func TestSupplementaryPostalServiceDataElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SupplementaryPostalServiceDataElementType", nil)
	req.SetPathValue("name", "SupplementaryPostalServiceDataElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSyntheticIdElement_CRUD tests Create, Read, Update, Delete for SyntheticIdElement.
func TestSyntheticIdElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SyntheticIdElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SyntheticIdElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSyntheticIdElement_ListByType tests listing elements of type SyntheticIdElement.
func TestSyntheticIdElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SyntheticIdElement", nil)
	req.SetPathValue("type", "SyntheticIdElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSyntheticIdElement_GetTypeMetadata tests getting type metadata for SyntheticIdElement.
func TestSyntheticIdElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SyntheticIdElement", nil)
	req.SetPathValue("name", "SyntheticIdElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSyntheticIdElementType_CRUD tests Create, Read, Update, Delete for SyntheticIdElementType.
func TestSyntheticIdElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SyntheticIdElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SyntheticIdElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSyntheticIdElementType_ListByType tests listing elements of type SyntheticIdElementType.
func TestSyntheticIdElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SyntheticIdElementType", nil)
	req.SetPathValue("type", "SyntheticIdElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSyntheticIdElementType_GetTypeMetadata tests getting type metadata for SyntheticIdElementType.
func TestSyntheticIdElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SyntheticIdElementType", nil)
	req.SetPathValue("name", "SyntheticIdElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSystemElement_CRUD tests Create, Read, Update, Delete for SystemElement.
func TestSystemElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SystemElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SystemElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSystemElement_ListByType tests listing elements of type SystemElement.
func TestSystemElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SystemElement", nil)
	req.SetPathValue("type", "SystemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSystemElement_GetTypeMetadata tests getting type metadata for SystemElement.
func TestSystemElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SystemElement", nil)
	req.SetPathValue("name", "SystemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSystemElement_GetValidChildTypes tests getting valid child types for SystemElement.
func TestSystemElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SystemElement/children", nil)
	req.SetPathValue("name", "SystemElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestSystemNameElementType_CRUD tests Create, Read, Update, Delete for SystemNameElementType.
func TestSystemNameElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SystemNameElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SystemNameElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSystemNameElementType_ListByType tests listing elements of type SystemNameElementType.
func TestSystemNameElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SystemNameElementType", nil)
	req.SetPathValue("type", "SystemNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSystemNameElementType_GetTypeMetadata tests getting type metadata for SystemNameElementType.
func TestSystemNameElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SystemNameElementType", nil)
	req.SetPathValue("name", "SystemNameElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSystemType_CRUD tests Create, Read, Update, Delete for SystemType.
func TestSystemType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "SystemType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create SystemType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestSystemType_ListByType tests listing elements of type SystemType.
func TestSystemType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/SystemType", nil)
	req.SetPathValue("type", "SystemType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSystemType_GetTypeMetadata tests getting type metadata for SystemType.
func TestSystemType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SystemType", nil)
	req.SetPathValue("name", "SystemType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestSystemType_GetValidChildTypes tests getting valid child types for SystemType.
func TestSystemType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/SystemType/children", nil)
	req.SetPathValue("name", "SystemType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTailoringBenchmarkReferenceType_CRUD tests Create, Read, Update, Delete for TailoringBenchmarkReferenceType.
func TestTailoringBenchmarkReferenceType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TailoringBenchmarkReferenceType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TailoringBenchmarkReferenceType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTailoringBenchmarkReferenceType_ListByType tests listing elements of type TailoringBenchmarkReferenceType.
func TestTailoringBenchmarkReferenceType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TailoringBenchmarkReferenceType", nil)
	req.SetPathValue("type", "TailoringBenchmarkReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringBenchmarkReferenceType_GetTypeMetadata tests getting type metadata for TailoringBenchmarkReferenceType.
func TestTailoringBenchmarkReferenceType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TailoringBenchmarkReferenceType", nil)
	req.SetPathValue("name", "TailoringBenchmarkReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringElement_CRUD tests Create, Read, Update, Delete for TailoringElement.
func TestTailoringElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TailoringElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TailoringElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTailoringElement_ListByType tests listing elements of type TailoringElement.
func TestTailoringElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TailoringElement", nil)
	req.SetPathValue("type", "TailoringElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringElement_GetTypeMetadata tests getting type metadata for TailoringElement.
func TestTailoringElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TailoringElement", nil)
	req.SetPathValue("name", "TailoringElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringElement_GetValidChildTypes tests getting valid child types for TailoringElement.
func TestTailoringElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TailoringElement/children", nil)
	req.SetPathValue("name", "TailoringElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTailoringIdType_CRUD tests Create, Read, Update, Delete for TailoringIdType.
func TestTailoringIdType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TailoringIdType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TailoringIdType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTailoringIdType_ListByType tests listing elements of type TailoringIdType.
func TestTailoringIdType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TailoringIdType", nil)
	req.SetPathValue("type", "TailoringIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringIdType_GetTypeMetadata tests getting type metadata for TailoringIdType.
func TestTailoringIdType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TailoringIdType", nil)
	req.SetPathValue("name", "TailoringIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringReferenceType_CRUD tests Create, Read, Update, Delete for TailoringReferenceType.
func TestTailoringReferenceType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TailoringReferenceType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TailoringReferenceType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTailoringReferenceType_ListByType tests listing elements of type TailoringReferenceType.
func TestTailoringReferenceType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TailoringReferenceType", nil)
	req.SetPathValue("type", "TailoringReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringReferenceType_GetTypeMetadata tests getting type metadata for TailoringReferenceType.
func TestTailoringReferenceType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TailoringReferenceType", nil)
	req.SetPathValue("name", "TailoringReferenceType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringType_CRUD tests Create, Read, Update, Delete for TailoringType.
func TestTailoringType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TailoringType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TailoringType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTailoringType_ListByType tests listing elements of type TailoringType.
func TestTailoringType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TailoringType", nil)
	req.SetPathValue("type", "TailoringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringType_GetTypeMetadata tests getting type metadata for TailoringType.
func TestTailoringType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TailoringType", nil)
	req.SetPathValue("name", "TailoringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringType_GetValidChildTypes tests getting valid child types for TailoringType.
func TestTailoringType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TailoringType/children", nil)
	req.SetPathValue("name", "TailoringType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTailoringVersionType_CRUD tests Create, Read, Update, Delete for TailoringVersionType.
func TestTailoringVersionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TailoringVersionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TailoringVersionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTailoringVersionType_ListByType tests listing elements of type TailoringVersionType.
func TestTailoringVersionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TailoringVersionType", nil)
	req.SetPathValue("type", "TailoringVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTailoringVersionType_GetTypeMetadata tests getting type metadata for TailoringVersionType.
func TestTailoringVersionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TailoringVersionType", nil)
	req.SetPathValue("name", "TailoringVersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTargetFactsType_CRUD tests Create, Read, Update, Delete for TargetFactsType.
func TestTargetFactsType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TargetFactsType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TargetFactsType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTargetFactsType_ListByType tests listing elements of type TargetFactsType.
func TestTargetFactsType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TargetFactsType", nil)
	req.SetPathValue("type", "TargetFactsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTargetFactsType_GetTypeMetadata tests getting type metadata for TargetFactsType.
func TestTargetFactsType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TargetFactsType", nil)
	req.SetPathValue("name", "TargetFactsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTargetFactsType_GetValidChildTypes tests getting valid child types for TargetFactsType.
func TestTargetFactsType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TargetFactsType/children", nil)
	req.SetPathValue("name", "TargetFactsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTargetIdRefType_CRUD tests Create, Read, Update, Delete for TargetIdRefType.
func TestTargetIdRefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TargetIdRefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TargetIdRefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTargetIdRefType_ListByType tests listing elements of type TargetIdRefType.
func TestTargetIdRefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TargetIdRefType", nil)
	req.SetPathValue("type", "TargetIdRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTargetIdRefType_GetTypeMetadata tests getting type metadata for TargetIdRefType.
func TestTargetIdRefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TargetIdRefType", nil)
	req.SetPathValue("name", "TargetIdRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTelephoneNumberElement_CRUD tests Create, Read, Update, Delete for TelephoneNumberElement.
func TestTelephoneNumberElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TelephoneNumberElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TelephoneNumberElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTelephoneNumberElement_ListByType tests listing elements of type TelephoneNumberElement.
func TestTelephoneNumberElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TelephoneNumberElement", nil)
	req.SetPathValue("type", "TelephoneNumberElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTelephoneNumberElement_GetTypeMetadata tests getting type metadata for TelephoneNumberElement.
func TestTelephoneNumberElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TelephoneNumberElement", nil)
	req.SetPathValue("name", "TelephoneNumberElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTelephoneNumberElementType_CRUD tests Create, Read, Update, Delete for TelephoneNumberElementType.
func TestTelephoneNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TelephoneNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TelephoneNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTelephoneNumberElementType_ListByType tests listing elements of type TelephoneNumberElementType.
func TestTelephoneNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TelephoneNumberElementType", nil)
	req.SetPathValue("type", "TelephoneNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTelephoneNumberElementType_GetTypeMetadata tests getting type metadata for TelephoneNumberElementType.
func TestTelephoneNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TelephoneNumberElementType", nil)
	req.SetPathValue("name", "TelephoneNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTelephoneNumberType_CRUD tests Create, Read, Update, Delete for TelephoneNumberType.
func TestTelephoneNumberType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TelephoneNumberType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TelephoneNumberType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTelephoneNumberType_ListByType tests listing elements of type TelephoneNumberType.
func TestTelephoneNumberType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TelephoneNumberType", nil)
	req.SetPathValue("type", "TelephoneNumberType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTelephoneNumberType_GetTypeMetadata tests getting type metadata for TelephoneNumberType.
func TestTelephoneNumberType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TelephoneNumberType", nil)
	req.SetPathValue("name", "TelephoneNumberType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestElement_CRUD tests Create, Read, Update, Delete for TestElement.
func TestTestElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TestElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TestElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTestElement_ListByType tests listing elements of type TestElement.
func TestTestElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TestElement", nil)
	req.SetPathValue("type", "TestElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestElement_GetTypeMetadata tests getting type metadata for TestElement.
func TestTestElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestElement", nil)
	req.SetPathValue("name", "TestElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestElement_GetValidChildTypes tests getting valid child types for TestElement.
func TestTestElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestElement/children", nil)
	req.SetPathValue("name", "TestElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTestIDPattern_CRUD tests Create, Read, Update, Delete for TestIDPattern.
func TestTestIDPattern_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TestIDPattern",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TestIDPattern returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTestIDPattern_ListByType tests listing elements of type TestIDPattern.
func TestTestIDPattern_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TestIDPattern", nil)
	req.SetPathValue("type", "TestIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestIDPattern_GetTypeMetadata tests getting type metadata for TestIDPattern.
func TestTestIDPattern_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestIDPattern", nil)
	req.SetPathValue("name", "TestIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestResultElement_CRUD tests Create, Read, Update, Delete for TestResultElement.
func TestTestResultElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TestResultElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TestResultElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTestResultElement_ListByType tests listing elements of type TestResultElement.
func TestTestResultElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TestResultElement", nil)
	req.SetPathValue("type", "TestResultElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestResultElement_GetTypeMetadata tests getting type metadata for TestResultElement.
func TestTestResultElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestResultElement", nil)
	req.SetPathValue("name", "TestResultElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestResultElement_GetValidChildTypes tests getting valid child types for TestResultElement.
func TestTestResultElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestResultElement/children", nil)
	req.SetPathValue("name", "TestResultElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTestResultType_CRUD tests Create, Read, Update, Delete for TestResultType.
func TestTestResultType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TestResultType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TestResultType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTestResultType_ListByType tests listing elements of type TestResultType.
func TestTestResultType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TestResultType", nil)
	req.SetPathValue("type", "TestResultType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestResultType_GetTypeMetadata tests getting type metadata for TestResultType.
func TestTestResultType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestResultType", nil)
	req.SetPathValue("name", "TestResultType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestResultType_GetValidChildTypes tests getting valid child types for TestResultType.
func TestTestResultType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestResultType/children", nil)
	req.SetPathValue("name", "TestResultType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTestType_CRUD tests Create, Read, Update, Delete for TestType.
func TestTestType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TestType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TestType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTestType_ListByType tests listing elements of type TestType.
func TestTestType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TestType", nil)
	req.SetPathValue("type", "TestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestType_GetTypeMetadata tests getting type metadata for TestType.
func TestTestType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestType", nil)
	req.SetPathValue("name", "TestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestType_GetValidChildTypes tests getting valid child types for TestType.
func TestTestType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestType/children", nil)
	req.SetPathValue("name", "TestType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTestresultIdType_CRUD tests Create, Read, Update, Delete for TestresultIdType.
func TestTestresultIdType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TestresultIdType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TestresultIdType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTestresultIdType_ListByType tests listing elements of type TestresultIdType.
func TestTestresultIdType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TestresultIdType", nil)
	req.SetPathValue("type", "TestresultIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestresultIdType_GetTypeMetadata tests getting type metadata for TestresultIdType.
func TestTestresultIdType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestresultIdType", nil)
	req.SetPathValue("name", "TestresultIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestsType_CRUD tests Create, Read, Update, Delete for TestsType.
func TestTestsType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TestsType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TestsType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTestsType_ListByType tests listing elements of type TestsType.
func TestTestsType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TestsType", nil)
	req.SetPathValue("type", "TestsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestsType_GetTypeMetadata tests getting type metadata for TestsType.
func TestTestsType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestsType", nil)
	req.SetPathValue("name", "TestsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTestsType_GetValidChildTypes tests getting valid child types for TestsType.
func TestTestsType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TestsType/children", nil)
	req.SetPathValue("name", "TestsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTextType_CRUD tests Create, Read, Update, Delete for TextType.
func TestTextType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TextType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TextType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTextType_ListByType tests listing elements of type TextType.
func TestTextType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TextType", nil)
	req.SetPathValue("type", "TextType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTextType_GetTypeMetadata tests getting type metadata for TextType.
func TestTextType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TextType", nil)
	req.SetPathValue("name", "TextType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTextWithSubType_CRUD tests Create, Read, Update, Delete for TextWithSubType.
func TestTextWithSubType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TextWithSubType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TextWithSubType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTextWithSubType_ListByType tests listing elements of type TextWithSubType.
func TestTextWithSubType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TextWithSubType", nil)
	req.SetPathValue("type", "TextWithSubType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTextWithSubType_GetTypeMetadata tests getting type metadata for TextWithSubType.
func TestTextWithSubType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TextWithSubType", nil)
	req.SetPathValue("name", "TextWithSubType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTextWithSubType_GetValidChildTypes tests getting valid child types for TextWithSubType.
func TestTextWithSubType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TextWithSubType/children", nil)
	req.SetPathValue("name", "TextWithSubType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestThoroughfareElement_CRUD tests Create, Read, Update, Delete for ThoroughfareElement.
func TestThoroughfareElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareElement_ListByType tests listing elements of type ThoroughfareElement.
func TestThoroughfareElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareElement", nil)
	req.SetPathValue("type", "ThoroughfareElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareElement_GetTypeMetadata tests getting type metadata for ThoroughfareElement.
func TestThoroughfareElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareElement", nil)
	req.SetPathValue("name", "ThoroughfareElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareElement_GetValidChildTypes tests getting valid child types for ThoroughfareElement.
func TestThoroughfareElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareElement/children", nil)
	req.SetPathValue("name", "ThoroughfareElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestThoroughfareElementType_CRUD tests Create, Read, Update, Delete for ThoroughfareElementType.
func TestThoroughfareElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareElementType_ListByType tests listing elements of type ThoroughfareElementType.
func TestThoroughfareElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareElementType", nil)
	req.SetPathValue("type", "ThoroughfareElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareElementType_GetTypeMetadata tests getting type metadata for ThoroughfareElementType.
func TestThoroughfareElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareElementType", nil)
	req.SetPathValue("name", "ThoroughfareElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareElementType_GetValidChildTypes tests getting valid child types for ThoroughfareElementType.
func TestThoroughfareElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareElementType/children", nil)
	req.SetPathValue("name", "ThoroughfareElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestThoroughfareLeadingTypeType_CRUD tests Create, Read, Update, Delete for ThoroughfareLeadingTypeType.
func TestThoroughfareLeadingTypeType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareLeadingTypeType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareLeadingTypeType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareLeadingTypeType_ListByType tests listing elements of type ThoroughfareLeadingTypeType.
func TestThoroughfareLeadingTypeType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareLeadingTypeType", nil)
	req.SetPathValue("type", "ThoroughfareLeadingTypeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareLeadingTypeType_GetTypeMetadata tests getting type metadata for ThoroughfareLeadingTypeType.
func TestThoroughfareLeadingTypeType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareLeadingTypeType", nil)
	req.SetPathValue("name", "ThoroughfareLeadingTypeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNameType_CRUD tests Create, Read, Update, Delete for ThoroughfareNameType.
func TestThoroughfareNameType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNameType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNameType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNameType_ListByType tests listing elements of type ThoroughfareNameType.
func TestThoroughfareNameType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNameType", nil)
	req.SetPathValue("type", "ThoroughfareNameType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNameType_GetTypeMetadata tests getting type metadata for ThoroughfareNameType.
func TestThoroughfareNameType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNameType", nil)
	req.SetPathValue("name", "ThoroughfareNameType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberElement_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberElement.
func TestThoroughfareNumberElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberElement_ListByType tests listing elements of type ThoroughfareNumberElement.
func TestThoroughfareNumberElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberElement", nil)
	req.SetPathValue("type", "ThoroughfareNumberElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberElement_GetTypeMetadata tests getting type metadata for ThoroughfareNumberElement.
func TestThoroughfareNumberElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberElement", nil)
	req.SetPathValue("name", "ThoroughfareNumberElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberElementType_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberElementType.
func TestThoroughfareNumberElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberElementType_ListByType tests listing elements of type ThoroughfareNumberElementType.
func TestThoroughfareNumberElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberElementType", nil)
	req.SetPathValue("type", "ThoroughfareNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberElementType_GetTypeMetadata tests getting type metadata for ThoroughfareNumberElementType.
func TestThoroughfareNumberElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberElementType", nil)
	req.SetPathValue("name", "ThoroughfareNumberElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberFromElementType_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberFromElementType.
func TestThoroughfareNumberFromElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberFromElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberFromElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberFromElementType_ListByType tests listing elements of type ThoroughfareNumberFromElementType.
func TestThoroughfareNumberFromElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberFromElementType", nil)
	req.SetPathValue("type", "ThoroughfareNumberFromElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberFromElementType_GetTypeMetadata tests getting type metadata for ThoroughfareNumberFromElementType.
func TestThoroughfareNumberFromElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberFromElementType", nil)
	req.SetPathValue("name", "ThoroughfareNumberFromElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberFromElementType_GetValidChildTypes tests getting valid child types for ThoroughfareNumberFromElementType.
func TestThoroughfareNumberFromElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberFromElementType/children", nil)
	req.SetPathValue("name", "ThoroughfareNumberFromElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestThoroughfareNumberPrefixElement_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberPrefixElement.
func TestThoroughfareNumberPrefixElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberPrefixElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberPrefixElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberPrefixElement_ListByType tests listing elements of type ThoroughfareNumberPrefixElement.
func TestThoroughfareNumberPrefixElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberPrefixElement", nil)
	req.SetPathValue("type", "ThoroughfareNumberPrefixElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberPrefixElement_GetTypeMetadata tests getting type metadata for ThoroughfareNumberPrefixElement.
func TestThoroughfareNumberPrefixElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberPrefixElement", nil)
	req.SetPathValue("name", "ThoroughfareNumberPrefixElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberPrefixElementType_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberPrefixElementType.
func TestThoroughfareNumberPrefixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberPrefixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberPrefixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberPrefixElementType_ListByType tests listing elements of type ThoroughfareNumberPrefixElementType.
func TestThoroughfareNumberPrefixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberPrefixElementType", nil)
	req.SetPathValue("type", "ThoroughfareNumberPrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberPrefixElementType_GetTypeMetadata tests getting type metadata for ThoroughfareNumberPrefixElementType.
func TestThoroughfareNumberPrefixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberPrefixElementType", nil)
	req.SetPathValue("name", "ThoroughfareNumberPrefixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberRangeElementType_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberRangeElementType.
func TestThoroughfareNumberRangeElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberRangeElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberRangeElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberRangeElementType_ListByType tests listing elements of type ThoroughfareNumberRangeElementType.
func TestThoroughfareNumberRangeElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberRangeElementType", nil)
	req.SetPathValue("type", "ThoroughfareNumberRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberRangeElementType_GetTypeMetadata tests getting type metadata for ThoroughfareNumberRangeElementType.
func TestThoroughfareNumberRangeElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberRangeElementType", nil)
	req.SetPathValue("name", "ThoroughfareNumberRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberRangeElementType_GetValidChildTypes tests getting valid child types for ThoroughfareNumberRangeElementType.
func TestThoroughfareNumberRangeElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberRangeElementType/children", nil)
	req.SetPathValue("name", "ThoroughfareNumberRangeElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestThoroughfareNumberSuffixElement_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberSuffixElement.
func TestThoroughfareNumberSuffixElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberSuffixElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberSuffixElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberSuffixElement_ListByType tests listing elements of type ThoroughfareNumberSuffixElement.
func TestThoroughfareNumberSuffixElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberSuffixElement", nil)
	req.SetPathValue("type", "ThoroughfareNumberSuffixElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberSuffixElement_GetTypeMetadata tests getting type metadata for ThoroughfareNumberSuffixElement.
func TestThoroughfareNumberSuffixElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberSuffixElement", nil)
	req.SetPathValue("name", "ThoroughfareNumberSuffixElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberSuffixElementType_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberSuffixElementType.
func TestThoroughfareNumberSuffixElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberSuffixElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberSuffixElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberSuffixElementType_ListByType tests listing elements of type ThoroughfareNumberSuffixElementType.
func TestThoroughfareNumberSuffixElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberSuffixElementType", nil)
	req.SetPathValue("type", "ThoroughfareNumberSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberSuffixElementType_GetTypeMetadata tests getting type metadata for ThoroughfareNumberSuffixElementType.
func TestThoroughfareNumberSuffixElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberSuffixElementType", nil)
	req.SetPathValue("name", "ThoroughfareNumberSuffixElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberToElementType_CRUD tests Create, Read, Update, Delete for ThoroughfareNumberToElementType.
func TestThoroughfareNumberToElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareNumberToElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareNumberToElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareNumberToElementType_ListByType tests listing elements of type ThoroughfareNumberToElementType.
func TestThoroughfareNumberToElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareNumberToElementType", nil)
	req.SetPathValue("type", "ThoroughfareNumberToElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberToElementType_GetTypeMetadata tests getting type metadata for ThoroughfareNumberToElementType.
func TestThoroughfareNumberToElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberToElementType", nil)
	req.SetPathValue("name", "ThoroughfareNumberToElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareNumberToElementType_GetValidChildTypes tests getting valid child types for ThoroughfareNumberToElementType.
func TestThoroughfareNumberToElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareNumberToElementType/children", nil)
	req.SetPathValue("name", "ThoroughfareNumberToElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestThoroughfarePostDirectionType_CRUD tests Create, Read, Update, Delete for ThoroughfarePostDirectionType.
func TestThoroughfarePostDirectionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfarePostDirectionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfarePostDirectionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfarePostDirectionType_ListByType tests listing elements of type ThoroughfarePostDirectionType.
func TestThoroughfarePostDirectionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfarePostDirectionType", nil)
	req.SetPathValue("type", "ThoroughfarePostDirectionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfarePostDirectionType_GetTypeMetadata tests getting type metadata for ThoroughfarePostDirectionType.
func TestThoroughfarePostDirectionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfarePostDirectionType", nil)
	req.SetPathValue("name", "ThoroughfarePostDirectionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfarePreDirectionType_CRUD tests Create, Read, Update, Delete for ThoroughfarePreDirectionType.
func TestThoroughfarePreDirectionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfarePreDirectionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfarePreDirectionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfarePreDirectionType_ListByType tests listing elements of type ThoroughfarePreDirectionType.
func TestThoroughfarePreDirectionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfarePreDirectionType", nil)
	req.SetPathValue("type", "ThoroughfarePreDirectionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfarePreDirectionType_GetTypeMetadata tests getting type metadata for ThoroughfarePreDirectionType.
func TestThoroughfarePreDirectionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfarePreDirectionType", nil)
	req.SetPathValue("name", "ThoroughfarePreDirectionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareTrailingTypeType_CRUD tests Create, Read, Update, Delete for ThoroughfareTrailingTypeType.
func TestThoroughfareTrailingTypeType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ThoroughfareTrailingTypeType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ThoroughfareTrailingTypeType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestThoroughfareTrailingTypeType_ListByType tests listing elements of type ThoroughfareTrailingTypeType.
func TestThoroughfareTrailingTypeType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ThoroughfareTrailingTypeType", nil)
	req.SetPathValue("type", "ThoroughfareTrailingTypeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestThoroughfareTrailingTypeType_GetTypeMetadata tests getting type metadata for ThoroughfareTrailingTypeType.
func TestThoroughfareTrailingTypeType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ThoroughfareTrailingTypeType", nil)
	req.SetPathValue("name", "ThoroughfareTrailingTypeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTimeDifferenceFunctionType_CRUD tests Create, Read, Update, Delete for TimeDifferenceFunctionType.
func TestTimeDifferenceFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TimeDifferenceFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TimeDifferenceFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTimeDifferenceFunctionType_ListByType tests listing elements of type TimeDifferenceFunctionType.
func TestTimeDifferenceFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TimeDifferenceFunctionType", nil)
	req.SetPathValue("type", "TimeDifferenceFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTimeDifferenceFunctionType_GetTypeMetadata tests getting type metadata for TimeDifferenceFunctionType.
func TestTimeDifferenceFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TimeDifferenceFunctionType", nil)
	req.SetPathValue("name", "TimeDifferenceFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTitleAttrType_CRUD tests Create, Read, Update, Delete for TitleAttrType.
func TestTitleAttrType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TitleAttrType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TitleAttrType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTitleAttrType_ListByType tests listing elements of type TitleAttrType.
func TestTitleAttrType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TitleAttrType", nil)
	req.SetPathValue("type", "TitleAttrType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTitleAttrType_GetTypeMetadata tests getting type metadata for TitleAttrType.
func TestTitleAttrType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TitleAttrType", nil)
	req.SetPathValue("name", "TitleAttrType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTitleElement_CRUD tests Create, Read, Update, Delete for TitleElement.
func TestTitleElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TitleElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TitleElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTitleElement_ListByType tests listing elements of type TitleElement.
func TestTitleElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TitleElement", nil)
	req.SetPathValue("type", "TitleElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTitleElement_GetTypeMetadata tests getting type metadata for TitleElement.
func TestTitleElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TitleElement", nil)
	req.SetPathValue("name", "TitleElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTitleElementType_CRUD tests Create, Read, Update, Delete for TitleElementType.
func TestTitleElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TitleElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TitleElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTitleElementType_ListByType tests listing elements of type TitleElementType.
func TestTitleElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TitleElementType", nil)
	req.SetPathValue("type", "TitleElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTitleElementType_GetTypeMetadata tests getting type metadata for TitleElementType.
func TestTitleElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TitleElementType", nil)
	req.SetPathValue("name", "TitleElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTitleEltType_CRUD tests Create, Read, Update, Delete for TitleEltType.
func TestTitleEltType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TitleEltType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TitleEltType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTitleEltType_ListByType tests listing elements of type TitleEltType.
func TestTitleEltType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TitleEltType", nil)
	req.SetPathValue("type", "TitleEltType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTitleEltType_GetTypeMetadata tests getting type metadata for TitleEltType.
func TestTitleEltType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TitleEltType", nil)
	req.SetPathValue("name", "TitleEltType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestToType_CRUD tests Create, Read, Update, Delete for ToType.
func TestToType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ToType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ToType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestToType_ListByType tests listing elements of type ToType.
func TestToType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ToType", nil)
	req.SetPathValue("type", "ToType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestToType_GetTypeMetadata tests getting type metadata for ToType.
func TestToType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ToType", nil)
	req.SetPathValue("name", "ToType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformElement_CRUD tests Create, Read, Update, Delete for TransformElement.
func TestTransformElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TransformElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TransformElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTransformElement_ListByType tests listing elements of type TransformElement.
func TestTransformElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TransformElement", nil)
	req.SetPathValue("type", "TransformElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformElement_GetTypeMetadata tests getting type metadata for TransformElement.
func TestTransformElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TransformElement", nil)
	req.SetPathValue("name", "TransformElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformType_CRUD tests Create, Read, Update, Delete for TransformType.
func TestTransformType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TransformType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TransformType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTransformType_ListByType tests listing elements of type TransformType.
func TestTransformType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TransformType", nil)
	req.SetPathValue("type", "TransformType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformType_GetTypeMetadata tests getting type metadata for TransformType.
func TestTransformType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TransformType", nil)
	req.SetPathValue("name", "TransformType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformsElement_CRUD tests Create, Read, Update, Delete for TransformsElement.
func TestTransformsElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TransformsElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TransformsElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTransformsElement_ListByType tests listing elements of type TransformsElement.
func TestTransformsElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TransformsElement", nil)
	req.SetPathValue("type", "TransformsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformsElement_GetTypeMetadata tests getting type metadata for TransformsElement.
func TestTransformsElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TransformsElement", nil)
	req.SetPathValue("name", "TransformsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformsElement_GetValidChildTypes tests getting valid child types for TransformsElement.
func TestTransformsElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TransformsElement/children", nil)
	req.SetPathValue("name", "TransformsElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTransformsType_CRUD tests Create, Read, Update, Delete for TransformsType.
func TestTransformsType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TransformsType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TransformsType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTransformsType_ListByType tests listing elements of type TransformsType.
func TestTransformsType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TransformsType", nil)
	req.SetPathValue("type", "TransformsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformsType_GetTypeMetadata tests getting type metadata for TransformsType.
func TestTransformsType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TransformsType", nil)
	req.SetPathValue("name", "TransformsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTransformsType_GetValidChildTypes tests getting valid child types for TransformsType.
func TestTransformsType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TransformsType/children", nil)
	req.SetPathValue("name", "TransformsType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestTypeType_CRUD tests Create, Read, Update, Delete for TypeType.
func TestTypeType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "TypeType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create TypeType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestTypeType_ListByType tests listing elements of type TypeType.
func TestTypeType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/TypeType", nil)
	req.SetPathValue("type", "TypeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestTypeType_GetTypeMetadata tests getting type metadata for TypeType.
func TestTypeType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/TypeType", nil)
	req.SetPathValue("name", "TypeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestUniqueFunctionType_CRUD tests Create, Read, Update, Delete for UniqueFunctionType.
func TestUniqueFunctionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "UniqueFunctionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create UniqueFunctionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestUniqueFunctionType_ListByType tests listing elements of type UniqueFunctionType.
func TestUniqueFunctionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/UniqueFunctionType", nil)
	req.SetPathValue("type", "UniqueFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestUniqueFunctionType_GetTypeMetadata tests getting type metadata for UniqueFunctionType.
func TestUniqueFunctionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/UniqueFunctionType", nil)
	req.SetPathValue("name", "UniqueFunctionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestUriRefType_CRUD tests Create, Read, Update, Delete for UriRefType.
func TestUriRefType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "UriRefType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create UriRefType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestUriRefType_ListByType tests listing elements of type UriRefType.
func TestUriRefType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/UriRefType", nil)
	req.SetPathValue("type", "UriRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestUriRefType_GetTypeMetadata tests getting type metadata for UriRefType.
func TestUriRefType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/UriRefType", nil)
	req.SetPathValue("name", "UriRefType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestUrlElementType_CRUD tests Create, Read, Update, Delete for UrlElementType.
func TestUrlElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "UrlElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create UrlElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestUrlElementType_ListByType tests listing elements of type UrlElementType.
func TestUrlElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/UrlElementType", nil)
	req.SetPathValue("type", "UrlElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestUrlElementType_GetTypeMetadata tests getting type metadata for UrlElementType.
func TestUrlElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/UrlElementType", nil)
	req.SetPathValue("name", "UrlElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueElement_CRUD tests Create, Read, Update, Delete for ValueElement.
func TestValueElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ValueElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ValueElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestValueElement_ListByType tests listing elements of type ValueElement.
func TestValueElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ValueElement", nil)
	req.SetPathValue("type", "ValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueElement_GetTypeMetadata tests getting type metadata for ValueElement.
func TestValueElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ValueElement", nil)
	req.SetPathValue("name", "ValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueElement_GetValidChildTypes tests getting valid child types for ValueElement.
func TestValueElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ValueElement/children", nil)
	req.SetPathValue("name", "ValueElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestValueIdType_CRUD tests Create, Read, Update, Delete for ValueIdType.
func TestValueIdType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ValueIdType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ValueIdType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestValueIdType_ListByType tests listing elements of type ValueIdType.
func TestValueIdType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ValueIdType", nil)
	req.SetPathValue("type", "ValueIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueIdType_GetTypeMetadata tests getting type metadata for ValueIdType.
func TestValueIdType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ValueIdType", nil)
	req.SetPathValue("name", "ValueIdType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueOperatorType_CRUD tests Create, Read, Update, Delete for ValueOperatorType.
func TestValueOperatorType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ValueOperatorType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ValueOperatorType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestValueOperatorType_ListByType tests listing elements of type ValueOperatorType.
func TestValueOperatorType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ValueOperatorType", nil)
	req.SetPathValue("type", "ValueOperatorType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueOperatorType_GetTypeMetadata tests getting type metadata for ValueOperatorType.
func TestValueOperatorType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ValueOperatorType", nil)
	req.SetPathValue("name", "ValueOperatorType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueType_CRUD tests Create, Read, Update, Delete for ValueType.
func TestValueType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ValueType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ValueType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestValueType_ListByType tests listing elements of type ValueType.
func TestValueType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ValueType", nil)
	req.SetPathValue("type", "ValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueType_GetTypeMetadata tests getting type metadata for ValueType.
func TestValueType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ValueType", nil)
	req.SetPathValue("name", "ValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueType_GetValidChildTypes tests getting valid child types for ValueType.
func TestValueType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ValueType/children", nil)
	req.SetPathValue("name", "ValueType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestValueTypeType_CRUD tests Create, Read, Update, Delete for ValueTypeType.
func TestValueTypeType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "ValueTypeType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create ValueTypeType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestValueTypeType_ListByType tests listing elements of type ValueTypeType.
func TestValueTypeType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/ValueTypeType", nil)
	req.SetPathValue("type", "ValueTypeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestValueTypeType_GetTypeMetadata tests getting type metadata for ValueTypeType.
func TestValueTypeType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/ValueTypeType", nil)
	req.SetPathValue("name", "ValueTypeType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableComponentType_CRUD tests Create, Read, Update, Delete for VariableComponentType.
func TestVariableComponentType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "VariableComponentType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create VariableComponentType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestVariableComponentType_ListByType tests listing elements of type VariableComponentType.
func TestVariableComponentType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/VariableComponentType", nil)
	req.SetPathValue("type", "VariableComponentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableComponentType_GetTypeMetadata tests getting type metadata for VariableComponentType.
func TestVariableComponentType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VariableComponentType", nil)
	req.SetPathValue("name", "VariableComponentType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableElement_CRUD tests Create, Read, Update, Delete for VariableElement.
func TestVariableElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "VariableElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create VariableElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestVariableElement_ListByType tests listing elements of type VariableElement.
func TestVariableElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/VariableElement", nil)
	req.SetPathValue("type", "VariableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableElement_GetTypeMetadata tests getting type metadata for VariableElement.
func TestVariableElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VariableElement", nil)
	req.SetPathValue("name", "VariableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableElement_GetValidChildTypes tests getting valid child types for VariableElement.
func TestVariableElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VariableElement/children", nil)
	req.SetPathValue("name", "VariableElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestVariableIDPattern_CRUD tests Create, Read, Update, Delete for VariableIDPattern.
func TestVariableIDPattern_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "VariableIDPattern",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create VariableIDPattern returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestVariableIDPattern_ListByType tests listing elements of type VariableIDPattern.
func TestVariableIDPattern_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/VariableIDPattern", nil)
	req.SetPathValue("type", "VariableIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableIDPattern_GetTypeMetadata tests getting type metadata for VariableIDPattern.
func TestVariableIDPattern_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VariableIDPattern", nil)
	req.SetPathValue("name", "VariableIDPattern")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableType_CRUD tests Create, Read, Update, Delete for VariableType.
func TestVariableType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "VariableType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create VariableType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestVariableType_ListByType tests listing elements of type VariableType.
func TestVariableType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/VariableType", nil)
	req.SetPathValue("type", "VariableType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableType_GetTypeMetadata tests getting type metadata for VariableType.
func TestVariableType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VariableType", nil)
	req.SetPathValue("name", "VariableType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariableType_GetValidChildTypes tests getting valid child types for VariableType.
func TestVariableType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VariableType/children", nil)
	req.SetPathValue("name", "VariableType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestVariablesType_CRUD tests Create, Read, Update, Delete for VariablesType.
func TestVariablesType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "VariablesType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create VariablesType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestVariablesType_ListByType tests listing elements of type VariablesType.
func TestVariablesType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/VariablesType", nil)
	req.SetPathValue("type", "VariablesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariablesType_GetTypeMetadata tests getting type metadata for VariablesType.
func TestVariablesType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VariablesType", nil)
	req.SetPathValue("name", "VariablesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVariablesType_GetValidChildTypes tests getting valid child types for VariablesType.
func TestVariablesType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VariablesType/children", nil)
	req.SetPathValue("name", "VariablesType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestVersionElementType_CRUD tests Create, Read, Update, Delete for VersionElementType.
func TestVersionElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "VersionElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create VersionElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestVersionElementType_ListByType tests listing elements of type VersionElementType.
func TestVersionElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/VersionElementType", nil)
	req.SetPathValue("type", "VersionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVersionElementType_GetTypeMetadata tests getting type metadata for VersionElementType.
func TestVersionElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VersionElementType", nil)
	req.SetPathValue("name", "VersionElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVersionType_CRUD tests Create, Read, Update, Delete for VersionType.
func TestVersionType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "VersionType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create VersionType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestVersionType_ListByType tests listing elements of type VersionType.
func TestVersionType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/VersionType", nil)
	req.SetPathValue("type", "VersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestVersionType_GetTypeMetadata tests getting type metadata for VersionType.
func TestVersionType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/VersionType", nil)
	req.SetPathValue("name", "VersionType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWarningCategoryEnumType_CRUD tests Create, Read, Update, Delete for WarningCategoryEnumType.
func TestWarningCategoryEnumType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "WarningCategoryEnumType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create WarningCategoryEnumType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestWarningCategoryEnumType_ListByType tests listing elements of type WarningCategoryEnumType.
func TestWarningCategoryEnumType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/WarningCategoryEnumType", nil)
	req.SetPathValue("type", "WarningCategoryEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWarningCategoryEnumType_GetTypeMetadata tests getting type metadata for WarningCategoryEnumType.
func TestWarningCategoryEnumType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WarningCategoryEnumType", nil)
	req.SetPathValue("name", "WarningCategoryEnumType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWarningType_CRUD tests Create, Read, Update, Delete for WarningType.
func TestWarningType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "WarningType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create WarningType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestWarningType_ListByType tests listing elements of type WarningType.
func TestWarningType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/WarningType", nil)
	req.SetPathValue("type", "WarningType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWarningType_GetTypeMetadata tests getting type metadata for WarningType.
func TestWarningType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WarningType", nil)
	req.SetPathValue("name", "WarningType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWebsiteElement_CRUD tests Create, Read, Update, Delete for WebsiteElement.
func TestWebsiteElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "WebsiteElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create WebsiteElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestWebsiteElement_ListByType tests listing elements of type WebsiteElement.
func TestWebsiteElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/WebsiteElement", nil)
	req.SetPathValue("type", "WebsiteElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWebsiteElement_GetTypeMetadata tests getting type metadata for WebsiteElement.
func TestWebsiteElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WebsiteElement", nil)
	req.SetPathValue("name", "WebsiteElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWebsiteElement_GetValidChildTypes tests getting valid child types for WebsiteElement.
func TestWebsiteElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WebsiteElement/children", nil)
	req.SetPathValue("name", "WebsiteElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestWebsiteType_CRUD tests Create, Read, Update, Delete for WebsiteType.
func TestWebsiteType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "WebsiteType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create WebsiteType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestWebsiteType_ListByType tests listing elements of type WebsiteType.
func TestWebsiteType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/WebsiteType", nil)
	req.SetPathValue("type", "WebsiteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWebsiteType_GetTypeMetadata tests getting type metadata for WebsiteType.
func TestWebsiteType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WebsiteType", nil)
	req.SetPathValue("name", "WebsiteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWebsiteType_GetValidChildTypes tests getting valid child types for WebsiteType.
func TestWebsiteType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WebsiteType/children", nil)
	req.SetPathValue("name", "WebsiteType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestWebsiteUrlElement_CRUD tests Create, Read, Update, Delete for WebsiteUrlElement.
func TestWebsiteUrlElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "WebsiteUrlElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create WebsiteUrlElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestWebsiteUrlElement_ListByType tests listing elements of type WebsiteUrlElement.
func TestWebsiteUrlElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/WebsiteUrlElement", nil)
	req.SetPathValue("type", "WebsiteUrlElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWebsiteUrlElement_GetTypeMetadata tests getting type metadata for WebsiteUrlElement.
func TestWebsiteUrlElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WebsiteUrlElement", nil)
	req.SetPathValue("name", "WebsiteUrlElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWebsiteUrlElementType_CRUD tests Create, Read, Update, Delete for WebsiteUrlElementType.
func TestWebsiteUrlElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "WebsiteUrlElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create WebsiteUrlElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestWebsiteUrlElementType_ListByType tests listing elements of type WebsiteUrlElementType.
func TestWebsiteUrlElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/WebsiteUrlElementType", nil)
	req.SetPathValue("type", "WebsiteUrlElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWebsiteUrlElementType_GetTypeMetadata tests getting type metadata for WebsiteUrlElementType.
func TestWebsiteUrlElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WebsiteUrlElementType", nil)
	req.SetPathValue("name", "WebsiteUrlElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWeightType_CRUD tests Create, Read, Update, Delete for WeightType.
func TestWeightType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "WeightType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create WeightType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestWeightType_ListByType tests listing elements of type WeightType.
func TestWeightType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/WeightType", nil)
	req.SetPathValue("type", "WeightType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestWeightType_GetTypeMetadata tests getting type metadata for WeightType.
func TestWeightType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/WeightType", nil)
	req.SetPathValue("name", "WeightType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestX509DataElement_CRUD tests Create, Read, Update, Delete for X509DataElement.
func TestX509DataElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "X509DataElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create X509DataElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestX509DataElement_ListByType tests listing elements of type X509DataElement.
func TestX509DataElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/X509DataElement", nil)
	req.SetPathValue("type", "X509DataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestX509DataElement_GetTypeMetadata tests getting type metadata for X509DataElement.
func TestX509DataElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/X509DataElement", nil)
	req.SetPathValue("name", "X509DataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestX509DataElement_GetValidChildTypes tests getting valid child types for X509DataElement.
func TestX509DataElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/X509DataElement/children", nil)
	req.SetPathValue("name", "X509DataElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestX509DataType_CRUD tests Create, Read, Update, Delete for X509DataType.
func TestX509DataType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "X509DataType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create X509DataType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestX509DataType_ListByType tests listing elements of type X509DataType.
func TestX509DataType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/X509DataType", nil)
	req.SetPathValue("type", "X509DataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestX509DataType_GetTypeMetadata tests getting type metadata for X509DataType.
func TestX509DataType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/X509DataType", nil)
	req.SetPathValue("name", "X509DataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestX509DataType_GetValidChildTypes tests getting valid child types for X509DataType.
func TestX509DataType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/X509DataType/children", nil)
	req.SetPathValue("name", "X509DataType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestX509IssuerSerialType_CRUD tests Create, Read, Update, Delete for X509IssuerSerialType.
func TestX509IssuerSerialType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "X509IssuerSerialType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create X509IssuerSerialType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestX509IssuerSerialType_ListByType tests listing elements of type X509IssuerSerialType.
func TestX509IssuerSerialType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/X509IssuerSerialType", nil)
	req.SetPathValue("type", "X509IssuerSerialType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestX509IssuerSerialType_GetTypeMetadata tests getting type metadata for X509IssuerSerialType.
func TestX509IssuerSerialType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/X509IssuerSerialType", nil)
	req.SetPathValue("name", "X509IssuerSerialType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXALElement_CRUD tests Create, Read, Update, Delete for XALElement.
func TestXALElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "XALElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create XALElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestXALElement_ListByType tests listing elements of type XALElement.
func TestXALElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/XALElement", nil)
	req.SetPathValue("type", "XALElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXALElement_GetTypeMetadata tests getting type metadata for XALElement.
func TestXALElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/XALElement", nil)
	req.SetPathValue("name", "XALElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXALElement_GetValidChildTypes tests getting valid child types for XALElement.
func TestXALElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/XALElement/children", nil)
	req.SetPathValue("name", "XALElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestXALElementType_CRUD tests Create, Read, Update, Delete for XALElementType.
func TestXALElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "XALElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create XALElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestXALElementType_ListByType tests listing elements of type XALElementType.
func TestXALElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/XALElementType", nil)
	req.SetPathValue("type", "XALElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXALElementType_GetTypeMetadata tests getting type metadata for XALElementType.
func TestXALElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/XALElementType", nil)
	req.SetPathValue("name", "XALElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXALElementType_GetValidChildTypes tests getting valid child types for XALElementType.
func TestXALElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/XALElementType/children", nil)
	req.SetPathValue("name", "XALElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestXNLElement_CRUD tests Create, Read, Update, Delete for XNLElement.
func TestXNLElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "XNLElement",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create XNLElement returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestXNLElement_ListByType tests listing elements of type XNLElement.
func TestXNLElement_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/XNLElement", nil)
	req.SetPathValue("type", "XNLElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXNLElement_GetTypeMetadata tests getting type metadata for XNLElement.
func TestXNLElement_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/XNLElement", nil)
	req.SetPathValue("name", "XNLElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXNLElement_GetValidChildTypes tests getting valid child types for XNLElement.
func TestXNLElement_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/XNLElement/children", nil)
	req.SetPathValue("name", "XNLElement")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// TestXNLElementType_CRUD tests Create, Read, Update, Delete for XNLElementType.
func TestXNLElementType_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	createBody := map[string]interface{}{
		"type":       "XNLElementType",
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()

	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code == http.StatusOK {
		var createResp map[string]string
		json.Unmarshal(createRR.Body.Bytes(), &createResp)
		path := createResp["path"]

		if path == "" {
			t.Fatal("Create succeeded but no path returned")
		}

		// READ
		readReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		readRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(readRR, readReq)

		if readRR.Code != http.StatusOK {
			t.Errorf("READ failed: status %d, body: %s", readRR.Code, readRR.Body.String())
		}

		// UPDATE
		updateBody := map[string]interface{}{}
		updateBytes, _ := json.Marshal(updateBody)
		updateReq := httptest.NewRequest("PUT", "/api/elements?path="+path, bytes.NewReader(updateBytes))
		updateReq.Header.Set("Content-Type", "application/json")
		updateRR := httptest.NewRecorder()
		ts.handlers.HandleUpdateElement(updateRR, updateReq)

		if updateRR.Code != http.StatusOK {
			t.Errorf("UPDATE failed: status %d, body: %s", updateRR.Code, updateRR.Body.String())
		}

		// DELETE
		deleteReq := httptest.NewRequest("DELETE", "/api/elements?path="+path, nil)
		deleteRR := httptest.NewRecorder()
		ts.handlers.HandleDeleteElement(deleteRR, deleteReq)

		if deleteRR.Code != http.StatusOK {
			t.Errorf("DELETE failed: status %d, body: %s", deleteRR.Code, deleteRR.Body.String())
		}

		// VERIFY DELETED
		verifyReq := httptest.NewRequest("GET", "/api/elements?path="+path, nil)
		verifyRR := httptest.NewRecorder()
		ts.handlers.HandleGetElement(verifyRR, verifyReq)

		if verifyRR.Code == http.StatusOK {
			t.Error("Element should not exist after delete")
		}
	} else {
		t.Logf("Create XNLElementType returned %d (type may not be creatable): %s",
			createRR.Code, createRR.Body.String())
	}
}

// TestXNLElementType_ListByType tests listing elements of type XNLElementType.
func TestXNLElementType_ListByType(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/elements/type/XNLElementType", nil)
	req.SetPathValue("type", "XNLElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleListElements(rr, req)

	// Should return OK with empty list or list of elements
	if rr.Code != http.StatusOK && rr.Code != http.StatusInternalServerError {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXNLElementType_GetTypeMetadata tests getting type metadata for XNLElementType.
func TestXNLElementType_GetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/XNLElementType", nil)
	req.SetPathValue("name", "XNLElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetType(rr, req)

	if rr.Code != http.StatusOK && rr.Code != http.StatusNotFound {
		t.Errorf("Unexpected status: %d, body: %s", rr.Code, rr.Body.String())
	}
}

// TestXNLElementType_GetValidChildTypes tests getting valid child types for XNLElementType.
func TestXNLElementType_GetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	req := httptest.NewRequest("GET", "/api/types/XNLElementType/children", nil)
	req.SetPathValue("name", "XNLElementType")
	rr := httptest.NewRecorder()

	ts.handlers.HandleGetValidChildTypes(rr, req)

	assertStatusCode(t, rr, http.StatusOK)
}

// =============================================================================
// Benchmark Tests
// =============================================================================

// =============================================================================
// Export Validation Tests - Create, Export, Validate XML
// =============================================================================

// TestExportValidation_RoundTrip creates a document, exports it, and validates the XML.
func TestExportValidation_RoundTrip(t *testing.T) {
	ts := setupTestSuite(t)

	// Get root types to find a valid document root
	rootReq := httptest.NewRequest("GET", "/api/types/root", nil)
	rootRR := httptest.NewRecorder()
	ts.handlers.HandleGetRootTypes(rootRR, rootReq)

	if rootRR.Code != http.StatusOK {
		t.Skipf("Could not get root types: %s", rootRR.Body.String())
	}

	var rootTypes []string
	if err := json.Unmarshal(rootRR.Body.Bytes(), &rootTypes); err != nil {
		t.Fatalf("Failed to parse root types: %v", err)
	}

	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create a root element
	rootType := rootTypes[0]
	createBody := map[string]interface{}{
		"type":       rootType,
		"parentPath": "",
		"data":       map[string]interface{}{},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()
	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code != http.StatusOK {
		t.Fatalf("Failed to create root element %s: %s", rootType, createRR.Body.String())
	}

	// Export the document
	exportReq := httptest.NewRequest("GET", "/api/export", nil)
	exportRR := httptest.NewRecorder()
	ts.handlers.HandleExport(exportRR, exportReq)

	if exportRR.Code != http.StatusOK {
		t.Fatalf("Export failed: status %d, body: %s", exportRR.Code, exportRR.Body.String())
	}

	xmlContent := exportRR.Body.String()

	// Validate XML structure
	if !strings.HasPrefix(xmlContent, "<?xml") {
		t.Error("Export should start with XML declaration")
	}

	if len(xmlContent) < 50 {
		t.Errorf("Export seems too short: %d bytes", len(xmlContent))
	}

	// Check for common XML serialization errors
	if strings.Contains(xmlContent, "StartElement with missing name") {
		t.Error("XML contains serialization error message")
	}

	if strings.Contains(xmlContent, "<>") || strings.Contains(xmlContent, "</>") {
		t.Error("XML contains empty element tags (missing element names)")
	}

	t.Logf("Successfully exported %d bytes of XML for %s", len(xmlContent), rootType)
}

// TestExportValidation_WithData creates an element with data, exports, and validates.
func TestExportValidation_WithData(t *testing.T) {
	ts := setupTestSuite(t)

	// Get root types
	rootReq := httptest.NewRequest("GET", "/api/types/root", nil)
	rootRR := httptest.NewRecorder()
	ts.handlers.HandleGetRootTypes(rootRR, rootReq)

	if rootRR.Code != http.StatusOK {
		t.Skipf("Could not get root types: %s", rootRR.Body.String())
	}

	var rootTypes []string
	if err := json.Unmarshal(rootRR.Body.Bytes(), &rootTypes); err != nil {
		t.Fatalf("Failed to parse root types: %v", err)
	}

	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create root element with some data
	rootType := rootTypes[0]
	createBody := map[string]interface{}{
		"type":       rootType,
		"parentPath": "",
		"data": map[string]interface{}{
			"id": "test-export-validation",
		},
	}
	jsonBytes, _ := json.Marshal(createBody)

	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()
	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code != http.StatusOK {
		t.Fatalf("Failed to create root element: %s", createRR.Body.String())
	}

	// Export
	exportReq := httptest.NewRequest("GET", "/api/export", nil)
	exportRR := httptest.NewRecorder()
	ts.handlers.HandleExport(exportRR, exportReq)

	if exportRR.Code != http.StatusOK {
		t.Fatalf("Export failed: %s", exportRR.Body.String())
	}

	xmlContent := exportRR.Body.String()

	// Verify the ID was included in export
	// Note: Some root types may have id fields that are pointer+type-alias combinations
	// which are skipped in updates due to cross-namespace package resolution issues
	if !strings.Contains(xmlContent, "test-export-validation") {
		t.Log("Note: Exported XML does not contain the test ID - this may be expected if the root type's id field is a complex type")
	}

	t.Logf("Export with data successful: %d bytes", len(xmlContent))
}

// TestExportValidation_ImportExportRoundTrip imports XML and re-exports to verify consistency.
func TestExportValidation_ImportExportRoundTrip(t *testing.T) {
	ts := setupTestSuite(t)

	// First create and export a document
	rootReq := httptest.NewRequest("GET", "/api/types/root", nil)
	rootRR := httptest.NewRecorder()
	ts.handlers.HandleGetRootTypes(rootRR, rootReq)

	if rootRR.Code != http.StatusOK {
		t.Skip("Could not get root types")
	}

	var rootTypes []string
	json.Unmarshal(rootRR.Body.Bytes(), &rootTypes)
	if len(rootTypes) == 0 {
		t.Skip("No root types")
	}

	// Create element
	createBody := map[string]interface{}{
		"type":       rootTypes[0],
		"parentPath": "",
		"data":       map[string]interface{}{"id": "roundtrip-test"},
	}
	jsonBytes, _ := json.Marshal(createBody)
	createReq := httptest.NewRequest("POST", "/api/elements", bytes.NewReader(jsonBytes))
	createReq.Header.Set("Content-Type", "application/json")
	createRR := httptest.NewRecorder()
	ts.handlers.HandleCreateElementAPI(createRR, createReq)

	if createRR.Code != http.StatusOK {
		t.Skip("Could not create element")
	}

	// Export first time
	export1Req := httptest.NewRequest("GET", "/api/export", nil)
	export1RR := httptest.NewRecorder()
	ts.handlers.HandleExport(export1RR, export1Req)

	if export1RR.Code != http.StatusOK {
		t.Fatalf("First export failed: %s", export1RR.Body.String())
	}

	originalXML := export1RR.Body.String()

	// Create new state and import the XML
	ts2 := setupTestSuite(t)

	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)
	part, _ := writer.CreateFormFile("file", "roundtrip.xml")
	part.Write([]byte(originalXML))
	writer.Close()

	importReq := httptest.NewRequest("POST", "/api/import", &buf)
	importReq.Header.Set("Content-Type", writer.FormDataContentType())
	importRR := httptest.NewRecorder()
	ts2.handlers.HandleImport(importRR, importReq)

	if importRR.Code != http.StatusOK {
		t.Logf("Import failed (may be expected for some schemas): %s", importRR.Body.String())
		return
	}

	// Export again
	export2Req := httptest.NewRequest("GET", "/api/export", nil)
	export2RR := httptest.NewRecorder()
	ts2.handlers.HandleExport(export2RR, export2Req)

	if export2RR.Code != http.StatusOK {
		t.Fatalf("Second export failed: %s", export2RR.Body.String())
	}

	reExportedXML := export2RR.Body.String()

	// Both exports should contain the same key data
	// Note: Some root types may have id fields that are pointer+type-alias combinations
	// which are skipped in updates due to cross-namespace package resolution issues
	if !strings.Contains(reExportedXML, "roundtrip-test") {
		t.Log("Note: Re-exported XML does not contain the test ID - this may be expected if the root type's id field is a complex type")
	}

	t.Logf("Round-trip successful: original %d bytes, re-exported %d bytes",
		len(originalXML), len(reExportedXML))
}

// =============================================================================
// Benchmark Tests
// =============================================================================

func BenchmarkHandleHealth(b *testing.B) {
	xmlState := state.NewXMLDocumentState()
	handlers := &Handlers{state: xmlState}

	req := httptest.NewRequest("GET", "/api/health", nil)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rr := httptest.NewRecorder()
		handlers.HandleHealth(rr, req)
	}
}

func BenchmarkHandleListTypes(b *testing.B) {
	xmlState := state.NewXMLDocumentState()
	handlers := &Handlers{state: xmlState}

	req := httptest.NewRequest("GET", "/api/types", nil)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rr := httptest.NewRecorder()
		handlers.HandleListTypes(rr, req)
	}
}

func BenchmarkHandleTreeRoot(b *testing.B) {
	xmlState := state.NewXMLDocumentState()
	handlers := &Handlers{state: xmlState}

	req := httptest.NewRequest("GET", "/api/tree/root", nil)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rr := httptest.NewRecorder()
		handlers.HandleTreeRoot(rr, req)
	}
}
