// Code generated by forgexml UI generator. DO NOT EDIT.
package state

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	asset_identification1_1 "forgexml-scap/internal/generated/gov/nist/scap/schema/asset-identification/1-1"
	asset_reporting_format1_1 "forgexml-scap/internal/generated/gov/nist/scap/schema/asset-reporting-format/1-1"
	reporting_core1_1 "forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1"
	pkg_2_0 "forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xal/2-0"
	pkg_2_01 "forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xnl/2-0"
	pkg_1999xlink "forgexml-scap/internal/generated/org/w3/1999/xlink"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// =============================================================================
// Test Suite Setup
// =============================================================================

// TestSuite holds shared test resources for state tests.
type TestSuite struct {
	state *XMLDocumentState
}

// setupTestSuite creates a fresh XMLDocumentState for testing.
func setupTestSuite(t *testing.T) *TestSuite {
	t.Helper()
	return &TestSuite{
		state: NewXMLDocumentState(),
	}
}

// =============================================================================
// NewXMLDocumentState Tests
// =============================================================================

func TestNewXMLDocumentState(t *testing.T) {
	state := NewXMLDocumentState()

	if state == nil {
		t.Fatal("NewXMLDocumentState returned nil")
	}

	if state.HasDocument() {
		t.Error("New state should not have a document loaded")
	}

	if state.IsDirty() {
		t.Error("New state should not be dirty")
	}

	if state.GetSourceFile() != "" {
		t.Error("New state should have empty source file")
	}
}

// =============================================================================
// LoadFromBytes Tests
// =============================================================================

func TestLoadFromBytes_AssetReportCollectionElement(t *testing.T) {
	ts := setupTestSuite(t)

	// Create a minimal valid XML for AssetReportCollectionElement
	xmlContent := []byte(`<?xml version="1.0" encoding="UTF-8"?>
<asset-report-collection xmlns="http://scap.nist.gov/schema/asset-reporting-format/1.1">
</asset-report-collection>`)

	err := ts.state.LoadFromBytes(xmlContent, "test_asset-report-collection.xml")
	if err != nil {
		t.Logf("LoadFromBytes for AssetReportCollectionElement returned error (may be expected for complex schemas): %v", err)
		return
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after LoadFromBytes")
	}

	if ts.state.GetSourceFile() != "test_asset-report-collection.xml" {
		t.Errorf("Expected source file 'test_asset-report-collection.xml', got '%s'", ts.state.GetSourceFile())
	}
}

func TestLoadFromBytes_InvalidXML(t *testing.T) {
	ts := setupTestSuite(t)

	err := ts.state.LoadFromBytes([]byte("not valid xml"), "invalid.xml")
	if err == nil {
		t.Error("Expected error for invalid XML")
	}
}

func TestLoadFromBytes_UnknownRoot(t *testing.T) {
	ts := setupTestSuite(t)

	xmlContent := []byte(`<?xml version="1.0" encoding="UTF-8"?>
<unknown-element xmlns="http://example.com/unknown">
</unknown-element>`)

	err := ts.state.LoadFromBytes(xmlContent, "unknown.xml")
	if err == nil {
		t.Error("Expected error for unknown root element")
	}
	if err != nil && !strings.Contains(err.Error(), "unknown root element") {
		t.Errorf("Expected 'unknown root element' error, got: %v", err)
	}
}

// =============================================================================
// LoadFromFile Tests
// =============================================================================

func TestLoadFromFile_NonExistent(t *testing.T) {
	ts := setupTestSuite(t)

	err := ts.state.LoadFromFile("/nonexistent/path/to/file.xml")
	if err == nil {
		t.Error("Expected error for non-existent file")
	}
}

func TestLoadFromFile_WithTempFile(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type to test with
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create element and export to get valid XML
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	xmlBytes, _, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Failed to export: %v", err)
	}

	// Write to temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")
	if err := os.WriteFile(tmpFile, xmlBytes, 0644); err != nil {
		t.Fatalf("Failed to write temp file: %v", err)
	}

	// Load from file
	ts2 := setupTestSuite(t)
	err = ts2.state.LoadFromFile(tmpFile)
	if err != nil {
		t.Errorf("LoadFromFile failed: %v", err)
	}

	if !ts2.state.HasDocument() {
		t.Error("State should have document after LoadFromFile")
	}
}

// =============================================================================
// ExportToBytes Tests
// =============================================================================

func TestExportToBytes_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	_, _, err := ts.state.ExportToBytes()
	if err == nil {
		t.Error("Expected error when exporting with no document")
	}
}

func TestExportToBytes_WithDocument(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type to test with
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create a root element
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	xmlBytes, filename, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("ExportToBytes failed: %v", err)
	}

	if len(xmlBytes) == 0 {
		t.Error("Exported bytes should not be empty")
	}

	if filename == "" {
		t.Error("Filename should not be empty")
	}

	// Verify XML header
	if !bytes.HasPrefix(xmlBytes, []byte("<?xml")) {
		t.Error("Exported XML should have XML declaration")
	}
}

func TestExportToBytes_RoundTrip(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type to test with
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create element
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Export
	xmlBytes1, _, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("First export failed: %v", err)
	}

	// Load into new state
	ts2 := setupTestSuite(t)
	err = ts2.state.LoadFromBytes(xmlBytes1, "roundtrip.xml")
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}

	// Export again
	xmlBytes2, _, err := ts2.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Second export failed: %v", err)
	}

	// Both exports should be similar in structure (may differ in whitespace)
	if len(xmlBytes2) == 0 {
		t.Error("Second export should not be empty")
	}

	t.Logf("Round-trip: original %d bytes, re-exported %d bytes", len(xmlBytes1), len(xmlBytes2))
}

// =============================================================================
// GetRootNodes Tests
// =============================================================================

func TestGetRootNodes_Empty(t *testing.T) {
	ts := setupTestSuite(t)

	nodes, err := ts.state.GetRootNodes()
	if err != nil {
		t.Fatalf("GetRootNodes failed: %v", err)
	}

	if len(nodes) != 0 {
		t.Errorf("Expected 0 root nodes for empty state, got %d", len(nodes))
	}
}

func TestGetRootNodes_WithDocument(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type to test with
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create a root element
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	nodes, err := ts.state.GetRootNodes()
	if err != nil {
		t.Fatalf("GetRootNodes failed: %v", err)
	}

	if len(nodes) != 1 {
		t.Errorf("Expected 1 root node, got %d", len(nodes))
	}

	if len(nodes) > 0 {
		if nodes[0].Path != "/" {
			t.Errorf("Root node path should be '/', got '%s'", nodes[0].Path)
		}
		if nodes[0].Type != rootTypes[0] {
			t.Errorf("Root node type should be '%s', got '%s'", rootTypes[0], nodes[0].Type)
		}
	}
}

// =============================================================================
// GetChildNodes Tests
// =============================================================================

func TestGetChildNodes_Empty(t *testing.T) {
	ts := setupTestSuite(t)

	nodes, err := ts.state.GetChildNodes("/")
	if err != nil {
		t.Fatalf("GetChildNodes failed: %v", err)
	}

	if len(nodes) != 0 {
		t.Errorf("Expected 0 child nodes for empty state, got %d", len(nodes))
	}
}

func TestGetChildNodes_InvalidPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Try to get children of non-existent path
	nodes, err := ts.state.GetChildNodes("/nonexistent")
	// Should not error, just return empty
	if err != nil {
		t.Logf("GetChildNodes for invalid path returned error: %v", err)
	}

	// Should return empty array
	if len(nodes) != 0 {
		t.Logf("GetChildNodes for invalid path returned %d nodes (may be expected)", len(nodes))
	}
}

// =============================================================================
// GetElement Tests
// =============================================================================

func TestGetElement_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	_, err := ts.state.GetElement("/")
	if err == nil {
		t.Error("Expected error when getting element with no document")
	}
}

func TestGetElement_Root(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	details, err := ts.state.GetElement("/")
	if err != nil {
		t.Fatalf("GetElement failed: %v", err)
	}

	if details == nil {
		t.Fatal("GetElement returned nil details")
	}

	if details.Path != "/" {
		t.Errorf("Expected path '/', got '%s'", details.Path)
	}

	if details.Type != rootTypes[0] {
		t.Errorf("Expected type '%s', got '%s'", rootTypes[0], details.Type)
	}
}

// =============================================================================
// CreateElement Tests
// =============================================================================

func TestCreateElement_UnknownType(t *testing.T) {
	ts := setupTestSuite(t)

	_, err := ts.state.CreateElement("UnknownType", "", nil)
	if err == nil {
		t.Error("Expected error for unknown type")
	}
}

func TestCreateElement_ActuateType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ActuateType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ActuateType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressDetails(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressDetails", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressDetails returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressDetailsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressDetailsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressDetailsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressIdentifierElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressIdentifierElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressIdentifierElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLatitudeDirectionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLatitudeDirectionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLatitudeDirectionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLatitudeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLatitudeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLatitudeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLineElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLineElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLineElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLineElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLineElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLineElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLinesType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLinesType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLinesType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLongitudeDirectionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLongitudeDirectionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLongitudeDirectionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLongitudeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLongitudeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLongitudeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddresseeIndicatorElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddresseeIndicatorElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddresseeIndicatorElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AdministrativeAreaElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AdministrativeAreaElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AdministrativeAreaElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AdministrativeAreaElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AdministrativeAreaElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AdministrativeAreaElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AdministrativeAreaNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AdministrativeAreaNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AdministrativeAreaNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AliasElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AliasElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AliasElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ArcElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ArcElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ArcElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ArcType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ArcType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ArcType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ArcroleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ArcroleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ArcroleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetIdentificationType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetIdentificationType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetIdentificationType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetRelatedElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetRelatedElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetRelatedElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetReportCollectionElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetReportCollectionElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetReportCollectionElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetReportCollectionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetReportCollectionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetReportCollectionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetsType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetsType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetsType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BarcodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BarcodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BarcodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BirthdateElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BirthdateElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BirthdateElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BuildingNameType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BuildingNameType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BuildingNameType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CidrElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CidrElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CidrElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CidrType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CidrType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CidrType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CircuitElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CircuitElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CircuitElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CircuitNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CircuitNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CircuitNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CircuitType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CircuitType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CircuitType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ComputingDeviceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ComputingDeviceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ComputingDeviceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ComputingDeviceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ComputingDeviceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ComputingDeviceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ConnectionsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ConnectionsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ConnectionsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ContentElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ContentElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ContentElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ContentElementType1(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ContentElementType1", "", nil)
	if err != nil {
		t.Logf("CreateElement for ContentElementType1 returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountryElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountryElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountryElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountryNameCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountryNameCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountryNameCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountryNameElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountryNameElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountryNameElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountryNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountryNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountryNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CpeElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CpeElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CpeElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CpeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CpeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CpeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CpeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CpeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CpeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DataElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DataElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DataElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DataType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DataType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DataType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DatabaseElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DatabaseElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DatabaseElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DatabaseType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DatabaseType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DatabaseType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DepartmentElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DepartmentElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DepartmentElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DepartmentElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DepartmentElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DepartmentElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DepartmentNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DepartmentNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DepartmentNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependencyNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependencyNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependencyNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependentLocalityNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependentLocalityNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependentLocalityNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependentLocalityNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependentLocalityNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependentLocalityNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependentLocalityType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependentLocalityType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependentLocalityType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependentThoroughfareElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependentThoroughfareElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependentThoroughfareElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DistinguishedNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DistinguishedNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DistinguishedNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DocumentRootElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DocumentRootElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DocumentRootElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EmailAddressElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EmailAddressElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for EmailAddressElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EmailAddressElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EmailAddressElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EmailAddressElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EndorsementLineCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EndorsementLineCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EndorsementLineCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Extended(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Extended", "", nil)
	if err != nil {
		t.Logf("CreateElement for Extended returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ExtendedInfoElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ExtendedInfoElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ExtendedInfoElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ExtendedInformationElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ExtendedInformationElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ExtendedInformationElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ExtendedInfosElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ExtendedInfosElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ExtendedInfosElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FirmNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FirmNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FirmNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FirmType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FirmType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FirmType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FirstNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FirstNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FirstNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FormerNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FormerNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FormerNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FqdnElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FqdnElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for FqdnElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FqdnElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FqdnElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FqdnElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FromType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FromType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FromType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Function(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Function", "", nil)
	if err != nil {
		t.Logf("CreateElement for Function returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FunctionElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FunctionElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for FunctionElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GeneralSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GeneralSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for GeneralSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GenerationIdentifierElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GenerationIdentifierElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for GenerationIdentifierElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HostElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HostElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HostElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HostnameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HostnameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HostnameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HostnameType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HostnameType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HostnameType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HrefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HrefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HrefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_InstallationIdElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("InstallationIdElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for InstallationIdElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_InstanceNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("InstanceNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for InstanceNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpAddressElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpAddressElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpAddressElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpAddressType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpAddressType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpAddressType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpNetRangeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpNetRangeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpNetRangeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpV4ElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpV4ElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpV4ElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpV6ElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpV6ElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpV6ElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Ipv4Type(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Ipv4Type", "", nil)
	if err != nil {
		t.Logf("CreateElement for Ipv4Type returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Ipv6Type(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Ipv6Type", "", nil)
	if err != nil {
		t.Logf("CreateElement for Ipv6Type returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ItAssetElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ItAssetElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ItAssetElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_JointPersonNameElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("JointPersonNameElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for JointPersonNameElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_JointPersonNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("JointPersonNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for JointPersonNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KeyLineCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KeyLineCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for KeyLineCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KnownAsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KnownAsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for KnownAsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LabelType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LabelType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LabelType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LargeMailUserIdentifierElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LargeMailUserIdentifierElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LargeMailUserIdentifierElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LargeMailUserNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LargeMailUserNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LargeMailUserNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LargeMailUserType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LargeMailUserType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LargeMailUserType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LastNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LastNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LastNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LicenseElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LicenseElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LicenseElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocaleElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocaleElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocaleElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocaleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocaleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocaleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocalityElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocalityElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocalityElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocalityElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocalityElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocalityElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocalityNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocalityNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocalityNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationAddressElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationAddressElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationAddressElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationPointElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationPointElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationPointElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationPointElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationPointElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationPointElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationRegionElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationRegionElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationRegionElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationRegionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationRegionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationRegionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocatorElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocatorElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocatorElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocatorType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocatorType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocatorType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MacAddressElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MacAddressElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MacAddressElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MacAddressType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MacAddressType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MacAddressType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MailStopNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MailStopNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MailStopNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MailStopNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MailStopNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MailStopNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MailStopType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MailStopType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MailStopType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MiddleNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MiddleNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MiddleNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MotherboardGuidElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MotherboardGuidElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MotherboardGuidElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NameDetails(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NameDetails", "", nil)
	if err != nil {
		t.Logf("CreateElement for NameDetails returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NameDetailsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NameDetailsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for NameDetailsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NameDetailsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NameDetailsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NameDetailsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NameLineType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NameLineType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NameLineType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NamePrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NamePrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NamePrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NetworkElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NetworkElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for NetworkElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NetworkInterfaceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NetworkInterfaceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NetworkInterfaceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NetworkNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NetworkNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NetworkNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NetworkType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NetworkType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NetworkType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectRefElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectRefElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectRefElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectRefElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectRefElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectRefElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationFormerNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationFormerNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationFormerNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationKnownAsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationKnownAsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationKnownAsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationNameDetails(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationNameDetails", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationNameDetails returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationNameDetailsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationNameDetailsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationNameDetailsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationNameDetailsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationNameDetailsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationNameDetailsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationTypeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationTypeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationTypeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganizationElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganizationElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganizationElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganizationType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganizationType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganizationType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OtherNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OtherNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OtherNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonName(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonName", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonName returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonNameElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonNameElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonNameElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PortElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PortElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PortElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PortRangeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PortRangeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PortRangeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PortType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PortType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PortType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxNumberExtensionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxNumberExtensionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxNumberExtensionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxNumberPrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxNumberPrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxNumberPrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxNumberSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxNumberSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxNumberSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostOfficeElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostOfficeElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostOfficeElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostOfficeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostOfficeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostOfficeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostOfficeNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostOfficeNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostOfficeNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostOfficeNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostOfficeNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostOfficeNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostTownElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostTownElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostTownElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostTownNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostTownNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostTownNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostTownSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostTownSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostTownSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalCodeElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalCodeElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalCodeElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalCodeNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalCodeNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalCodeNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalCodeNumberExtensionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalCodeNumberExtensionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalCodeNumberExtensionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalRouteNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalRouteNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalRouteNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalRouteNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalRouteNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalRouteNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalRouteType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalRouteType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalRouteType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalServiceElementsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalServiceElementsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalServiceElementsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PrecedingTitleElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PrecedingTitleElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PrecedingTitleElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseLocationElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseLocationElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseLocationElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberPrefixElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberPrefixElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberPrefixElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberPrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberPrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberPrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberRangeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberRangeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberRangeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberRangeFromElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberRangeFromElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberRangeFromElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberRangeToElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberRangeToElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberRangeToElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberSuffixElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberSuffixElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberSuffixElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProtocolElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProtocolElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProtocolElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RelationshipType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RelationshipType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RelationshipType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RelationshipsContainerType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RelationshipsContainerType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RelationshipsContainerType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RelationshipsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RelationshipsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RelationshipsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RemoteResourceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RemoteResourceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for RemoteResourceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RemoteResourceElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RemoteResourceElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RemoteResourceElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReportRequestType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReportRequestType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReportRequestType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReportRequestsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReportRequestsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReportRequestsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReportType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReportType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReportType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReportsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReportsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReportsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ResourceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ResourceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ResourceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ResourceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ResourceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ResourceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RoleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RoleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RoleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ServedByElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ServedByElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ServedByElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ServiceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ServiceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ServiceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ServiceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ServiceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ServiceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ShowType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ShowType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ShowType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Simple(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Simple", "", nil)
	if err != nil {
		t.Logf("CreateElement for Simple returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SoftwareElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SoftwareElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SoftwareElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SoftwareType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SoftwareType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SoftwareType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SortingCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SortingCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SortingCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubAdministrativeAreaElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubAdministrativeAreaElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubAdministrativeAreaElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubAdministrativeAreaNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubAdministrativeAreaNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubAdministrativeAreaNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseLocationElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseLocationElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseLocationElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseNumberPrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseNumberPrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseNumberPrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseNumberSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseNumberSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseNumberSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SupplementaryPostalServiceDataElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SupplementaryPostalServiceDataElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SupplementaryPostalServiceDataElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SyntheticIdElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SyntheticIdElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SyntheticIdElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SyntheticIdElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SyntheticIdElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SyntheticIdElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SystemElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SystemElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SystemElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SystemNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SystemNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SystemNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SystemType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SystemType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SystemType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TelephoneNumberElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TelephoneNumberElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TelephoneNumberElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TelephoneNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TelephoneNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TelephoneNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TelephoneNumberType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TelephoneNumberType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TelephoneNumberType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareLeadingTypeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareLeadingTypeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareLeadingTypeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNameType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNameType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNameType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberFromElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberFromElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberFromElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberPrefixElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberPrefixElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberPrefixElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberPrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberPrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberPrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberRangeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberRangeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberRangeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberSuffixElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberSuffixElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberSuffixElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberToElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberToElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberToElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfarePostDirectionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfarePostDirectionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfarePostDirectionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfarePreDirectionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfarePreDirectionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfarePreDirectionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareTrailingTypeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareTrailingTypeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareTrailingTypeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TitleAttrType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TitleAttrType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TitleAttrType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TitleElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TitleElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TitleElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TitleElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TitleElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TitleElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TitleEltType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TitleEltType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TitleEltType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ToType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ToType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ToType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TypeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TypeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TypeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_UrlElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("UrlElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for UrlElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_VersionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("VersionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for VersionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WebsiteElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WebsiteElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for WebsiteElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WebsiteType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WebsiteType", "", nil)
	if err != nil {
		t.Logf("CreateElement for WebsiteType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WebsiteUrlElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WebsiteUrlElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for WebsiteUrlElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WebsiteUrlElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WebsiteUrlElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for WebsiteUrlElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_XALElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("XALElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for XALElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_XALElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("XALElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for XALElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_XNLElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("XNLElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for XNLElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_XNLElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("XNLElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for XNLElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WithData(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types
	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Skip("No types available")
	}

	// Try to create with some data
	data := json.RawMessage(`{"id": "test-id"}`)
	path, err := ts.state.CreateElement(types[0], "", data)
	if err != nil {
		t.Logf("CreateElement with data returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}
}

// =============================================================================
// UpdateElement Tests
// =============================================================================

func TestUpdateElement_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	err := ts.state.UpdateElement("/", json.RawMessage(`{}`))
	if err == nil {
		t.Error("Expected error when updating with no document")
	}
}

func TestUpdateElement_Root(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Update root element
	updateData := json.RawMessage(`{"id": "updated-id"}`)
	err = ts.state.UpdateElement("/", updateData)
	if err != nil {
		t.Logf("UpdateElement returned error (may be expected): %v", err)
	}

	// State should be dirty after update attempt
	if !ts.state.IsDirty() {
		t.Error("State should be dirty after update")
	}
}

func TestUpdateElement_InvalidJSON(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Try to update with invalid JSON
	err = ts.state.UpdateElement("/", json.RawMessage(`invalid json`))
	if err == nil {
		t.Error("Expected error for invalid JSON")
	}
}

// =============================================================================
// DeleteElement Tests
// =============================================================================

func TestDeleteElement_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	err := ts.state.DeleteElement("/")
	if err == nil {
		t.Error("Expected error when deleting with no document")
	}
}

func TestDeleteElement_Root(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Delete root (clears document)
	err = ts.state.DeleteElement("/")
	if err != nil {
		t.Fatalf("DeleteElement failed: %v", err)
	}

	if ts.state.HasDocument() {
		t.Error("State should not have document after deleting root")
	}
}

func TestDeleteElement_InvalidPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Try to delete non-existent element
	err = ts.state.DeleteElement("/nonexistent")
	if err == nil {
		t.Log("DeleteElement for non-existent path succeeded (may be expected)")
	}
}

// =============================================================================
// Validate Tests
// =============================================================================

func TestValidate_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	errors, err := ts.state.Validate()
	if err != nil {
		t.Fatalf("Validate failed: %v", err)
	}

	// Should have at least one error for no document
	if len(errors) == 0 {
		t.Error("Expected validation error for no document")
	}

	// Check error message
	if len(errors) > 0 && !strings.Contains(errors[0].Message, "No document") {
		t.Errorf("Expected 'No document' error, got: %s", errors[0].Message)
	}
}

func TestValidate_WithDocument(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	errors, err := ts.state.Validate()
	if err != nil {
		t.Fatalf("Validate failed: %v", err)
	}

	// Log validation errors (may have some for empty required fields)
	t.Logf("Validation returned %d errors", len(errors))
	for i, ve := range errors {
		if i < 5 { // Only log first 5
			t.Logf("  Error %d: %s - %s", i, ve.Path, ve.Message)
		}
	}
}

// =============================================================================
// Type Information Tests
// =============================================================================

func TestGetAvailableTypes(t *testing.T) {
	ts := setupTestSuite(t)

	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Error("GetAvailableTypes should return at least one type")
	}

	t.Logf("Available types: %d", len(types))
}

func TestGetRootElementTypes(t *testing.T) {
	ts := setupTestSuite(t)

	types := ts.state.GetRootElementTypes()
	// Root types may be empty if no root elements are configured
	t.Logf("Root element types: %d", len(types))
}

func TestGetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types and check child types
	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Skip("No types available")
	}

	childTypes := ts.state.GetValidChildTypes(types[0])
	t.Logf("Valid child types for %s: %d", types[0], len(childTypes))
}

func TestGetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types and check metadata
	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Skip("No types available")
	}

	metadata, err := ts.state.GetTypeMetadata(types[0])
	if err != nil {
		t.Fatalf("GetTypeMetadata failed: %v", err)
	}

	if metadata == nil {
		t.Fatal("GetTypeMetadata returned nil")
	}

	if metadata.Name != types[0] {
		t.Errorf("Expected name '%s', got '%s'", types[0], metadata.Name)
	}

	t.Logf("Type %s has %d fields", metadata.Name, len(metadata.Fields))
}

func TestGetTypeMetadata_Unknown(t *testing.T) {
	ts := setupTestSuite(t)

	_, err := ts.state.GetTypeMetadata("UnknownType")
	if err == nil {
		t.Error("Expected error for unknown type")
	}
}

func TestGetConcreteTypes(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types and check concrete types
	types := ts.state.GetAvailableTypes()
	for _, typeName := range types {
		concretes, err := ts.state.GetConcreteTypes(typeName)
		if err != nil {
			t.Logf("GetConcreteTypes for %s returned error: %v", typeName, err)
			continue
		}
		if len(concretes) > 0 {
			t.Logf("Abstract type %s has %d concrete types", typeName, len(concretes))
		}
	}
}

// =============================================================================
// State Management Tests
// =============================================================================

func TestIsDirty(t *testing.T) {
	ts := setupTestSuite(t)

	if ts.state.IsDirty() {
		t.Error("New state should not be dirty")
	}

	// Create element to make dirty
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after creating element")
	}
}

func TestMarkClean(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element to make dirty
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after creating element")
	}

	ts.state.MarkClean()

	if ts.state.IsDirty() {
		t.Error("State should not be dirty after MarkClean")
	}
}

func TestClear(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document")
	}

	ts.state.Clear()

	if ts.state.HasDocument() {
		t.Error("State should not have document after Clear")
	}

	if ts.state.IsDirty() {
		t.Error("State should not be dirty after Clear")
	}

	if ts.state.GetSourceFile() != "" {
		t.Error("Source file should be empty after Clear")
	}
}

func TestHasDocument(t *testing.T) {
	ts := setupTestSuite(t)

	if ts.state.HasDocument() {
		t.Error("New state should not have document")
	}

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after creating element")
	}
}

func TestGetLastModified(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element to set lastModified
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	lastMod := ts.state.GetLastModified()
	if lastMod.IsZero() {
		t.Error("Last modified should not be zero after creating element")
	}
}

// =============================================================================
// GenerateInstanceDiagram Tests
// =============================================================================

func TestGenerateInstanceDiagram_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	_, err := ts.state.GenerateInstanceDiagram("flowchart")
	if err == nil {
		t.Error("Expected error when generating diagram with no document")
	}
}

func TestGenerateInstanceDiagram_Flowchart(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	diagram, err := ts.state.GenerateInstanceDiagram("flowchart")
	if err != nil {
		t.Fatalf("GenerateInstanceDiagram failed: %v", err)
	}

	if !strings.HasPrefix(diagram, "flowchart TD") {
		t.Error("Flowchart should start with 'flowchart TD'")
	}

	t.Logf("Flowchart diagram: %d bytes", len(diagram))
}

func TestGenerateInstanceDiagram_Mindmap(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	diagram, err := ts.state.GenerateInstanceDiagram("mindmap")
	if err != nil {
		t.Fatalf("GenerateInstanceDiagram failed: %v", err)
	}

	if !strings.HasPrefix(diagram, "mindmap") {
		t.Error("Mindmap should start with 'mindmap'")
	}

	t.Logf("Mindmap diagram: %d bytes", len(diagram))
}

func TestGenerateInstanceDiagram_Tree(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	diagram, err := ts.state.GenerateInstanceDiagram("tree")
	if err != nil {
		t.Fatalf("GenerateInstanceDiagram failed: %v", err)
	}

	if !strings.HasPrefix(diagram, "graph TD") {
		t.Error("Tree diagram should start with 'graph TD'")
	}

	t.Logf("Tree diagram: %d bytes", len(diagram))
}

// =============================================================================
// Helper Function Tests
// =============================================================================

func TestSplitPath(t *testing.T) {
	tests := []struct {
		input    string
		expected []string
	}{
		{"", nil},
		{"/", nil},
		{"/root", []string{"root"}},
		{"/parent/child", []string{"parent", "child"}},
		{"/a/b/c", []string{"a", "b", "c"}},
		{"no-leading-slash", []string{"no-leading-slash"}},
	}

	for _, tc := range tests {
		result := splitPath(tc.input)
		if len(result) != len(tc.expected) {
			t.Errorf("splitPath(%q) = %v, expected %v", tc.input, result, tc.expected)
			continue
		}
		for i := range result {
			if result[i] != tc.expected[i] {
				t.Errorf("splitPath(%q)[%d] = %q, expected %q", tc.input, i, result[i], tc.expected[i])
			}
		}
	}
}

func TestEscapeLabel(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"simple", "simple"},
		{`with "quotes"`, `with 'quotes'`},
		{"with [brackets]", "with brackets"},
		{"with {braces}", "with braces"},
	}

	for _, tc := range tests {
		result := escapeLabel(tc.input)
		if result != tc.expected {
			t.Errorf("escapeLabel(%q) = %q, expected %q", tc.input, result, tc.expected)
		}
	}
}

func TestTruncateString(t *testing.T) {
	tests := []struct {
		input    string
		maxLen   int
		expected string
	}{
		{"short", 10, "short"},
		{"exactly10c", 10, "exactly10c"},
		{"this is a long string", 10, "this is..."},
		{"", 5, ""},
	}

	for _, tc := range tests {
		result := truncateString(tc.input, tc.maxLen)
		if result != tc.expected {
			t.Errorf("truncateString(%q, %d) = %q, expected %q", tc.input, tc.maxLen, result, tc.expected)
		}
	}
}

// =============================================================================
// Benchmark Tests
// =============================================================================

func BenchmarkNewXMLDocumentState(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = NewXMLDocumentState()
	}
}

func BenchmarkGetAvailableTypes(b *testing.B) {
	state := NewXMLDocumentState()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = state.GetAvailableTypes()
	}
}

func BenchmarkGetRootElementTypes(b *testing.B) {
	state := NewXMLDocumentState()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = state.GetRootElementTypes()
	}
}

// =============================================================================
// Concurrent Access Tests
// =============================================================================

func TestConcurrentAccess(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element first
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Run concurrent reads
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func() {
			for j := 0; j < 100; j++ {
				ts.state.HasDocument()
				ts.state.IsDirty()
				ts.state.GetRootNodes()
			}
			done <- true
		}()
	}

	// Wait for all goroutines
	for i := 0; i < 10; i++ {
		<-done
	}
}

// =============================================================================
// Type-Specific CRUD Tests
// =============================================================================

// TestAssetReportCollectionElement_CRUD tests full CRUD lifecycle for AssetReportCollectionElement.
func TestAssetReportCollectionElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	path, err := ts.state.CreateElement("AssetReportCollectionElement", "", nil)
	if err != nil {
		t.Logf("Create AssetReportCollectionElement returned error (may be expected): %v", err)
		return
	}

	if path != "/" {
		t.Errorf("Expected root path '/', got '%s'", path)
	}

	// READ
	details, err := ts.state.GetElement("/")
	if err != nil {
		t.Fatalf("GetElement failed: %v", err)
	}

	if details.Type != "AssetReportCollectionElement" {
		t.Errorf("Expected type 'AssetReportCollectionElement', got '%s'", details.Type)
	}

	// UPDATE (with empty data, just to test the path)
	err = ts.state.UpdateElement("/", json.RawMessage(`{}`))
	if err != nil {
		t.Logf("Update returned error (may be expected): %v", err)
	}

	// VALIDATE
	errors, err := ts.state.Validate()
	if err != nil {
		t.Fatalf("Validate failed: %v", err)
	}
	t.Logf("Validation for AssetReportCollectionElement: %d errors", len(errors))

	// EXPORT
	xmlBytes, filename, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Export failed: %v", err)
	}
	t.Logf("Exported AssetReportCollectionElement: %d bytes, filename: %s", len(xmlBytes), filename)

	// DELETE
	err = ts.state.DeleteElement("/")
	if err != nil {
		t.Fatalf("Delete failed: %v", err)
	}

	if ts.state.HasDocument() {
		t.Error("Document should be cleared after delete")
	}
}

// TestAssetReportCollectionElement_ExportRoundTrip tests export and re-import for AssetReportCollectionElement.
func TestAssetReportCollectionElement_ExportRoundTrip(t *testing.T) {
	ts := setupTestSuite(t)

	// Create
	_, err := ts.state.CreateElement("AssetReportCollectionElement", "", nil)
	if err != nil {
		t.Skipf("Create AssetReportCollectionElement returned error: %v", err)
	}

	// Export
	xmlBytes, _, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Export failed: %v", err)
	}

	// Re-import into new state
	ts2 := setupTestSuite(t)
	err = ts2.state.LoadFromBytes(xmlBytes, "roundtrip.xml")
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}

	// Verify
	if !ts2.state.HasDocument() {
		t.Error("State should have document after round-trip")
	}

	// Export again
	xmlBytes2, _, err := ts2.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Second export failed: %v", err)
	}

	t.Logf("Round-trip for AssetReportCollectionElement: %d -> %d bytes", len(xmlBytes), len(xmlBytes2))
}

// =============================================================================
// XML Marshal/Unmarshal Tests for Generated Types
// =============================================================================

func TestMarshalUnmarshal_ActuateType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ActuateType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ActuateType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ActuateType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ActuateType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressDetails(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressDetails

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressDetails returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressDetails
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressDetails: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressDetailsElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressDetailsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressDetailsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressDetailsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressDetailsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressIdentifierElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressIdentifierElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressIdentifierElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressIdentifierElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressIdentifierElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLatitudeDirectionElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLatitudeDirectionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLatitudeDirectionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLatitudeDirectionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLatitudeDirectionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLatitudeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLatitudeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLatitudeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLatitudeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLatitudeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLineElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLineElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLineElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLineElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLineElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLineElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLineElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLineElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLineElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLineElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLinesType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLinesType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLinesType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLinesType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLinesType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLongitudeDirectionElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLongitudeDirectionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLongitudeDirectionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLongitudeDirectionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLongitudeDirectionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLongitudeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLongitudeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLongitudeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLongitudeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLongitudeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddresseeIndicatorElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.AddresseeIndicatorElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddresseeIndicatorElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.AddresseeIndicatorElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddresseeIndicatorElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AdministrativeAreaElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AdministrativeAreaElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AdministrativeAreaElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AdministrativeAreaElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AdministrativeAreaElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AdministrativeAreaElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AdministrativeAreaElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AdministrativeAreaElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AdministrativeAreaElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AdministrativeAreaElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AdministrativeAreaNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AdministrativeAreaNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AdministrativeAreaNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AdministrativeAreaNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AdministrativeAreaNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AliasElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.AliasElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AliasElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.AliasElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AliasElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ArcElement(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ArcElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ArcElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ArcElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ArcElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ArcType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ArcType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ArcType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ArcType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ArcType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ArcroleType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ArcroleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ArcroleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ArcroleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ArcroleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetIdentificationType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetIdentificationType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetIdentificationType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetIdentificationType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetIdentificationType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetRelatedElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetRelatedElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetRelatedElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetRelatedElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetRelatedElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetReportCollectionElement(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.AssetReportCollectionElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetReportCollectionElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.AssetReportCollectionElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetReportCollectionElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetReportCollectionElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.AssetReportCollectionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetReportCollectionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.AssetReportCollectionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetReportCollectionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetsElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.AssetsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.AssetsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetsType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetsType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetsType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetsType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetsType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BarcodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.BarcodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BarcodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.BarcodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BarcodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BirthdateElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.BirthdateElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BirthdateElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.BirthdateElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BirthdateElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BuildingNameType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.BuildingNameType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BuildingNameType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.BuildingNameType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BuildingNameType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CidrElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CidrElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CidrElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CidrElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CidrElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CidrType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CidrType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CidrType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CidrType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CidrType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CircuitElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CircuitElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CircuitElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CircuitElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CircuitElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CircuitNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CircuitNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CircuitNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CircuitNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CircuitNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CircuitType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CircuitType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CircuitType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CircuitType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CircuitType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ComputingDeviceElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ComputingDeviceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ComputingDeviceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ComputingDeviceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ComputingDeviceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ComputingDeviceType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ComputingDeviceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ComputingDeviceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ComputingDeviceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ComputingDeviceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ConnectionsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ConnectionsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ConnectionsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ConnectionsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ConnectionsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ContentElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ContentElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ContentElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ContentElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ContentElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ContentElementType1(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ContentElementType1

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ContentElementType1 returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ContentElementType1
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ContentElementType1: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountryElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.CountryElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountryElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.CountryElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountryElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountryNameCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.CountryNameCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountryNameCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.CountryNameCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountryNameCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountryNameElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.CountryNameElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountryNameElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.CountryNameElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountryNameElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountryNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.CountryNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountryNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.CountryNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountryNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CpeElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CpeElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CpeElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CpeElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CpeElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CpeElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CpeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CpeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CpeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CpeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CpeType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CpeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CpeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CpeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CpeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DataElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DataElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DataElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DataElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DataElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DataType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DataType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DataType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DataType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DataType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DatabaseElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DatabaseElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DatabaseElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DatabaseElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DatabaseElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DatabaseType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DatabaseType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DatabaseType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DatabaseType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DatabaseType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DepartmentElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DepartmentElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DepartmentElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DepartmentElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DepartmentElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DepartmentElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DepartmentElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DepartmentElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DepartmentElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DepartmentElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DepartmentNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DepartmentNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DepartmentNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DepartmentNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DepartmentNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependencyNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.DependencyNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependencyNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.DependencyNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependencyNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependentLocalityNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DependentLocalityNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependentLocalityNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DependentLocalityNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependentLocalityNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependentLocalityNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DependentLocalityNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependentLocalityNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DependentLocalityNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependentLocalityNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependentLocalityType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DependentLocalityType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependentLocalityType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DependentLocalityType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependentLocalityType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependentThoroughfareElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DependentThoroughfareElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependentThoroughfareElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DependentThoroughfareElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependentThoroughfareElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DistinguishedNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DistinguishedNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DistinguishedNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DistinguishedNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DistinguishedNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DocumentRootElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DocumentRootElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DocumentRootElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DocumentRootElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DocumentRootElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EmailAddressElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.EmailAddressElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EmailAddressElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.EmailAddressElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EmailAddressElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EmailAddressElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.EmailAddressElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EmailAddressElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.EmailAddressElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EmailAddressElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EndorsementLineCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.EndorsementLineCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EndorsementLineCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.EndorsementLineCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EndorsementLineCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Extended(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.Extended

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Extended returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.Extended
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Extended: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ExtendedInfoElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ExtendedInfoElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ExtendedInfoElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ExtendedInfoElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ExtendedInfoElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ExtendedInformationElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ExtendedInformationElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ExtendedInformationElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ExtendedInformationElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ExtendedInformationElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ExtendedInfosElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ExtendedInfosElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ExtendedInfosElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ExtendedInfosElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ExtendedInfosElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FirmNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.FirmNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FirmNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.FirmNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FirmNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FirmType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.FirmType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FirmType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.FirmType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FirmType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FirstNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.FirstNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FirstNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.FirstNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FirstNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FormerNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.FormerNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FormerNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.FormerNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FormerNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FqdnElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.FqdnElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FqdnElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.FqdnElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FqdnElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FqdnElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.FqdnElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FqdnElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.FqdnElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FqdnElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FromType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.FromType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FromType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.FromType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FromType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Function(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.Function

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Function returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.Function
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Function: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FunctionElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.FunctionElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FunctionElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.FunctionElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FunctionElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GeneralSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.GeneralSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GeneralSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.GeneralSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GeneralSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GenerationIdentifierElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.GenerationIdentifierElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GenerationIdentifierElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.GenerationIdentifierElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GenerationIdentifierElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HostElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.HostElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HostElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.HostElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HostElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HostnameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.HostnameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HostnameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.HostnameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HostnameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HostnameType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.HostnameType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HostnameType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.HostnameType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HostnameType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HrefType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.HrefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HrefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.HrefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HrefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_InstallationIdElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.InstallationIdElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal InstallationIdElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.InstallationIdElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal InstallationIdElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_InstanceNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.InstanceNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal InstanceNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.InstanceNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal InstanceNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpAddressElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpAddressElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpAddressElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpAddressElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpAddressElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpAddressType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpAddressType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpAddressType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpAddressType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpAddressType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpNetRangeElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpNetRangeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpNetRangeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpNetRangeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpNetRangeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpV4ElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpV4ElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpV4ElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpV4ElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpV4ElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpV6ElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpV6ElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpV6ElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpV6ElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpV6ElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Ipv4Type(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.Ipv4Type

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Ipv4Type returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.Ipv4Type
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Ipv4Type: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Ipv6Type(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.Ipv6Type

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Ipv6Type returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.Ipv6Type
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Ipv6Type: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ItAssetElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ItAssetElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ItAssetElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ItAssetElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ItAssetElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_JointPersonNameElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.JointPersonNameElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal JointPersonNameElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.JointPersonNameElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal JointPersonNameElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_JointPersonNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.JointPersonNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal JointPersonNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.JointPersonNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal JointPersonNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KeyLineCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.KeyLineCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KeyLineCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.KeyLineCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KeyLineCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KnownAsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.KnownAsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KnownAsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.KnownAsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KnownAsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LabelType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.LabelType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LabelType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.LabelType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LabelType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LargeMailUserIdentifierElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LargeMailUserIdentifierElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LargeMailUserIdentifierElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LargeMailUserIdentifierElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LargeMailUserIdentifierElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LargeMailUserNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LargeMailUserNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LargeMailUserNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LargeMailUserNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LargeMailUserNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LargeMailUserType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LargeMailUserType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LargeMailUserType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LargeMailUserType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LargeMailUserType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LastNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.LastNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LastNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.LastNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LastNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LicenseElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LicenseElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LicenseElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LicenseElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LicenseElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocaleElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocaleElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocaleElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocaleElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocaleElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocaleType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocaleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocaleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocaleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocaleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocalityElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LocalityElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocalityElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LocalityElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocalityElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocalityElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LocalityElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocalityElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LocalityElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocalityElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocalityNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LocalityNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocalityNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LocalityNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocalityNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationAddressElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationAddressElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationAddressElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationAddressElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationAddressElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationPointElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationPointElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationPointElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationPointElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationPointElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationPointElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationPointElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationPointElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationPointElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationPointElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationRegionElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationRegionElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationRegionElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationRegionElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationRegionElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationRegionElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationRegionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationRegionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationRegionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationRegionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationsElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocatorElement(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.LocatorElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocatorElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.LocatorElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocatorElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocatorType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.LocatorType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocatorType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.LocatorType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocatorType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MacAddressElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.MacAddressElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MacAddressElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.MacAddressElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MacAddressElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MacAddressType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.MacAddressType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MacAddressType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.MacAddressType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MacAddressType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MailStopNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.MailStopNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MailStopNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.MailStopNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MailStopNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MailStopNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.MailStopNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MailStopNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.MailStopNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MailStopNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MailStopType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.MailStopType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MailStopType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.MailStopType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MailStopType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MiddleNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.MiddleNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MiddleNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.MiddleNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MiddleNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MotherboardGuidElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.MotherboardGuidElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MotherboardGuidElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.MotherboardGuidElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MotherboardGuidElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NameDetails(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NameDetails

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NameDetails returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NameDetails
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NameDetails: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NameDetailsElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NameDetailsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NameDetailsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NameDetailsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NameDetailsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NameDetailsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NameDetailsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NameDetailsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NameDetailsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NameDetailsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NameLineType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NameLineType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NameLineType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NameLineType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NameLineType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NamePrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NamePrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NamePrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NamePrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NamePrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NetworkElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.NetworkElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NetworkElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.NetworkElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NetworkElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NetworkInterfaceType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.NetworkInterfaceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NetworkInterfaceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.NetworkInterfaceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NetworkInterfaceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NetworkNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.NetworkNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NetworkNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.NetworkNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NetworkNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NetworkType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.NetworkType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NetworkType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.NetworkType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NetworkType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectRefElement(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ObjectRefElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectRefElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ObjectRefElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectRefElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectRefElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ObjectRefElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectRefElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ObjectRefElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectRefElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationFormerNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationFormerNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationFormerNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationFormerNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationFormerNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationKnownAsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationKnownAsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationKnownAsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationKnownAsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationKnownAsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationNameDetails(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationNameDetails

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationNameDetails returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationNameDetails
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationNameDetails: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationNameDetailsElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationNameDetailsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationNameDetailsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationNameDetailsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationNameDetailsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationNameDetailsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationNameDetailsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationNameDetailsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationNameDetailsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationNameDetailsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationTypeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationTypeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationTypeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationTypeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationTypeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganizationElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.OrganizationElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganizationElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.OrganizationElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganizationElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganizationType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.OrganizationType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganizationType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.OrganizationType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganizationType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OtherNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OtherNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OtherNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OtherNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OtherNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PersonElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PersonElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonName(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.PersonName

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonName returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.PersonName
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonName: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonNameElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.PersonNameElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonNameElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.PersonNameElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonNameElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.PersonNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.PersonNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PersonType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PersonType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PortElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PortElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PortElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PortElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PortElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PortRangeElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PortRangeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PortRangeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PortRangeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PortRangeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PortType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PortType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PortType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PortType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PortType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxNumberExtensionElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxNumberExtensionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxNumberExtensionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxNumberExtensionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxNumberExtensionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxNumberPrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxNumberPrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxNumberPrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxNumberPrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxNumberPrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxNumberSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxNumberSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxNumberSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxNumberSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxNumberSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostOfficeElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostOfficeElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostOfficeElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostOfficeElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostOfficeElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostOfficeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostOfficeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostOfficeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostOfficeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostOfficeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostOfficeNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostOfficeNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostOfficeNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostOfficeNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostOfficeNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostOfficeNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostOfficeNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostOfficeNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostOfficeNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostOfficeNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostTownElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostTownElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostTownElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostTownElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostTownElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostTownNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostTownNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostTownNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostTownNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostTownNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostTownSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostTownSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostTownSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostTownSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostTownSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalCodeElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalCodeElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalCodeElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalCodeElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalCodeElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalCodeNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalCodeNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalCodeNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalCodeNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalCodeNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalCodeNumberExtensionElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalCodeNumberExtensionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalCodeNumberExtensionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalCodeNumberExtensionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalCodeNumberExtensionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalRouteNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalRouteNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalRouteNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalRouteNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalRouteNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalRouteNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalRouteNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalRouteNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalRouteNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalRouteNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalRouteType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalRouteType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalRouteType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalRouteType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalRouteType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalServiceElementsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalServiceElementsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalServiceElementsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalServiceElementsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalServiceElementsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PrecedingTitleElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.PrecedingTitleElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PrecedingTitleElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.PrecedingTitleElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PrecedingTitleElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseLocationElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseLocationElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseLocationElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseLocationElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseLocationElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberPrefixElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberPrefixElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberPrefixElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberPrefixElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberPrefixElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberPrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberPrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberPrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberPrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberPrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberRangeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberRangeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberRangeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberRangeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberRangeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberRangeFromElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberRangeFromElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberRangeFromElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberRangeFromElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberRangeFromElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberRangeToElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberRangeToElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberRangeToElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberRangeToElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberRangeToElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberSuffixElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberSuffixElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberSuffixElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberSuffixElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberSuffixElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProtocolElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ProtocolElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProtocolElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ProtocolElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProtocolElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RelationshipType(t *testing.T) {
	// Create a default instance
	var elem reporting_core1_1.RelationshipType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RelationshipType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 reporting_core1_1.RelationshipType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RelationshipType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RelationshipsContainerType(t *testing.T) {
	// Create a default instance
	var elem reporting_core1_1.RelationshipsContainerType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RelationshipsContainerType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 reporting_core1_1.RelationshipsContainerType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RelationshipsContainerType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RelationshipsElementType(t *testing.T) {
	// Create a default instance
	var elem reporting_core1_1.RelationshipsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RelationshipsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 reporting_core1_1.RelationshipsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RelationshipsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RemoteResourceElement(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.RemoteResourceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RemoteResourceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.RemoteResourceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RemoteResourceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RemoteResourceElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.RemoteResourceElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RemoteResourceElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.RemoteResourceElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RemoteResourceElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReportRequestType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ReportRequestType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReportRequestType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ReportRequestType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReportRequestType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReportRequestsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ReportRequestsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReportRequestsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ReportRequestsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReportRequestsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReportType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ReportType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReportType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ReportType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReportType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReportsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ReportsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReportsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ReportsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReportsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ResourceElement(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ResourceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ResourceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ResourceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ResourceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ResourceType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ResourceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ResourceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ResourceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ResourceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RoleType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.RoleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RoleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.RoleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RoleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ServedByElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ServedByElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ServedByElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ServedByElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ServedByElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ServiceElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ServiceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ServiceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ServiceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ServiceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ServiceType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ServiceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ServiceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ServiceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ServiceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ShowType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ShowType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ShowType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ShowType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ShowType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Simple(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.Simple

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Simple returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.Simple
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Simple: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SoftwareElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SoftwareElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SoftwareElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SoftwareElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SoftwareElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SoftwareType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SoftwareType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SoftwareType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SoftwareType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SoftwareType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SortingCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SortingCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SortingCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SortingCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SortingCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubAdministrativeAreaElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubAdministrativeAreaElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubAdministrativeAreaElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubAdministrativeAreaElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubAdministrativeAreaElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubAdministrativeAreaNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubAdministrativeAreaNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubAdministrativeAreaNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubAdministrativeAreaNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubAdministrativeAreaNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseLocationElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseLocationElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseLocationElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseLocationElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseLocationElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseNumberPrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseNumberPrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseNumberPrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseNumberPrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseNumberPrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseNumberSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseNumberSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseNumberSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseNumberSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseNumberSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.SuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.SuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SupplementaryPostalServiceDataElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SupplementaryPostalServiceDataElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SupplementaryPostalServiceDataElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SupplementaryPostalServiceDataElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SupplementaryPostalServiceDataElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SyntheticIdElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SyntheticIdElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SyntheticIdElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SyntheticIdElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SyntheticIdElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SyntheticIdElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SyntheticIdElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SyntheticIdElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SyntheticIdElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SyntheticIdElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SystemElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SystemElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SystemElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SystemElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SystemElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SystemNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SystemNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SystemNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SystemNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SystemNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SystemType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SystemType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SystemType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SystemType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SystemType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TelephoneNumberElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.TelephoneNumberElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TelephoneNumberElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.TelephoneNumberElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TelephoneNumberElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TelephoneNumberElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.TelephoneNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TelephoneNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.TelephoneNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TelephoneNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TelephoneNumberType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.TelephoneNumberType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TelephoneNumberType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.TelephoneNumberType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TelephoneNumberType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareLeadingTypeType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareLeadingTypeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareLeadingTypeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareLeadingTypeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareLeadingTypeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNameType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNameType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNameType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNameType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNameType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberFromElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberFromElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberFromElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberFromElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberFromElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberPrefixElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberPrefixElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberPrefixElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberPrefixElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberPrefixElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberPrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberPrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberPrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberPrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberPrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberRangeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberRangeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberRangeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberRangeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberRangeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberSuffixElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberSuffixElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberSuffixElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberSuffixElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberSuffixElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberToElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberToElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberToElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberToElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberToElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfarePostDirectionType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfarePostDirectionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfarePostDirectionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfarePostDirectionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfarePostDirectionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfarePreDirectionType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfarePreDirectionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfarePreDirectionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfarePreDirectionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfarePreDirectionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareTrailingTypeType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareTrailingTypeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareTrailingTypeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareTrailingTypeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareTrailingTypeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TitleAttrType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.TitleAttrType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TitleAttrType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.TitleAttrType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TitleAttrType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TitleElement(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.TitleElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TitleElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.TitleElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TitleElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TitleElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.TitleElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TitleElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.TitleElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TitleElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TitleEltType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.TitleEltType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TitleEltType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.TitleEltType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TitleEltType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ToType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ToType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ToType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ToType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ToType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TypeType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.TypeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TypeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.TypeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TypeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_UrlElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.UrlElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal UrlElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.UrlElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal UrlElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_VersionElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.VersionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal VersionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.VersionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal VersionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WebsiteElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.WebsiteElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WebsiteElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.WebsiteElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WebsiteElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WebsiteType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.WebsiteType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WebsiteType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.WebsiteType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WebsiteType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WebsiteUrlElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.WebsiteUrlElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WebsiteUrlElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.WebsiteUrlElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WebsiteUrlElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WebsiteUrlElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.WebsiteUrlElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WebsiteUrlElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.WebsiteUrlElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WebsiteUrlElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_XALElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.XALElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal XALElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.XALElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal XALElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_XALElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.XALElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal XALElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.XALElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal XALElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_XNLElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.XNLElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal XNLElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.XNLElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal XNLElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_XNLElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.XNLElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal XNLElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.XNLElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal XNLElementType: %d bytes", len(xmlBytes))
}

// =============================================================================
// Path Navigation Tests (getRootChildNodes, getElementAtPath, getFirstLevelElement)
// =============================================================================

func TestGetChildNodes_RootPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Get children of root element
	nodes, err := ts.state.GetChildNodes("/")
	if err != nil {
		t.Fatalf("GetChildNodes failed: %v", err)
	}

	// Log the child nodes - root elements should have children defined by schema
	t.Logf("Root element has %d child nodes", len(nodes))
	for i, node := range nodes {
		if i < 10 { // Log first 10
			t.Logf("  Child %d: %s (type: %s, path: %s)", i, node.Label, node.Type, node.Path)
		}
	}
}

func TestGetChildNodes_NestedPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// First get root children to find a valid path
	rootNodes, err := ts.state.GetChildNodes("/")
	if err != nil {
		t.Fatalf("GetChildNodes for root failed: %v", err)
	}

	if len(rootNodes) == 0 {
		t.Skip("No root children to test nested path")
	}

	// Try to get children of first child using defer/recover for robustness
	nestedPath := rootNodes[0].Path
	func() {
		defer func() {
			if r := recover(); r != nil {
				t.Logf("GetChildNodes for nested path %s panicked (implementation incomplete): %v", nestedPath, r)
			}
		}()
		nodes, err := ts.state.GetChildNodes(nestedPath)
		if err != nil {
			t.Logf("GetChildNodes for nested path %s returned error: %v", nestedPath, err)
		} else {
			t.Logf("Path %s has %d child nodes", nestedPath, len(nodes))
		}
	}()
}

func TestGetElement_NestedPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// First get root children to find a valid nested path
	rootNodes, err := ts.state.GetChildNodes("/")
	if err != nil {
		t.Fatalf("GetChildNodes for root failed: %v", err)
	}

	if len(rootNodes) == 0 {
		t.Skip("No root children to test nested element")
	}

	// Try to get element at first child path
	nestedPath := rootNodes[0].Path
	details, err := ts.state.GetElement(nestedPath)
	if err != nil {
		t.Logf("GetElement for nested path %s returned error: %v", nestedPath, err)
		return
	}

	if details != nil {
		t.Logf("Element at %s: type=%s, hasData=%v", nestedPath, details.Type, len(details.Data) > 0)
	}
}

func TestGetElement_InvalidPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Try to get element at invalid path
	_, err = ts.state.GetElement("/completely/invalid/path/that/does/not/exist")
	if err == nil {
		t.Log("GetElement for invalid path succeeded (may return empty details)")
	} else {
		t.Logf("GetElement for invalid path returned expected error: %v", err)
	}
}

// =============================================================================
// ListElementsByType Tests
// =============================================================================

func TestListElementsByType_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Skip("No types available")
	}

	// Try to list elements with no document
	elements, err := ts.state.ListElementsByType(types[0])
	if err != nil {
		t.Logf("ListElementsByType with no document returned error: %v", err)
	}

	// Should return empty list
	if len(elements) != 0 {
		t.Logf("ListElementsByType returned %d elements (expected 0)", len(elements))
	}
}

func TestListElementsByType_WithDocument(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// List elements of the root type
	elements, err := ts.state.ListElementsByType(rootTypes[0])
	if err != nil {
		t.Logf("ListElementsByType returned error: %v", err)
	}

	t.Logf("ListElementsByType(%s) returned %d elements", rootTypes[0], len(elements))
}

func TestListElementsByType_UnknownType(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// List elements of unknown type
	elements, err := ts.state.ListElementsByType("NonExistentType12345")
	if err != nil {
		t.Logf("ListElementsByType for unknown type returned error: %v", err)
	}

	// Should return empty list
	if len(elements) != 0 {
		t.Logf("ListElementsByType for unknown type returned %d elements", len(elements))
	}
}

// =============================================================================
// Tree Traversal Tests
// =============================================================================

func TestTreeTraversal_FullDepth(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Traverse tree from root with panic recovery for incomplete implementations
	visited := make(map[string]bool)
	var traverse func(path string, depth int)
	traverse = func(path string, depth int) {
		defer func() {
			if r := recover(); r != nil {
				t.Logf("Traversal at path %s panicked (implementation incomplete): %v", path, r)
			}
		}()

		if depth > 5 { // Limit depth to prevent infinite loops
			return
		}
		if visited[path] {
			return
		}
		visited[path] = true

		nodes, err := ts.state.GetChildNodes(path)
		if err != nil {
			return
		}

		for _, node := range nodes {
			traverse(node.Path, depth+1)
		}
	}

	traverse("/", 0)
	t.Logf("Tree traversal visited %d unique paths", len(visited))
}

func TestGetRootNodes_NodeProperties(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	nodes, err := ts.state.GetRootNodes()
	if err != nil {
		t.Fatalf("GetRootNodes failed: %v", err)
	}

	if len(nodes) == 0 {
		t.Fatal("Expected at least one root node")
	}

	// Verify root node properties
	rootNode := nodes[0]
	if rootNode.ID == "" {
		t.Error("Root node ID should not be empty")
	}
	if rootNode.Label == "" {
		t.Error("Root node Label should not be empty")
	}
	if rootNode.Type == "" {
		t.Error("Root node Type should not be empty")
	}
	if rootNode.Path != "/" {
		t.Errorf("Root node Path should be '/', got '%s'", rootNode.Path)
	}

	t.Logf("Root node: ID=%s, Label=%s, Type=%s, HasChildren=%v",
		rootNode.ID, rootNode.Label, rootNode.Type, rootNode.HasChildren)
}

// =============================================================================
// Child Element Creation and Update Tests
// =============================================================================

func TestCreateChildElement(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create root element first
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create root element: %v", err)
	}

	// Get valid child types for the root
	childTypes := ts.state.GetValidChildTypes(rootTypes[0])
	if len(childTypes) == 0 {
		t.Skip("No valid child types for root")
	}

	// Try to create a child element
	childPath, err := ts.state.CreateElement(childTypes[0], "/", nil)
	if err != nil {
		t.Logf("CreateElement for child returned error (may be expected): %v", err)
		return
	}

	if childPath == "" {
		t.Error("CreateElement for child should return a path")
	}

	t.Logf("Created child element at path: %s", childPath)
}

func TestUpdateFirstLevelElement(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create root element
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create root element: %v", err)
	}

	// Get children of root
	children, err := ts.state.GetChildNodes("/")
	if err != nil {
		t.Fatalf("GetChildNodes failed: %v", err)
	}

	if len(children) == 0 {
		t.Skip("No children to update")
	}

	// Try to update the first child element
	childPath := children[0].Path
	updateData := json.RawMessage(`{"id": "updated-child"}`)
	err = ts.state.UpdateElement(childPath, updateData)
	if err != nil {
		t.Logf("UpdateElement for child %s returned error (may be expected): %v", childPath, err)
	} else {
		t.Logf("Successfully updated child element at %s", childPath)
	}
}

func TestDeleteFirstLevelElement(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create root element
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create root element: %v", err)
	}

	// Get children of root
	children, err := ts.state.GetChildNodes("/")
	if err != nil {
		t.Fatalf("GetChildNodes failed: %v", err)
	}

	if len(children) == 0 {
		t.Skip("No children to delete")
	}

	// Try to delete the first child element
	childPath := children[0].Path
	err = ts.state.DeleteElement(childPath)
	if err != nil {
		t.Logf("DeleteElement for child %s returned error (may be expected): %v", childPath, err)
	} else {
		t.Logf("Successfully deleted child element at %s", childPath)
	}
}

// =============================================================================
// Per-Type Validation Tests
// =============================================================================

func TestValidate_AssetReportCollectionElement(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	_, err := ts.state.CreateElement("AssetReportCollectionElement", "", nil)
	if err != nil {
		t.Skipf("Could not create AssetReportCollectionElement: %v", err)
	}

	// Run validation - this should call validateAssetReportCollectionElement
	errors, err := ts.state.Validate()
	if err != nil {
		t.Fatalf("Validate failed: %v", err)
	}

	t.Logf("Validation of AssetReportCollectionElement: %d errors", len(errors))

	// Log first few validation errors for debugging
	for i, ve := range errors {
		if i < 5 {
			t.Logf("  - %s: %s", ve.Path, ve.Message)
		}
	}
}

// =============================================================================
// Edge Case Tests
// =============================================================================

func TestGetChildNodes_EmptyPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Empty path should behave like root
	nodes, err := ts.state.GetChildNodes("")
	if err != nil {
		t.Logf("GetChildNodes for empty path returned error: %v", err)
	}

	// Compare with root nodes
	rootNodes, _ := ts.state.GetChildNodes("/")
	t.Logf("Empty path returned %d nodes, root path returned %d nodes", len(nodes), len(rootNodes))
}

func TestGetElement_PathWithTrailingSlash(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Path with trailing slash should work like without
	details1, err1 := ts.state.GetElement("/")
	details2, err2 := ts.state.GetElement("//")

	if err1 != nil {
		t.Fatalf("GetElement('/') failed: %v", err1)
	}

	if err2 == nil && details1 != nil && details2 != nil {
		if details1.Type != details2.Type {
			t.Logf("Paths '/' and '//' returned different types: %s vs %s", details1.Type, details2.Type)
		}
	}
}

func TestGetChildNodes_SpecialCharactersInPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Test paths with special characters - should handle gracefully
	testPaths := []string{
		"/path/with spaces",
		"/path/with[brackets]",
		"/path/with-dashes",
		"/path/with_underscores",
	}

	for _, path := range testPaths {
		nodes, err := ts.state.GetChildNodes(path)
		if err != nil {
			t.Logf("GetChildNodes(%q) returned error (expected): %v", path, err)
		} else {
			t.Logf("GetChildNodes(%q) returned %d nodes", path, len(nodes))
		}
	}
}
