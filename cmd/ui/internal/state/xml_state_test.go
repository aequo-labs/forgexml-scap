// Code generated by forgexml UI generator. DO NOT EDIT.
package state

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	xccdf1_2 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/checklists/xccdf/1-2"
	asset_identification1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-identification/1-1"
	asset_reporting_format1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-reporting-format/1-1"
	reporting_core1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1"
	pkg_2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xal/2-0"
	pkg_2_01 "github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xnl/2-0"
	dictionary2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/dictionary/2-0"
	language2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/language/2-0"
	xmlschemaoval_common_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-common-5"
	xmlschemaoval_definitions_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5"
	pkg_1999xlink "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/1999/xlink"
	pkg_200009xmldsig "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// =============================================================================
// Test Suite Setup
// =============================================================================

// TestSuite holds shared test resources for state tests.
type TestSuite struct {
	state *XMLDocumentState
}

// setupTestSuite creates a fresh XMLDocumentState for testing.
func setupTestSuite(t *testing.T) *TestSuite {
	t.Helper()
	return &TestSuite{
		state: NewXMLDocumentState(),
	}
}

// =============================================================================
// NewXMLDocumentState Tests
// =============================================================================

func TestNewXMLDocumentState(t *testing.T) {
	state := NewXMLDocumentState()

	if state == nil {
		t.Fatal("NewXMLDocumentState returned nil")
	}

	if state.HasDocument() {
		t.Error("New state should not have a document loaded")
	}

	if state.IsDirty() {
		t.Error("New state should not be dirty")
	}

	if state.GetSourceFile() != "" {
		t.Error("New state should have empty source file")
	}
}

// =============================================================================
// LoadFromBytes Tests
// =============================================================================

func TestLoadFromBytes_CpeListElement(t *testing.T) {
	ts := setupTestSuite(t)

	// Create a minimal valid XML for CpeListElement
	xmlContent := []byte(`<?xml version="1.0" encoding="UTF-8"?>
<cpe-list xmlns="http://cpe.mitre.org/dictionary/2.0">
</cpe-list>`)

	err := ts.state.LoadFromBytes(xmlContent, "test_cpe-list.xml")
	if err != nil {
		t.Logf("LoadFromBytes for CpeListElement returned error (may be expected for complex schemas): %v", err)
		return
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after LoadFromBytes")
	}

	if ts.state.GetSourceFile() != "test_cpe-list.xml" {
		t.Errorf("Expected source file 'test_cpe-list.xml', got '%s'", ts.state.GetSourceFile())
	}
}

func TestLoadFromBytes_InvalidXML(t *testing.T) {
	ts := setupTestSuite(t)

	err := ts.state.LoadFromBytes([]byte("not valid xml"), "invalid.xml")
	if err == nil {
		t.Error("Expected error for invalid XML")
	}
}

func TestLoadFromBytes_UnknownRoot(t *testing.T) {
	ts := setupTestSuite(t)

	xmlContent := []byte(`<?xml version="1.0" encoding="UTF-8"?>
<unknown-element xmlns="http://example.com/unknown">
</unknown-element>`)

	err := ts.state.LoadFromBytes(xmlContent, "unknown.xml")
	if err == nil {
		t.Error("Expected error for unknown root element")
	}
	if err != nil && !strings.Contains(err.Error(), "unknown root element") {
		t.Errorf("Expected 'unknown root element' error, got: %v", err)
	}
}

// =============================================================================
// LoadFromFile Tests
// =============================================================================

func TestLoadFromFile_NonExistent(t *testing.T) {
	ts := setupTestSuite(t)

	err := ts.state.LoadFromFile("/nonexistent/path/to/file.xml")
	if err == nil {
		t.Error("Expected error for non-existent file")
	}
}

func TestLoadFromFile_WithTempFile(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type to test with
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create element and export to get valid XML
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	xmlBytes, _, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Failed to export: %v", err)
	}

	// Write to temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")
	if err := os.WriteFile(tmpFile, xmlBytes, 0644); err != nil {
		t.Fatalf("Failed to write temp file: %v", err)
	}

	// Load from file
	ts2 := setupTestSuite(t)
	err = ts2.state.LoadFromFile(tmpFile)
	if err != nil {
		t.Errorf("LoadFromFile failed: %v", err)
	}

	if !ts2.state.HasDocument() {
		t.Error("State should have document after LoadFromFile")
	}
}

// =============================================================================
// ExportToBytes Tests
// =============================================================================

func TestExportToBytes_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	_, _, err := ts.state.ExportToBytes()
	if err == nil {
		t.Error("Expected error when exporting with no document")
	}
}

func TestExportToBytes_WithDocument(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type to test with
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create a root element
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	xmlBytes, filename, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("ExportToBytes failed: %v", err)
	}

	if len(xmlBytes) == 0 {
		t.Error("Exported bytes should not be empty")
	}

	if filename == "" {
		t.Error("Filename should not be empty")
	}

	// Verify XML header
	if !bytes.HasPrefix(xmlBytes, []byte("<?xml")) {
		t.Error("Exported XML should have XML declaration")
	}
}

func TestExportToBytes_RoundTrip(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type to test with
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create element
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Export
	xmlBytes1, _, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("First export failed: %v", err)
	}

	// Load into new state
	ts2 := setupTestSuite(t)
	err = ts2.state.LoadFromBytes(xmlBytes1, "roundtrip.xml")
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}

	// Export again
	xmlBytes2, _, err := ts2.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Second export failed: %v", err)
	}

	// Both exports should be similar in structure (may differ in whitespace)
	if len(xmlBytes2) == 0 {
		t.Error("Second export should not be empty")
	}

	t.Logf("Round-trip: original %d bytes, re-exported %d bytes", len(xmlBytes1), len(xmlBytes2))
}

// =============================================================================
// GetRootNodes Tests
// =============================================================================

func TestGetRootNodes_Empty(t *testing.T) {
	ts := setupTestSuite(t)

	nodes, err := ts.state.GetRootNodes()
	if err != nil {
		t.Fatalf("GetRootNodes failed: %v", err)
	}

	if len(nodes) != 0 {
		t.Errorf("Expected 0 root nodes for empty state, got %d", len(nodes))
	}
}

func TestGetRootNodes_WithDocument(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type to test with
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	// Create a root element
	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	nodes, err := ts.state.GetRootNodes()
	if err != nil {
		t.Fatalf("GetRootNodes failed: %v", err)
	}

	if len(nodes) != 1 {
		t.Errorf("Expected 1 root node, got %d", len(nodes))
	}

	if len(nodes) > 0 {
		if nodes[0].Path != "/" {
			t.Errorf("Root node path should be '/', got '%s'", nodes[0].Path)
		}
		if nodes[0].Type != rootTypes[0] {
			t.Errorf("Root node type should be '%s', got '%s'", rootTypes[0], nodes[0].Type)
		}
	}
}

// =============================================================================
// GetChildNodes Tests
// =============================================================================

func TestGetChildNodes_Empty(t *testing.T) {
	ts := setupTestSuite(t)

	nodes, err := ts.state.GetChildNodes("/")
	if err != nil {
		t.Fatalf("GetChildNodes failed: %v", err)
	}

	if len(nodes) != 0 {
		t.Errorf("Expected 0 child nodes for empty state, got %d", len(nodes))
	}
}

func TestGetChildNodes_InvalidPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Try to get children of non-existent path
	nodes, err := ts.state.GetChildNodes("/nonexistent")
	// Should not error, just return empty
	if err != nil {
		t.Logf("GetChildNodes for invalid path returned error: %v", err)
	}

	// Should return empty array
	if len(nodes) != 0 {
		t.Logf("GetChildNodes for invalid path returned %d nodes (may be expected)", len(nodes))
	}
}

// =============================================================================
// GetElement Tests
// =============================================================================

func TestGetElement_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	_, err := ts.state.GetElement("/")
	if err == nil {
		t.Error("Expected error when getting element with no document")
	}
}

func TestGetElement_Root(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	details, err := ts.state.GetElement("/")
	if err != nil {
		t.Fatalf("GetElement failed: %v", err)
	}

	if details == nil {
		t.Fatal("GetElement returned nil details")
	}

	if details.Path != "/" {
		t.Errorf("Expected path '/', got '%s'", details.Path)
	}

	if details.Type != rootTypes[0] {
		t.Errorf("Expected type '%s', got '%s'", rootTypes[0], details.Type)
	}
}

// =============================================================================
// CreateElement Tests
// =============================================================================

func TestCreateElement_UnknownType(t *testing.T) {
	ts := setupTestSuite(t)

	_, err := ts.state.CreateElement("UnknownType", "", nil)
	if err == nil {
		t.Error("Expected error for unknown type")
	}
}

func TestCreateElement_ActuateType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ActuateType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ActuateType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressDetails(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressDetails", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressDetails returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressDetailsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressDetailsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressDetailsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressIdentifierElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressIdentifierElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressIdentifierElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLatitudeDirectionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLatitudeDirectionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLatitudeDirectionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLatitudeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLatitudeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLatitudeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLineElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLineElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLineElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLineElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLineElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLineElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLinesType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLinesType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLinesType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLongitudeDirectionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLongitudeDirectionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLongitudeDirectionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddressLongitudeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddressLongitudeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddressLongitudeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AddresseeIndicatorElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AddresseeIndicatorElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AddresseeIndicatorElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AdministrativeAreaElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AdministrativeAreaElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AdministrativeAreaElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AdministrativeAreaElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AdministrativeAreaElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AdministrativeAreaElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AdministrativeAreaNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AdministrativeAreaNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AdministrativeAreaNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AffectedType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AffectedType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AffectedType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AliasElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AliasElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AliasElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ArcElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ArcElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ArcElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ArcType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ArcType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ArcType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ArcroleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ArcroleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ArcroleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ArithmeticEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ArithmeticEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for ArithmeticEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ArithmeticFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ArithmeticFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ArithmeticFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetIdentificationType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetIdentificationType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetIdentificationType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetRelatedElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetRelatedElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetRelatedElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetReportCollectionElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetReportCollectionElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetReportCollectionElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetReportCollectionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetReportCollectionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetReportCollectionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_AssetsType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("AssetsType", "", nil)
	if err != nil {
		t.Logf("CreateElement for AssetsType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BarcodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BarcodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BarcodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BeginFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BeginFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BeginFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BenchmarkElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BenchmarkElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for BenchmarkElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BenchmarkElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BenchmarkElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BenchmarkElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BenchmarkIdType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BenchmarkIdType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BenchmarkIdType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BenchmarkReferenceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BenchmarkReferenceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BenchmarkReferenceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BirthdateElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BirthdateElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BirthdateElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_BuildingNameType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("BuildingNameType", "", nil)
	if err != nil {
		t.Logf("CreateElement for BuildingNameType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CPE2idrefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CPE2idrefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CPE2idrefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CanonicalizationMethodElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CanonicalizationMethodElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CanonicalizationMethodElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CanonicalizationMethodType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CanonicalizationMethodType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CanonicalizationMethodType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CcOperatorEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CcOperatorEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CcOperatorEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CheckContentRefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CheckContentRefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CheckContentRefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CheckContentType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CheckContentType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CheckContentType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CheckEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CheckEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for CheckEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CheckExportType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CheckExportType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CheckExportType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CheckImportType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CheckImportType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CheckImportType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CheckType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CheckType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CheckType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CidrElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CidrElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CidrElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CidrType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CidrType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CidrType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CircuitElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CircuitElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CircuitElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CircuitNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CircuitNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CircuitNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CircuitType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CircuitType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CircuitType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ClassEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ClassEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for ClassEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ComplexCheckType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ComplexCheckType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ComplexCheckType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ComplexDatatypeEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ComplexDatatypeEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for ComplexDatatypeEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ComplexValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ComplexValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ComplexValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ComputingDeviceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ComputingDeviceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ComputingDeviceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ComputingDeviceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ComputingDeviceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ComputingDeviceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ConcatFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ConcatFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ConcatFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ConnectionsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ConnectionsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ConnectionsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Constant_variableElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Constant_variableElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for Constant_variableElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Constant_variableElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Constant_variableElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for Constant_variableElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ContentElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ContentElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ContentElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ContentElementType1(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ContentElementType1", "", nil)
	if err != nil {
		t.Logf("CreateElement for ContentElementType1 returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountryElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountryElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountryElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountryNameCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountryNameCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountryNameCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountryNameElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountryNameElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountryNameElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CountryNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CountryNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CountryNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CpeElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CpeElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CpeElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CpeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CpeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CpeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CpeItemElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CpeItemElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CpeItemElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CpeListElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CpeListElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for CpeListElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CpeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CpeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CpeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CriteriaType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CriteriaType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CriteriaType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CriterionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CriterionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for CriterionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_CryptoBinary(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("CryptoBinary", "", nil)
	if err != nil {
		t.Logf("CreateElement for CryptoBinary returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DSAKeyValueElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DSAKeyValueElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DSAKeyValueElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DSAKeyValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DSAKeyValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DSAKeyValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DataElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DataElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DataElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DataType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DataType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DataType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DatabaseElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DatabaseElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DatabaseElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DatabaseType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DatabaseType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DatabaseType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DatatypeEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DatatypeEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for DatatypeEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DateTimeFormatEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DateTimeFormatEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for DateTimeFormatEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DcStatusType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DcStatusType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DcStatusType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DefinitionElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DefinitionElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DefinitionElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DefinitionIDPattern(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DefinitionIDPattern", "", nil)
	if err != nil {
		t.Logf("CreateElement for DefinitionIDPattern returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DefinitionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DefinitionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DefinitionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DefinitionsType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DefinitionsType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DefinitionsType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DepartmentElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DepartmentElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DepartmentElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DepartmentElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DepartmentElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DepartmentElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DepartmentNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DepartmentNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DepartmentNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependencyNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependencyNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependencyNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependentLocalityNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependentLocalityNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependentLocalityNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependentLocalityNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependentLocalityNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependentLocalityNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependentLocalityType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependentLocalityType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependentLocalityType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DependentThoroughfareElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DependentThoroughfareElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DependentThoroughfareElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DeprecatedInfoType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DeprecatedInfoType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DeprecatedInfoType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Deprecated_infoElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Deprecated_infoElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for Deprecated_infoElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DigestMethodElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DigestMethodElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DigestMethodElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DigestMethodType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DigestMethodType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DigestMethodType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DigestValueElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DigestValueElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for DigestValueElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DigestValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DigestValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DigestValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DistinguishedNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DistinguishedNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DistinguishedNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_DocumentRootElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("DocumentRootElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for DocumentRootElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ElementMapItemType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ElementMapItemType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ElementMapItemType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ElementMapType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ElementMapType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ElementMapType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Element_mappingElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Element_mappingElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for Element_mappingElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EmailAddressElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EmailAddressElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for EmailAddressElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EmailAddressElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EmailAddressElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EmailAddressElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EmptyStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EmptyStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EmptyStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EndFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EndFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EndFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EndorsementLineCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EndorsementLineCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EndorsementLineCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectAnySimpleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectAnySimpleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectAnySimpleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectBinaryType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectBinaryType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectBinaryType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectBoolType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectBoolType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectBoolType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectFieldType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectFieldType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectFieldType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectFloatType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectFloatType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectFloatType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectIPAddressStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectIPAddressStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectIPAddressStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectIPAddressType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectIPAddressType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectIPAddressType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectIntType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectIntType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectIntType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectRecordType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectRecordType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectRecordType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityObjectVersionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityObjectVersionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityObjectVersionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateAnySimpleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateAnySimpleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateAnySimpleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateBinaryType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateBinaryType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateBinaryType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateBoolType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateBoolType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateBoolType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateDebianEVRStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateDebianEVRStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateDebianEVRStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateEVRStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateEVRStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateEVRStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateFieldType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateFieldType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateFieldType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateFileSetRevisionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateFileSetRevisionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateFileSetRevisionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateFloatType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateFloatType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateFloatType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateIOSVersionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateIOSVersionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateIOSVersionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateIPAddressStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateIPAddressStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateIPAddressStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateIPAddressType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateIPAddressType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateIPAddressType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateIntType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateIntType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateIntType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateRecordType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateRecordType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateRecordType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EntityStateVersionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EntityStateVersionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EntityStateVersionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_EscapeRegexFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("EscapeRegexFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for EscapeRegexFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ExistenceEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ExistenceEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for ExistenceEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ExtendDefinitionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ExtendDefinitionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ExtendDefinitionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Extended(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Extended", "", nil)
	if err != nil {
		t.Logf("CreateElement for Extended returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ExtendedInfoElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ExtendedInfoElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ExtendedInfoElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ExtendedInformationElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ExtendedInformationElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ExtendedInformationElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ExtendedInfosElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ExtendedInfosElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ExtendedInfosElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_External_variableElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("External_variableElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for External_variableElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_External_variableElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("External_variableElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for External_variableElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FactRefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FactRefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FactRefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FactType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FactType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FactType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FamilyEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FamilyEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for FamilyEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FilterActionEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FilterActionEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for FilterActionEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FilterElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FilterElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for FilterElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FilterElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FilterElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FilterElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FirmNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FirmNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FirmNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FirmType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FirmType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FirmType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FirstNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FirstNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FirstNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FixStrategyEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FixStrategyEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FixStrategyEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FixTextType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FixTextType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FixTextType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FixType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FixType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FixType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FormerNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FormerNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FormerNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FqdnElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FqdnElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for FqdnElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FqdnElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FqdnElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FqdnElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FromType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FromType", "", nil)
	if err != nil {
		t.Logf("CreateElement for FromType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Function(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Function", "", nil)
	if err != nil {
		t.Logf("CreateElement for Function returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_FunctionElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("FunctionElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for FunctionElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GeneralSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GeneralSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for GeneralSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GenerationIdentifierElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GenerationIdentifierElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for GenerationIdentifierElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GeneratorType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GeneratorType", "", nil)
	if err != nil {
		t.Logf("CreateElement for GeneratorType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GlobToRegexFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GlobToRegexFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for GlobToRegexFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GroupElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GroupElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for GroupElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GroupIdType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GroupIdType", "", nil)
	if err != nil {
		t.Logf("CreateElement for GroupIdType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_GroupType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("GroupType", "", nil)
	if err != nil {
		t.Logf("CreateElement for GroupType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HMACOutputLengthType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HMACOutputLengthType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HMACOutputLengthType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HostElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HostElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HostElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HostnameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HostnameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HostnameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HostnameType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HostnameType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HostnameType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HrefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HrefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HrefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HtmlTextType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HtmlTextType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HtmlTextType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_HtmlTextWithSubType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("HtmlTextWithSubType", "", nil)
	if err != nil {
		t.Logf("CreateElement for HtmlTextWithSubType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IdentType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IdentType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IdentType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IdentityType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IdentityType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IdentityType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IdrefListType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IdrefListType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IdrefListType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IdrefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IdrefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IdrefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_InstallationIdElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("InstallationIdElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for InstallationIdElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_InstanceFixType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("InstanceFixType", "", nil)
	if err != nil {
		t.Logf("CreateElement for InstanceFixType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_InstanceNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("InstanceNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for InstanceNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_InstanceResultType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("InstanceResultType", "", nil)
	if err != nil {
		t.Logf("CreateElement for InstanceResultType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_InterfaceHintType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("InterfaceHintType", "", nil)
	if err != nil {
		t.Logf("CreateElement for InterfaceHintType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpAddressElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpAddressElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpAddressElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpAddressType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpAddressType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpAddressType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpNetRangeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpNetRangeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpNetRangeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpV4ElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpV4ElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpV4ElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_IpV6ElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("IpV6ElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for IpV6ElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Ipv4Type(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Ipv4Type", "", nil)
	if err != nil {
		t.Logf("CreateElement for Ipv4Type returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Ipv6Type(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Ipv6Type", "", nil)
	if err != nil {
		t.Logf("CreateElement for Ipv6Type returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ItAssetElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ItAssetElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ItAssetElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ItemElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ItemElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ItemElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ItemIDPattern(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ItemIDPattern", "", nil)
	if err != nil {
		t.Logf("CreateElement for ItemIDPattern returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_JointPersonNameElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("JointPersonNameElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for JointPersonNameElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_JointPersonNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("JointPersonNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for JointPersonNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KeyInfoElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KeyInfoElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for KeyInfoElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KeyInfoType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KeyInfoType", "", nil)
	if err != nil {
		t.Logf("CreateElement for KeyInfoType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KeyLineCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KeyLineCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for KeyLineCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KeyNameElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KeyNameElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for KeyNameElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KeyValueElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KeyValueElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for KeyValueElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KeyValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KeyValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for KeyValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_KnownAsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("KnownAsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for KnownAsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LabelType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LabelType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LabelType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LargeMailUserIdentifierElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LargeMailUserIdentifierElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LargeMailUserIdentifierElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LargeMailUserNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LargeMailUserNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LargeMailUserNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LargeMailUserType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LargeMailUserType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LargeMailUserType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LastNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LastNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LastNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LicenseElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LicenseElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LicenseElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ListType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ListType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ListType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LiteralComponentType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LiteralComponentType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LiteralComponentType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Local_variableElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Local_variableElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for Local_variableElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Local_variableElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Local_variableElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for Local_variableElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocaleElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocaleElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocaleElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocaleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocaleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocaleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocalityElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocalityElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocalityElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocalityElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocalityElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocalityElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocalityNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocalityNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocalityNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationAddressElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationAddressElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationAddressElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationPointElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationPointElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationPointElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationPointElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationPointElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationPointElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationRegionElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationRegionElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationRegionElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationRegionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationRegionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationRegionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocationsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocationsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocationsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocatorElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocatorElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocatorElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LocatorType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LocatorType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LocatorType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_LogicalTestType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("LogicalTestType", "", nil)
	if err != nil {
		t.Logf("CreateElement for LogicalTestType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MacAddressElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MacAddressElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MacAddressElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MacAddressType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MacAddressType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MacAddressType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MailStopNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MailStopNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MailStopNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MailStopNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MailStopNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MailStopNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MailStopType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MailStopType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MailStopType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ManifestElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ManifestElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ManifestElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ManifestType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ManifestType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ManifestType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MessageLevelEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MessageLevelEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for MessageLevelEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MessageType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MessageType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MessageType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MetadataType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MetadataType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MetadataType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MgmtDataElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MgmtDataElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for MgmtDataElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MiddleNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MiddleNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MiddleNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ModelElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ModelElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ModelElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ModelElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ModelElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ModelElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MotherboardGuidElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MotherboardGuidElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MotherboardGuidElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_MsgSevEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("MsgSevEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for MsgSevEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NameDetails(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NameDetails", "", nil)
	if err != nil {
		t.Logf("CreateElement for NameDetails returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NameDetailsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NameDetailsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for NameDetailsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NameDetailsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NameDetailsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NameDetailsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NameLineType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NameLineType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NameLineType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NamePattern(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NamePattern", "", nil)
	if err != nil {
		t.Logf("CreateElement for NamePattern returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NamePrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NamePrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NamePrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NetworkElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NetworkElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for NetworkElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NetworkInterfaceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NetworkInterfaceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NetworkInterfaceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NetworkNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NetworkNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NetworkNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NetworkType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NetworkType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NetworkType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NonEmptyStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NonEmptyStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NonEmptyStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NotesElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NotesElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for NotesElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NotesElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NotesElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NotesElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NotesType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NotesType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NotesType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_NoticeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("NoticeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for NoticeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectComponentType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectComponentType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectComponentType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectIDPattern(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectIDPattern", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectIDPattern returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectRefElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectRefElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectRefElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectRefElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectRefElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectRefElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectRefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectRefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectRefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ObjectsType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ObjectsType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ObjectsType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OperationEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OperationEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for OperationEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OperatorEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OperatorEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for OperatorEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationFormerNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationFormerNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationFormerNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationKnownAsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationKnownAsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationKnownAsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationNameDetails(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationNameDetails", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationNameDetails returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationNameDetailsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationNameDetailsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationNameDetailsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationNameDetailsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationNameDetailsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationNameDetailsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganisationTypeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganisationTypeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganisationTypeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganizationElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganizationElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganizationElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OrganizationType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OrganizationType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OrganizationType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OtherNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OtherNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OtherNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Oval_definitionsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Oval_definitionsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for Oval_definitionsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Oval_definitionsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Oval_definitionsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for Oval_definitionsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OverrideType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OverrideType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OverrideType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_OverrideableCPE2idrefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("OverrideableCPE2idrefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for OverrideableCPE2idrefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PGPDataElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PGPDataElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PGPDataElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PGPDataType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PGPDataType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PGPDataType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ParamType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ParamType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ParamType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonName(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonName", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonName returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonNameElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonNameElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonNameElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PersonType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PersonType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PersonType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PlainTextType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PlainTextType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PlainTextType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PlatformSpecificationElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PlatformSpecificationElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PlatformSpecificationElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PlatformSpecificationElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PlatformSpecificationElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PlatformSpecificationElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PlatformType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PlatformType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PlatformType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PortElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PortElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PortElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PortRangeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PortRangeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PortRangeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PortType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PortType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PortType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PossibleRestrictionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PossibleRestrictionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PossibleRestrictionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PossibleValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PossibleValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PossibleValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxNumberExtensionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxNumberExtensionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxNumberExtensionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxNumberPrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxNumberPrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxNumberPrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostBoxNumberSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostBoxNumberSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostBoxNumberSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostOfficeElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostOfficeElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostOfficeElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostOfficeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostOfficeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostOfficeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostOfficeNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostOfficeNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostOfficeNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostOfficeNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostOfficeNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostOfficeNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostTownElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostTownElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostTownElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostTownNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostTownNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostTownNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostTownSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostTownSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostTownSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalCodeElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalCodeElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalCodeElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalCodeNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalCodeNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalCodeNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalCodeNumberExtensionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalCodeNumberExtensionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalCodeNumberExtensionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalRouteNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalRouteNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalRouteNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalRouteNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalRouteNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalRouteNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalRouteType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalRouteType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalRouteType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PostalServiceElementsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PostalServiceElementsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PostalServiceElementsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PrecedingTitleElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PrecedingTitleElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PrecedingTitleElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseLocationElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseLocationElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseLocationElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberPrefixElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberPrefixElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberPrefixElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberPrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberPrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberPrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberRangeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberRangeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberRangeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberRangeFromElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberRangeFromElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberRangeFromElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberRangeToElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberRangeToElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberRangeToElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberSuffixElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberSuffixElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberSuffixElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_PremiseNumberSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("PremiseNumberSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for PremiseNumberSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileIdType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileIdType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileIdType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileNoteType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileNoteType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileNoteType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileRefineRuleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileRefineRuleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileRefineRuleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileRefineValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileRefineValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileRefineValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileSelectType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileSelectType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileSelectType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileSetComplexValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileSetComplexValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileSetComplexValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileSetValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileSetValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileSetValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProfileType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProfileType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProfileType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ProtocolElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ProtocolElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ProtocolElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RSAKeyValueElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RSAKeyValueElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for RSAKeyValueElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RSAKeyValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RSAKeyValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RSAKeyValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RatingEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RatingEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RatingEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReferenceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReferenceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReferenceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReferenceElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReferenceElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReferenceElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReferenceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReferenceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReferenceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReferencesType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReferencesType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReferencesType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RegexCaptureFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RegexCaptureFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RegexCaptureFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RelationshipType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RelationshipType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RelationshipType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RelationshipsContainerType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RelationshipsContainerType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RelationshipsContainerType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RelationshipsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RelationshipsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RelationshipsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RemoteResourceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RemoteResourceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for RemoteResourceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RemoteResourceElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RemoteResourceElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RemoteResourceElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReportRequestType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReportRequestType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReportRequestType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReportRequestsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReportRequestsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReportRequestsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReportType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReportType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReportType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ReportsElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ReportsElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ReportsElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ResourceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ResourceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ResourceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ResourceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ResourceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ResourceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RestrictionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RestrictionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RestrictionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ResultEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ResultEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ResultEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RetrievalMethodElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RetrievalMethodElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for RetrievalMethodElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RetrievalMethodType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RetrievalMethodType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RetrievalMethodType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RoleEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RoleEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RoleEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RoleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RoleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RoleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RuleElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RuleElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for RuleElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RuleIdType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RuleIdType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RuleIdType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RuleResultType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RuleResultType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RuleResultType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_RuleType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("RuleType", "", nil)
	if err != nil {
		t.Logf("CreateElement for RuleType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SPKIDataElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SPKIDataElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SPKIDataElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SPKIDataType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SPKIDataType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SPKIDataType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SchemaVersionPattern(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SchemaVersionPattern", "", nil)
	if err != nil {
		t.Logf("CreateElement for SchemaVersionPattern returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SchemaVersionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SchemaVersionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SchemaVersionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ScoreType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ScoreType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ScoreType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SelChoicesType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SelChoicesType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SelChoicesType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SelComplexValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SelComplexValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SelComplexValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SelNumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SelNumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SelNumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SelStringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SelStringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SelStringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ServedByElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ServedByElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ServedByElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ServiceElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ServiceElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ServiceElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ServiceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ServiceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ServiceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SetElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SetElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SetElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SetElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SetElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SetElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SetOperatorEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SetOperatorEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for SetOperatorEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SeverityEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SeverityEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SeverityEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ShowType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ShowType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ShowType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignatureElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignatureElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignatureElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignatureMethodElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignatureMethodElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignatureMethodElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignatureMethodType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignatureMethodType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignatureMethodType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignaturePropertiesElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignaturePropertiesElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignaturePropertiesElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignaturePropertiesType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignaturePropertiesType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignaturePropertiesType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignaturePropertyElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignaturePropertyElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignaturePropertyElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignaturePropertyType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignaturePropertyType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignaturePropertyType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignatureType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignatureType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignatureType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignatureValueElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignatureValueElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignatureValueElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignatureValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignatureValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignatureValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignedInfoElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignedInfoElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignedInfoElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SignedInfoType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SignedInfoType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SignedInfoType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_Simple(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("Simple", "", nil)
	if err != nil {
		t.Logf("CreateElement for Simple returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SimpleDatatypeEnumeration(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SimpleDatatypeEnumeration", "", nil)
	if err != nil {
		t.Logf("CreateElement for SimpleDatatypeEnumeration returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SoftwareElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SoftwareElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SoftwareElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SoftwareType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SoftwareType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SoftwareType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SortingCodeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SortingCodeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SortingCodeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SplitFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SplitFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SplitFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_StateElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("StateElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for StateElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_StateIDPattern(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("StateIDPattern", "", nil)
	if err != nil {
		t.Logf("CreateElement for StateIDPattern returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_StateRefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("StateRefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for StateRefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_StateType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("StateType", "", nil)
	if err != nil {
		t.Logf("CreateElement for StateType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_StatesType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("StatesType", "", nil)
	if err != nil {
		t.Logf("CreateElement for StatesType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_StatusElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("StatusElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for StatusElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_StatusElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("StatusElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for StatusElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_StatusType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("StatusType", "", nil)
	if err != nil {
		t.Logf("CreateElement for StatusType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubAdministrativeAreaElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubAdministrativeAreaElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubAdministrativeAreaElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubAdministrativeAreaNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubAdministrativeAreaNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubAdministrativeAreaNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseLocationElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseLocationElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseLocationElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseNumberPrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseNumberPrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseNumberPrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseNumberSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseNumberSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseNumberSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubPremiseType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubPremiseType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubPremiseType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubUseEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubUseEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubUseEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SubstringFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SubstringFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SubstringFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SupplementaryPostalServiceDataElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SupplementaryPostalServiceDataElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SupplementaryPostalServiceDataElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SyntheticIdElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SyntheticIdElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SyntheticIdElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SyntheticIdElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SyntheticIdElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SyntheticIdElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SystemElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SystemElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for SystemElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SystemNameElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SystemNameElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SystemNameElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_SystemType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("SystemType", "", nil)
	if err != nil {
		t.Logf("CreateElement for SystemType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TailoringBenchmarkReferenceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TailoringBenchmarkReferenceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TailoringBenchmarkReferenceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TailoringElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TailoringElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TailoringElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TailoringIdType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TailoringIdType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TailoringIdType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TailoringReferenceType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TailoringReferenceType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TailoringReferenceType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TailoringType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TailoringType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TailoringType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TailoringVersionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TailoringVersionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TailoringVersionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TargetFactsType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TargetFactsType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TargetFactsType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TargetIdRefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TargetIdRefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TargetIdRefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TelephoneNumberElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TelephoneNumberElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TelephoneNumberElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TelephoneNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TelephoneNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TelephoneNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TelephoneNumberType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TelephoneNumberType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TelephoneNumberType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TestElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TestElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TestElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TestIDPattern(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TestIDPattern", "", nil)
	if err != nil {
		t.Logf("CreateElement for TestIDPattern returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TestResultElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TestResultElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TestResultElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TestResultType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TestResultType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TestResultType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TestType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TestType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TestType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TestresultIdType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TestresultIdType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TestresultIdType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TestsType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TestsType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TestsType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TextType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TextType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TextType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TextWithSubType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TextWithSubType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TextWithSubType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareLeadingTypeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareLeadingTypeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareLeadingTypeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNameType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNameType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNameType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberFromElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberFromElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberFromElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberPrefixElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberPrefixElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberPrefixElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberPrefixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberPrefixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberPrefixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberRangeElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberRangeElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberRangeElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberSuffixElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberSuffixElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberSuffixElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberSuffixElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberSuffixElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberSuffixElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareNumberToElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareNumberToElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareNumberToElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfarePostDirectionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfarePostDirectionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfarePostDirectionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfarePreDirectionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfarePreDirectionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfarePreDirectionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ThoroughfareTrailingTypeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ThoroughfareTrailingTypeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ThoroughfareTrailingTypeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TimeDifferenceFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TimeDifferenceFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TimeDifferenceFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TitleAttrType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TitleAttrType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TitleAttrType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TitleElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TitleElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TitleElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TitleElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TitleElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TitleElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TitleEltType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TitleEltType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TitleEltType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ToType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ToType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ToType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TransformElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TransformElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TransformElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TransformType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TransformType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TransformType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TransformsElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TransformsElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for TransformsElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TransformsType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TransformsType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TransformsType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_TypeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("TypeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for TypeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_UniqueFunctionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("UniqueFunctionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for UniqueFunctionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_UriRefType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("UriRefType", "", nil)
	if err != nil {
		t.Logf("CreateElement for UriRefType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_UrlElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("UrlElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for UrlElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ValueElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ValueElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for ValueElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ValueIdType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ValueIdType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ValueIdType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ValueOperatorType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ValueOperatorType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ValueOperatorType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ValueType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ValueType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ValueType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_ValueTypeType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("ValueTypeType", "", nil)
	if err != nil {
		t.Logf("CreateElement for ValueTypeType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_VariableComponentType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("VariableComponentType", "", nil)
	if err != nil {
		t.Logf("CreateElement for VariableComponentType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_VariableElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("VariableElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for VariableElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_VariableIDPattern(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("VariableIDPattern", "", nil)
	if err != nil {
		t.Logf("CreateElement for VariableIDPattern returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_VariableType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("VariableType", "", nil)
	if err != nil {
		t.Logf("CreateElement for VariableType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_VariablesType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("VariablesType", "", nil)
	if err != nil {
		t.Logf("CreateElement for VariablesType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_VersionElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("VersionElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for VersionElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_VersionType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("VersionType", "", nil)
	if err != nil {
		t.Logf("CreateElement for VersionType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WarningCategoryEnumType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WarningCategoryEnumType", "", nil)
	if err != nil {
		t.Logf("CreateElement for WarningCategoryEnumType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WarningType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WarningType", "", nil)
	if err != nil {
		t.Logf("CreateElement for WarningType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WebsiteElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WebsiteElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for WebsiteElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WebsiteType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WebsiteType", "", nil)
	if err != nil {
		t.Logf("CreateElement for WebsiteType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WebsiteUrlElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WebsiteUrlElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for WebsiteUrlElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WebsiteUrlElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WebsiteUrlElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for WebsiteUrlElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WeightType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("WeightType", "", nil)
	if err != nil {
		t.Logf("CreateElement for WeightType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_X509DataElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("X509DataElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for X509DataElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_X509DataType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("X509DataType", "", nil)
	if err != nil {
		t.Logf("CreateElement for X509DataType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_X509IssuerSerialType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("X509IssuerSerialType", "", nil)
	if err != nil {
		t.Logf("CreateElement for X509IssuerSerialType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_XALElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("XALElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for XALElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_XALElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("XALElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for XALElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_XNLElement(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("XNLElement", "", nil)
	if err != nil {
		t.Logf("CreateElement for XNLElement returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_XNLElementType(t *testing.T) {
	ts := setupTestSuite(t)

	path, err := ts.state.CreateElement("XNLElementType", "", nil)
	if err != nil {
		t.Logf("CreateElement for XNLElementType returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after CreateElement")
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after CreateElement")
	}
}

func TestCreateElement_WithData(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types
	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Skip("No types available")
	}

	// Try to create with some data
	data := json.RawMessage(`{"id": "test-id"}`)
	path, err := ts.state.CreateElement(types[0], "", data)
	if err != nil {
		t.Logf("CreateElement with data returned error (may be expected): %v", err)
		return
	}

	if path == "" {
		t.Error("CreateElement should return a path")
	}
}

// =============================================================================
// UpdateElement Tests
// =============================================================================

func TestUpdateElement_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	err := ts.state.UpdateElement("/", json.RawMessage(`{}`))
	if err == nil {
		t.Error("Expected error when updating with no document")
	}
}

func TestUpdateElement_Root(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Update root element
	updateData := json.RawMessage(`{"id": "updated-id"}`)
	err = ts.state.UpdateElement("/", updateData)
	if err != nil {
		t.Logf("UpdateElement returned error (may be expected): %v", err)
	}

	// State should be dirty after update attempt
	if !ts.state.IsDirty() {
		t.Error("State should be dirty after update")
	}
}

func TestUpdateElement_InvalidJSON(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Try to update with invalid JSON
	err = ts.state.UpdateElement("/", json.RawMessage(`invalid json`))
	if err == nil {
		t.Error("Expected error for invalid JSON")
	}
}

// =============================================================================
// DeleteElement Tests
// =============================================================================

func TestDeleteElement_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	err := ts.state.DeleteElement("/")
	if err == nil {
		t.Error("Expected error when deleting with no document")
	}
}

func TestDeleteElement_Root(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Delete root (clears document)
	err = ts.state.DeleteElement("/")
	if err != nil {
		t.Fatalf("DeleteElement failed: %v", err)
	}

	if ts.state.HasDocument() {
		t.Error("State should not have document after deleting root")
	}
}

func TestDeleteElement_InvalidPath(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Try to delete non-existent element
	err = ts.state.DeleteElement("/nonexistent")
	if err == nil {
		t.Log("DeleteElement for non-existent path succeeded (may be expected)")
	}
}

// =============================================================================
// Validate Tests
// =============================================================================

func TestValidate_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	errors, err := ts.state.Validate()
	if err != nil {
		t.Fatalf("Validate failed: %v", err)
	}

	// Should have at least one error for no document
	if len(errors) == 0 {
		t.Error("Expected validation error for no document")
	}

	// Check error message
	if len(errors) > 0 && !strings.Contains(errors[0].Message, "No document") {
		t.Errorf("Expected 'No document' error, got: %s", errors[0].Message)
	}
}

func TestValidate_WithDocument(t *testing.T) {
	ts := setupTestSuite(t)

	// Get a root type and create document
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	errors, err := ts.state.Validate()
	if err != nil {
		t.Fatalf("Validate failed: %v", err)
	}

	// Log validation errors (may have some for empty required fields)
	t.Logf("Validation returned %d errors", len(errors))
	for i, ve := range errors {
		if i < 5 { // Only log first 5
			t.Logf("  Error %d: %s - %s", i, ve.Path, ve.Message)
		}
	}
}

// =============================================================================
// Type Information Tests
// =============================================================================

func TestGetAvailableTypes(t *testing.T) {
	ts := setupTestSuite(t)

	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Error("GetAvailableTypes should return at least one type")
	}

	t.Logf("Available types: %d", len(types))
}

func TestGetRootElementTypes(t *testing.T) {
	ts := setupTestSuite(t)

	types := ts.state.GetRootElementTypes()
	// Root types may be empty if no root elements are configured
	t.Logf("Root element types: %d", len(types))
}

func TestGetValidChildTypes(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types and check child types
	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Skip("No types available")
	}

	childTypes := ts.state.GetValidChildTypes(types[0])
	t.Logf("Valid child types for %s: %d", types[0], len(childTypes))
}

func TestGetTypeMetadata(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types and check metadata
	types := ts.state.GetAvailableTypes()
	if len(types) == 0 {
		t.Skip("No types available")
	}

	metadata, err := ts.state.GetTypeMetadata(types[0])
	if err != nil {
		t.Fatalf("GetTypeMetadata failed: %v", err)
	}

	if metadata == nil {
		t.Fatal("GetTypeMetadata returned nil")
	}

	if metadata.Name != types[0] {
		t.Errorf("Expected name '%s', got '%s'", types[0], metadata.Name)
	}

	t.Logf("Type %s has %d fields", metadata.Name, len(metadata.Fields))
}

func TestGetTypeMetadata_Unknown(t *testing.T) {
	ts := setupTestSuite(t)

	_, err := ts.state.GetTypeMetadata("UnknownType")
	if err == nil {
		t.Error("Expected error for unknown type")
	}
}

func TestGetConcreteTypes(t *testing.T) {
	ts := setupTestSuite(t)

	// Get available types and check concrete types
	types := ts.state.GetAvailableTypes()
	for _, typeName := range types {
		concretes, err := ts.state.GetConcreteTypes(typeName)
		if err != nil {
			t.Logf("GetConcreteTypes for %s returned error: %v", typeName, err)
			continue
		}
		if len(concretes) > 0 {
			t.Logf("Abstract type %s has %d concrete types", typeName, len(concretes))
		}
	}
}

// =============================================================================
// State Management Tests
// =============================================================================

func TestIsDirty(t *testing.T) {
	ts := setupTestSuite(t)

	if ts.state.IsDirty() {
		t.Error("New state should not be dirty")
	}

	// Create element to make dirty
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after creating element")
	}
}

func TestMarkClean(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element to make dirty
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	if !ts.state.IsDirty() {
		t.Error("State should be dirty after creating element")
	}

	ts.state.MarkClean()

	if ts.state.IsDirty() {
		t.Error("State should not be dirty after MarkClean")
	}
}

func TestClear(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document")
	}

	ts.state.Clear()

	if ts.state.HasDocument() {
		t.Error("State should not have document after Clear")
	}

	if ts.state.IsDirty() {
		t.Error("State should not be dirty after Clear")
	}

	if ts.state.GetSourceFile() != "" {
		t.Error("Source file should be empty after Clear")
	}
}

func TestHasDocument(t *testing.T) {
	ts := setupTestSuite(t)

	if ts.state.HasDocument() {
		t.Error("New state should not have document")
	}

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	if !ts.state.HasDocument() {
		t.Error("State should have document after creating element")
	}
}

func TestGetLastModified(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element to set lastModified
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	lastMod := ts.state.GetLastModified()
	if lastMod.IsZero() {
		t.Error("Last modified should not be zero after creating element")
	}
}

// =============================================================================
// GenerateInstanceDiagram Tests
// =============================================================================

func TestGenerateInstanceDiagram_NoDocument(t *testing.T) {
	ts := setupTestSuite(t)

	_, err := ts.state.GenerateInstanceDiagram("flowchart")
	if err == nil {
		t.Error("Expected error when generating diagram with no document")
	}
}

func TestGenerateInstanceDiagram_Flowchart(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	diagram, err := ts.state.GenerateInstanceDiagram("flowchart")
	if err != nil {
		t.Fatalf("GenerateInstanceDiagram failed: %v", err)
	}

	if !strings.HasPrefix(diagram, "flowchart TD") {
		t.Error("Flowchart should start with 'flowchart TD'")
	}

	t.Logf("Flowchart diagram: %d bytes", len(diagram))
}

func TestGenerateInstanceDiagram_Mindmap(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	diagram, err := ts.state.GenerateInstanceDiagram("mindmap")
	if err != nil {
		t.Fatalf("GenerateInstanceDiagram failed: %v", err)
	}

	if !strings.HasPrefix(diagram, "mindmap") {
		t.Error("Mindmap should start with 'mindmap'")
	}

	t.Logf("Mindmap diagram: %d bytes", len(diagram))
}

func TestGenerateInstanceDiagram_Tree(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	diagram, err := ts.state.GenerateInstanceDiagram("tree")
	if err != nil {
		t.Fatalf("GenerateInstanceDiagram failed: %v", err)
	}

	if !strings.HasPrefix(diagram, "graph TD") {
		t.Error("Tree diagram should start with 'graph TD'")
	}

	t.Logf("Tree diagram: %d bytes", len(diagram))
}

// =============================================================================
// Helper Function Tests
// =============================================================================

func TestSplitPath(t *testing.T) {
	tests := []struct {
		input    string
		expected []string
	}{
		{"", nil},
		{"/", nil},
		{"/root", []string{"root"}},
		{"/parent/child", []string{"parent", "child"}},
		{"/a/b/c", []string{"a", "b", "c"}},
		{"no-leading-slash", []string{"no-leading-slash"}},
	}

	for _, tc := range tests {
		result := splitPath(tc.input)
		if len(result) != len(tc.expected) {
			t.Errorf("splitPath(%q) = %v, expected %v", tc.input, result, tc.expected)
			continue
		}
		for i := range result {
			if result[i] != tc.expected[i] {
				t.Errorf("splitPath(%q)[%d] = %q, expected %q", tc.input, i, result[i], tc.expected[i])
			}
		}
	}
}

func TestEscapeLabel(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"simple", "simple"},
		{`with "quotes"`, `with 'quotes'`},
		{"with [brackets]", "with brackets"},
		{"with {braces}", "with braces"},
	}

	for _, tc := range tests {
		result := escapeLabel(tc.input)
		if result != tc.expected {
			t.Errorf("escapeLabel(%q) = %q, expected %q", tc.input, result, tc.expected)
		}
	}
}

func TestTruncateString(t *testing.T) {
	tests := []struct {
		input    string
		maxLen   int
		expected string
	}{
		{"short", 10, "short"},
		{"exactly10c", 10, "exactly10c"},
		{"this is a long string", 10, "this is..."},
		{"", 5, ""},
	}

	for _, tc := range tests {
		result := truncateString(tc.input, tc.maxLen)
		if result != tc.expected {
			t.Errorf("truncateString(%q, %d) = %q, expected %q", tc.input, tc.maxLen, result, tc.expected)
		}
	}
}

// =============================================================================
// Benchmark Tests
// =============================================================================

func BenchmarkNewXMLDocumentState(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = NewXMLDocumentState()
	}
}

func BenchmarkGetAvailableTypes(b *testing.B) {
	state := NewXMLDocumentState()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = state.GetAvailableTypes()
	}
}

func BenchmarkGetRootElementTypes(b *testing.B) {
	state := NewXMLDocumentState()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = state.GetRootElementTypes()
	}
}

// =============================================================================
// Concurrent Access Tests
// =============================================================================

func TestConcurrentAccess(t *testing.T) {
	ts := setupTestSuite(t)

	// Create element first
	rootTypes := ts.state.GetRootElementTypes()
	if len(rootTypes) == 0 {
		t.Skip("No root types available")
	}

	_, err := ts.state.CreateElement(rootTypes[0], "", nil)
	if err != nil {
		t.Skipf("Could not create element: %v", err)
	}

	// Run concurrent reads
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func() {
			for j := 0; j < 100; j++ {
				ts.state.HasDocument()
				ts.state.IsDirty()
				ts.state.GetRootNodes()
			}
			done <- true
		}()
	}

	// Wait for all goroutines
	for i := 0; i < 10; i++ {
		<-done
	}
}

// =============================================================================
// Type-Specific CRUD Tests
// =============================================================================

// TestCpeListElement_CRUD tests full CRUD lifecycle for CpeListElement.
func TestCpeListElement_CRUD(t *testing.T) {
	ts := setupTestSuite(t)

	// CREATE
	path, err := ts.state.CreateElement("CpeListElement", "", nil)
	if err != nil {
		t.Logf("Create CpeListElement returned error (may be expected): %v", err)
		return
	}

	if path != "/" {
		t.Errorf("Expected root path '/', got '%s'", path)
	}

	// READ
	details, err := ts.state.GetElement("/")
	if err != nil {
		t.Fatalf("GetElement failed: %v", err)
	}

	if details.Type != "CpeListElement" {
		t.Errorf("Expected type 'CpeListElement', got '%s'", details.Type)
	}

	// UPDATE (with empty data, just to test the path)
	err = ts.state.UpdateElement("/", json.RawMessage(`{}`))
	if err != nil {
		t.Logf("Update returned error (may be expected): %v", err)
	}

	// VALIDATE
	errors, err := ts.state.Validate()
	if err != nil {
		t.Fatalf("Validate failed: %v", err)
	}
	t.Logf("Validation for CpeListElement: %d errors", len(errors))

	// EXPORT
	xmlBytes, filename, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Export failed: %v", err)
	}
	t.Logf("Exported CpeListElement: %d bytes, filename: %s", len(xmlBytes), filename)

	// DELETE
	err = ts.state.DeleteElement("/")
	if err != nil {
		t.Fatalf("Delete failed: %v", err)
	}

	if ts.state.HasDocument() {
		t.Error("Document should be cleared after delete")
	}
}

// TestCpeListElement_ExportRoundTrip tests export and re-import for CpeListElement.
func TestCpeListElement_ExportRoundTrip(t *testing.T) {
	ts := setupTestSuite(t)

	// Create
	_, err := ts.state.CreateElement("CpeListElement", "", nil)
	if err != nil {
		t.Skipf("Create CpeListElement returned error: %v", err)
	}

	// Export
	xmlBytes, _, err := ts.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Export failed: %v", err)
	}

	// Re-import into new state
	ts2 := setupTestSuite(t)
	err = ts2.state.LoadFromBytes(xmlBytes, "roundtrip.xml")
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}

	// Verify
	if !ts2.state.HasDocument() {
		t.Error("State should have document after round-trip")
	}

	// Export again
	xmlBytes2, _, err := ts2.state.ExportToBytes()
	if err != nil {
		t.Fatalf("Second export failed: %v", err)
	}

	t.Logf("Round-trip for CpeListElement: %d -> %d bytes", len(xmlBytes), len(xmlBytes2))
}

// =============================================================================
// XML Marshal/Unmarshal Tests for Generated Types
// =============================================================================

func TestMarshalUnmarshal_ActuateType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ActuateType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ActuateType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ActuateType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ActuateType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressDetails(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressDetails

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressDetails returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressDetails
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressDetails: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressDetailsElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressDetailsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressDetailsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressDetailsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressDetailsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressIdentifierElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressIdentifierElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressIdentifierElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressIdentifierElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressIdentifierElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLatitudeDirectionElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLatitudeDirectionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLatitudeDirectionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLatitudeDirectionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLatitudeDirectionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLatitudeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLatitudeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLatitudeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLatitudeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLatitudeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLineElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLineElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLineElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLineElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLineElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLineElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLineElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLineElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLineElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLineElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLinesType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLinesType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLinesType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLinesType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLinesType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLongitudeDirectionElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLongitudeDirectionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLongitudeDirectionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLongitudeDirectionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLongitudeDirectionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddressLongitudeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AddressLongitudeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddressLongitudeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AddressLongitudeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddressLongitudeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AddresseeIndicatorElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.AddresseeIndicatorElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AddresseeIndicatorElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.AddresseeIndicatorElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AddresseeIndicatorElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AdministrativeAreaElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AdministrativeAreaElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AdministrativeAreaElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AdministrativeAreaElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AdministrativeAreaElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AdministrativeAreaElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AdministrativeAreaElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AdministrativeAreaElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AdministrativeAreaElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AdministrativeAreaElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AdministrativeAreaNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.AdministrativeAreaNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AdministrativeAreaNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.AdministrativeAreaNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AdministrativeAreaNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AffectedType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.AffectedType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AffectedType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.AffectedType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AffectedType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AliasElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.AliasElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AliasElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.AliasElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AliasElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ArcElement(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ArcElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ArcElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ArcElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ArcElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ArcType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ArcType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ArcType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ArcType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ArcType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ArcroleType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ArcroleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ArcroleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ArcroleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ArcroleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ArithmeticEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ArithmeticEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ArithmeticEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ArithmeticEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ArithmeticEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ArithmeticFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ArithmeticFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ArithmeticFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ArithmeticFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ArithmeticFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.AssetElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.AssetElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetIdentificationType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetIdentificationType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetIdentificationType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetIdentificationType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetIdentificationType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetRelatedElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetRelatedElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetRelatedElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetRelatedElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetRelatedElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetReportCollectionElement(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.AssetReportCollectionElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetReportCollectionElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.AssetReportCollectionElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetReportCollectionElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetReportCollectionElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.AssetReportCollectionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetReportCollectionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.AssetReportCollectionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetReportCollectionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetsElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.AssetsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.AssetsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_AssetsType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.AssetsType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal AssetsType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.AssetsType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal AssetsType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BarcodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.BarcodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BarcodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.BarcodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BarcodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BeginFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.BeginFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BeginFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.BeginFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BeginFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BenchmarkElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.BenchmarkElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BenchmarkElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.BenchmarkElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BenchmarkElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BenchmarkElementType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.BenchmarkElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BenchmarkElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.BenchmarkElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BenchmarkElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BenchmarkIdType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.BenchmarkIdType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BenchmarkIdType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.BenchmarkIdType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BenchmarkIdType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BenchmarkReferenceType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.BenchmarkReferenceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BenchmarkReferenceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.BenchmarkReferenceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BenchmarkReferenceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BirthdateElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.BirthdateElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BirthdateElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.BirthdateElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BirthdateElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_BuildingNameType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.BuildingNameType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal BuildingNameType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.BuildingNameType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal BuildingNameType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CPE2idrefType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.CPE2idrefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CPE2idrefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.CPE2idrefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CPE2idrefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CanonicalizationMethodElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.CanonicalizationMethodElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CanonicalizationMethodElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.CanonicalizationMethodElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CanonicalizationMethodElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CanonicalizationMethodType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.CanonicalizationMethodType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CanonicalizationMethodType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.CanonicalizationMethodType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CanonicalizationMethodType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CcOperatorEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.CcOperatorEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CcOperatorEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.CcOperatorEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CcOperatorEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CheckContentRefType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.CheckContentRefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CheckContentRefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.CheckContentRefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CheckContentRefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CheckContentType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.CheckContentType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CheckContentType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.CheckContentType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CheckContentType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CheckEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.CheckEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CheckEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.CheckEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CheckEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CheckExportType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.CheckExportType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CheckExportType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.CheckExportType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CheckExportType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CheckImportType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.CheckImportType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CheckImportType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.CheckImportType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CheckImportType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CheckType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.CheckType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CheckType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.CheckType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CheckType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CidrElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CidrElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CidrElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CidrElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CidrElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CidrType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CidrType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CidrType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CidrType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CidrType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CircuitElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CircuitElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CircuitElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CircuitElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CircuitElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CircuitNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CircuitNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CircuitNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CircuitNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CircuitNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CircuitType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CircuitType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CircuitType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CircuitType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CircuitType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ClassEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.ClassEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ClassEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.ClassEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ClassEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ComplexCheckType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ComplexCheckType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ComplexCheckType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ComplexCheckType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ComplexCheckType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ComplexDatatypeEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.ComplexDatatypeEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ComplexDatatypeEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.ComplexDatatypeEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ComplexDatatypeEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ComplexValueType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ComplexValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ComplexValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ComplexValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ComplexValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ComputingDeviceElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ComputingDeviceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ComputingDeviceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ComputingDeviceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ComputingDeviceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ComputingDeviceType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ComputingDeviceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ComputingDeviceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ComputingDeviceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ComputingDeviceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ConcatFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ConcatFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ConcatFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ConcatFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ConcatFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ConnectionsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ConnectionsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ConnectionsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ConnectionsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ConnectionsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Constant_variableElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.Constant_variableElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Constant_variableElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.Constant_variableElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Constant_variableElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Constant_variableElementType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.Constant_variableElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Constant_variableElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.Constant_variableElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Constant_variableElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ContentElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ContentElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ContentElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ContentElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ContentElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ContentElementType1(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ContentElementType1

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ContentElementType1 returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ContentElementType1
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ContentElementType1: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.CountFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.CountFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountryElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.CountryElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountryElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.CountryElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountryElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountryNameCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.CountryNameCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountryNameCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.CountryNameCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountryNameCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountryNameElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.CountryNameElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountryNameElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.CountryNameElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountryNameElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CountryNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.CountryNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CountryNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.CountryNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CountryNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CpeElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CpeElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CpeElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CpeElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CpeElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CpeElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CpeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CpeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CpeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CpeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CpeItemElement(t *testing.T) {
	// Create a default instance
	var elem dictionary2_0.CpeItemElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CpeItemElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 dictionary2_0.CpeItemElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CpeItemElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CpeListElement(t *testing.T) {
	// Create a default instance
	var elem dictionary2_0.CpeListElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CpeListElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 dictionary2_0.CpeListElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CpeListElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CpeType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.CpeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CpeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.CpeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CpeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CriteriaType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.CriteriaType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CriteriaType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.CriteriaType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CriteriaType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CriterionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.CriterionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CriterionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.CriterionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CriterionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_CryptoBinary(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.CryptoBinary

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal CryptoBinary returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.CryptoBinary
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal CryptoBinary: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DSAKeyValueElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.DSAKeyValueElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DSAKeyValueElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.DSAKeyValueElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DSAKeyValueElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DSAKeyValueType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.DSAKeyValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DSAKeyValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.DSAKeyValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DSAKeyValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DataElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DataElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DataElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DataElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DataElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DataType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DataType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DataType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DataType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DataType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DatabaseElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DatabaseElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DatabaseElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DatabaseElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DatabaseElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DatabaseType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DatabaseType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DatabaseType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DatabaseType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DatabaseType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DatatypeEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.DatatypeEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DatatypeEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.DatatypeEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DatatypeEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DateTimeFormatEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.DateTimeFormatEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DateTimeFormatEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.DateTimeFormatEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DateTimeFormatEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DcStatusType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.DcStatusType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DcStatusType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.DcStatusType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DcStatusType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DefinitionElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.DefinitionElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DefinitionElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.DefinitionElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DefinitionElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DefinitionIDPattern(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.DefinitionIDPattern

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DefinitionIDPattern returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.DefinitionIDPattern
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DefinitionIDPattern: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DefinitionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.DefinitionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DefinitionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.DefinitionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DefinitionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DefinitionsType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.DefinitionsType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DefinitionsType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.DefinitionsType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DefinitionsType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DepartmentElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DepartmentElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DepartmentElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DepartmentElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DepartmentElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DepartmentElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DepartmentElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DepartmentElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DepartmentElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DepartmentElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DepartmentNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DepartmentNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DepartmentNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DepartmentNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DepartmentNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependencyNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.DependencyNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependencyNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.DependencyNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependencyNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependentLocalityNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DependentLocalityNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependentLocalityNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DependentLocalityNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependentLocalityNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependentLocalityNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DependentLocalityNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependentLocalityNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DependentLocalityNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependentLocalityNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependentLocalityType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DependentLocalityType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependentLocalityType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DependentLocalityType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependentLocalityType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DependentThoroughfareElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.DependentThoroughfareElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DependentThoroughfareElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.DependentThoroughfareElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DependentThoroughfareElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DeprecatedInfoType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.DeprecatedInfoType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DeprecatedInfoType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.DeprecatedInfoType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DeprecatedInfoType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Deprecated_infoElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.Deprecated_infoElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Deprecated_infoElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.Deprecated_infoElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Deprecated_infoElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DigestMethodElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.DigestMethodElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DigestMethodElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.DigestMethodElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DigestMethodElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DigestMethodType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.DigestMethodType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DigestMethodType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.DigestMethodType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DigestMethodType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DigestValueElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.DigestValueElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DigestValueElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.DigestValueElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DigestValueElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DigestValueType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.DigestValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DigestValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.DigestValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DigestValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DistinguishedNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DistinguishedNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DistinguishedNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DistinguishedNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DistinguishedNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_DocumentRootElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.DocumentRootElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal DocumentRootElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.DocumentRootElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal DocumentRootElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ElementMapItemType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.ElementMapItemType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ElementMapItemType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.ElementMapItemType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ElementMapItemType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ElementMapType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.ElementMapType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ElementMapType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.ElementMapType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ElementMapType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Element_mappingElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.Element_mappingElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Element_mappingElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.Element_mappingElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Element_mappingElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EmailAddressElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.EmailAddressElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EmailAddressElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.EmailAddressElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EmailAddressElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EmailAddressElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.EmailAddressElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EmailAddressElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.EmailAddressElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EmailAddressElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EmptyStringType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.EmptyStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EmptyStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.EmptyStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EmptyStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EndFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EndFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EndFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EndFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EndFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EndorsementLineCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.EndorsementLineCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EndorsementLineCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.EndorsementLineCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EndorsementLineCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectAnySimpleType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectAnySimpleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectAnySimpleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectAnySimpleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectAnySimpleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectBinaryType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectBinaryType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectBinaryType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectBinaryType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectBinaryType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectBoolType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectBoolType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectBoolType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectBoolType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectBoolType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectFieldType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectFieldType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectFieldType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectFieldType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectFieldType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectFloatType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectFloatType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectFloatType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectFloatType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectFloatType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectIPAddressStringType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectIPAddressStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectIPAddressStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectIPAddressStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectIPAddressStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectIPAddressType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectIPAddressType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectIPAddressType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectIPAddressType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectIPAddressType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectIntType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectIntType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectIntType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectIntType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectIntType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectRecordType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectRecordType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectRecordType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectRecordType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectRecordType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectStringType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityObjectVersionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityObjectVersionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityObjectVersionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityObjectVersionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityObjectVersionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateAnySimpleType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateAnySimpleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateAnySimpleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateAnySimpleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateAnySimpleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateBinaryType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateBinaryType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateBinaryType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateBinaryType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateBinaryType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateBoolType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateBoolType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateBoolType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateBoolType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateBoolType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateDebianEVRStringType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateDebianEVRStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateDebianEVRStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateDebianEVRStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateDebianEVRStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateEVRStringType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateEVRStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateEVRStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateEVRStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateEVRStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateFieldType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateFieldType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateFieldType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateFieldType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateFieldType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateFileSetRevisionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateFileSetRevisionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateFileSetRevisionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateFileSetRevisionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateFileSetRevisionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateFloatType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateFloatType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateFloatType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateFloatType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateFloatType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateIOSVersionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateIOSVersionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateIOSVersionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateIOSVersionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateIOSVersionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateIPAddressStringType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateIPAddressStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateIPAddressStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateIPAddressStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateIPAddressStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateIPAddressType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateIPAddressType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateIPAddressType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateIPAddressType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateIPAddressType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateIntType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateIntType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateIntType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateIntType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateIntType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateRecordType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateRecordType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateRecordType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateRecordType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateRecordType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateStringType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EntityStateVersionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EntityStateVersionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EntityStateVersionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EntityStateVersionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EntityStateVersionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_EscapeRegexFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.EscapeRegexFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal EscapeRegexFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.EscapeRegexFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal EscapeRegexFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ExistenceEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.ExistenceEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ExistenceEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.ExistenceEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ExistenceEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ExtendDefinitionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ExtendDefinitionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ExtendDefinitionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ExtendDefinitionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ExtendDefinitionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Extended(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.Extended

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Extended returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.Extended
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Extended: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ExtendedInfoElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ExtendedInfoElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ExtendedInfoElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ExtendedInfoElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ExtendedInfoElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ExtendedInformationElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ExtendedInformationElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ExtendedInformationElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ExtendedInformationElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ExtendedInformationElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ExtendedInfosElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ExtendedInfosElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ExtendedInfosElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ExtendedInfosElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ExtendedInfosElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_External_variableElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.External_variableElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal External_variableElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.External_variableElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal External_variableElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_External_variableElementType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.External_variableElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal External_variableElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.External_variableElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal External_variableElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FactRefType(t *testing.T) {
	// Create a default instance
	var elem language2_0.FactRefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FactRefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 language2_0.FactRefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FactRefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FactType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.FactType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FactType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.FactType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FactType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FamilyEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.FamilyEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FamilyEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.FamilyEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FamilyEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FilterActionEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.FilterActionEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FilterActionEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.FilterActionEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FilterActionEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FilterElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.FilterElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FilterElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.FilterElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FilterElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FilterElementType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.FilterElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FilterElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.FilterElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FilterElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FirmNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.FirmNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FirmNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.FirmNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FirmNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FirmType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.FirmType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FirmType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.FirmType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FirmType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FirstNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.FirstNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FirstNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.FirstNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FirstNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FixStrategyEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.FixStrategyEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FixStrategyEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.FixStrategyEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FixStrategyEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FixTextType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.FixTextType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FixTextType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.FixTextType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FixTextType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FixType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.FixType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FixType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.FixType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FixType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FormerNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.FormerNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FormerNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.FormerNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FormerNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FqdnElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.FqdnElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FqdnElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.FqdnElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FqdnElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FqdnElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.FqdnElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FqdnElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.FqdnElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FqdnElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FromType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.FromType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FromType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.FromType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FromType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Function(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.Function

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Function returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.Function
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Function: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_FunctionElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.FunctionElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal FunctionElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.FunctionElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal FunctionElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GeneralSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.GeneralSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GeneralSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.GeneralSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GeneralSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GenerationIdentifierElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.GenerationIdentifierElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GenerationIdentifierElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.GenerationIdentifierElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GenerationIdentifierElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GeneratorType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.GeneratorType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GeneratorType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.GeneratorType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GeneratorType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GlobToRegexFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.GlobToRegexFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GlobToRegexFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.GlobToRegexFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GlobToRegexFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GroupElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.GroupElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GroupElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.GroupElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GroupElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GroupIdType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.GroupIdType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GroupIdType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.GroupIdType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GroupIdType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_GroupType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.GroupType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal GroupType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.GroupType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal GroupType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HMACOutputLengthType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.HMACOutputLengthType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HMACOutputLengthType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.HMACOutputLengthType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HMACOutputLengthType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HostElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.HostElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HostElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.HostElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HostElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HostnameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.HostnameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HostnameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.HostnameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HostnameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HostnameType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.HostnameType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HostnameType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.HostnameType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HostnameType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HrefType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.HrefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HrefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.HrefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HrefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HtmlTextType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.HtmlTextType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HtmlTextType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.HtmlTextType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HtmlTextType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_HtmlTextWithSubType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.HtmlTextWithSubType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal HtmlTextWithSubType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.HtmlTextWithSubType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal HtmlTextWithSubType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IdentType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.IdentType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IdentType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.IdentType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IdentType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IdentityType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.IdentityType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IdentityType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.IdentityType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IdentityType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IdrefListType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.IdrefListType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IdrefListType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.IdrefListType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IdrefListType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IdrefType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.IdrefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IdrefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.IdrefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IdrefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_InstallationIdElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.InstallationIdElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal InstallationIdElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.InstallationIdElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal InstallationIdElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_InstanceFixType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.InstanceFixType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal InstanceFixType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.InstanceFixType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal InstanceFixType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_InstanceNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.InstanceNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal InstanceNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.InstanceNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal InstanceNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_InstanceResultType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.InstanceResultType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal InstanceResultType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.InstanceResultType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal InstanceResultType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_InterfaceHintType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.InterfaceHintType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal InterfaceHintType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.InterfaceHintType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal InterfaceHintType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpAddressElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpAddressElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpAddressElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpAddressElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpAddressElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpAddressType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpAddressType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpAddressType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpAddressType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpAddressType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpNetRangeElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpNetRangeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpNetRangeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpNetRangeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpNetRangeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpV4ElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpV4ElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpV4ElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpV4ElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpV4ElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_IpV6ElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.IpV6ElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal IpV6ElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.IpV6ElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal IpV6ElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Ipv4Type(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.Ipv4Type

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Ipv4Type returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.Ipv4Type
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Ipv4Type: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Ipv6Type(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.Ipv6Type

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Ipv6Type returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.Ipv6Type
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Ipv6Type: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ItAssetElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ItAssetElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ItAssetElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ItAssetElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ItAssetElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ItemElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ItemElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ItemElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ItemElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ItemElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ItemIDPattern(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.ItemIDPattern

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ItemIDPattern returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.ItemIDPattern
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ItemIDPattern: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_JointPersonNameElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.JointPersonNameElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal JointPersonNameElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.JointPersonNameElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal JointPersonNameElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_JointPersonNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.JointPersonNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal JointPersonNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.JointPersonNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal JointPersonNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KeyInfoElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.KeyInfoElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KeyInfoElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.KeyInfoElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KeyInfoElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KeyInfoType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.KeyInfoType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KeyInfoType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.KeyInfoType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KeyInfoType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KeyLineCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.KeyLineCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KeyLineCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.KeyLineCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KeyLineCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KeyNameElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.KeyNameElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KeyNameElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.KeyNameElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KeyNameElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KeyValueElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.KeyValueElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KeyValueElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.KeyValueElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KeyValueElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KeyValueType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.KeyValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KeyValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.KeyValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KeyValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_KnownAsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.KnownAsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal KnownAsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.KnownAsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal KnownAsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LabelType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.LabelType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LabelType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.LabelType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LabelType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LargeMailUserIdentifierElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LargeMailUserIdentifierElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LargeMailUserIdentifierElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LargeMailUserIdentifierElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LargeMailUserIdentifierElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LargeMailUserNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LargeMailUserNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LargeMailUserNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LargeMailUserNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LargeMailUserNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LargeMailUserType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LargeMailUserType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LargeMailUserType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LargeMailUserType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LargeMailUserType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LastNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.LastNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LastNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.LastNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LastNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LicenseElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LicenseElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LicenseElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LicenseElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LicenseElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ListType(t *testing.T) {
	// Create a default instance
	var elem dictionary2_0.ListType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ListType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 dictionary2_0.ListType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ListType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LiteralComponentType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.LiteralComponentType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LiteralComponentType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.LiteralComponentType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LiteralComponentType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Local_variableElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.Local_variableElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Local_variableElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.Local_variableElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Local_variableElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Local_variableElementType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.Local_variableElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Local_variableElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.Local_variableElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Local_variableElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocaleElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocaleElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocaleElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocaleElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocaleElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocaleType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocaleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocaleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocaleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocaleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocalityElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LocalityElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocalityElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LocalityElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocalityElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocalityElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LocalityElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocalityElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LocalityElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocalityElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocalityNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.LocalityNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocalityNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.LocalityNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocalityNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationAddressElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationAddressElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationAddressElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationAddressElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationAddressElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationPointElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationPointElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationPointElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationPointElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationPointElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationPointElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationPointElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationPointElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationPointElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationPointElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationRegionElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationRegionElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationRegionElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationRegionElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationRegionElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationRegionElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationRegionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationRegionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationRegionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationRegionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationsElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocationsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.LocationsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocationsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.LocationsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocationsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocatorElement(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.LocatorElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocatorElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.LocatorElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocatorElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LocatorType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.LocatorType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LocatorType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.LocatorType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LocatorType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_LogicalTestType(t *testing.T) {
	// Create a default instance
	var elem language2_0.LogicalTestType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal LogicalTestType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 language2_0.LogicalTestType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal LogicalTestType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MacAddressElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.MacAddressElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MacAddressElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.MacAddressElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MacAddressElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MacAddressType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.MacAddressType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MacAddressType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.MacAddressType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MacAddressType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MailStopNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.MailStopNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MailStopNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.MailStopNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MailStopNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MailStopNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.MailStopNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MailStopNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.MailStopNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MailStopNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MailStopType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.MailStopType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MailStopType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.MailStopType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MailStopType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ManifestElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.ManifestElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ManifestElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.ManifestElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ManifestElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ManifestType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.ManifestType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ManifestType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.ManifestType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ManifestType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MessageLevelEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.MessageLevelEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MessageLevelEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.MessageLevelEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MessageLevelEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MessageType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.MessageType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MessageType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.MessageType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MessageType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MetadataType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.MetadataType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MetadataType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.MetadataType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MetadataType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MgmtDataElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.MgmtDataElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MgmtDataElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.MgmtDataElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MgmtDataElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MiddleNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.MiddleNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MiddleNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.MiddleNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MiddleNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ModelElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ModelElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ModelElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ModelElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ModelElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ModelElementType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ModelElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ModelElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ModelElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ModelElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MotherboardGuidElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.MotherboardGuidElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MotherboardGuidElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.MotherboardGuidElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MotherboardGuidElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_MsgSevEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.MsgSevEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal MsgSevEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.MsgSevEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal MsgSevEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NameDetails(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NameDetails

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NameDetails returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NameDetails
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NameDetails: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NameDetailsElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NameDetailsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NameDetailsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NameDetailsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NameDetailsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NameDetailsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NameDetailsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NameDetailsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NameDetailsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NameDetailsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NameLineType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NameLineType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NameLineType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NameLineType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NameLineType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NamePattern(t *testing.T) {
	// Create a default instance
	var elem language2_0.NamePattern

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NamePattern returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 language2_0.NamePattern
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NamePattern: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NamePrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.NamePrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NamePrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.NamePrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NamePrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NetworkElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.NetworkElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NetworkElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.NetworkElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NetworkElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NetworkInterfaceType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.NetworkInterfaceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NetworkInterfaceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.NetworkInterfaceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NetworkInterfaceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NetworkNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.NetworkNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NetworkNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.NetworkNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NetworkNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NetworkType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.NetworkType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NetworkType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.NetworkType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NetworkType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NonEmptyStringType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.NonEmptyStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NonEmptyStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.NonEmptyStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NonEmptyStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NotesElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.NotesElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NotesElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.NotesElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NotesElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NotesElementType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.NotesElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NotesElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.NotesElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NotesElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NotesType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.NotesType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NotesType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.NotesType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NotesType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_NoticeType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.NoticeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal NoticeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.NoticeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal NoticeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectComponentType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ObjectComponentType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectComponentType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ObjectComponentType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectComponentType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ObjectElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ObjectElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectIDPattern(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.ObjectIDPattern

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectIDPattern returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.ObjectIDPattern
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectIDPattern: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectRefElement(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ObjectRefElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectRefElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ObjectRefElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectRefElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectRefElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ObjectRefElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectRefElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ObjectRefElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectRefElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectRefType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ObjectRefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectRefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ObjectRefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectRefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ObjectType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ObjectType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ObjectsType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ObjectsType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ObjectsType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ObjectsType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ObjectsType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OperationEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.OperationEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OperationEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.OperationEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OperationEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OperatorEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.OperatorEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OperatorEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.OperatorEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OperatorEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationFormerNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationFormerNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationFormerNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationFormerNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationFormerNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationKnownAsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationKnownAsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationKnownAsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationKnownAsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationKnownAsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationNameDetails(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationNameDetails

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationNameDetails returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationNameDetails
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationNameDetails: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationNameDetailsElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationNameDetailsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationNameDetailsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationNameDetailsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationNameDetailsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationNameDetailsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationNameDetailsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationNameDetailsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationNameDetailsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationNameDetailsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganisationTypeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OrganisationTypeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganisationTypeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OrganisationTypeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganisationTypeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganizationElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.OrganizationElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganizationElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.OrganizationElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganizationElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OrganizationType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.OrganizationType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OrganizationType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.OrganizationType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OrganizationType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OtherNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.OtherNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OtherNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.OtherNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OtherNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Oval_definitionsElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.Oval_definitionsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Oval_definitionsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.Oval_definitionsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Oval_definitionsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Oval_definitionsElementType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.Oval_definitionsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Oval_definitionsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.Oval_definitionsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Oval_definitionsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OverrideType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.OverrideType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OverrideType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.OverrideType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OverrideType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_OverrideableCPE2idrefType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.OverrideableCPE2idrefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal OverrideableCPE2idrefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.OverrideableCPE2idrefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal OverrideableCPE2idrefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PGPDataElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.PGPDataElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PGPDataElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.PGPDataElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PGPDataElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PGPDataType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.PGPDataType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PGPDataType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.PGPDataType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PGPDataType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ParamType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ParamType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ParamType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ParamType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ParamType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PersonElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PersonElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonName(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.PersonName

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonName returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.PersonName
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonName: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonNameElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.PersonNameElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonNameElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.PersonNameElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonNameElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.PersonNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.PersonNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PersonType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PersonType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PersonType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PersonType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PersonType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PlainTextType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.PlainTextType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PlainTextType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.PlainTextType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PlainTextType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PlatformSpecificationElement(t *testing.T) {
	// Create a default instance
	var elem language2_0.PlatformSpecificationElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PlatformSpecificationElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 language2_0.PlatformSpecificationElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PlatformSpecificationElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PlatformSpecificationElementType(t *testing.T) {
	// Create a default instance
	var elem language2_0.PlatformSpecificationElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PlatformSpecificationElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 language2_0.PlatformSpecificationElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PlatformSpecificationElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PlatformType(t *testing.T) {
	// Create a default instance
	var elem language2_0.PlatformType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PlatformType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 language2_0.PlatformType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PlatformType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PortElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PortElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PortElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PortElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PortElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PortRangeElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PortRangeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PortRangeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PortRangeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PortRangeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PortType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.PortType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PortType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.PortType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PortType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PossibleRestrictionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.PossibleRestrictionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PossibleRestrictionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.PossibleRestrictionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PossibleRestrictionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PossibleValueType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.PossibleValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PossibleValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.PossibleValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PossibleValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxNumberExtensionElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxNumberExtensionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxNumberExtensionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxNumberExtensionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxNumberExtensionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxNumberPrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxNumberPrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxNumberPrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxNumberPrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxNumberPrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostBoxNumberSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostBoxNumberSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostBoxNumberSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostBoxNumberSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostBoxNumberSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostOfficeElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostOfficeElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostOfficeElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostOfficeElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostOfficeElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostOfficeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostOfficeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostOfficeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostOfficeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostOfficeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostOfficeNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostOfficeNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostOfficeNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostOfficeNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostOfficeNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostOfficeNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostOfficeNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostOfficeNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostOfficeNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostOfficeNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostTownElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostTownElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostTownElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostTownElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostTownElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostTownNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostTownNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostTownNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostTownNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostTownNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostTownSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostTownSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostTownSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostTownSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostTownSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalCodeElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalCodeElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalCodeElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalCodeElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalCodeElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalCodeNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalCodeNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalCodeNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalCodeNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalCodeNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalCodeNumberExtensionElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalCodeNumberExtensionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalCodeNumberExtensionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalCodeNumberExtensionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalCodeNumberExtensionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalRouteNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalRouteNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalRouteNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalRouteNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalRouteNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalRouteNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalRouteNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalRouteNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalRouteNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalRouteNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalRouteType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalRouteType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalRouteType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalRouteType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalRouteType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PostalServiceElementsElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PostalServiceElementsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PostalServiceElementsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PostalServiceElementsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PostalServiceElementsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PrecedingTitleElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.PrecedingTitleElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PrecedingTitleElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.PrecedingTitleElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PrecedingTitleElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseLocationElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseLocationElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseLocationElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseLocationElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseLocationElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberPrefixElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberPrefixElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberPrefixElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberPrefixElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberPrefixElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberPrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberPrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberPrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberPrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberPrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberRangeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberRangeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberRangeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberRangeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberRangeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberRangeFromElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberRangeFromElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberRangeFromElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberRangeFromElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberRangeFromElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberRangeToElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberRangeToElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberRangeToElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberRangeToElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberRangeToElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberSuffixElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberSuffixElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberSuffixElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberSuffixElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberSuffixElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_PremiseNumberSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.PremiseNumberSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal PremiseNumberSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.PremiseNumberSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal PremiseNumberSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileIdType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileIdType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileIdType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileIdType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileIdType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileNoteType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileNoteType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileNoteType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileNoteType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileNoteType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileRefineRuleType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileRefineRuleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileRefineRuleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileRefineRuleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileRefineRuleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileRefineValueType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileRefineValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileRefineValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileRefineValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileRefineValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileSelectType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileSelectType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileSelectType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileSelectType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileSelectType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileSetComplexValueType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileSetComplexValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileSetComplexValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileSetComplexValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileSetComplexValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileSetValueType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileSetValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileSetValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileSetValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileSetValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProfileType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ProfileType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProfileType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ProfileType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProfileType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ProtocolElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ProtocolElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ProtocolElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ProtocolElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ProtocolElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RSAKeyValueElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.RSAKeyValueElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RSAKeyValueElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.RSAKeyValueElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RSAKeyValueElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RSAKeyValueType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.RSAKeyValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RSAKeyValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.RSAKeyValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RSAKeyValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RatingEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.RatingEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RatingEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.RatingEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RatingEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReferenceElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.ReferenceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReferenceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.ReferenceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReferenceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReferenceElementType(t *testing.T) {
	// Create a default instance
	var elem dictionary2_0.ReferenceElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReferenceElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 dictionary2_0.ReferenceElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReferenceElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReferenceType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ReferenceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReferenceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ReferenceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReferenceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReferencesType(t *testing.T) {
	// Create a default instance
	var elem dictionary2_0.ReferencesType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReferencesType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 dictionary2_0.ReferencesType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReferencesType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RegexCaptureFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.RegexCaptureFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RegexCaptureFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.RegexCaptureFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RegexCaptureFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RelationshipType(t *testing.T) {
	// Create a default instance
	var elem reporting_core1_1.RelationshipType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RelationshipType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 reporting_core1_1.RelationshipType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RelationshipType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RelationshipsContainerType(t *testing.T) {
	// Create a default instance
	var elem reporting_core1_1.RelationshipsContainerType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RelationshipsContainerType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 reporting_core1_1.RelationshipsContainerType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RelationshipsContainerType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RelationshipsElementType(t *testing.T) {
	// Create a default instance
	var elem reporting_core1_1.RelationshipsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RelationshipsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 reporting_core1_1.RelationshipsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RelationshipsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RemoteResourceElement(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.RemoteResourceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RemoteResourceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.RemoteResourceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RemoteResourceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RemoteResourceElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.RemoteResourceElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RemoteResourceElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.RemoteResourceElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RemoteResourceElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReportRequestType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ReportRequestType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReportRequestType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ReportRequestType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReportRequestType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReportRequestsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ReportRequestsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReportRequestsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ReportRequestsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReportRequestsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReportType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ReportType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReportType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ReportType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReportType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ReportsElementType(t *testing.T) {
	// Create a default instance
	var elem asset_reporting_format1_1.ReportsElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ReportsElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_reporting_format1_1.ReportsElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ReportsElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ResourceElement(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ResourceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ResourceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ResourceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ResourceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ResourceType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ResourceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ResourceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ResourceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ResourceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RestrictionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.RestrictionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RestrictionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.RestrictionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RestrictionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ResultEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ResultEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ResultEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ResultEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ResultEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RetrievalMethodElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.RetrievalMethodElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RetrievalMethodElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.RetrievalMethodElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RetrievalMethodElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RetrievalMethodType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.RetrievalMethodType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RetrievalMethodType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.RetrievalMethodType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RetrievalMethodType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RoleEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.RoleEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RoleEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.RoleEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RoleEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RoleType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.RoleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RoleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.RoleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RoleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RuleElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.RuleElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RuleElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.RuleElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RuleElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RuleIdType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.RuleIdType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RuleIdType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.RuleIdType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RuleIdType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RuleResultType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.RuleResultType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RuleResultType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.RuleResultType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RuleResultType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_RuleType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.RuleType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal RuleType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.RuleType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal RuleType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SPKIDataElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SPKIDataElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SPKIDataElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SPKIDataElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SPKIDataElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SPKIDataType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SPKIDataType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SPKIDataType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SPKIDataType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SPKIDataType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SchemaVersionPattern(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.SchemaVersionPattern

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SchemaVersionPattern returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.SchemaVersionPattern
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SchemaVersionPattern: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SchemaVersionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.SchemaVersionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SchemaVersionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.SchemaVersionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SchemaVersionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ScoreType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ScoreType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ScoreType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ScoreType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ScoreType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SelChoicesType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.SelChoicesType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SelChoicesType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.SelChoicesType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SelChoicesType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SelComplexValueType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.SelComplexValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SelComplexValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.SelComplexValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SelComplexValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SelNumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.SelNumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SelNumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.SelNumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SelNumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SelStringType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.SelStringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SelStringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.SelStringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SelStringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ServedByElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ServedByElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ServedByElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ServedByElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ServedByElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ServiceElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ServiceElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ServiceElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ServiceElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ServiceElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ServiceType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.ServiceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ServiceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.ServiceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ServiceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SetElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.SetElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SetElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.SetElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SetElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SetElementType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.SetElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SetElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.SetElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SetElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SetOperatorEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.SetOperatorEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SetOperatorEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.SetOperatorEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SetOperatorEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SeverityEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.SeverityEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SeverityEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.SeverityEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SeverityEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ShowType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ShowType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ShowType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ShowType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ShowType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignatureElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignatureElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignatureElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignatureElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignatureElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignatureMethodElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignatureMethodElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignatureMethodElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignatureMethodElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignatureMethodElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignatureMethodType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignatureMethodType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignatureMethodType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignatureMethodType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignatureMethodType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignaturePropertiesElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignaturePropertiesElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignaturePropertiesElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignaturePropertiesElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignaturePropertiesElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignaturePropertiesType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignaturePropertiesType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignaturePropertiesType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignaturePropertiesType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignaturePropertiesType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignaturePropertyElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignaturePropertyElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignaturePropertyElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignaturePropertyElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignaturePropertyElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignaturePropertyType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignaturePropertyType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignaturePropertyType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignaturePropertyType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignaturePropertyType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignatureType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.SignatureType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignatureType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.SignatureType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignatureType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignatureValueElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignatureValueElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignatureValueElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignatureValueElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignatureValueElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignatureValueType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignatureValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignatureValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignatureValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignatureValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignedInfoElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignedInfoElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignedInfoElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignedInfoElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignedInfoElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SignedInfoType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.SignedInfoType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SignedInfoType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.SignedInfoType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SignedInfoType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_Simple(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.Simple

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal Simple returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.Simple
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal Simple: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SimpleDatatypeEnumeration(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.SimpleDatatypeEnumeration

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SimpleDatatypeEnumeration returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.SimpleDatatypeEnumeration
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SimpleDatatypeEnumeration: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SoftwareElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SoftwareElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SoftwareElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SoftwareElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SoftwareElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SoftwareType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SoftwareType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SoftwareType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SoftwareType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SoftwareType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SortingCodeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SortingCodeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SortingCodeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SortingCodeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SortingCodeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SplitFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.SplitFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SplitFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.SplitFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SplitFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_StateElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.StateElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal StateElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.StateElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal StateElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_StateIDPattern(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.StateIDPattern

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal StateIDPattern returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.StateIDPattern
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal StateIDPattern: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_StateRefType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.StateRefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal StateRefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.StateRefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal StateRefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_StateType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.StateType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal StateType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.StateType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal StateType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_StatesType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.StatesType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal StatesType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.StatesType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal StatesType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_StatusElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.StatusElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal StatusElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.StatusElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal StatusElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_StatusElementType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.StatusElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal StatusElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.StatusElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal StatusElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_StatusType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.StatusType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal StatusType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.StatusType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal StatusType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubAdministrativeAreaElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubAdministrativeAreaElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubAdministrativeAreaElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubAdministrativeAreaElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubAdministrativeAreaElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubAdministrativeAreaNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubAdministrativeAreaNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubAdministrativeAreaNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubAdministrativeAreaNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubAdministrativeAreaNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseLocationElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseLocationElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseLocationElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseLocationElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseLocationElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseNameElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseNumberPrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseNumberPrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseNumberPrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseNumberPrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseNumberPrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseNumberSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseNumberSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseNumberSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseNumberSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseNumberSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubPremiseType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SubPremiseType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubPremiseType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SubPremiseType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubPremiseType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.SubType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.SubType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubUseEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.SubUseEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubUseEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.SubUseEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubUseEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SubstringFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.SubstringFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SubstringFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.SubstringFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SubstringFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.SuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.SuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SupplementaryPostalServiceDataElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.SupplementaryPostalServiceDataElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SupplementaryPostalServiceDataElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.SupplementaryPostalServiceDataElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SupplementaryPostalServiceDataElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SyntheticIdElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SyntheticIdElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SyntheticIdElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SyntheticIdElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SyntheticIdElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SyntheticIdElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SyntheticIdElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SyntheticIdElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SyntheticIdElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SyntheticIdElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SystemElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SystemElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SystemElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SystemElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SystemElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SystemNameElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SystemNameElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SystemNameElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SystemNameElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SystemNameElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_SystemType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.SystemType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal SystemType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.SystemType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal SystemType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TailoringBenchmarkReferenceType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TailoringBenchmarkReferenceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TailoringBenchmarkReferenceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TailoringBenchmarkReferenceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TailoringBenchmarkReferenceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TailoringElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TailoringElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TailoringElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TailoringElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TailoringElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TailoringIdType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TailoringIdType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TailoringIdType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TailoringIdType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TailoringIdType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TailoringReferenceType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TailoringReferenceType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TailoringReferenceType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TailoringReferenceType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TailoringReferenceType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TailoringType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TailoringType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TailoringType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TailoringType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TailoringType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TailoringVersionType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TailoringVersionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TailoringVersionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TailoringVersionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TailoringVersionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TargetFactsType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TargetFactsType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TargetFactsType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TargetFactsType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TargetFactsType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TargetIdRefType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TargetIdRefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TargetIdRefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TargetIdRefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TargetIdRefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TelephoneNumberElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.TelephoneNumberElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TelephoneNumberElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.TelephoneNumberElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TelephoneNumberElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TelephoneNumberElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.TelephoneNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TelephoneNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.TelephoneNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TelephoneNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TelephoneNumberType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.TelephoneNumberType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TelephoneNumberType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.TelephoneNumberType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TelephoneNumberType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TestElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.TestElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TestElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.TestElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TestElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TestIDPattern(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.TestIDPattern

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TestIDPattern returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.TestIDPattern
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TestIDPattern: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TestResultElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TestResultElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TestResultElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TestResultElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TestResultElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TestResultType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TestResultType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TestResultType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TestResultType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TestResultType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TestType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.TestType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TestType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.TestType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TestType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TestresultIdType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TestresultIdType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TestresultIdType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TestresultIdType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TestresultIdType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TestsType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.TestsType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TestsType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.TestsType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TestsType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TextType(t *testing.T) {
	// Create a default instance
	var elem language2_0.TextType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TextType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 language2_0.TextType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TextType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TextWithSubType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.TextWithSubType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TextWithSubType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.TextWithSubType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TextWithSubType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareLeadingTypeType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareLeadingTypeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareLeadingTypeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareLeadingTypeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareLeadingTypeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNameType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNameType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNameType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNameType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNameType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberFromElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberFromElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberFromElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberFromElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberFromElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberPrefixElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberPrefixElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberPrefixElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberPrefixElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberPrefixElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberPrefixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberPrefixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberPrefixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberPrefixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberPrefixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberRangeElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberRangeElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberRangeElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberRangeElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberRangeElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberSuffixElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberSuffixElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberSuffixElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberSuffixElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberSuffixElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberSuffixElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberSuffixElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberSuffixElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberSuffixElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberSuffixElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareNumberToElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareNumberToElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareNumberToElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareNumberToElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareNumberToElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfarePostDirectionType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfarePostDirectionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfarePostDirectionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfarePostDirectionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfarePostDirectionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfarePreDirectionType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfarePreDirectionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfarePreDirectionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfarePreDirectionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfarePreDirectionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ThoroughfareTrailingTypeType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.ThoroughfareTrailingTypeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ThoroughfareTrailingTypeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.ThoroughfareTrailingTypeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ThoroughfareTrailingTypeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TimeDifferenceFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.TimeDifferenceFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TimeDifferenceFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.TimeDifferenceFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TimeDifferenceFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TitleAttrType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.TitleAttrType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TitleAttrType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.TitleAttrType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TitleAttrType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TitleElement(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.TitleElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TitleElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.TitleElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TitleElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TitleElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.TitleElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TitleElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.TitleElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TitleElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TitleEltType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.TitleEltType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TitleEltType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.TitleEltType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TitleEltType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ToType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.ToType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ToType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.ToType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ToType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TransformElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.TransformElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TransformElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.TransformElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TransformElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TransformType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.TransformType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TransformType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.TransformType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TransformType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TransformsElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.TransformsElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TransformsElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.TransformsElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TransformsElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TransformsType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.TransformsType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TransformsType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.TransformsType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TransformsType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_TypeType(t *testing.T) {
	// Create a default instance
	var elem pkg_1999xlink.TypeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal TypeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_1999xlink.TypeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal TypeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_UniqueFunctionType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.UniqueFunctionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal UniqueFunctionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.UniqueFunctionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal UniqueFunctionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_UriRefType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.UriRefType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal UriRefType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.UriRefType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal UriRefType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_UrlElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.UrlElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal UrlElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.UrlElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal UrlElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ValueElement(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ValueElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ValueElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ValueElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ValueElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ValueIdType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ValueIdType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ValueIdType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ValueIdType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ValueIdType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ValueOperatorType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ValueOperatorType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ValueOperatorType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ValueOperatorType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ValueOperatorType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ValueType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.ValueType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ValueType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.ValueType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ValueType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_ValueTypeType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.ValueTypeType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal ValueTypeType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.ValueTypeType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal ValueTypeType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_VariableComponentType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.VariableComponentType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal VariableComponentType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.VariableComponentType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal VariableComponentType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_VariableElement(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.VariableElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal VariableElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.VariableElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal VariableElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_VariableIDPattern(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.VariableIDPattern

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal VariableIDPattern returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.VariableIDPattern
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal VariableIDPattern: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_VariableType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.VariableType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal VariableType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.VariableType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal VariableType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_VariablesType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_definitions_5.VariablesType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal VariablesType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_definitions_5.VariablesType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal VariablesType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_VersionElementType(t *testing.T) {
	// Create a default instance
	var elem xmlschemaoval_common_5.VersionElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal VersionElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xmlschemaoval_common_5.VersionElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal VersionElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_VersionType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.VersionType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal VersionType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.VersionType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal VersionType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WarningCategoryEnumType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.WarningCategoryEnumType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WarningCategoryEnumType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.WarningCategoryEnumType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WarningCategoryEnumType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WarningType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.WarningType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WarningType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.WarningType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WarningType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WebsiteElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.WebsiteElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WebsiteElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.WebsiteElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WebsiteElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WebsiteType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.WebsiteType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WebsiteType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.WebsiteType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WebsiteType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WebsiteUrlElement(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.WebsiteUrlElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WebsiteUrlElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.WebsiteUrlElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WebsiteUrlElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WebsiteUrlElementType(t *testing.T) {
	// Create a default instance
	var elem asset_identification1_1.WebsiteUrlElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WebsiteUrlElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 asset_identification1_1.WebsiteUrlElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WebsiteUrlElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_WeightType(t *testing.T) {
	// Create a default instance
	var elem xccdf1_2.WeightType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal WeightType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 xccdf1_2.WeightType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal WeightType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_X509DataElement(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.X509DataElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal X509DataElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.X509DataElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal X509DataElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_X509DataType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.X509DataType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal X509DataType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.X509DataType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal X509DataType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_X509IssuerSerialType(t *testing.T) {
	// Create a default instance
	var elem pkg_200009xmldsig.X509IssuerSerialType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal X509IssuerSerialType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_200009xmldsig.X509IssuerSerialType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal X509IssuerSerialType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_XALElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.XALElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal XALElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.XALElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal XALElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_XALElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_0.XALElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal XALElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_0.XALElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal XALElementType: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_XNLElement(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.XNLElement

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal XNLElement returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.XNLElement
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal XNLElement: %d bytes", len(xmlBytes))
}

func TestMarshalUnmarshal_XNLElementType(t *testing.T) {
	// Create a default instance
	var elem pkg_2_01.XNLElementType

	// Marshal to XML
	xmlBytes, err := xml.MarshalIndent(&elem, "", "  ")
	if err != nil {
		t.Logf("Marshal XNLElementType returned error (may be expected for empty struct): %v", err)
		return
	}

	if len(xmlBytes) == 0 {
		t.Error("Marshal should produce non-empty output")
	}

	// Unmarshal back
	var elem2 pkg_2_01.XNLElementType
	err = xml.Unmarshal(xmlBytes, &elem2)
	if err != nil {
		t.Errorf("Unmarshal failed: %v", err)
	}

	t.Logf("Marshal/Unmarshal XNLElementType: %d bytes", len(xmlBytes))
}
