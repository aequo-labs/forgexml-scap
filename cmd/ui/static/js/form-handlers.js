// Xmlschema Editor - Form Handlers
// Auto-generated by forgexml UI generator

const FormHandlers = {
    // Initialize form validation
    initValidation: function(form) {
        const inputs = form.querySelectorAll('input, select, textarea');
        
        inputs.forEach(input => {
            input.addEventListener('blur', () => this.validateField(input));
            input.addEventListener('input', () => this.clearError(input));
        });
    },
    
    // Validate a single field
    validateField: function(input) {
        const field = input.closest('.field');
        let isValid = true;
        let errorMessage = '';
        
        // Required validation
        if (input.required && !input.value.trim()) {
            isValid = false;
            errorMessage = 'This field is required';
        }
        
        // Pattern validation
        if (isValid && input.pattern && input.value) {
            const regex = new RegExp(input.pattern);
            if (!regex.test(input.value)) {
                isValid = false;
                errorMessage = 'Value does not match required pattern';
            }
        }
        
        // Min/max length
        if (isValid && input.minLength && input.value.length < input.minLength) {
            isValid = false;
            errorMessage = `Minimum length is ${input.minLength} characters`;
        }
        
        if (isValid && input.maxLength && input.value.length > input.maxLength) {
            isValid = false;
            errorMessage = `Maximum length is ${input.maxLength} characters`;
        }
        
        // Number validation
        if (isValid && input.type === 'number' && input.value) {
            const num = parseFloat(input.value);
            if (input.min && num < parseFloat(input.min)) {
                isValid = false;
                errorMessage = `Minimum value is ${input.min}`;
            }
            if (input.max && num > parseFloat(input.max)) {
                isValid = false;
                errorMessage = `Maximum value is ${input.max}`;
            }
        }
        
        // Update UI
        if (!isValid) {
            this.showError(field, errorMessage);
        } else {
            this.clearError(input);
            field.classList.add('is-valid');
        }
        
        return isValid;
    },
    
    // Show error on field
    showError: function(field, message) {
        field.classList.add('has-error');
        field.classList.remove('is-valid');
        
        let helpText = field.querySelector('.help.is-danger');
        if (!helpText) {
            helpText = document.createElement('p');
            helpText.className = 'help is-danger';
            field.appendChild(helpText);
        }
        helpText.textContent = message;
    },
    
    // Clear error from field
    clearError: function(input) {
        const field = input.closest('.field');
        field.classList.remove('has-error');
        
        const helpText = field.querySelector('.help.is-danger');
        if (helpText) {
            helpText.remove();
        }
    },
    
    // Validate entire form
    validateForm: function(form) {
        const inputs = form.querySelectorAll('input, select, textarea');
        let isValid = true;
        
        inputs.forEach(input => {
            if (!this.validateField(input)) {
                isValid = false;
            }
        });
        
        return isValid;
    },
    
    // Serialize form to JSON
    serializeForm: function(form) {
        const formData = new FormData(form);
        const data = {};
        
        for (const [key, value] of formData.entries()) {
            // Handle nested fields (e.g., "address.street")
            if (key.includes('.')) {
                const parts = key.split('.');
                let obj = data;
                for (let i = 0; i < parts.length - 1; i++) {
                    obj[parts[i]] = obj[parts[i]] || {};
                    obj = obj[parts[i]];
                }
                obj[parts[parts.length - 1]] = this.convertValue(value, form.elements[key]);
            } else {
                data[key] = this.convertValue(value, form.elements[key]);
            }
        }
        
        return data;
    },
    
    // Convert value based on input type
    convertValue: function(value, input) {
        if (!input) return value;
        
        switch (input.type) {
            case 'number':
                return value ? parseFloat(value) : null;
            case 'checkbox':
                return input.checked;
            default:
                return value || null;
        }
    },
    
    // Add item to repeated field
    addRepeatedItem: function(container, template) {
        const newItem = template.cloneNode(true);
        const index = container.children.length;
        
        // Update field names with new index
        newItem.querySelectorAll('[name]').forEach(el => {
            el.name = el.name.replace('[0]', `[${index}]`);
        });
        
        container.appendChild(newItem);
        this.initValidation(newItem);
    },
    
    // Remove item from repeated field
    removeRepeatedItem: function(item) {
        const container = item.parentElement;
        item.remove();
        
        // Re-index remaining items
        Array.from(container.children).forEach((child, index) => {
            child.querySelectorAll('[name]').forEach(el => {
                el.name = el.name.replace(/\[\d+\]/, `[${index}]`);
            });
        });
    },
    
    // Handle abstract type selection
    handleTypeChange: function(select, formContainer) {
        const typeName = select.value;
        if (!typeName) {
            formContainer.innerHTML = '';
            return;
        }
        
        // Fetch type metadata and render form
        fetch(`/api/types/${encodeURIComponent(typeName)}`)
            .then(response => response.json())
            .then(typeInfo => {
                formContainer.innerHTML = this.renderTypeForm(typeInfo);
                this.initValidation(formContainer);
            })
            .catch(err => {
                formContainer.innerHTML = `<div class="notification is-danger">Failed to load type: ${err.message}</div>`;
            });
    },
    
    // Render form fields for a type
    renderTypeForm: function(typeInfo) {
        if (!typeInfo.fields || typeInfo.fields.length === 0) {
            return '<p class="has-text-grey">No fields</p>';
        }
        
        return typeInfo.fields.map(field => this.renderField(field)).join('');
    },
    
    // Render a single field
    renderField: function(field, value = '') {
        const required = field.isRequired ? 'required' : '';
        const requiredMark = field.isRequired ? '<span class="has-text-danger">*</span>' : '';
        
        let inputHtml = '';
        
        if (field.isEnum && field.enumValues) {
            inputHtml = `<div class="select is-fullwidth">
                <select name="${field.name}" ${required}>
                    <option value="">-- Select --</option>
                    ${field.enumValues.map(v => `<option value="${v}">${v}</option>`).join('')}
                </select>
            </div>`;
        } else if (field.type === 'bool') {
            inputHtml = `<label class="checkbox">
                <input type="checkbox" name="${field.name}"> ${field.name}
            </label>`;
        } else {
            const inputType = this.getInputType(field.type);
            inputHtml = `<input class="input" type="${inputType}" name="${field.name}" value="${value}" ${required}
                ${field.minLength ? `minlength="${field.minLength}"` : ''}
                ${field.maxLength ? `maxlength="${field.maxLength}"` : ''}
                ${field.pattern ? `pattern="${field.pattern}"` : ''}>`;
        }
        
        return `
            <div class="field">
                <label class="label">${field.name} ${requiredMark}</label>
                <div class="control">${inputHtml}</div>
                ${field.documentation ? `<p class="help">${field.documentation}</p>` : ''}
            </div>
        `;
    },
    
    // Get input type for field type
    getInputType: function(fieldType) {
        const typeMap = {
            'int': 'number', 'int8': 'number', 'int16': 'number', 'int32': 'number', 'int64': 'number',
            'uint': 'number', 'uint8': 'number', 'uint16': 'number', 'uint32': 'number', 'uint64': 'number',
            'float32': 'number', 'float64': 'number',
            'time.Time': 'datetime-local',
            'bool': 'checkbox'
        };
        return typeMap[fieldType] || 'text';
    },

    // LocalStorage auto-save functionality
    autoSaveKey: 'github.com/aequo-labs/forgexml-scap/cmd/ui_autosave',
    autoSaveInterval: null,

    // Start auto-save for a form
    startAutoSave: function(form, intervalMs = 30000) {
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
        }
        
        this.autoSaveInterval = setInterval(() => {
            this.saveToLocalStorage(form);
        }, intervalMs);

        // Also save on input changes (debounced)
        let saveTimeout;
        form.addEventListener('input', () => {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => this.saveToLocalStorage(form), 2000);
        });
    },

    // Save form data to localStorage
    saveToLocalStorage: function(form) {
        try {
            const data = this.serializeForm(form);
            const saveData = {
                data: data,
                timestamp: new Date().toISOString(),
                path: window.location.pathname
            };
            localStorage.setItem(this.autoSaveKey, JSON.stringify(saveData));
        } catch (e) {
            console.warn('Failed to auto-save:', e);
        }
    },

    // Check for and offer to restore auto-saved data
    checkAutoSave: function() {
        try {
            const saved = localStorage.getItem(this.autoSaveKey);
            if (!saved) return null;
            
            const saveData = JSON.parse(saved);
            const savedTime = new Date(saveData.timestamp);
            const now = new Date();
            const hoursSinceSave = (now - savedTime) / (1000 * 60 * 60);
            
            // Only offer restore if saved within last 24 hours
            if (hoursSinceSave < 24) {
                return saveData;
            } else {
                this.clearAutoSave();
                return null;
            }
        } catch (e) {
            console.warn('Failed to check auto-save:', e);
            return null;
        }
    },

    // Restore form data from localStorage
    restoreFromLocalStorage: function(form) {
        const saveData = this.checkAutoSave();
        if (!saveData) return false;

        try {
            const data = saveData.data;
            for (const [key, value] of Object.entries(data)) {
                const input = form.elements[key];
                if (input) {
                    if (input.type === 'checkbox') {
                        input.checked = !!value;
                    } else {
                        input.value = value || '';
                    }
                }
            }
            return true;
        } catch (e) {
            console.warn('Failed to restore from auto-save:', e);
            return false;
        }
    },

    // Clear auto-saved data
    clearAutoSave: function() {
        localStorage.removeItem(this.autoSaveKey);
    },

    // Stop auto-save interval
    stopAutoSave: function() {
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
        }
    }
};

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = FormHandlers;
}
