// Xccdf 1.2 Editor - Import/Export Handlers
// Auto-generated by forgexml UI generator

const ImportExport = {
    // Initialize drag and drop
    initDragDrop: function(dropZone, onFile) {
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, e => {
                e.preventDefault();
                e.stopPropagation();
            });
        });
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.add('is-hover');
            });
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, () => {
                dropZone.classList.remove('is-hover');
            });
        });
        
        dropZone.addEventListener('drop', e => {
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                onFile(files[0]);
            }
        });
    },
    
    // Import XML file
    importFile: async function(file) {
        const formData = new FormData();
        formData.append('file', file);
        
        const response = await fetch('/api/import', {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Import failed');
        }
        
        return response.json();
    },
    
    // Export XML
    exportXML: function() {
        window.location.href = '/api/export';
    },
    
    // Get XML preview
    getPreview: async function() {
        const response = await fetch('/api/export/preview');
        if (!response.ok) {
            throw new Error('Failed to get preview');
        }
        return response.text();
    },
    
    // Validate document
    validate: async function() {
        const response = await fetch('/api/validate', {
            method: 'POST'
        });
        
        if (!response.ok) {
            throw new Error('Validation request failed');
        }
        
        return response.json();
    },
    
    // Copy to clipboard
    copyToClipboard: async function(text) {
        if (navigator.clipboard) {
            await navigator.clipboard.writeText(text);
        } else {
            // Fallback for older browsers
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }
    },
    
    // Download as file
    downloadAsFile: function(content, filename, mimeType = 'application/xml') {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        URL.revokeObjectURL(url);
    },
    
    // Read file as text
    readFileAsText: function(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error);
            reader.readAsText(file);
        });
    },
    
    // Format XML for display
    formatXML: function(xml) {
        const PADDING = '  ';
        let formatted = '';
        let pad = 0;
        
        xml.split(/>\s*</).forEach((node, index) => {
            if (index > 0) {
                formatted += '<';
            }
            
            let indent = pad;
            if (node.match(/^\/\w/)) {
                // Closing tag
                indent = --pad;
            } else if (node.match(/^<?\w[^>]*[^\/]$/) && !node.startsWith('?') && !node.startsWith('!')) {
                // Opening tag (not self-closing)
                if (!node.match(/\/$/)) {
                    pad++;
                }
            }
            
            formatted += PADDING.repeat(Math.max(0, indent)) + node;
            if (index < xml.split(/>\s*</).length - 1) {
                formatted += '>\n';
            }
        });
        
        return formatted;
    },
    
    // Syntax highlight XML
    highlightXML: function(xml) {
        return xml
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/(".*?")/g, '<span class="xml-string">$1</span>')
            .replace(/(&lt;\/?)([\w:-]+)/g, '$1<span class="xml-tag">$2</span>')
            .replace(/(\s)([\w:-]+)(=)/g, '$1<span class="xml-attr">$2</span>$3');
    }
};

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ImportExport;
}
