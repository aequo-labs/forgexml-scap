
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aequo-labs/forgexml-scap/cmd/ui/internal/handlers/handlers.go (63.8%)</option>
				
				<option value="file1">github.com/aequo-labs/forgexml-scap/cmd/ui/internal/state/xml_state.go (33.9%)</option>
				
				<option value="file2">github.com/aequo-labs/forgexml-scap/cmd/ui/main.go (0.0%)</option>
				
				<option value="file3">github.com/aequo-labs/forgexml-scap/cmd/validator/main.go (0.0%)</option>
				
				<option value="file4">github.com/aequo-labs/forgexml-scap/cmd/validator/validator.go (0.0%)</option>
				
				<option value="file5">github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/checklists/xccdf/1-2/elements.go (33.6%)</option>
				
				<option value="file6">github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/checklists/xccdf/1-2/types.go (0.0%)</option>
				
				<option value="file7">github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-identification/1-1/elements.go (28.9%)</option>
				
				<option value="file8">github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-identification/1-1/types.go (0.0%)</option>
				
				<option value="file9">github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-reporting-format/1-1/elements.go (32.1%)</option>
				
				<option value="file10">github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-reporting-format/1-1/types.go (0.0%)</option>
				
				<option value="file11">github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1/types.go (0.0%)</option>
				
				<option value="file12">github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xal/2-0/elements.go (32.1%)</option>
				
				<option value="file13">github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xal/2-0/types.go (0.0%)</option>
				
				<option value="file14">github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xnl/2-0/elements.go (32.1%)</option>
				
				<option value="file15">github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xnl/2-0/types.go (0.0%)</option>
				
				<option value="file16">github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/dictionary/2-0/elements.go (33.0%)</option>
				
				<option value="file17">github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/dictionary/2-0/types.go (0.0%)</option>
				
				<option value="file18">github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/language/2-0/elements.go (32.1%)</option>
				
				<option value="file19">github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/language/2-0/types.go (0.0%)</option>
				
				<option value="file20">github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-common-5/elements.go (32.1%)</option>
				
				<option value="file21">github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-common-5/types.go (0.0%)</option>
				
				<option value="file22">github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5/elements.go (22.0%)</option>
				
				<option value="file23">github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5/types.go (0.0%)</option>
				
				<option value="file24">github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/1999/xlink/elements.go (0.0%)</option>
				
				<option value="file25">github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/1999/xlink/types.go (0.0%)</option>
				
				<option value="file26">github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig/elements.go (32.5%)</option>
				
				<option value="file27">github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig/types.go (0.0%)</option>
				
				<option value="file28">github.com/aequo-labs/forgexml-scap/internal/generated/types/datetime.go (96.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by forgexml UI generator. DO NOT EDIT.
package handlers

import (
        "embed"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"

        _ "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/checklists/xccdf/1-2"
        "github.com/aequo-labs/webserver-core-ui/pkg/webserver"

        "github.com/aequo-labs/forgexml-scap/cmd/ui/internal/state"
)

// Handlers provides HTTP handlers for the UI application.
type Handlers struct {
        srv      *webserver.UIServer
        state    *state.XMLDocumentState
        schemaFS embed.FS
}

// NewHandlers creates a new Handlers instance.
func NewHandlers(srv *webserver.UIServer, state *state.XMLDocumentState, schemaFS embed.FS) *Handlers <span class="cov0" title="0">{
        return &amp;Handlers{
                srv:      srv,
                state:    state,
                schemaFS: schemaFS,
        }
}</span>

// HomePageData extends PageData with home page specific fields.
type HomePageData struct {
        webserver.PageData
        RootElementTypes []string
}

// HandleHome renders the home page.
func (h *Handlers) HandleHome(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        baseData := h.srv.GetBasePageData("home")
        baseData.Title = "Xccdf 1.2 Editor - Home"
        data := HomePageData{
                PageData:         baseData,
                RootElementTypes: h.state.GetRootElementTypes(),
        }
        h.srv.RenderPageWithContent(w, "home-content", data)
}</span>

// HandleTreeView renders the tree navigation view.
func (h *Handlers) HandleTreeView(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := h.srv.GetBasePageData("tree")
        data.Title = "Xccdf 1.2 Editor - Tree View"
        h.srv.RenderPageWithContent(w, "tree-content", data)
}</span>

// HandleEditElement renders the edit form for an element.
func (h *Handlers) HandleEditElement(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        path := r.URL.Query().Get("path")
        if path == "" </span><span class="cov0" title="0">{
                http.Error(w, "path parameter required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">data := h.srv.GetBasePageData("edit")
        data.Title = "Xccdf 1.2 Editor - Edit Element"
        h.srv.RenderPageWithContent(w, "edit-content", data)</span>
}

// HandleCreateElement renders the create form for a new element.
func (h *Handlers) HandleCreateElement(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        typeName := r.URL.Query().Get("type")
        if typeName == "" </span><span class="cov0" title="0">{
                http.Error(w, "type parameter required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">data := h.srv.GetBasePageData("create")
        data.Title = "Xccdf 1.2 Editor - Create Element"
        h.srv.RenderPageWithContent(w, "edit-content", data)</span>
}

// HandleExportPage renders the export page.
func (h *Handlers) HandleExportPage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := h.srv.GetBasePageData("export")
        data.Title = "Xccdf 1.2 Editor - Export"
        h.srv.RenderPageWithContent(w, "export-content", data)
}</span>

// Tree API handlers

// HandleTreeRoot returns the root elements of the XML tree.
func (h *Handlers) HandleTreeRoot(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        nodes, err := h.state.GetRootNodes()
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to get root nodes", err, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">h.jsonResponse(w, nodes)</span>
}

// HandleTreeChildren returns child elements of a given path.
func (h *Handlers) HandleTreeChildren(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := r.URL.Query().Get("path")
        if path == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">nodes, err := h.state.GetChildNodes(path)
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to get child nodes", err, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">h.jsonResponse(w, nodes)</span>
}

// HandleTreeElement returns details for a specific element.
func (h *Handlers) HandleTreeElement(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := r.URL.Query().Get("path")
        if path == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">element, err := h.state.GetElement(path)
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to get element", err, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">h.jsonResponse(w, element)</span>
}

// CRUD API handlers

// HandleListElements returns all elements of a given type.
func (h *Handlers) HandleListElements(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        typeName := r.PathValue("type")
        if typeName == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "type parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">elements, err := h.state.ListElementsByType(typeName)
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to list elements", err, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">h.jsonResponse(w, elements)</span>
}

// HandleGetElement returns a single element by path.
func (h *Handlers) HandleGetElement(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := r.URL.Query().Get("path")
        if path == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">element, err := h.state.GetElement(path)
        if err != nil </span><span class="cov8" title="1">{
                h.jsonError(w, "Failed to get element", err, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">h.jsonResponse(w, element)</span>
}

// HandleCreateElementAPI creates a new element.
func (h *Handlers) HandleCreateElementAPI(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req struct {
                Type       string          `json:"type"`
                ParentPath string          `json:"parentPath"`
                Data       json.RawMessage `json:"data"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                h.jsonError(w, "Invalid request body", err, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">path, err := h.state.CreateElement(req.Type, req.ParentPath, req.Data)
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to create element", err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">h.jsonResponse(w, map[string]string{"path": path})</span>
}

// HandleUpdateElement updates an existing element.
func (h *Handlers) HandleUpdateElement(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := r.URL.Query().Get("path")
        if path == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var data json.RawMessage
        if err := json.NewDecoder(r.Body).Decode(&amp;data); err != nil </span><span class="cov8" title="1">{
                h.jsonError(w, "Invalid request body", err, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.state.UpdateElement(path, data); err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to update element", err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">h.jsonResponse(w, map[string]string{"status": "updated"})</span>
}

// HandleDeleteElement deletes an element.
func (h *Handlers) HandleDeleteElement(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        path := r.URL.Query().Get("path")
        if path == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "path parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if err := h.state.DeleteElement(path); err != nil </span><span class="cov8" title="1">{
                h.jsonError(w, "Failed to delete element", err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">h.jsonResponse(w, map[string]string{"status": "deleted"})</span>
}

// Import/Export handlers

// HandleImport imports an XML file.
func (h *Handlers) HandleImport(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if err := r.ParseMultipartForm(32 &lt;&lt; 20); err != nil </span><span class="cov8" title="1">{
                h.jsonError(w, "Failed to parse form", err, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to get uploaded file", err, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        content, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to read file", err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if err := h.state.LoadFromBytes(content, header.Filename); err != nil </span><span class="cov8" title="1">{
                h.jsonError(w, "Failed to parse XML", err, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">h.jsonResponse(w, map[string]string{
                "status":   "imported",
                "filename": header.Filename,
        })</span>
}

// HandleExport exports the current document as XML.
func (h *Handlers) HandleExport(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        content, filename, err := h.state.ExportToBytes()
        if err != nil </span><span class="cov8" title="1">{
                h.jsonError(w, "Failed to export XML", err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/xml")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", filename))
        w.Write(content)</span>
}

// HandleExportPreview returns the XML content without downloading.
func (h *Handlers) HandleExportPreview(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        content, _, err := h.state.ExportToBytes()
        if err != nil </span><span class="cov8" title="1">{
                h.jsonError(w, "Failed to export XML", err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/xml")
        w.Write(content)</span>
}

// HandleValidate validates the current document against the XSD.
func (h *Handlers) HandleValidate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        errors, err := h.state.Validate()
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Validation failed", err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">h.jsonResponse(w, map[string]interface{}{
                "valid":  len(errors) == 0,
                "errors": errors,
        })</span>
}

// Type information handlers

// HandleListTypes returns all available element types.
func (h *Handlers) HandleListTypes(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        types := h.state.GetAvailableTypes()
        h.jsonResponse(w, types)
}</span>

// HandleGetType returns metadata for a specific type.
func (h *Handlers) HandleGetType(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        name := r.PathValue("name")
        if name == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "name parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">typeInfo, err := h.state.GetTypeMetadata(name)
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Type not found", err, http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">h.jsonResponse(w, typeInfo)</span>
}

// HandleGetConcreteTypes returns concrete types for an abstract type.
func (h *Handlers) HandleGetConcreteTypes(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        name := r.PathValue("name")
        if name == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "name parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">types, err := h.state.GetConcreteTypes(name)
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to get concrete types", err, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">h.jsonResponse(w, types)</span>
}

// HandleGetValidChildTypes returns valid child types for a parent type.
func (h *Handlers) HandleGetValidChildTypes(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        name := r.PathValue("name")
        if name == "" </span><span class="cov8" title="1">{
                h.jsonError(w, "name parameter required", nil, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">types := h.state.GetValidChildTypes(name)
        h.jsonResponse(w, types)</span>
}

// HandleGetRootTypes returns types that can be used as document roots.
func (h *Handlers) HandleGetRootTypes(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        types := h.state.GetRootElementTypes()
        h.jsonResponse(w, types)
}</span>

// HandleHealth returns health status for the status indicator.
func (h *Handlers) HandleHealth(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.jsonResponse(w, map[string]interface{}{
                "status":    "healthy",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
        })
}</span>

// HandleInstanceDiagram generates a Mermaid diagram from the current XML document.
func (h *Handlers) HandleInstanceDiagram(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        diagramType := r.URL.Query().Get("type")
        if diagramType == "" </span><span class="cov0" title="0">{
                diagramType = "flowchart"
        }</span>

        <span class="cov0" title="0">diagram, err := h.state.GenerateInstanceDiagram(diagramType)
        if err != nil </span><span class="cov0" title="0">{
                h.jsonError(w, "Failed to generate diagram", err, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">h.jsonResponse(w, map[string]string{
                "diagram": diagram,
                "type":    diagramType,
        })</span>
}

// Helper methods

func (h *Handlers) jsonResponse(w http.ResponseWriter, data interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(data)
}</span>

func (h *Handlers) jsonError(w http.ResponseWriter, message string, err error, status int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        response := map[string]string{"error": message}
        if err != nil </span><span class="cov8" title="1">{
                response["details"] = err.Error()
        }</span>
        <span class="cov8" title="1">json.NewEncoder(w).Encode(response)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by forgexml UI generator. DO NOT EDIT.
package state

import (
        "bytes"
        "encoding/json"
        "encoding/xml"
        "fmt"
        xccdf1_2 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/checklists/xccdf/1-2"
        asset_identification1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-identification/1-1"
        asset_reporting_format1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-reporting-format/1-1"
        reporting_core1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1"
        pkg_2_01 "github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xal/2-0"
        pkg_2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xnl/2-0"
        dictionary2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/dictionary/2-0"
        language2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/language/2-0"
        xmlschemaoval_common_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-common-5"
        xmlschemaoval_definitions_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5"
        pkg_1999xlink "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/1999/xlink"
        pkg_200009xmldsig "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig"
        "os"
        "reflect"
        "regexp"
        "sync"
        "time"
)

// Ensure regexp is used (pattern validation may not be generated for all schemas)
var _ = regexp.MatchString

// TreeNode represents a node in the XML tree navigation.
type TreeNode struct {
        ID          string      `json:"id"`
        Label       string      `json:"label"`
        Type        string      `json:"type"`
        Path        string      `json:"path"`
        HasChildren bool        `json:"hasChildren"`
        Expanded    bool        `json:"expanded"`
        Icon        string      `json:"icon,omitempty"`
        Data        interface{} `json:"data,omitempty"`
}

// TypeMetadata holds information about an element type.
type TypeMetadata struct {
        Name          string      `json:"name"`
        Documentation string      `json:"documentation,omitempty"`
        IsAbstract    bool        `json:"isAbstract"`
        Fields        []FieldInfo `json:"fields"`
}

// FieldInfo holds information about a field.
type FieldInfo struct {
        Name           string   `json:"name"`
        Type           string   `json:"type"`
        IsRequired     bool     `json:"isRequired"`
        IsRepeated     bool     `json:"isRepeated"`
        IsEnum         bool     `json:"isEnum"`
        EnumValues     []string `json:"enumValues,omitempty"`
        Pattern        string   `json:"pattern,omitempty"`
        MinLength      int      `json:"minLength,omitempty"`
        MaxLength      int      `json:"maxLength,omitempty"`
        MinValue       string   `json:"minValue,omitempty"`
        MaxValue       string   `json:"maxValue,omitempty"`
        MinOccurs      int      `json:"minOccurs,omitempty"`
        MaxOccurs      int      `json:"maxOccurs,omitempty"`
        IsChoice       bool     `json:"isChoice,omitempty"`
        ChoiceGroup    string   `json:"choiceGroup,omitempty"`
        IsAny          bool     `json:"isAny,omitempty"`
        IsAnyAttribute bool     `json:"isAnyAttribute,omitempty"`
        Documentation  string   `json:"documentation,omitempty"`
}

// ValidationError represents a validation error.
type ValidationError struct {
        Path    string `json:"path"`
        Message string `json:"message"`
        Line    int    `json:"line,omitempty"`
}

// ElementDetails represents detailed information about an element for the UI.
type ElementDetails struct {
        Label string                 `json:"label"`
        Type  string                 `json:"type"`
        Path  string                 `json:"path"`
        Data  map[string]interface{} `json:"data"`
}

// XMLDocumentState manages the in-memory XML document.
type XMLDocumentState struct {
        mu           sync.RWMutex
        rootElement  interface{}
        rootType     string
        namespace    string
        schemaLocs   map[string]string
        isDirty      bool
        lastModified time.Time
        sourceFile   string
}

// NewXMLDocumentState creates a new empty document state.
func NewXMLDocumentState() *XMLDocumentState <span class="cov8" title="1">{
        return &amp;XMLDocumentState{
                schemaLocs: make(map[string]string),
        }
}</span>

// LoadFromFile loads an XML document from a file.
func (s *XMLDocumentState) LoadFromFile(path string) error <span class="cov8" title="1">{
        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read file: %w", err)
        }</span>
        <span class="cov8" title="1">return s.LoadFromBytes(content, path)</span>
}

// detectRootElementName parses the XML to find the root element's local name.
func detectRootElementName(content []byte) (string, string, error) <span class="cov8" title="1">{
        decoder := xml.NewDecoder(bytes.NewReader(content))
        for </span><span class="cov8" title="1">{
                token, err := decoder.Token()
                if err != nil </span><span class="cov8" title="1">{
                        return "", "", fmt.Errorf("failed to parse XML: %w", err)
                }</span>
                <span class="cov8" title="1">if startElem, ok := token.(xml.StartElement); ok </span><span class="cov8" title="1">{
                        return startElem.Name.Local, startElem.Name.Space, nil
                }</span>
        }
}

// xmlNameToGoType maps XML element names to Go type names.
// Only includes root element types (global elements with proper XMLName tags).
var xmlNameToGoType = map[string]string{
        "Benchmark": "BenchmarkElement",
}

// LoadFromBytes loads an XML document from bytes.
func (s *XMLDocumentState) LoadFromBytes(content []byte, filename string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // First, detect the actual root element name from the XML
        rootName, rootNS, err := detectRootElementName(content)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Map XML element name to Go type
        <span class="cov8" title="1">goType, ok := xmlNameToGoType[rootName]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("unknown root element: %s (namespace: %s)", rootName, rootNS)
        }</span>

        // Unmarshal based on the detected root element type
        <span class="cov8" title="1">switch goType </span>{
        case "BenchmarkElement":<span class="cov8" title="1">
                var root xccdf1_2.BenchmarkElement
                if err := xml.Unmarshal(content, &amp;root); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal BenchmarkElement: %w", err)
                }</span>
                <span class="cov8" title="1">s.rootElement = &amp;root
                s.rootType = "BenchmarkElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.sourceFile = filename
                s.lastModified = time.Now()
                s.isDirty = false
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("no handler for type: %s", goType)</span>
        }
}

// ExportToBytes exports the current document as XML bytes.
func (s *XMLDocumentState) ExportToBytes() ([]byte, string, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if s.rootElement == nil </span><span class="cov8" title="1">{
                return nil, "", fmt.Errorf("no document loaded")
        }</span>

        <span class="cov8" title="1">content, err := xml.MarshalIndent(s.rootElement, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to marshal XML: %w", err)
        }</span>

        // Add XML header
        <span class="cov8" title="1">xmlContent := append([]byte(xml.Header), content...)

        filename := s.sourceFile
        if filename == "" </span><span class="cov8" title="1">{
                filename = "document.xml"
        }</span>

        <span class="cov8" title="1">return xmlContent, filename, nil</span>
}

// GetRootNodes returns the root-level tree nodes.
func (s *XMLDocumentState) GetRootNodes() ([]TreeNode, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if s.rootElement == nil </span><span class="cov8" title="1">{
                return []TreeNode{}, nil
        }</span>

        <span class="cov8" title="1">return []TreeNode{
                {
                        ID:          "/",
                        Label:       s.rootType,
                        Type:        s.rootType,
                        Path:        "/",
                        HasChildren: true,
                        Expanded:    true,
                        Icon:        "fa-file-code",
                },
        }, nil</span>
}

// GetChildNodes returns child nodes for a given path.
func (s *XMLDocumentState) GetChildNodes(path string) ([]TreeNode, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if s.rootElement == nil </span><span class="cov8" title="1">{
                return []TreeNode{}, nil
        }</span>

        // Handle root path - return children of root element
        <span class="cov8" title="1">if path == "/" </span><span class="cov8" title="1">{
                return s.getRootChildNodes()
        }</span>

        // Handle nested paths
        <span class="cov8" title="1">return s.getNestedChildNodes(path)</span>
}

// getRootChildNodes returns child nodes for the root element.
func (s *XMLDocumentState) getRootChildNodes() ([]TreeNode, error) <span class="cov8" title="1">{
        var nodes []TreeNode

        switch root := s.rootElement.(type) </span>{
        case *xccdf1_2.BenchmarkElement:<span class="cov8" title="1">
                _ = root // Ensure root is used even when only static TreeNodes are generated
                // DcStatus is a repeated element
                if len(root.DcStatus) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/dc-status",
                                Label:       fmt.Sprintf("DcStatus (%d)", len(root.DcStatus)),
                                Type:        "DcStatusType",
                                Path:        "/dc-status",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // Title is a repeated element
                <span class="cov8" title="1">if len(root.Title) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/title",
                                Label:       fmt.Sprintf("Title (%d)", len(root.Title)),
                                Type:        "TextType",
                                Path:        "/title",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // Description is a repeated element
                <span class="cov8" title="1">if len(root.Description) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/description",
                                Label:       fmt.Sprintf("Description (%d)", len(root.Description)),
                                Type:        "HtmlTextWithSubType",
                                Path:        "/description",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // Notice is a repeated element
                <span class="cov8" title="1">if len(root.Notice) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/notice",
                                Label:       fmt.Sprintf("Notice (%d)", len(root.Notice)),
                                Type:        "NoticeType",
                                Path:        "/notice",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // FrontMatter is a repeated element
                <span class="cov8" title="1">if len(root.FrontMatter) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/front-matter",
                                Label:       fmt.Sprintf("FrontMatter (%d)", len(root.FrontMatter)),
                                Type:        "HtmlTextWithSubType",
                                Path:        "/front-matter",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // RearMatter is a repeated element
                <span class="cov8" title="1">if len(root.RearMatter) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/rear-matter",
                                Label:       fmt.Sprintf("RearMatter (%d)", len(root.RearMatter)),
                                Type:        "HtmlTextWithSubType",
                                Path:        "/rear-matter",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // Reference is a repeated element
                <span class="cov8" title="1">if len(root.Reference) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/reference",
                                Label:       fmt.Sprintf("Reference (%d)", len(root.Reference)),
                                Type:        "ReferenceType",
                                Path:        "/reference",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // PlainText is a repeated element
                <span class="cov8" title="1">if len(root.PlainText) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/plain-text",
                                Label:       fmt.Sprintf("PlainText (%d)", len(root.PlainText)),
                                Type:        "PlainTextType",
                                Path:        "/plain-text",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // Platform is a repeated element
                <span class="cov8" title="1">if len(root.Platform) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/platform",
                                Label:       fmt.Sprintf("Platform (%d)", len(root.Platform)),
                                Type:        "CPE2idrefType",
                                Path:        "/platform",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // Version is a required element
                <span class="cov8" title="1">nodes = append(nodes, TreeNode{
                        ID:          "/version",
                        Label:       "Version",
                        Type:        "VersionType",
                        Path:        "/version",
                        HasChildren: true,
                        Icon:        "fa-cube",
                })
                // Metadata is a repeated element
                if len(root.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                        nodes = append(nodes, TreeNode{
                                ID:          "/metadata",
                                Label:       fmt.Sprintf("Metadata (%d)", len(root.Metadata)),
                                Type:        "MetadataType",
                                Path:        "/metadata",
                                HasChildren: true,
                                Icon:        "fa-folder",
                        })
                }</span>
                // Signature is a required element
                <span class="cov8" title="1">nodes = append(nodes, TreeNode{
                        ID:          "/signature",
                        Label:       "Signature",
                        Type:        "SignatureType",
                        Path:        "/signature",
                        HasChildren: true,
                        Icon:        "fa-cube",
                })</span>
        }

        <span class="cov8" title="1">return nodes, nil</span>
}

// getNestedChildNodes returns child nodes for a nested path.
func (s *XMLDocumentState) getNestedChildNodes(path string) ([]TreeNode, error) <span class="cov8" title="1">{
        var nodes []TreeNode

        // Parse path - remove leading slash and get first segment
        parts := splitPath(path)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return nodes, nil
        }</span>

        // Handle first-level children of root (e.g., /report-requests, /assets, /reports)
        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                return s.getFirstLevelChildNodes(parts[0])
        }</span>

        // For deeper paths, parse index if present (e.g., /report-requests/0)
        // This requires more complex traversal - return empty for now
        <span class="cov8" title="1">return nodes, nil</span>
}

// getFirstLevelChildNodes returns child nodes for a first-level element.
func (s *XMLDocumentState) getFirstLevelChildNodes(name string) ([]TreeNode, error) <span class="cov8" title="1">{
        var nodes []TreeNode

        switch root := s.rootElement.(type) </span>{
        case *xccdf1_2.BenchmarkElement:<span class="cov8" title="1">
                _ = root // Ensure root is used even when element fields don't access it directly
                if name == "dc-status" &amp;&amp; len(root.DcStatus) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.DcStatus </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("DcStatus[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/dc-status/%d", i),
                                        Label:       label,
                                        Type:        "DcStatusType",
                                        Path:        fmt.Sprintf("/dc-status/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "title" &amp;&amp; len(root.Title) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.Title </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("Title[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/title/%d", i),
                                        Label:       label,
                                        Type:        "TextType",
                                        Path:        fmt.Sprintf("/title/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "description" &amp;&amp; len(root.Description) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.Description </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("Description[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/description/%d", i),
                                        Label:       label,
                                        Type:        "HtmlTextWithSubType",
                                        Path:        fmt.Sprintf("/description/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "notice" &amp;&amp; len(root.Notice) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.Notice </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("Notice[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/notice/%d", i),
                                        Label:       label,
                                        Type:        "NoticeType",
                                        Path:        fmt.Sprintf("/notice/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "front-matter" &amp;&amp; len(root.FrontMatter) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.FrontMatter </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("FrontMatter[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/front-matter/%d", i),
                                        Label:       label,
                                        Type:        "HtmlTextWithSubType",
                                        Path:        fmt.Sprintf("/front-matter/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "rear-matter" &amp;&amp; len(root.RearMatter) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.RearMatter </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("RearMatter[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/rear-matter/%d", i),
                                        Label:       label,
                                        Type:        "HtmlTextWithSubType",
                                        Path:        fmt.Sprintf("/rear-matter/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "reference" &amp;&amp; len(root.Reference) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.Reference </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("Reference[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/reference/%d", i),
                                        Label:       label,
                                        Type:        "ReferenceType",
                                        Path:        fmt.Sprintf("/reference/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "plain-text" &amp;&amp; len(root.PlainText) &gt; 0 </span><span class="cov0" title="0">{
                        for i, item := range root.PlainText </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("PlainText[%d]", i)
                                // Use Id field for better label if available
                                if item.Id != "" </span><span class="cov0" title="0">{
                                        label = item.Id
                                }</span>
                                <span class="cov0" title="0">nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/plain-text/%d", i),
                                        Label:       label,
                                        Type:        "PlainTextType",
                                        Path:        fmt.Sprintf("/plain-text/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })</span>
                        }
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "platform" &amp;&amp; len(root.Platform) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.Platform </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("Platform[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/platform/%d", i),
                                        Label:       label,
                                        Type:        "CPE2idrefType",
                                        Path:        fmt.Sprintf("/platform/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "version" </span><span class="cov8" title="1">{
                        // Required element - traverse into its child fields
                        return nodes, nil
                }</span>
                <span class="cov8" title="1">if name == "metadata" &amp;&amp; len(root.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range root.Metadata </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("Metadata[%d]", i)
                                nodes = append(nodes, TreeNode{
                                        ID:          fmt.Sprintf("/metadata/%d", i),
                                        Label:       label,
                                        Type:        "MetadataType",
                                        Path:        fmt.Sprintf("/metadata/%d", i),
                                        HasChildren: true,
                                        Icon:        "fa-cube",
                                })
                        }</span>
                        <span class="cov0" title="0">return nodes, nil</span>
                }
                <span class="cov8" title="1">if name == "signature" </span><span class="cov8" title="1">{
                        // Required element - traverse into its child fields
                        return nodes, nil
                }</span>
        }

        <span class="cov8" title="1">return nodes, nil</span>
}

// GetElement returns the element details at the given path.
func (s *XMLDocumentState) GetElement(path string) (*ElementDetails, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if s.rootElement == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no document loaded")
        }</span>

        <span class="cov8" title="1">if path == "/" </span><span class="cov8" title="1">{
                return s.getRootElementDetails()
        }</span>

        <span class="cov8" title="1">return s.getElementAtPath(path)</span>
}

// getRootElementDetails returns details for the root element.
func (s *XMLDocumentState) getRootElementDetails() (*ElementDetails, error) <span class="cov8" title="1">{
        data := make(map[string]interface{})

        switch root := s.rootElement.(type) </span>{
        case *xccdf1_2.BenchmarkElement:<span class="cov8" title="1">
                _ = root // Ensure root is used even when no attribute fields match
                data["id"] = root.Id
                if root.Id2 != nil </span><span class="cov0" title="0">{
                        data["Id"] = *root.Id2
                }</span>
                <span class="cov8" title="1">if root.Resolved != nil </span><span class="cov0" title="0">{
                        data["resolved"] = *root.Resolved
                }</span>
                <span class="cov8" title="1">if root.Style != nil </span><span class="cov0" title="0">{
                        data["style"] = *root.Style
                }</span>
                <span class="cov8" title="1">if root.StyleHref != nil </span><span class="cov0" title="0">{
                        data["style-href"] = *root.StyleHref
                }</span>
        }

        <span class="cov8" title="1">return &amp;ElementDetails{
                Label: s.rootType,
                Type:  s.rootType,
                Path:  "/",
                Data:  data,
        }, nil</span>
}

// getElementAtPath returns details for an element at a nested path.
func (s *XMLDocumentState) getElementAtPath(path string) (*ElementDetails, error) <span class="cov8" title="1">{
        // Parse the path to get element name
        // Path format: /elementName or /elementName[index]
        parts := splitPath(path)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid path: %s", path)
        }</span>

        // For now, handle first-level children
        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                return s.getFirstLevelElement(parts[0])
        }</span>

        // Deep path traversal - return basic info for now
        <span class="cov8" title="1">return &amp;ElementDetails{
                Label: parts[len(parts)-1],
                Type:  "unknown",
                Path:  path,
                Data:  map[string]interface{}{"info": "Deep path traversal not yet implemented"},
        }, nil</span>
}

// splitPath splits a path into its component parts.
func splitPath(path string) []string <span class="cov8" title="1">{
        if path == "" || path == "/" </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Remove leading slash
        <span class="cov8" title="1">if path[0] == '/' </span><span class="cov8" title="1">{
                path = path[1:]
        }</span>
        // Split by /
        <span class="cov8" title="1">var parts []string
        for _, p := range bytes.Split([]byte(path), []byte("/")) </span><span class="cov8" title="1">{
                if len(p) &gt; 0 </span><span class="cov8" title="1">{
                        parts = append(parts, string(p))
                }</span>
        }
        <span class="cov8" title="1">return parts</span>
}

// getFirstLevelElement returns details for a first-level child element.
func (s *XMLDocumentState) getFirstLevelElement(name string) (*ElementDetails, error) <span class="cov8" title="1">{
        data := make(map[string]interface{})
        var label, typeName string

        switch root := s.rootElement.(type) </span>{
        case *xccdf1_2.BenchmarkElement:<span class="cov8" title="1">
                _ = root // Ensure root is used even when only static data is set
                switch name </span>{
                case "dc-status":<span class="cov0" title="0">
                        label = "DcStatus"
                        typeName = "DcStatusType"
                        data["count"] = len(root.DcStatus)
                        if len(root.DcStatus) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d DcStatus elements", len(root.DcStatus))
                        }</span>
                case "title":<span class="cov0" title="0">
                        label = "Title"
                        typeName = "TextType"
                        data["count"] = len(root.Title)
                        if len(root.Title) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d Title elements", len(root.Title))
                        }</span>
                case "description":<span class="cov0" title="0">
                        label = "Description"
                        typeName = "HtmlTextWithSubType"
                        data["count"] = len(root.Description)
                        if len(root.Description) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d Description elements", len(root.Description))
                        }</span>
                case "notice":<span class="cov0" title="0">
                        label = "Notice"
                        typeName = "NoticeType"
                        data["count"] = len(root.Notice)
                        if len(root.Notice) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d Notice elements", len(root.Notice))
                        }</span>
                case "front-matter":<span class="cov0" title="0">
                        label = "FrontMatter"
                        typeName = "HtmlTextWithSubType"
                        data["count"] = len(root.FrontMatter)
                        if len(root.FrontMatter) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d FrontMatter elements", len(root.FrontMatter))
                        }</span>
                case "rear-matter":<span class="cov0" title="0">
                        label = "RearMatter"
                        typeName = "HtmlTextWithSubType"
                        data["count"] = len(root.RearMatter)
                        if len(root.RearMatter) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d RearMatter elements", len(root.RearMatter))
                        }</span>
                case "reference":<span class="cov0" title="0">
                        label = "Reference"
                        typeName = "ReferenceType"
                        data["count"] = len(root.Reference)
                        if len(root.Reference) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d Reference elements", len(root.Reference))
                        }</span>
                case "plain-text":<span class="cov0" title="0">
                        label = "PlainText"
                        typeName = "PlainTextType"
                        data["count"] = len(root.PlainText)
                        if len(root.PlainText) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d PlainText elements", len(root.PlainText))
                        }</span>
                case "platform":<span class="cov0" title="0">
                        label = "Platform"
                        typeName = "CPE2idrefType"
                        data["count"] = len(root.Platform)
                        if len(root.Platform) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d Platform elements", len(root.Platform))
                        }</span>
                case "version":<span class="cov8" title="1">
                        label = "Version"
                        typeName = "VersionType"
                        data["present"] = true</span>
                case "metadata":<span class="cov0" title="0">
                        label = "Metadata"
                        typeName = "MetadataType"
                        data["count"] = len(root.Metadata)
                        if len(root.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                                data["info"] = fmt.Sprintf("Contains %d Metadata elements", len(root.Metadata))
                        }</span>
                case "signature":<span class="cov0" title="0">
                        label = "Signature"
                        typeName = "SignatureType"
                        data["present"] = true</span>
                }
        }

        <span class="cov8" title="1">if typeName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("element not found: %s", name)
        }</span>

        <span class="cov8" title="1">return &amp;ElementDetails{
                Label: label,
                Type:  typeName,
                Path:  "/" + name,
                Data:  data,
        }, nil</span>
}

// ListElementsByType returns all elements of a given type.
func (s *XMLDocumentState) ListElementsByType(typeName string) ([]interface{}, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // TODO: Implement type-based element search
        return []interface{}{}, nil
}</span>

// CreateElement creates a new element of the given type.
func (s *XMLDocumentState) CreateElement(typeName, parentPath string, data json.RawMessage) (string, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // If no parent path, this is creating a root document
        if parentPath == "" || parentPath == "/" </span><span class="cov8" title="1">{
                return s.createRootElement(typeName, data)
        }</span>

        // Otherwise, create a child element
        <span class="cov0" title="0">return s.createChildElement(typeName, parentPath, data)</span>
}

// createRootElement creates a new root document element.
func (s *XMLDocumentState) createRootElement(typeName string, data json.RawMessage) (string, error) <span class="cov8" title="1">{
        switch typeName </span>{
        case "ActuateType":<span class="cov8" title="1">
                var element pkg_1999xlink.ActuateType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov8" title="1">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("failed to unmarshal data for ActuateType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ActuateType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressDetails":<span class="cov8" title="1">
                var element pkg_2_01.AddressDetails
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressDetails: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressDetails"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressDetailsElement":<span class="cov8" title="1">
                var element pkg_2_01.AddressDetailsElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressDetailsElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressDetailsElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressElementType":<span class="cov8" title="1">
                var element pkg_2_01.AddressElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressIdentifierElementType":<span class="cov8" title="1">
                var element pkg_2_01.AddressIdentifierElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressIdentifierElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressIdentifierElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressLatitudeDirectionElementType":<span class="cov8" title="1">
                var element pkg_2_01.AddressLatitudeDirectionElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressLatitudeDirectionElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressLatitudeDirectionElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressLatitudeElementType":<span class="cov8" title="1">
                var element pkg_2_01.AddressLatitudeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressLatitudeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressLatitudeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressLineElement":<span class="cov8" title="1">
                var element pkg_2_01.AddressLineElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressLineElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressLineElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressLineElementType":<span class="cov8" title="1">
                var element pkg_2_01.AddressLineElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressLineElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressLineElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressLinesType":<span class="cov8" title="1">
                var element pkg_2_01.AddressLinesType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressLinesType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressLinesType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressLongitudeDirectionElementType":<span class="cov8" title="1">
                var element pkg_2_01.AddressLongitudeDirectionElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressLongitudeDirectionElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressLongitudeDirectionElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddressLongitudeElementType":<span class="cov8" title="1">
                var element pkg_2_01.AddressLongitudeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddressLongitudeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddressLongitudeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AddresseeIndicatorElementType":<span class="cov8" title="1">
                var element pkg_2_0.AddresseeIndicatorElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AddresseeIndicatorElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AddresseeIndicatorElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AdministrativeAreaElement":<span class="cov8" title="1">
                var element pkg_2_01.AdministrativeAreaElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AdministrativeAreaElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AdministrativeAreaElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AdministrativeAreaElementType":<span class="cov8" title="1">
                var element pkg_2_01.AdministrativeAreaElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AdministrativeAreaElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AdministrativeAreaElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AdministrativeAreaNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.AdministrativeAreaNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AdministrativeAreaNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AdministrativeAreaNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AffectedType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.AffectedType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AffectedType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AffectedType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AliasElementType":<span class="cov8" title="1">
                var element pkg_2_0.AliasElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AliasElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AliasElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ArcElement":<span class="cov8" title="1">
                var element pkg_1999xlink.ArcElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ArcElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ArcElement"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ArcType":<span class="cov8" title="1">
                var element pkg_1999xlink.ArcType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ArcType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ArcType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ArcroleType":<span class="cov8" title="1">
                var element pkg_1999xlink.ArcroleType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ArcroleType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ArcroleType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ArithmeticEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.ArithmeticEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ArithmeticEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ArithmeticEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ArithmeticFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.ArithmeticFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ArithmeticFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ArithmeticFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetElement":<span class="cov8" title="1">
                var element asset_identification1_1.AssetElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.AssetElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetIdentificationType":<span class="cov8" title="1">
                var element asset_identification1_1.AssetIdentificationType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetIdentificationType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetIdentificationType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetRelatedElement":<span class="cov8" title="1">
                var element asset_identification1_1.AssetRelatedElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetRelatedElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetRelatedElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetReportCollectionElement":<span class="cov8" title="1">
                var element asset_reporting_format1_1.AssetReportCollectionElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetReportCollectionElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetReportCollectionElement"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetReportCollectionElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.AssetReportCollectionElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetReportCollectionElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetReportCollectionElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetsElement":<span class="cov8" title="1">
                var element asset_identification1_1.AssetsElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetsElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetsElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetsElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.AssetsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetsElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "AssetsType":<span class="cov8" title="1">
                var element asset_identification1_1.AssetsType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for AssetsType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "AssetsType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "BarcodeElementType":<span class="cov8" title="1">
                var element pkg_2_01.BarcodeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for BarcodeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "BarcodeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "BeginFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.BeginFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for BeginFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "BeginFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "BenchmarkElement":<span class="cov8" title="1">
                var element xccdf1_2.BenchmarkElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for BenchmarkElement: %w", err)
                        }</span>
                }
                // Initialize XMLName for proper XML serialization (root elements only)
                <span class="cov8" title="1">element.XMLName = xml.Name{Space: "http://checklists.nist.gov/xccdf/1.2", Local: "Benchmark"}
                s.rootElement = &amp;element
                s.rootType = "BenchmarkElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "BenchmarkElementType":<span class="cov8" title="1">
                var element xccdf1_2.BenchmarkElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for BenchmarkElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "BenchmarkElementType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "BenchmarkIdType":<span class="cov8" title="1">
                var element xccdf1_2.BenchmarkIdType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for BenchmarkIdType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "BenchmarkIdType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "BenchmarkReferenceType":<span class="cov8" title="1">
                var element xccdf1_2.BenchmarkReferenceType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for BenchmarkReferenceType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "BenchmarkReferenceType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "BirthdateElementType":<span class="cov8" title="1">
                var element asset_identification1_1.BirthdateElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for BirthdateElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "BirthdateElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "BuildingNameType":<span class="cov8" title="1">
                var element pkg_2_01.BuildingNameType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for BuildingNameType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "BuildingNameType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CPE2idrefType":<span class="cov8" title="1">
                var element xccdf1_2.CPE2idrefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CPE2idrefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CPE2idrefType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CanonicalizationMethodElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.CanonicalizationMethodElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CanonicalizationMethodElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CanonicalizationMethodElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CanonicalizationMethodType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.CanonicalizationMethodType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CanonicalizationMethodType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CanonicalizationMethodType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CcOperatorEnumType":<span class="cov8" title="1">
                var element xccdf1_2.CcOperatorEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CcOperatorEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CcOperatorEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CheckContentRefType":<span class="cov8" title="1">
                var element xccdf1_2.CheckContentRefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CheckContentRefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CheckContentRefType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CheckContentType":<span class="cov8" title="1">
                var element xccdf1_2.CheckContentType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CheckContentType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CheckContentType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CheckEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.CheckEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CheckEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CheckEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CheckExportType":<span class="cov8" title="1">
                var element xccdf1_2.CheckExportType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CheckExportType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CheckExportType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CheckImportType":<span class="cov8" title="1">
                var element xccdf1_2.CheckImportType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CheckImportType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CheckImportType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CheckType":<span class="cov8" title="1">
                var element xccdf1_2.CheckType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CheckType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CheckType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CidrElementType":<span class="cov8" title="1">
                var element asset_identification1_1.CidrElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CidrElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CidrElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CidrType":<span class="cov8" title="1">
                var element asset_identification1_1.CidrType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CidrType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CidrType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CircuitElement":<span class="cov8" title="1">
                var element asset_identification1_1.CircuitElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CircuitElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CircuitElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CircuitNameElementType":<span class="cov8" title="1">
                var element asset_identification1_1.CircuitNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CircuitNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CircuitNameElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CircuitType":<span class="cov8" title="1">
                var element asset_identification1_1.CircuitType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CircuitType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CircuitType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ClassEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.ClassEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ClassEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ClassEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ComplexCheckType":<span class="cov8" title="1">
                var element xccdf1_2.ComplexCheckType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ComplexCheckType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ComplexCheckType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ComplexDatatypeEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.ComplexDatatypeEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ComplexDatatypeEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ComplexDatatypeEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ComplexValueType":<span class="cov8" title="1">
                var element xccdf1_2.ComplexValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ComplexValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ComplexValueType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ComputingDeviceElement":<span class="cov8" title="1">
                var element asset_identification1_1.ComputingDeviceElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ComputingDeviceElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ComputingDeviceElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ComputingDeviceType":<span class="cov8" title="1">
                var element asset_identification1_1.ComputingDeviceType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ComputingDeviceType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ComputingDeviceType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ConcatFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.ConcatFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ConcatFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ConcatFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ConnectionsElementType":<span class="cov8" title="1">
                var element asset_identification1_1.ConnectionsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ConnectionsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ConnectionsElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Constant_variableElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.Constant_variableElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Constant_variableElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Constant_variableElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Constant_variableElementType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.Constant_variableElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Constant_variableElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Constant_variableElementType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ContentElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ContentElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ContentElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ContentElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ContentElementType1":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ContentElementType1
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ContentElementType1: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ContentElementType1"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CountFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.CountFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CountFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CountFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CountryElementType":<span class="cov8" title="1">
                var element pkg_2_01.CountryElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CountryElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CountryElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CountryNameCodeElementType":<span class="cov8" title="1">
                var element pkg_2_01.CountryNameCodeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CountryNameCodeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CountryNameCodeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CountryNameElement":<span class="cov8" title="1">
                var element pkg_2_01.CountryNameElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CountryNameElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CountryNameElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CountryNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.CountryNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CountryNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CountryNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CpeElement":<span class="cov8" title="1">
                var element asset_identification1_1.CpeElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CpeElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CpeElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CpeElementType":<span class="cov8" title="1">
                var element asset_identification1_1.CpeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CpeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CpeElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CpeItemElement":<span class="cov8" title="1">
                var element dictionary2_0.CpeItemElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CpeItemElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CpeItemElement"
                s.namespace = "http://cpe.mitre.org/dictionary/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CpeListElement":<span class="cov8" title="1">
                var element dictionary2_0.CpeListElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CpeListElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CpeListElement"
                s.namespace = "http://cpe.mitre.org/dictionary/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CpeType":<span class="cov8" title="1">
                var element asset_identification1_1.CpeType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CpeType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CpeType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CriteriaType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.CriteriaType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CriteriaType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CriteriaType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CriterionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.CriterionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CriterionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CriterionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "CryptoBinary":<span class="cov8" title="1">
                var element pkg_200009xmldsig.CryptoBinary
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for CryptoBinary: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "CryptoBinary"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DSAKeyValueElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.DSAKeyValueElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DSAKeyValueElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DSAKeyValueElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DSAKeyValueType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.DSAKeyValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DSAKeyValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DSAKeyValueType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DataElement":<span class="cov8" title="1">
                var element asset_identification1_1.DataElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DataElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DataElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DataType":<span class="cov8" title="1">
                var element asset_identification1_1.DataType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DataType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DataType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DatabaseElement":<span class="cov8" title="1">
                var element asset_identification1_1.DatabaseElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DatabaseElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DatabaseElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DatabaseType":<span class="cov8" title="1">
                var element asset_identification1_1.DatabaseType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DatabaseType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DatabaseType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DatatypeEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.DatatypeEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DatatypeEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DatatypeEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DateTimeFormatEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.DateTimeFormatEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DateTimeFormatEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DateTimeFormatEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DcStatusType":<span class="cov8" title="1">
                var element xccdf1_2.DcStatusType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DcStatusType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DcStatusType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DefinitionElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.DefinitionElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DefinitionElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DefinitionElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DefinitionIDPattern":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.DefinitionIDPattern
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DefinitionIDPattern: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DefinitionIDPattern"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DefinitionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.DefinitionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DefinitionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DefinitionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DefinitionsType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.DefinitionsType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DefinitionsType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DefinitionsType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DepartmentElement":<span class="cov8" title="1">
                var element pkg_2_01.DepartmentElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DepartmentElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DepartmentElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DepartmentElementType":<span class="cov8" title="1">
                var element pkg_2_01.DepartmentElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DepartmentElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DepartmentElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DepartmentNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.DepartmentNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DepartmentNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DepartmentNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DependencyNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.DependencyNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DependencyNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DependencyNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DependentLocalityNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.DependentLocalityNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DependentLocalityNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DependentLocalityNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DependentLocalityNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.DependentLocalityNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DependentLocalityNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DependentLocalityNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DependentLocalityType":<span class="cov8" title="1">
                var element pkg_2_01.DependentLocalityType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DependentLocalityType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DependentLocalityType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DependentThoroughfareElementType":<span class="cov8" title="1">
                var element pkg_2_01.DependentThoroughfareElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DependentThoroughfareElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DependentThoroughfareElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DeprecatedInfoType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.DeprecatedInfoType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DeprecatedInfoType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DeprecatedInfoType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Deprecated_infoElement":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.Deprecated_infoElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Deprecated_infoElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Deprecated_infoElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DigestMethodElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.DigestMethodElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DigestMethodElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DigestMethodElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DigestMethodType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.DigestMethodType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DigestMethodType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DigestMethodType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DigestValueElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.DigestValueElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DigestValueElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DigestValueElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DigestValueType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.DigestValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DigestValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DigestValueType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DistinguishedNameElementType":<span class="cov8" title="1">
                var element asset_identification1_1.DistinguishedNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DistinguishedNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DistinguishedNameElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "DocumentRootElementType":<span class="cov8" title="1">
                var element asset_identification1_1.DocumentRootElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for DocumentRootElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "DocumentRootElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ElementMapItemType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.ElementMapItemType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ElementMapItemType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ElementMapItemType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ElementMapType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.ElementMapType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ElementMapType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ElementMapType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Element_mappingElement":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.Element_mappingElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Element_mappingElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Element_mappingElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EmailAddressElement":<span class="cov8" title="1">
                var element asset_identification1_1.EmailAddressElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EmailAddressElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EmailAddressElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EmailAddressElementType":<span class="cov8" title="1">
                var element asset_identification1_1.EmailAddressElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EmailAddressElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EmailAddressElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EmptyStringType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.EmptyStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EmptyStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EmptyStringType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EndFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EndFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EndFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EndFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EndorsementLineCodeElementType":<span class="cov8" title="1">
                var element pkg_2_01.EndorsementLineCodeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EndorsementLineCodeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EndorsementLineCodeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectAnySimpleType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectAnySimpleType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectAnySimpleType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectAnySimpleType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectBinaryType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectBinaryType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectBinaryType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectBinaryType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectBoolType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectBoolType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectBoolType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectBoolType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectFieldType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectFieldType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectFieldType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectFieldType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectFloatType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectFloatType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectFloatType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectFloatType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectIPAddressStringType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectIPAddressStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectIPAddressStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectIPAddressStringType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectIPAddressType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectIPAddressType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectIPAddressType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectIPAddressType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectIntType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectIntType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectIntType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectIntType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectRecordType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectRecordType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectRecordType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectRecordType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectStringType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectStringType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityObjectVersionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityObjectVersionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityObjectVersionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityObjectVersionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateAnySimpleType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateAnySimpleType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateAnySimpleType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateAnySimpleType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateBinaryType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateBinaryType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateBinaryType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateBinaryType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateBoolType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateBoolType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateBoolType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateBoolType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateDebianEVRStringType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateDebianEVRStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateDebianEVRStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateDebianEVRStringType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateEVRStringType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateEVRStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateEVRStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateEVRStringType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateFieldType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateFieldType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateFieldType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateFieldType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateFileSetRevisionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateFileSetRevisionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateFileSetRevisionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateFileSetRevisionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateFloatType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateFloatType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateFloatType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateFloatType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateIOSVersionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateIOSVersionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateIOSVersionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateIOSVersionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateIPAddressStringType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateIPAddressStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateIPAddressStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateIPAddressStringType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateIPAddressType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateIPAddressType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateIPAddressType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateIPAddressType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateIntType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateIntType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateIntType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateIntType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateRecordType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateRecordType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateRecordType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateRecordType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateStringType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateStringType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EntityStateVersionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EntityStateVersionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EntityStateVersionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EntityStateVersionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "EscapeRegexFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.EscapeRegexFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for EscapeRegexFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "EscapeRegexFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ExistenceEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.ExistenceEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ExistenceEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ExistenceEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ExtendDefinitionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.ExtendDefinitionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ExtendDefinitionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ExtendDefinitionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Extended":<span class="cov8" title="1">
                var element pkg_1999xlink.Extended
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Extended: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Extended"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ExtendedInfoElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ExtendedInfoElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ExtendedInfoElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ExtendedInfoElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ExtendedInformationElementType":<span class="cov8" title="1">
                var element asset_identification1_1.ExtendedInformationElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ExtendedInformationElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ExtendedInformationElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ExtendedInfosElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ExtendedInfosElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ExtendedInfosElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ExtendedInfosElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "External_variableElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.External_variableElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for External_variableElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "External_variableElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "External_variableElementType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.External_variableElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for External_variableElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "External_variableElementType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FactRefType":<span class="cov8" title="1">
                var element language2_0.FactRefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FactRefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FactRefType"
                s.namespace = "http://cpe.mitre.org/language/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FactType":<span class="cov8" title="1">
                var element xccdf1_2.FactType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FactType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FactType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FamilyEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.FamilyEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FamilyEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FamilyEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FilterActionEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.FilterActionEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FilterActionEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FilterActionEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FilterElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.FilterElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FilterElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FilterElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FilterElementType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.FilterElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FilterElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FilterElementType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FirmNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.FirmNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FirmNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FirmNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FirmType":<span class="cov8" title="1">
                var element pkg_2_01.FirmType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FirmType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FirmType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FirstNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.FirstNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FirstNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FirstNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FixStrategyEnumType":<span class="cov8" title="1">
                var element xccdf1_2.FixStrategyEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FixStrategyEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FixStrategyEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FixTextType":<span class="cov8" title="1">
                var element xccdf1_2.FixTextType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FixTextType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FixTextType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FixType":<span class="cov8" title="1">
                var element xccdf1_2.FixType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FixType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FixType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FormerNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.FormerNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FormerNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FormerNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FqdnElement":<span class="cov8" title="1">
                var element asset_identification1_1.FqdnElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FqdnElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FqdnElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FqdnElementType":<span class="cov8" title="1">
                var element asset_identification1_1.FqdnElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FqdnElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FqdnElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FromType":<span class="cov8" title="1">
                var element pkg_1999xlink.FromType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FromType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FromType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Function":<span class="cov8" title="1">
                var element pkg_2_0.Function
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Function: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Function"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "FunctionElement":<span class="cov8" title="1">
                var element pkg_2_0.FunctionElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for FunctionElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "FunctionElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "GeneralSuffixElementType":<span class="cov8" title="1">
                var element pkg_2_0.GeneralSuffixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for GeneralSuffixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "GeneralSuffixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "GenerationIdentifierElementType":<span class="cov8" title="1">
                var element pkg_2_0.GenerationIdentifierElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for GenerationIdentifierElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "GenerationIdentifierElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "GeneratorType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.GeneratorType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for GeneratorType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "GeneratorType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "GlobToRegexFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.GlobToRegexFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for GlobToRegexFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "GlobToRegexFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "GroupElement":<span class="cov8" title="1">
                var element xccdf1_2.GroupElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for GroupElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "GroupElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "GroupIdType":<span class="cov8" title="1">
                var element xccdf1_2.GroupIdType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for GroupIdType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "GroupIdType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "GroupType":<span class="cov8" title="1">
                var element xccdf1_2.GroupType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for GroupType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "GroupType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "HMACOutputLengthType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.HMACOutputLengthType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for HMACOutputLengthType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "HMACOutputLengthType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "HostElementType":<span class="cov8" title="1">
                var element asset_identification1_1.HostElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for HostElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "HostElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "HostnameElementType":<span class="cov8" title="1">
                var element asset_identification1_1.HostnameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for HostnameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "HostnameElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "HostnameType":<span class="cov8" title="1">
                var element asset_identification1_1.HostnameType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for HostnameType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "HostnameType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "HrefType":<span class="cov8" title="1">
                var element pkg_1999xlink.HrefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for HrefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "HrefType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "HtmlTextType":<span class="cov8" title="1">
                var element xccdf1_2.HtmlTextType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for HtmlTextType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "HtmlTextType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "HtmlTextWithSubType":<span class="cov8" title="1">
                var element xccdf1_2.HtmlTextWithSubType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for HtmlTextWithSubType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "HtmlTextWithSubType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IdentType":<span class="cov8" title="1">
                var element xccdf1_2.IdentType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IdentType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IdentType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IdentityType":<span class="cov8" title="1">
                var element xccdf1_2.IdentityType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IdentityType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IdentityType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IdrefListType":<span class="cov8" title="1">
                var element xccdf1_2.IdrefListType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IdrefListType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IdrefListType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IdrefType":<span class="cov8" title="1">
                var element xccdf1_2.IdrefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IdrefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IdrefType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "InstallationIdElementType":<span class="cov8" title="1">
                var element asset_identification1_1.InstallationIdElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for InstallationIdElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "InstallationIdElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "InstanceFixType":<span class="cov8" title="1">
                var element xccdf1_2.InstanceFixType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for InstanceFixType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "InstanceFixType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "InstanceNameElementType":<span class="cov8" title="1">
                var element asset_identification1_1.InstanceNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for InstanceNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "InstanceNameElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "InstanceResultType":<span class="cov8" title="1">
                var element xccdf1_2.InstanceResultType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for InstanceResultType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "InstanceResultType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "InterfaceHintType":<span class="cov8" title="1">
                var element xccdf1_2.InterfaceHintType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for InterfaceHintType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "InterfaceHintType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IpAddressElement":<span class="cov8" title="1">
                var element asset_identification1_1.IpAddressElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IpAddressElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IpAddressElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IpAddressType":<span class="cov8" title="1">
                var element asset_identification1_1.IpAddressType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IpAddressType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IpAddressType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IpNetRangeElementType":<span class="cov8" title="1">
                var element asset_identification1_1.IpNetRangeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IpNetRangeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IpNetRangeElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IpV4ElementType":<span class="cov8" title="1">
                var element asset_identification1_1.IpV4ElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IpV4ElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IpV4ElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "IpV6ElementType":<span class="cov8" title="1">
                var element asset_identification1_1.IpV6ElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for IpV6ElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "IpV6ElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Ipv4Type":<span class="cov8" title="1">
                var element asset_identification1_1.Ipv4Type
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Ipv4Type: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Ipv4Type"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Ipv6Type":<span class="cov8" title="1">
                var element asset_identification1_1.Ipv6Type
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Ipv6Type: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Ipv6Type"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ItAssetElement":<span class="cov8" title="1">
                var element asset_identification1_1.ItAssetElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ItAssetElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ItAssetElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ItemElement":<span class="cov8" title="1">
                var element xccdf1_2.ItemElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ItemElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ItemElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ItemIDPattern":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.ItemIDPattern
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ItemIDPattern: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ItemIDPattern"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "JointPersonNameElement":<span class="cov8" title="1">
                var element pkg_2_0.JointPersonNameElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for JointPersonNameElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "JointPersonNameElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "JointPersonNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.JointPersonNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for JointPersonNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "JointPersonNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "KeyInfoElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.KeyInfoElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for KeyInfoElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "KeyInfoElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "KeyInfoType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.KeyInfoType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for KeyInfoType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "KeyInfoType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "KeyLineCodeElementType":<span class="cov8" title="1">
                var element pkg_2_01.KeyLineCodeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for KeyLineCodeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "KeyLineCodeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "KeyNameElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.KeyNameElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for KeyNameElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "KeyNameElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "KeyValueElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.KeyValueElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for KeyValueElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "KeyValueElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "KeyValueType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.KeyValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for KeyValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "KeyValueType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "KnownAsElementType":<span class="cov8" title="1">
                var element pkg_2_0.KnownAsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for KnownAsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "KnownAsElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LabelType":<span class="cov8" title="1">
                var element pkg_1999xlink.LabelType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LabelType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LabelType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LargeMailUserIdentifierElementType":<span class="cov8" title="1">
                var element pkg_2_01.LargeMailUserIdentifierElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LargeMailUserIdentifierElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LargeMailUserIdentifierElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LargeMailUserNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.LargeMailUserNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LargeMailUserNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LargeMailUserNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LargeMailUserType":<span class="cov8" title="1">
                var element pkg_2_01.LargeMailUserType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LargeMailUserType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LargeMailUserType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LastNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.LastNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LastNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LastNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LicenseElementType":<span class="cov8" title="1">
                var element asset_identification1_1.LicenseElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LicenseElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LicenseElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ListType":<span class="cov8" title="1">
                var element dictionary2_0.ListType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ListType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ListType"
                s.namespace = "http://cpe.mitre.org/dictionary/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LiteralComponentType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.LiteralComponentType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LiteralComponentType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LiteralComponentType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Local_variableElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.Local_variableElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Local_variableElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Local_variableElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Local_variableElementType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.Local_variableElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Local_variableElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Local_variableElementType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocaleElementType":<span class="cov8" title="1">
                var element asset_identification1_1.LocaleElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocaleElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocaleElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocaleType":<span class="cov8" title="1">
                var element asset_identification1_1.LocaleType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocaleType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocaleType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocalityElement":<span class="cov8" title="1">
                var element pkg_2_01.LocalityElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocalityElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocalityElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocalityElementType":<span class="cov8" title="1">
                var element pkg_2_01.LocalityElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocalityElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocalityElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocalityNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.LocalityNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocalityNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocalityNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocationAddressElement":<span class="cov8" title="1">
                var element asset_identification1_1.LocationAddressElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocationAddressElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocationAddressElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocationElement":<span class="cov8" title="1">
                var element asset_identification1_1.LocationElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocationElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocationElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocationPointElement":<span class="cov8" title="1">
                var element asset_identification1_1.LocationPointElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocationPointElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocationPointElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocationPointElementType":<span class="cov8" title="1">
                var element asset_identification1_1.LocationPointElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocationPointElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocationPointElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocationRegionElement":<span class="cov8" title="1">
                var element asset_identification1_1.LocationRegionElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocationRegionElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocationRegionElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocationRegionElementType":<span class="cov8" title="1">
                var element asset_identification1_1.LocationRegionElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocationRegionElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocationRegionElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocationsElement":<span class="cov8" title="1">
                var element asset_identification1_1.LocationsElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocationsElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocationsElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocationsElementType":<span class="cov8" title="1">
                var element asset_identification1_1.LocationsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocationsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocationsElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocatorElement":<span class="cov8" title="1">
                var element pkg_1999xlink.LocatorElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocatorElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocatorElement"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LocatorType":<span class="cov8" title="1">
                var element pkg_1999xlink.LocatorType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LocatorType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LocatorType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "LogicalTestType":<span class="cov8" title="1">
                var element language2_0.LogicalTestType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for LogicalTestType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "LogicalTestType"
                s.namespace = "http://cpe.mitre.org/language/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MacAddressElementType":<span class="cov8" title="1">
                var element asset_identification1_1.MacAddressElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MacAddressElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MacAddressElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MacAddressType":<span class="cov8" title="1">
                var element asset_identification1_1.MacAddressType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MacAddressType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MacAddressType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MailStopNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.MailStopNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MailStopNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MailStopNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MailStopNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.MailStopNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MailStopNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MailStopNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MailStopType":<span class="cov8" title="1">
                var element pkg_2_01.MailStopType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MailStopType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MailStopType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ManifestElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.ManifestElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ManifestElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ManifestElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ManifestType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.ManifestType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ManifestType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ManifestType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MessageLevelEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.MessageLevelEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MessageLevelEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MessageLevelEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MessageType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.MessageType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MessageType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MessageType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MetadataType":<span class="cov8" title="1">
                var element xccdf1_2.MetadataType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MetadataType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MetadataType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MgmtDataElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.MgmtDataElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MgmtDataElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MgmtDataElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MiddleNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.MiddleNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MiddleNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MiddleNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ModelElement":<span class="cov8" title="1">
                var element xccdf1_2.ModelElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ModelElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ModelElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ModelElementType":<span class="cov8" title="1">
                var element xccdf1_2.ModelElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ModelElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ModelElementType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MotherboardGuidElementType":<span class="cov8" title="1">
                var element asset_identification1_1.MotherboardGuidElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MotherboardGuidElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MotherboardGuidElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "MsgSevEnumType":<span class="cov8" title="1">
                var element xccdf1_2.MsgSevEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for MsgSevEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "MsgSevEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NameDetails":<span class="cov8" title="1">
                var element pkg_2_0.NameDetails
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NameDetails: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NameDetails"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NameDetailsElement":<span class="cov8" title="1">
                var element pkg_2_0.NameDetailsElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NameDetailsElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NameDetailsElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NameDetailsElementType":<span class="cov8" title="1">
                var element pkg_2_0.NameDetailsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NameDetailsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NameDetailsElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NameLineType":<span class="cov8" title="1">
                var element pkg_2_0.NameLineType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NameLineType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NameLineType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NamePattern":<span class="cov8" title="1">
                var element language2_0.NamePattern
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NamePattern: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NamePattern"
                s.namespace = "http://cpe.mitre.org/language/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NamePrefixElementType":<span class="cov8" title="1">
                var element pkg_2_0.NamePrefixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NamePrefixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NamePrefixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NetworkElement":<span class="cov8" title="1">
                var element asset_identification1_1.NetworkElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NetworkElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NetworkElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NetworkInterfaceType":<span class="cov8" title="1">
                var element asset_identification1_1.NetworkInterfaceType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NetworkInterfaceType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NetworkInterfaceType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NetworkNameElementType":<span class="cov8" title="1">
                var element asset_identification1_1.NetworkNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NetworkNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NetworkNameElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NetworkType":<span class="cov8" title="1">
                var element asset_identification1_1.NetworkType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NetworkType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NetworkType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NonEmptyStringType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.NonEmptyStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NonEmptyStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NonEmptyStringType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NotesElement":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.NotesElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NotesElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NotesElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NotesElementType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.NotesElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NotesElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NotesElementType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NotesType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.NotesType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NotesType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NotesType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "NoticeType":<span class="cov8" title="1">
                var element xccdf1_2.NoticeType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for NoticeType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "NoticeType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ObjectComponentType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.ObjectComponentType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ObjectComponentType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ObjectComponentType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ObjectElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.ObjectElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ObjectElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ObjectElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ObjectIDPattern":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.ObjectIDPattern
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ObjectIDPattern: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ObjectIDPattern"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ObjectRefElement":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ObjectRefElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ObjectRefElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ObjectRefElement"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ObjectRefElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ObjectRefElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ObjectRefElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ObjectRefElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ObjectRefType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.ObjectRefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ObjectRefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ObjectRefType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ObjectType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.ObjectType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ObjectType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ObjectType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ObjectsType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.ObjectsType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ObjectsType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ObjectsType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OperationEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.OperationEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OperationEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OperationEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OperatorEnumeration":<span class="cov8" title="1">
                var element language2_0.OperatorEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OperatorEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OperatorEnumeration"
                s.namespace = "http://cpe.mitre.org/language/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganisationFormerNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.OrganisationFormerNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganisationFormerNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganisationFormerNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganisationKnownAsElementType":<span class="cov8" title="1">
                var element pkg_2_0.OrganisationKnownAsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganisationKnownAsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganisationKnownAsElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganisationNameDetails":<span class="cov8" title="1">
                var element pkg_2_0.OrganisationNameDetails
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganisationNameDetails: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganisationNameDetails"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganisationNameDetailsElement":<span class="cov8" title="1">
                var element pkg_2_0.OrganisationNameDetailsElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganisationNameDetailsElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganisationNameDetailsElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganisationNameDetailsElementType":<span class="cov8" title="1">
                var element pkg_2_0.OrganisationNameDetailsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganisationNameDetailsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganisationNameDetailsElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganisationNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.OrganisationNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganisationNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganisationNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganisationTypeElementType":<span class="cov8" title="1">
                var element pkg_2_0.OrganisationTypeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganisationTypeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganisationTypeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganizationElement":<span class="cov8" title="1">
                var element asset_identification1_1.OrganizationElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganizationElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganizationElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OrganizationType":<span class="cov8" title="1">
                var element asset_identification1_1.OrganizationType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OrganizationType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OrganizationType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OtherNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.OtherNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OtherNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OtherNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Oval_definitionsElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.Oval_definitionsElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Oval_definitionsElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Oval_definitionsElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Oval_definitionsElementType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.Oval_definitionsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Oval_definitionsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Oval_definitionsElementType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OverrideType":<span class="cov8" title="1">
                var element xccdf1_2.OverrideType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OverrideType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OverrideType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "OverrideableCPE2idrefType":<span class="cov8" title="1">
                var element xccdf1_2.OverrideableCPE2idrefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for OverrideableCPE2idrefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "OverrideableCPE2idrefType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PGPDataElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.PGPDataElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PGPDataElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PGPDataElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PGPDataType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.PGPDataType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PGPDataType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PGPDataType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ParamType":<span class="cov8" title="1">
                var element xccdf1_2.ParamType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ParamType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ParamType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PersonElement":<span class="cov8" title="1">
                var element asset_identification1_1.PersonElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PersonElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PersonElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PersonName":<span class="cov8" title="1">
                var element pkg_2_0.PersonName
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PersonName: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PersonName"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PersonNameElement":<span class="cov8" title="1">
                var element pkg_2_0.PersonNameElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PersonNameElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PersonNameElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PersonNameElementType":<span class="cov8" title="1">
                var element pkg_2_0.PersonNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PersonNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PersonNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PersonType":<span class="cov8" title="1">
                var element asset_identification1_1.PersonType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PersonType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PersonType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PlainTextType":<span class="cov8" title="1">
                var element xccdf1_2.PlainTextType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PlainTextType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PlainTextType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PlatformSpecificationElement":<span class="cov8" title="1">
                var element language2_0.PlatformSpecificationElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PlatformSpecificationElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PlatformSpecificationElement"
                s.namespace = "http://cpe.mitre.org/language/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PlatformSpecificationElementType":<span class="cov8" title="1">
                var element language2_0.PlatformSpecificationElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PlatformSpecificationElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PlatformSpecificationElementType"
                s.namespace = "http://cpe.mitre.org/language/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PlatformType":<span class="cov8" title="1">
                var element language2_0.PlatformType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PlatformType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PlatformType"
                s.namespace = "http://cpe.mitre.org/language/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PortElementType":<span class="cov8" title="1">
                var element asset_identification1_1.PortElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PortElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PortElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PortRangeElementType":<span class="cov8" title="1">
                var element asset_identification1_1.PortRangeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PortRangeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PortRangeElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PortType":<span class="cov8" title="1">
                var element asset_identification1_1.PortType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PortType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PortType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PossibleRestrictionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.PossibleRestrictionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PossibleRestrictionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PossibleRestrictionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PossibleValueType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.PossibleValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PossibleValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PossibleValueType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostBoxElement":<span class="cov8" title="1">
                var element pkg_2_01.PostBoxElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostBoxElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostBoxElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostBoxElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostBoxElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostBoxElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostBoxElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostBoxNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostBoxNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostBoxNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostBoxNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostBoxNumberExtensionElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostBoxNumberExtensionElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostBoxNumberExtensionElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostBoxNumberExtensionElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostBoxNumberPrefixElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostBoxNumberPrefixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostBoxNumberPrefixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostBoxNumberPrefixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostBoxNumberSuffixElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostBoxNumberSuffixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostBoxNumberSuffixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostBoxNumberSuffixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostOfficeElement":<span class="cov8" title="1">
                var element pkg_2_01.PostOfficeElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostOfficeElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostOfficeElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostOfficeElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostOfficeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostOfficeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostOfficeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostOfficeNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostOfficeNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostOfficeNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostOfficeNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostOfficeNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostOfficeNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostOfficeNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostOfficeNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostTownElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostTownElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostTownElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostTownElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostTownNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostTownNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostTownNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostTownNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostTownSuffixElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostTownSuffixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostTownSuffixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostTownSuffixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostalCodeElement":<span class="cov8" title="1">
                var element pkg_2_01.PostalCodeElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostalCodeElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostalCodeElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostalCodeElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostalCodeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostalCodeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostalCodeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostalCodeNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostalCodeNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostalCodeNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostalCodeNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostalCodeNumberExtensionElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostalCodeNumberExtensionElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostalCodeNumberExtensionElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostalCodeNumberExtensionElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostalRouteNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostalRouteNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostalRouteNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostalRouteNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostalRouteNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostalRouteNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostalRouteNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostalRouteNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostalRouteType":<span class="cov8" title="1">
                var element pkg_2_01.PostalRouteType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostalRouteType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostalRouteType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PostalServiceElementsElementType":<span class="cov8" title="1">
                var element pkg_2_01.PostalServiceElementsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PostalServiceElementsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PostalServiceElementsElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PrecedingTitleElementType":<span class="cov8" title="1">
                var element pkg_2_0.PrecedingTitleElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PrecedingTitleElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PrecedingTitleElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseElement":<span class="cov8" title="1">
                var element pkg_2_01.PremiseElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseLocationElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseLocationElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseLocationElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseLocationElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberElement":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberPrefixElement":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberPrefixElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberPrefixElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberPrefixElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberPrefixElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberPrefixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberPrefixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberPrefixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberRangeElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberRangeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberRangeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberRangeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberRangeFromElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberRangeFromElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberRangeFromElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberRangeFromElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberRangeToElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberRangeToElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberRangeToElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberRangeToElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberSuffixElement":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberSuffixElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberSuffixElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberSuffixElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "PremiseNumberSuffixElementType":<span class="cov8" title="1">
                var element pkg_2_01.PremiseNumberSuffixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for PremiseNumberSuffixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "PremiseNumberSuffixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileElement":<span class="cov8" title="1">
                var element xccdf1_2.ProfileElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileIdType":<span class="cov8" title="1">
                var element xccdf1_2.ProfileIdType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileIdType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileIdType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileNoteType":<span class="cov8" title="1">
                var element xccdf1_2.ProfileNoteType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileNoteType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileNoteType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileRefineRuleType":<span class="cov8" title="1">
                var element xccdf1_2.ProfileRefineRuleType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileRefineRuleType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileRefineRuleType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileRefineValueType":<span class="cov8" title="1">
                var element xccdf1_2.ProfileRefineValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileRefineValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileRefineValueType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileSelectType":<span class="cov8" title="1">
                var element xccdf1_2.ProfileSelectType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileSelectType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileSelectType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileSetComplexValueType":<span class="cov8" title="1">
                var element xccdf1_2.ProfileSetComplexValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileSetComplexValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileSetComplexValueType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileSetValueType":<span class="cov8" title="1">
                var element xccdf1_2.ProfileSetValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileSetValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileSetValueType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProfileType":<span class="cov8" title="1">
                var element xccdf1_2.ProfileType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProfileType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProfileType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ProtocolElementType":<span class="cov8" title="1">
                var element asset_identification1_1.ProtocolElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ProtocolElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ProtocolElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RSAKeyValueElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.RSAKeyValueElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RSAKeyValueElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RSAKeyValueElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RSAKeyValueType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.RSAKeyValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RSAKeyValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RSAKeyValueType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RatingEnumType":<span class="cov8" title="1">
                var element xccdf1_2.RatingEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RatingEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RatingEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ReferenceElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.ReferenceElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ReferenceElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ReferenceElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ReferenceElementType":<span class="cov8" title="1">
                var element dictionary2_0.ReferenceElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ReferenceElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ReferenceElementType"
                s.namespace = "http://cpe.mitre.org/dictionary/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ReferenceType":<span class="cov8" title="1">
                var element xccdf1_2.ReferenceType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ReferenceType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ReferenceType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ReferencesType":<span class="cov8" title="1">
                var element dictionary2_0.ReferencesType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ReferencesType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ReferencesType"
                s.namespace = "http://cpe.mitre.org/dictionary/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RegexCaptureFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.RegexCaptureFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RegexCaptureFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RegexCaptureFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RelationshipType":<span class="cov8" title="1">
                var element reporting_core1_1.RelationshipType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RelationshipType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RelationshipType"
                s.namespace = "http://scap.nist.gov/schema/reporting-core/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RelationshipsContainerType":<span class="cov8" title="1">
                var element reporting_core1_1.RelationshipsContainerType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RelationshipsContainerType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RelationshipsContainerType"
                s.namespace = "http://scap.nist.gov/schema/reporting-core/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RelationshipsElementType":<span class="cov8" title="1">
                var element reporting_core1_1.RelationshipsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RelationshipsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RelationshipsElementType"
                s.namespace = "http://scap.nist.gov/schema/reporting-core/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RemoteResourceElement":<span class="cov8" title="1">
                var element asset_reporting_format1_1.RemoteResourceElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RemoteResourceElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RemoteResourceElement"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RemoteResourceElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.RemoteResourceElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RemoteResourceElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RemoteResourceElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ReportRequestType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ReportRequestType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ReportRequestType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ReportRequestType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ReportRequestsElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ReportRequestsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ReportRequestsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ReportRequestsElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ReportType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ReportType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ReportType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ReportType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ReportsElementType":<span class="cov8" title="1">
                var element asset_reporting_format1_1.ReportsElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ReportsElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ReportsElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-reporting-format/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ResourceElement":<span class="cov8" title="1">
                var element pkg_1999xlink.ResourceElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ResourceElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ResourceElement"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ResourceType":<span class="cov8" title="1">
                var element pkg_1999xlink.ResourceType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ResourceType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ResourceType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RestrictionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.RestrictionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RestrictionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RestrictionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ResultEnumType":<span class="cov8" title="1">
                var element xccdf1_2.ResultEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ResultEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ResultEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RetrievalMethodElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.RetrievalMethodElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RetrievalMethodElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RetrievalMethodElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RetrievalMethodType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.RetrievalMethodType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RetrievalMethodType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RetrievalMethodType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RoleEnumType":<span class="cov8" title="1">
                var element xccdf1_2.RoleEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RoleEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RoleEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RoleType":<span class="cov8" title="1">
                var element pkg_1999xlink.RoleType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RoleType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RoleType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RuleElement":<span class="cov8" title="1">
                var element xccdf1_2.RuleElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RuleElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RuleElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RuleIdType":<span class="cov8" title="1">
                var element xccdf1_2.RuleIdType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RuleIdType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RuleIdType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RuleResultType":<span class="cov8" title="1">
                var element xccdf1_2.RuleResultType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RuleResultType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RuleResultType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "RuleType":<span class="cov8" title="1">
                var element xccdf1_2.RuleType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for RuleType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "RuleType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SPKIDataElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SPKIDataElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SPKIDataElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SPKIDataElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SPKIDataType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SPKIDataType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SPKIDataType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SPKIDataType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SchemaVersionPattern":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.SchemaVersionPattern
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SchemaVersionPattern: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SchemaVersionPattern"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SchemaVersionType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.SchemaVersionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SchemaVersionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SchemaVersionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ScoreType":<span class="cov8" title="1">
                var element xccdf1_2.ScoreType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ScoreType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ScoreType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SelChoicesType":<span class="cov8" title="1">
                var element xccdf1_2.SelChoicesType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SelChoicesType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SelChoicesType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SelComplexValueType":<span class="cov8" title="1">
                var element xccdf1_2.SelComplexValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SelComplexValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SelComplexValueType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SelNumType":<span class="cov8" title="1">
                var element xccdf1_2.SelNumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SelNumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SelNumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SelStringType":<span class="cov8" title="1">
                var element xccdf1_2.SelStringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SelStringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SelStringType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ServedByElement":<span class="cov8" title="1">
                var element asset_identification1_1.ServedByElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ServedByElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ServedByElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ServiceElement":<span class="cov8" title="1">
                var element asset_identification1_1.ServiceElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ServiceElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ServiceElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ServiceType":<span class="cov8" title="1">
                var element asset_identification1_1.ServiceType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ServiceType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ServiceType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SetElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.SetElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SetElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SetElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SetElementType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.SetElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SetElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SetElementType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SetOperatorEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.SetOperatorEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SetOperatorEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SetOperatorEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SeverityEnumType":<span class="cov8" title="1">
                var element xccdf1_2.SeverityEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SeverityEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SeverityEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ShowType":<span class="cov8" title="1">
                var element pkg_1999xlink.ShowType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ShowType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ShowType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignatureElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignatureElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignatureElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignatureElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignatureMethodElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignatureMethodElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignatureMethodElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignatureMethodElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignatureMethodType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignatureMethodType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignatureMethodType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignatureMethodType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignaturePropertiesElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignaturePropertiesElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignaturePropertiesElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignaturePropertiesElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignaturePropertiesType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignaturePropertiesType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignaturePropertiesType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignaturePropertiesType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignaturePropertyElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignaturePropertyElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignaturePropertyElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignaturePropertyElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignaturePropertyType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignaturePropertyType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignaturePropertyType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignaturePropertyType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignatureType":<span class="cov8" title="1">
                var element xccdf1_2.SignatureType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignatureType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignatureType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignatureValueElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignatureValueElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignatureValueElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignatureValueElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignatureValueType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignatureValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignatureValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignatureValueType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignedInfoElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignedInfoElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignedInfoElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignedInfoElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SignedInfoType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.SignedInfoType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SignedInfoType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SignedInfoType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "Simple":<span class="cov8" title="1">
                var element pkg_1999xlink.Simple
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for Simple: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "Simple"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SimpleDatatypeEnumeration":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.SimpleDatatypeEnumeration
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SimpleDatatypeEnumeration: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SimpleDatatypeEnumeration"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SoftwareElement":<span class="cov8" title="1">
                var element asset_identification1_1.SoftwareElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SoftwareElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SoftwareElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SoftwareType":<span class="cov8" title="1">
                var element asset_identification1_1.SoftwareType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SoftwareType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SoftwareType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SortingCodeElementType":<span class="cov8" title="1">
                var element pkg_2_01.SortingCodeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SortingCodeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SortingCodeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SplitFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.SplitFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SplitFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SplitFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "StateElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.StateElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for StateElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "StateElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "StateIDPattern":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.StateIDPattern
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for StateIDPattern: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "StateIDPattern"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "StateRefType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.StateRefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for StateRefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "StateRefType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "StateType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.StateType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for StateType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "StateType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "StatesType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.StatesType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for StatesType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "StatesType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "StatusElement":<span class="cov8" title="1">
                var element xccdf1_2.StatusElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for StatusElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "StatusElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "StatusElementType":<span class="cov8" title="1">
                var element xccdf1_2.StatusElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for StatusElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "StatusElementType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "StatusType":<span class="cov8" title="1">
                var element xccdf1_2.StatusType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for StatusType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "StatusType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubAdministrativeAreaElementType":<span class="cov8" title="1">
                var element pkg_2_01.SubAdministrativeAreaElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubAdministrativeAreaElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubAdministrativeAreaElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubAdministrativeAreaNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.SubAdministrativeAreaNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubAdministrativeAreaNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubAdministrativeAreaNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubPremiseLocationElementType":<span class="cov8" title="1">
                var element pkg_2_01.SubPremiseLocationElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubPremiseLocationElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubPremiseLocationElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubPremiseNameElementType":<span class="cov8" title="1">
                var element pkg_2_01.SubPremiseNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubPremiseNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubPremiseNameElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubPremiseNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.SubPremiseNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubPremiseNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubPremiseNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubPremiseNumberPrefixElementType":<span class="cov8" title="1">
                var element pkg_2_01.SubPremiseNumberPrefixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubPremiseNumberPrefixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubPremiseNumberPrefixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubPremiseNumberSuffixElementType":<span class="cov8" title="1">
                var element pkg_2_01.SubPremiseNumberSuffixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubPremiseNumberSuffixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubPremiseNumberSuffixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubPremiseType":<span class="cov8" title="1">
                var element pkg_2_01.SubPremiseType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubPremiseType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubPremiseType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubType":<span class="cov8" title="1">
                var element xccdf1_2.SubType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubUseEnumType":<span class="cov8" title="1">
                var element xccdf1_2.SubUseEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubUseEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubUseEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SubstringFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.SubstringFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SubstringFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SubstringFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SuffixElementType":<span class="cov8" title="1">
                var element pkg_2_0.SuffixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SuffixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SuffixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SupplementaryPostalServiceDataElementType":<span class="cov8" title="1">
                var element pkg_2_01.SupplementaryPostalServiceDataElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SupplementaryPostalServiceDataElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SupplementaryPostalServiceDataElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SyntheticIdElement":<span class="cov8" title="1">
                var element asset_identification1_1.SyntheticIdElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SyntheticIdElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SyntheticIdElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SyntheticIdElementType":<span class="cov8" title="1">
                var element asset_identification1_1.SyntheticIdElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SyntheticIdElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SyntheticIdElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SystemElement":<span class="cov8" title="1">
                var element asset_identification1_1.SystemElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SystemElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SystemElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SystemNameElementType":<span class="cov8" title="1">
                var element asset_identification1_1.SystemNameElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SystemNameElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SystemNameElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "SystemType":<span class="cov8" title="1">
                var element asset_identification1_1.SystemType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for SystemType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "SystemType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TailoringBenchmarkReferenceType":<span class="cov8" title="1">
                var element xccdf1_2.TailoringBenchmarkReferenceType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TailoringBenchmarkReferenceType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TailoringBenchmarkReferenceType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TailoringElement":<span class="cov8" title="1">
                var element xccdf1_2.TailoringElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TailoringElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TailoringElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TailoringIdType":<span class="cov8" title="1">
                var element xccdf1_2.TailoringIdType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TailoringIdType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TailoringIdType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TailoringReferenceType":<span class="cov8" title="1">
                var element xccdf1_2.TailoringReferenceType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TailoringReferenceType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TailoringReferenceType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TailoringType":<span class="cov8" title="1">
                var element xccdf1_2.TailoringType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TailoringType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TailoringType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TailoringVersionType":<span class="cov8" title="1">
                var element xccdf1_2.TailoringVersionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TailoringVersionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TailoringVersionType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TargetFactsType":<span class="cov8" title="1">
                var element xccdf1_2.TargetFactsType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TargetFactsType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TargetFactsType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TargetIdRefType":<span class="cov8" title="1">
                var element xccdf1_2.TargetIdRefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TargetIdRefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TargetIdRefType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TelephoneNumberElement":<span class="cov8" title="1">
                var element asset_identification1_1.TelephoneNumberElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TelephoneNumberElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TelephoneNumberElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TelephoneNumberElementType":<span class="cov8" title="1">
                var element asset_identification1_1.TelephoneNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TelephoneNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TelephoneNumberElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TelephoneNumberType":<span class="cov8" title="1">
                var element asset_identification1_1.TelephoneNumberType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TelephoneNumberType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TelephoneNumberType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TestElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.TestElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TestElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TestElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TestIDPattern":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.TestIDPattern
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TestIDPattern: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TestIDPattern"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TestResultElement":<span class="cov8" title="1">
                var element xccdf1_2.TestResultElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TestResultElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TestResultElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TestResultType":<span class="cov8" title="1">
                var element xccdf1_2.TestResultType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TestResultType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TestResultType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TestType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.TestType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TestType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TestType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TestresultIdType":<span class="cov8" title="1">
                var element xccdf1_2.TestresultIdType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TestresultIdType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TestresultIdType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TestsType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.TestsType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TestsType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TestsType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TextType":<span class="cov8" title="1">
                var element language2_0.TextType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TextType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TextType"
                s.namespace = "http://cpe.mitre.org/language/2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TextWithSubType":<span class="cov8" title="1">
                var element xccdf1_2.TextWithSubType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TextWithSubType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TextWithSubType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareElement":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareElementType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareLeadingTypeType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareLeadingTypeType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareLeadingTypeType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareLeadingTypeType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNameType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNameType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNameType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNameType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberElement":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberElementType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberFromElementType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberFromElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberFromElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberFromElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberPrefixElement":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberPrefixElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberPrefixElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberPrefixElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberPrefixElementType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberPrefixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberPrefixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberPrefixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberRangeElementType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberRangeElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberRangeElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberRangeElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberSuffixElement":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberSuffixElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberSuffixElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberSuffixElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberSuffixElementType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberSuffixElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberSuffixElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberSuffixElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareNumberToElementType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareNumberToElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareNumberToElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareNumberToElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfarePostDirectionType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfarePostDirectionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfarePostDirectionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfarePostDirectionType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfarePreDirectionType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfarePreDirectionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfarePreDirectionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfarePreDirectionType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ThoroughfareTrailingTypeType":<span class="cov8" title="1">
                var element pkg_2_01.ThoroughfareTrailingTypeType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ThoroughfareTrailingTypeType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ThoroughfareTrailingTypeType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TimeDifferenceFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.TimeDifferenceFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TimeDifferenceFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TimeDifferenceFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TitleAttrType":<span class="cov8" title="1">
                var element pkg_1999xlink.TitleAttrType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TitleAttrType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TitleAttrType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TitleElement":<span class="cov8" title="1">
                var element pkg_1999xlink.TitleElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TitleElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TitleElement"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TitleElementType":<span class="cov8" title="1">
                var element pkg_2_0.TitleElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TitleElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TitleElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TitleEltType":<span class="cov8" title="1">
                var element pkg_1999xlink.TitleEltType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TitleEltType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TitleEltType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ToType":<span class="cov8" title="1">
                var element pkg_1999xlink.ToType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ToType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ToType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TransformElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.TransformElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TransformElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TransformElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TransformType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.TransformType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TransformType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TransformType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TransformsElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.TransformsElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TransformsElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TransformsElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TransformsType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.TransformsType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TransformsType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TransformsType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "TypeType":<span class="cov8" title="1">
                var element pkg_1999xlink.TypeType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for TypeType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "TypeType"
                s.namespace = "http://www.w3.org/1999/xlink"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "UniqueFunctionType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.UniqueFunctionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for UniqueFunctionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "UniqueFunctionType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "UriRefType":<span class="cov8" title="1">
                var element xccdf1_2.UriRefType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for UriRefType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "UriRefType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "UrlElementType":<span class="cov8" title="1">
                var element asset_identification1_1.UrlElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for UrlElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "UrlElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ValueElement":<span class="cov8" title="1">
                var element xccdf1_2.ValueElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ValueElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ValueElement"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ValueIdType":<span class="cov8" title="1">
                var element xccdf1_2.ValueIdType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ValueIdType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ValueIdType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ValueOperatorType":<span class="cov8" title="1">
                var element xccdf1_2.ValueOperatorType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ValueOperatorType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ValueOperatorType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ValueType":<span class="cov8" title="1">
                var element xccdf1_2.ValueType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ValueType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ValueType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "ValueTypeType":<span class="cov8" title="1">
                var element xccdf1_2.ValueTypeType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for ValueTypeType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "ValueTypeType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "VariableComponentType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.VariableComponentType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for VariableComponentType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "VariableComponentType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "VariableElement":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.VariableElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for VariableElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "VariableElement"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "VariableIDPattern":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.VariableIDPattern
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for VariableIDPattern: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "VariableIDPattern"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "VariableType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.VariableType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for VariableType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "VariableType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "VariablesType":<span class="cov8" title="1">
                var element xmlschemaoval_definitions_5.VariablesType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for VariablesType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "VariablesType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-definitions-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "VersionElementType":<span class="cov8" title="1">
                var element xmlschemaoval_common_5.VersionElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for VersionElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "VersionElementType"
                s.namespace = "http://oval.mitre.org/XMLSchema/oval-common-5"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "VersionType":<span class="cov8" title="1">
                var element xccdf1_2.VersionType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for VersionType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "VersionType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "WarningCategoryEnumType":<span class="cov8" title="1">
                var element xccdf1_2.WarningCategoryEnumType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for WarningCategoryEnumType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "WarningCategoryEnumType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "WarningType":<span class="cov8" title="1">
                var element xccdf1_2.WarningType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for WarningType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "WarningType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "WebsiteElement":<span class="cov8" title="1">
                var element asset_identification1_1.WebsiteElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for WebsiteElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "WebsiteElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "WebsiteType":<span class="cov8" title="1">
                var element asset_identification1_1.WebsiteType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for WebsiteType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "WebsiteType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "WebsiteUrlElement":<span class="cov8" title="1">
                var element asset_identification1_1.WebsiteUrlElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for WebsiteUrlElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "WebsiteUrlElement"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "WebsiteUrlElementType":<span class="cov8" title="1">
                var element asset_identification1_1.WebsiteUrlElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for WebsiteUrlElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "WebsiteUrlElementType"
                s.namespace = "http://scap.nist.gov/schema/asset-identification/1.1"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "WeightType":<span class="cov8" title="1">
                var element xccdf1_2.WeightType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for WeightType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "WeightType"
                s.namespace = "http://checklists.nist.gov/xccdf/1.2"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "X509DataElement":<span class="cov8" title="1">
                var element pkg_200009xmldsig.X509DataElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for X509DataElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "X509DataElement"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "X509DataType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.X509DataType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for X509DataType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "X509DataType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "X509IssuerSerialType":<span class="cov8" title="1">
                var element pkg_200009xmldsig.X509IssuerSerialType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for X509IssuerSerialType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "X509IssuerSerialType"
                s.namespace = "http://www.w3.org/2000/09/xmldsig#"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "XALElement":<span class="cov8" title="1">
                var element pkg_2_01.XALElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for XALElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "XALElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "XALElementType":<span class="cov8" title="1">
                var element pkg_2_01.XALElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for XALElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "XALElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xAL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "XNLElement":<span class="cov8" title="1">
                var element pkg_2_0.XNLElement
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for XNLElement: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "XNLElement"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        case "XNLElementType":<span class="cov8" title="1">
                var element pkg_2_0.XNLElementType
                if len(data) &gt; 0 &amp;&amp; string(data) != "{}" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal data for XNLElementType: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">s.rootElement = &amp;element
                s.rootType = "XNLElementType"
                s.namespace = "urn:oasis:names:tc:ciq:xsdschema:xNL:2.0"
                s.isDirty = true
                s.lastModified = time.Now()
                return "/", nil</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("unknown type: %s", typeName)</span>
        }
}

// createChildElement creates a child element under the given parent path.
func (s *XMLDocumentState) createChildElement(typeName, parentPath string, data json.RawMessage) (string, error) <span class="cov0" title="0">{
        // For now, child element creation requires the parent to exist
        // This will be implemented with reflection-based traversal
        s.isDirty = true
        s.lastModified = time.Now()
        return "", fmt.Errorf("child element creation not yet implemented - use tree view to add children")
}</span>

// UpdateElement updates an element at the given path.
func (s *XMLDocumentState) UpdateElement(path string, data json.RawMessage) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.rootElement == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no document loaded")
        }</span>

        <span class="cov8" title="1">if path == "/" </span><span class="cov8" title="1">{
                return s.updateRootElement(data)
        }</span>

        // Parse path for nested element updates
        <span class="cov0" title="0">parts := splitPath(path)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path: %s", path)
        }</span>

        // Handle first-level element updates
        <span class="cov0" title="0">if len(parts) == 1 </span><span class="cov0" title="0">{
                return s.updateFirstLevelElement(parts[0], data)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("deep path updates not yet implemented: %s", path)</span>
}

// updateRootElement updates fields on the root element.
// Currently only supports string field updates.
func (s *XMLDocumentState) updateRootElement(data json.RawMessage) error <span class="cov8" title="1">{
        var updates map[string]interface{}
        if err := json.Unmarshal(data, &amp;updates); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid update data: %w", err)
        }</span>

        <span class="cov8" title="1">switch root := s.rootElement.(type) </span>{
        case *pkg_1999xlink.ActuateType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressDetails:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressDetailsElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressIdentifierElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressLatitudeDirectionElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressLatitudeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressLineElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressLineElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressLinesType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressLongitudeDirectionElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AddressLongitudeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.AddresseeIndicatorElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AdministrativeAreaElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AdministrativeAreaElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.AdministrativeAreaNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.AffectedType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "family":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Family = xmlschemaoval_common_5.FamilyEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.AliasElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.ArcElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.ArcType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.ArcroleType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.ArithmeticEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.ArithmeticFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "arithmetic_operation":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Arithmetic_operation = xmlschemaoval_definitions_5.ArithmeticEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.AssetElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.AssetElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.AssetIdentificationType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "asset-ref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.AssetRef = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.AssetRelatedElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "asset-ref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.AssetRef = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.AssetReportCollectionElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.AssetReportCollectionElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.AssetsElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.AssetsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.AssetsType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.BarcodeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.BeginFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "character":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Character = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.BenchmarkElement:<span class="cov8" title="1">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov8" title="1">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov8" title="1">
                                if v, ok := value.(string); ok </span><span class="cov8" title="1">{
                                        root.Id = xccdf1_2.BenchmarkIdType(v)
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id2 = &amp;v
                                }</span>
                        case "style":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Style = &amp;v
                                }</span>
                        case "style-href":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.StyleHref = &amp;v
                                }</span>
                        }
                }
                <span class="cov8" title="1">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.BenchmarkElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.BenchmarkIdType(v)
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id2 = &amp;v
                                }</span>
                        case "style":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Style = &amp;v
                                }</span>
                        case "style-href":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.StyleHref = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.BenchmarkIdType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.BenchmarkReferenceType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "href":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Href = v
                                }</span>
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.BirthdateElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.BuildingNameType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.CPE2idrefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "idref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Idref = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.CanonicalizationMethodElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Algorithm":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Algorithm = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.CanonicalizationMethodType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Algorithm":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Algorithm = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.CcOperatorEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.CheckContentRefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "href":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Href = v
                                }</span>
                        case "name":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Name = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.CheckContentType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.CheckEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.CheckExportType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "value-id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.ValueId = v
                                }</span>
                        case "export-name":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.ExportName = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.CheckImportType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "import-name":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.ImportName = v
                                }</span>
                        case "import-xpath":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.ImportXpath = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.CheckType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.System = v
                                }</span>
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        case "selector":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Selector = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.CidrElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.CidrType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.CircuitElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.CircuitNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.CircuitType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.ClassEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ComplexCheckType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "operator":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Operator = xccdf1_2.CcOperatorEnumType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.ComplexDatatypeEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ComplexValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ComputingDeviceElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ComputingDeviceType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.ConcatFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ConnectionsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.Constant_variableElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.Constant_variableElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ContentElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ContentElementType1:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.CountFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.CountryElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.CountryNameCodeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.CountryNameElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.CountryNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.CpeElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.CpeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *dictionary2_0.CpeItemElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "name":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Name = dictionary2_0.NamePattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *dictionary2_0.CpeListElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.CpeType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.CriteriaType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.CriterionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "test_ref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Test_ref = xmlschemaoval_common_5.TestIDPattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.CryptoBinary:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.DSAKeyValueElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.DSAKeyValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.DataElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.DataType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.DatabaseElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.DatabaseType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.DatatypeEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.DateTimeFormatEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.DcStatusType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.DefinitionElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.DefinitionIDPattern(v)
                                }</span>
                        case "class":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Class = xmlschemaoval_common_5.ClassEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.DefinitionIDPattern:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.DefinitionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.DefinitionIDPattern(v)
                                }</span>
                        case "class":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Class = xmlschemaoval_common_5.ClassEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.DefinitionsType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.DepartmentElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.DepartmentElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.DepartmentNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.DependencyNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.DependentLocalityNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.DependentLocalityNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.DependentLocalityType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.DependentThoroughfareElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.DeprecatedInfoType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.Deprecated_infoElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.DigestMethodElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Algorithm":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Algorithm = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.DigestMethodType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Algorithm":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Algorithm = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.DigestValueElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.DigestValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.DistinguishedNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.DocumentRootElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.ElementMapItemType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "target_namespace":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Target_namespace = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.ElementMapType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.Element_mappingElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.EmailAddressElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.EmailAddressElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.EmptyStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EndFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "character":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Character = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.EndorsementLineCodeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectAnySimpleType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectBinaryType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectBoolType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectFieldType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectFloatType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectIPAddressStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectIPAddressType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectIntType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectRecordType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityObjectVersionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateAnySimpleType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateBinaryType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateBoolType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateDebianEVRStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateEVRStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateFieldType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateFileSetRevisionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateFloatType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateIOSVersionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateIPAddressStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateIPAddressType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateIntType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateRecordType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EntityStateVersionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.EscapeRegexFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.ExistenceEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.ExtendDefinitionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "definition_ref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Definition_ref = xmlschemaoval_common_5.DefinitionIDPattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.Extended:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ExtendedInfoElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ExtendedInformationElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ExtendedInfosElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.External_variableElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.External_variableElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *language2_0.FactRefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "name":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Name = language2_0.NamePattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.FactType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "name":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Name = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.FamilyEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.FilterActionEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.FilterElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.FilterElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.FirmNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.FirmType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.FirstNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.FixStrategyEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.FixTextType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "fixref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Fixref = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.FixType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        case "system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.System = &amp;v
                                }</span>
                        case "platform":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Platform = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.FormerNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.FqdnElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.FqdnElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.FromType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.Function:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.FunctionElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.GeneralSuffixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.GenerationIdentifierElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.GeneratorType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.GlobToRegexFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.GroupElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.GroupIdType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.GroupIdType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.GroupType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.GroupIdType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.HMACOutputLengthType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.HostElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.HostnameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.HostnameType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.HrefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.HtmlTextType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.HtmlTextWithSubType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.IdentType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.System = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.IdentityType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.IdrefListType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.IdrefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "idref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Idref = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.InstallationIdElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.InstanceFixType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "context":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Context = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.InstanceNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.InstanceResultType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "context":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Context = &amp;v
                                }</span>
                        case "parentContext":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.ParentContext = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.InterfaceHintType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.IpAddressElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.IpAddressType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.IpNetRangeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.IpV4ElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.IpV6ElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.Ipv4Type:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.Ipv6Type:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ItAssetElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ItemElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "cluster-id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.ClusterId = &amp;v
                                }</span>
                        case "extends":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Extends = &amp;v
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.ItemIDPattern:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.JointPersonNameElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.JointPersonNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.KeyInfoElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.KeyInfoType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.KeyLineCodeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.KeyNameElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.KeyValueElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.KeyValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.KnownAsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.LabelType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.LargeMailUserIdentifierElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Type":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Type = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.LargeMailUserNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Type":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Type = &amp;v
                                }</span>
                        case "Code":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Code = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.LargeMailUserType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Type":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Type = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.LastNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LicenseElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *dictionary2_0.ListType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.LiteralComponentType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.Local_variableElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.Local_variableElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocaleElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocaleType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.LocalityElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.LocalityElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.LocalityNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocationAddressElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocationElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocationPointElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocationPointElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocationRegionElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocationRegionElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocationsElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.LocationsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.LocatorElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.LocatorType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *language2_0.LogicalTestType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "operator":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Operator = language2_0.OperatorEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.MacAddressElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.MacAddressType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.MailStopNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.MailStopNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.MailStopType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.ManifestElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.ManifestType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.MessageLevelEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.MessageType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.MetadataType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.MgmtDataElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.MiddleNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ModelElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.System = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ModelElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.System = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.MotherboardGuidElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.MsgSevEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.NameDetails:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.NameDetailsElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.NameDetailsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.NameLineType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *language2_0.NamePattern:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.NamePrefixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.NetworkElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.NetworkInterfaceType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.NetworkNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.NetworkType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.NonEmptyStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.NotesElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.NotesElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.NotesType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.NoticeType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.ObjectComponentType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "object_ref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Object_ref = xmlschemaoval_common_5.ObjectIDPattern(v)
                                }</span>
                        case "item_field":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Item_field = xmlschemaoval_common_5.NonEmptyStringType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.ObjectElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.ObjectIDPattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.ObjectIDPattern:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ObjectRefElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "ref-id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.RefId = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ObjectRefElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "ref-id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.RefId = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.ObjectRefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "object_ref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Object_ref = xmlschemaoval_common_5.ObjectIDPattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.ObjectType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        case "MimeType":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.MimeType = &amp;v
                                }</span>
                        case "Encoding":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Encoding = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.ObjectsType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.OperationEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *language2_0.OperatorEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.OrganisationFormerNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.OrganisationKnownAsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.OrganisationNameDetails:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.OrganisationNameDetailsElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.OrganisationNameDetailsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.OrganisationNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.OrganisationTypeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.OrganizationElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.OrganizationType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.OtherNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.Oval_definitionsElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.Oval_definitionsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.OverrideType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "authority":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Authority = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.OverrideableCPE2idrefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.PGPDataElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.PGPDataType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ParamType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "name":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Name = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.PersonElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.PersonName:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.PersonNameElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.PersonNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.PersonType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.PlainTextType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *language2_0.PlatformSpecificationElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *language2_0.PlatformSpecificationElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *language2_0.PlatformType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.PortElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.PortRangeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.PortType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.PossibleRestrictionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "hint":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Hint = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.PossibleValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "hint":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Hint = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostBoxElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostBoxElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostBoxNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostBoxNumberExtensionElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostBoxNumberPrefixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostBoxNumberSuffixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostOfficeElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostOfficeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostOfficeNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostOfficeNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostTownElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostTownNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostTownSuffixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostalCodeElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostalCodeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostalCodeNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostalCodeNumberExtensionElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostalRouteNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostalRouteNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostalRouteType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PostalServiceElementsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.PrecedingTitleElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseLocationElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberPrefixElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberPrefixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberRangeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberRangeFromElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberRangeToElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberSuffixElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.PremiseNumberSuffixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.ProfileIdType(v)
                                }</span>
                        case "note-tag":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.NoteTag = &amp;v
                                }</span>
                        case "extends":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Extends = &amp;v
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id2 = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileIdType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileNoteType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "tag":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Tag = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileRefineRuleType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "idref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Idref = v
                                }</span>
                        case "selector":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Selector = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileRefineValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "idref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Idref = v
                                }</span>
                        case "selector":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Selector = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileSelectType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "idref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Idref = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileSetComplexValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "idref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Idref = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileSetValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "idref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Idref = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ProfileType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.ProfileIdType(v)
                                }</span>
                        case "note-tag":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.NoteTag = &amp;v
                                }</span>
                        case "extends":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Extends = &amp;v
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id2 = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ProtocolElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.RSAKeyValueElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.RSAKeyValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.RatingEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.ReferenceElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        case "URI":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.URI = &amp;v
                                }</span>
                        case "Type":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Type = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *dictionary2_0.ReferenceElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "href":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Href = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ReferenceType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "href":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Href = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *dictionary2_0.ReferencesType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.RegexCaptureFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "pattern":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Pattern = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *reporting_core1_1.RelationshipType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "type":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Type = v
                                }</span>
                        case "subject":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Subject = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *reporting_core1_1.RelationshipsContainerType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *reporting_core1_1.RelationshipsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.RemoteResourceElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.RemoteResourceElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ReportRequestType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ReportRequestsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ReportType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_reporting_format1_1.ReportsElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.ResourceElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.ResourceType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.RestrictionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "operation":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Operation = xmlschemaoval_common_5.OperationEnumeration(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ResultEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.RetrievalMethodElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "URI":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.URI = &amp;v
                                }</span>
                        case "Type":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Type = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.RetrievalMethodType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "URI":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.URI = &amp;v
                                }</span>
                        case "Type":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Type = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.RoleEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.RoleType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.RuleElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.RuleIdType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.RuleIdType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.RuleResultType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "idref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Idref = v
                                }</span>
                        case "version":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Version = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.RuleType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.RuleIdType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SPKIDataElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SPKIDataType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.SchemaVersionPattern:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.SchemaVersionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "platform":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Platform = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ScoreType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.System = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.SelChoicesType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "selector":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Selector = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.SelComplexValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "selector":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Selector = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.SelNumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "selector":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Selector = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.SelStringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "selector":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Selector = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ServedByElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ServiceElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.ServiceType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.SetElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.SetElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.SetOperatorEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.SeverityEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.ShowType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignatureElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignatureMethodElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Algorithm":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Algorithm = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignatureMethodType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Algorithm":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Algorithm = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignaturePropertiesElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignaturePropertiesType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignaturePropertyElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Target":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Target = v
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignaturePropertyType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Target":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Target = v
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.SignatureType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignatureValueElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignatureValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignedInfoElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.SignedInfoType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.Simple:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.SimpleDatatypeEnumeration:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.SoftwareElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.SoftwareType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SortingCodeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.SplitFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "delimiter":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Delimiter = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.StateElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.StateIDPattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.StateIDPattern:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.StateRefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "state_ref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.State_ref = xmlschemaoval_common_5.StateIDPattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.StateType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.StateIDPattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.StatesType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.StatusElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.StatusElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.StatusType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SubAdministrativeAreaElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SubAdministrativeAreaNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SubPremiseLocationElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SubPremiseNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SubPremiseNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SubPremiseNumberPrefixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SubPremiseNumberSuffixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SubPremiseType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.SubType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.SubUseEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.SubstringFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.SuffixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.SupplementaryPostalServiceDataElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.SyntheticIdElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "resource":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Resource = v
                                }</span>
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.SyntheticIdElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "resource":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Resource = v
                                }</span>
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.SystemElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.SystemNameElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.SystemType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TailoringBenchmarkReferenceType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "version":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Version = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TailoringElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.TailoringIdType(v)
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id2 = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TailoringIdType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TailoringReferenceType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "href":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Href = v
                                }</span>
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = v
                                }</span>
                        case "version":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Version = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TailoringType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.TailoringIdType(v)
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id2 = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TailoringVersionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TargetFactsType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TargetIdRefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.System = v
                                }</span>
                        case "href":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Href = v
                                }</span>
                        case "name":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Name = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.TelephoneNumberElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.TelephoneNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.TelephoneNumberType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.TestElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.TestIDPattern(v)
                                }</span>
                        case "check":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Check = xmlschemaoval_common_5.CheckEnumeration(v)
                                }</span>
                        case "comment":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Comment = xmlschemaoval_common_5.NonEmptyStringType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.TestIDPattern:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TestResultElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.TestresultIdType(v)
                                }</span>
                        case "test-system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.TestSystem = &amp;v
                                }</span>
                        case "version":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Version = &amp;v
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id2 = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TestResultType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.TestresultIdType(v)
                                }</span>
                        case "test-system":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.TestSystem = &amp;v
                                }</span>
                        case "version":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Version = &amp;v
                                }</span>
                        case "Id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id2 = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.TestType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.TestIDPattern(v)
                                }</span>
                        case "check":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Check = xmlschemaoval_common_5.CheckEnumeration(v)
                                }</span>
                        case "comment":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Comment = xmlschemaoval_common_5.NonEmptyStringType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TestresultIdType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.TestsType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *language2_0.TextType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.TextWithSubType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareLeadingTypeType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNameType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberFromElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberPrefixElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberPrefixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberRangeElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberSuffixElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberSuffixElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareNumberToElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfarePostDirectionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfarePreDirectionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.ThoroughfareTrailingTypeType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.TimeDifferenceFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.TitleAttrType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.TitleElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.TitleElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.TitleEltType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.ToType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.TransformElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Algorithm":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Algorithm = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.TransformType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "Algorithm":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Algorithm = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.TransformsElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.TransformsType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_1999xlink.TypeType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.UniqueFunctionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.UriRefType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "uri":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Uri = v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.UrlElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ValueElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.ValueIdType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ValueIdType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ValueOperatorType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ValueType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xccdf1_2.ValueIdType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.ValueTypeType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.VariableComponentType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "var_ref":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Var_ref = xmlschemaoval_common_5.VariableIDPattern(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.VariableElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.VariableIDPattern(v)
                                }</span>
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        case "comment":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Comment = xmlschemaoval_common_5.NonEmptyStringType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.VariableIDPattern:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.VariableType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "id":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Id = xmlschemaoval_common_5.VariableIDPattern(v)
                                }</span>
                        case "datatype":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Datatype = xmlschemaoval_common_5.SimpleDatatypeEnumeration(v)
                                }</span>
                        case "comment":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Comment = xmlschemaoval_common_5.NonEmptyStringType(v)
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_definitions_5.VariablesType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xmlschemaoval_common_5.VersionElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.VersionType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        case "update":<span class="cov0" title="0">
                                if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        root.Update = &amp;v
                                }</span>
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.WarningCategoryEnumType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.WarningType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.WebsiteElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.WebsiteType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.WebsiteUrlElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *asset_identification1_1.WebsiteUrlElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *xccdf1_2.WeightType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.X509DataElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.X509DataType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_200009xmldsig.X509IssuerSerialType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.XALElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_01.XALElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.XNLElement:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        case *pkg_2_0.XNLElementType:<span class="cov0" title="0">
                _ = root // Avoid unused variable if no updatable fields
                for key, value := range updates </span><span class="cov0" title="0">{
                        _ = value // Avoid unused variable
                        switch key </span>{
                        }
                }
                <span class="cov0" title="0">s.isDirty = true
                s.lastModified = time.Now()
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unknown root type: %T", s.rootElement)</span>
}

// updateFirstLevelElement updates a first-level child element.
func (s *XMLDocumentState) updateFirstLevelElement(name string, data json.RawMessage) error <span class="cov0" title="0">{
        // First-level element updates would require field-specific logic
        // For now, mark as dirty and return success for simple cases
        s.isDirty = true
        s.lastModified = time.Now()
        return fmt.Errorf("first-level element updates not yet fully implemented for: %s", name)
}</span>

// DeleteElement deletes an element at the given path.
func (s *XMLDocumentState) DeleteElement(path string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.rootElement == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no document loaded")
        }</span>

        <span class="cov8" title="1">if path == "/" </span><span class="cov8" title="1">{
                // Cannot delete root - clear the document instead
                s.rootElement = nil
                s.rootType = ""
                s.namespace = ""
                s.isDirty = true
                s.lastModified = time.Now()
                return nil
        }</span>

        <span class="cov8" title="1">parts := splitPath(path)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path: %s", path)
        }</span>

        // Handle first-level element deletion
        <span class="cov8" title="1">if len(parts) == 1 </span><span class="cov8" title="1">{
                return s.deleteFirstLevelElement(parts[0])
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("deep path deletion not yet implemented: %s", path)</span>
}

// deleteFirstLevelElement deletes a first-level child element.
func (s *XMLDocumentState) deleteFirstLevelElement(name string) error <span class="cov8" title="1">{
        switch root := s.rootElement.(type) </span>{
        case *xccdf1_2.BenchmarkElement:<span class="cov8" title="1">
                _ = root // Ensure root is used even when all fields are required (non-deletable)
                switch name </span>{
                case "dc-status":<span class="cov0" title="0">
                        root.DcStatus = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "title":<span class="cov0" title="0">
                        root.Title = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "description":<span class="cov0" title="0">
                        root.Description = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "notice":<span class="cov0" title="0">
                        root.Notice = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "front-matter":<span class="cov0" title="0">
                        root.FrontMatter = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "rear-matter":<span class="cov0" title="0">
                        root.RearMatter = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "reference":<span class="cov0" title="0">
                        root.Reference = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "plain-text":<span class="cov0" title="0">
                        root.PlainText = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "platform":<span class="cov0" title="0">
                        root.Platform = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "version":<span class="cov0" title="0">
                        // Cannot delete required non-pointer field
                        return fmt.Errorf("cannot delete required field: Version")</span>
                case "metadata":<span class="cov0" title="0">
                        root.Metadata = nil
                        s.isDirty = true
                        s.lastModified = time.Now()
                        return nil</span>
                case "signature":<span class="cov0" title="0">
                        // Cannot delete required non-pointer field
                        return fmt.Errorf("cannot delete required field: Signature")</span>
                }
        }

        <span class="cov8" title="1">return fmt.Errorf("element not found: %s", name)</span>
}

// Validate validates the current document.
func (s *XMLDocumentState) Validate() ([]ValidationError, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var errors []ValidationError

        if s.rootElement == nil </span><span class="cov8" title="1">{
                errors = append(errors, ValidationError{
                        Path:    "/",
                        Message: "No document loaded",
                })
                return errors, nil
        }</span>

        // Validate based on root element type
        <span class="cov8" title="1">switch root := s.rootElement.(type) </span>{
        case *xccdf1_2.BenchmarkElement:<span class="cov8" title="1">
                errors = append(errors, s.validateBenchmarkElement(root, "/")...)</span>
        }

        <span class="cov8" title="1">return errors, nil</span>
}

// validateAddressDetails validates a AddressDetails element.
func (s *XMLDocumentState) validateAddressDetails(elem *pkg_2_01.AddressDetails, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostalServiceElements
        // Validate Address
        // Validate AddressLines
        // Validate Country
        // Validate AddressType
        // Validate CurrentStatus
        // Validate ValidFromDate
        // Validate ValidToDate
        // Validate Usage
        // Validate AddressDetailsKey

        <span class="cov0" title="0">return errors</span>
}

// validateAddressDetailsElement validates a AddressDetailsElement element.
func (s *XMLDocumentState) validateAddressDetailsElement(elem *pkg_2_01.AddressDetailsElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostalServiceElements
        // Validate Address
        // Validate AddressLines
        // Validate Country
        // Validate AddressType
        // Validate CurrentStatus
        // Validate ValidFromDate
        // Validate ValidToDate
        // Validate Usage
        // Validate AddressDetailsKey

        <span class="cov0" title="0">return errors</span>
}

// validateAddressElementType validates a AddressElementType element.
func (s *XMLDocumentState) validateAddressElementType(elem *pkg_2_01.AddressElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAddressIdentifierElementType validates a AddressIdentifierElementType element.
func (s *XMLDocumentState) validateAddressIdentifierElementType(elem *pkg_2_01.AddressIdentifierElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate IdentifierType
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAddressLatitudeDirectionElementType validates a AddressLatitudeDirectionElementType element.
func (s *XMLDocumentState) validateAddressLatitudeDirectionElementType(elem *pkg_2_01.AddressLatitudeDirectionElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAddressLatitudeElementType validates a AddressLatitudeElementType element.
func (s *XMLDocumentState) validateAddressLatitudeElementType(elem *pkg_2_01.AddressLatitudeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAddressLineElement validates a AddressLineElement element.
func (s *XMLDocumentState) validateAddressLineElement(elem *pkg_2_01.AddressLineElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAddressLineElementType validates a AddressLineElementType element.
func (s *XMLDocumentState) validateAddressLineElementType(elem *pkg_2_01.AddressLineElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAddressLinesType validates a AddressLinesType element.
func (s *XMLDocumentState) validateAddressLinesType(elem *pkg_2_01.AddressLinesType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateAddressLongitudeDirectionElementType validates a AddressLongitudeDirectionElementType element.
func (s *XMLDocumentState) validateAddressLongitudeDirectionElementType(elem *pkg_2_01.AddressLongitudeDirectionElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAddressLongitudeElementType validates a AddressLongitudeElementType element.
func (s *XMLDocumentState) validateAddressLongitudeElementType(elem *pkg_2_01.AddressLongitudeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAddresseeIndicatorElementType validates a AddresseeIndicatorElementType element.
func (s *XMLDocumentState) validateAddresseeIndicatorElementType(elem *pkg_2_0.AddresseeIndicatorElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateAdministrativeAreaElement validates a AdministrativeAreaElement element.
func (s *XMLDocumentState) validateAdministrativeAreaElement(elem *pkg_2_01.AdministrativeAreaElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate AdministrativeAreaName
        // Validate SubAdministrativeArea
        // Validate Type
        // Validate UsageType
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validateAdministrativeAreaElementType validates a AdministrativeAreaElementType element.
func (s *XMLDocumentState) validateAdministrativeAreaElementType(elem *pkg_2_01.AdministrativeAreaElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate AdministrativeAreaName
        // Validate SubAdministrativeArea
        // Validate Type
        // Validate UsageType
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validateAdministrativeAreaNameElementType validates a AdministrativeAreaNameElementType element.
func (s *XMLDocumentState) validateAdministrativeAreaNameElementType(elem *pkg_2_01.AdministrativeAreaNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateAffectedType validates a AffectedType element.
func (s *XMLDocumentState) validateAffectedType(elem *xmlschemaoval_definitions_5.AffectedType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Platform
        // Validate Product
        // Validate Family
        <span class="cov0" title="0">if elem.Family == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/family",
                        Message: "Required field 'family' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Family) != "" </span><span class="cov0" title="0">{
                validValues := []string{"android", "asa", "apple_ios", "catos", "ios", "iosxe", "junos", "macos", "pixos", "undefined", "unix", "vmware_infrastructure", "windows"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Family) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/family",
                                Message: fmt.Sprintf("Field 'family' has invalid value '%s'", string(elem.Family)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateAliasElementType validates a AliasElementType element.
func (s *XMLDocumentState) validateAliasElementType(elem *pkg_2_0.AliasElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateArithmeticFunctionType validates a ArithmeticFunctionType element.
func (s *XMLDocumentState) validateArithmeticFunctionType(elem *xmlschemaoval_definitions_5.ArithmeticFunctionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Arithmetic_operation
        <span class="cov0" title="0">if elem.Arithmetic_operation == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/arithmetic_operation",
                        Message: "Required field 'arithmetic_operation' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Arithmetic_operation) != "" </span><span class="cov0" title="0">{
                validValues := []string{"add", "multiply"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Arithmetic_operation) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/arithmetic_operation",
                                Message: fmt.Sprintf("Field 'arithmetic_operation' has invalid value '%s'", string(elem.Arithmetic_operation)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateAssetElement validates a AssetElement element.
func (s *XMLDocumentState) validateAssetElement(elem *asset_identification1_1.AssetElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ExtendedInformation

        <span class="cov0" title="0">return errors</span>
}

// validateAssetElementType validates a AssetElementType element.
func (s *XMLDocumentState) validateAssetElementType(elem *asset_reporting_format1_1.AssetElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateAssetIdentificationType validates a AssetIdentificationType element.
func (s *XMLDocumentState) validateAssetIdentificationType(elem *asset_identification1_1.AssetIdentificationType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate AssetRef
        <span class="cov0" title="0">if elem.AssetRef == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/asset-ref",
                        Message: "Required field 'asset-ref' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateAssetRelatedElement validates a AssetRelatedElement element.
func (s *XMLDocumentState) validateAssetRelatedElement(elem *asset_identification1_1.AssetRelatedElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate AssetRef
        <span class="cov0" title="0">if elem.AssetRef == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/asset-ref",
                        Message: "Required field 'asset-ref' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateAssetReportCollectionElement validates a AssetReportCollectionElement element.
func (s *XMLDocumentState) validateAssetReportCollectionElement(elem *asset_reporting_format1_1.AssetReportCollectionElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ReportRequests
        // Validate Assets
        // Validate Reports
        // Validate ExtendedInfos
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateAssetReportCollectionElementType validates a AssetReportCollectionElementType element.
func (s *XMLDocumentState) validateAssetReportCollectionElementType(elem *asset_reporting_format1_1.AssetReportCollectionElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ReportRequests
        // Validate Assets
        // Validate Reports
        // Validate ExtendedInfos
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateAssetsElement validates a AssetsElement element.
func (s *XMLDocumentState) validateAssetsElement(elem *asset_identification1_1.AssetsElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Asset
        <span class="cov0" title="0">if len(elem.Asset) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/asset",
                        Message: "Required field 'asset' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Asset) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/asset",
                        Message: fmt.Sprintf("Field 'asset' requires at least 1 elements, got %d", len(elem.Asset)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateAssetsElementType validates a AssetsElementType element.
func (s *XMLDocumentState) validateAssetsElementType(elem *asset_reporting_format1_1.AssetsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Asset
        <span class="cov0" title="0">if len(elem.Asset) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/asset",
                        Message: "Required field 'asset' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Asset) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/asset",
                        Message: fmt.Sprintf("Field 'asset' requires at least 1 elements, got %d", len(elem.Asset)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateAssetsType validates a AssetsType element.
func (s *XMLDocumentState) validateAssetsType(elem *asset_identification1_1.AssetsType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Asset
        <span class="cov0" title="0">if len(elem.Asset) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/asset",
                        Message: "Required field 'asset' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Asset) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/asset",
                        Message: fmt.Sprintf("Field 'asset' requires at least 1 elements, got %d", len(elem.Asset)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateBarcodeElementType validates a BarcodeElementType element.
func (s *XMLDocumentState) validateBarcodeElementType(elem *pkg_2_01.BarcodeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateBeginFunctionType validates a BeginFunctionType element.
func (s *XMLDocumentState) validateBeginFunctionType(elem *xmlschemaoval_definitions_5.BeginFunctionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Character
        <span class="cov0" title="0">if elem.Character == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/character",
                        Message: "Required field 'character' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateBenchmarkElement validates a BenchmarkElement element.
func (s *XMLDocumentState) validateBenchmarkElement(elem *xccdf1_2.BenchmarkElement, path string) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DcStatus
        // Validate Title
        // Validate Description
        // Validate Notice
        // Validate FrontMatter
        // Validate RearMatter
        // Validate Reference
        // Validate PlainText
        // Validate Platform
        // Validate Version
        // Validate Metadata
        // Validate Signature
        // Validate Id
        <span class="cov8" title="1">if elem.Id == "" </span><span class="cov8" title="1">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov8" title="1">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_benchmark_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Id2
        // Validate Resolved
        // Validate Style
        // Validate StyleHref

        <span class="cov8" title="1">return errors</span>
}

// validateBenchmarkElementType validates a BenchmarkElementType element.
func (s *XMLDocumentState) validateBenchmarkElementType(elem *xccdf1_2.BenchmarkElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DcStatus
        // Validate Title
        // Validate Description
        // Validate Notice
        // Validate FrontMatter
        // Validate RearMatter
        // Validate Reference
        // Validate PlainText
        // Validate Platform
        // Validate Version
        // Validate Metadata
        // Validate Signature
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_benchmark_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Id2
        // Validate Resolved
        // Validate Style
        // Validate StyleHref

        <span class="cov0" title="0">return errors</span>
}

// validateBenchmarkReferenceType validates a BenchmarkReferenceType element.
func (s *XMLDocumentState) validateBenchmarkReferenceType(elem *xccdf1_2.BenchmarkReferenceType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Href
        <span class="cov0" title="0">if elem.Href == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/href",
                        Message: "Required field 'href' is missing or empty",
                })
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateBirthdateElementType validates a BirthdateElementType element.
func (s *XMLDocumentState) validateBirthdateElementType(elem *asset_identification1_1.BirthdateElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateBuildingNameType validates a BuildingNameType element.
func (s *XMLDocumentState) validateBuildingNameType(elem *pkg_2_01.BuildingNameType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate TypeOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validateCPE2idrefType validates a CPE2idrefType element.
func (s *XMLDocumentState) validateCPE2idrefType(elem *xccdf1_2.CPE2idrefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Idref
        <span class="cov0" title="0">if elem.Idref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCanonicalizationMethodElement validates a CanonicalizationMethodElement element.
func (s *XMLDocumentState) validateCanonicalizationMethodElement(elem *pkg_200009xmldsig.CanonicalizationMethodElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Algorithm
        <span class="cov0" title="0">if elem.Algorithm == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Algorithm",
                        Message: "Required field 'Algorithm' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCanonicalizationMethodType validates a CanonicalizationMethodType element.
func (s *XMLDocumentState) validateCanonicalizationMethodType(elem *pkg_200009xmldsig.CanonicalizationMethodType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Algorithm
        <span class="cov0" title="0">if elem.Algorithm == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Algorithm",
                        Message: "Required field 'Algorithm' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCheckContentRefType validates a CheckContentRefType element.
func (s *XMLDocumentState) validateCheckContentRefType(elem *xccdf1_2.CheckContentRefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Href
        <span class="cov0" title="0">if elem.Href == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/href",
                        Message: "Required field 'href' is missing or empty",
                })
        }</span>
        // Validate Name

        <span class="cov0" title="0">return errors</span>
}

// validateCheckExportType validates a CheckExportType element.
func (s *XMLDocumentState) validateCheckExportType(elem *xccdf1_2.CheckExportType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ValueId
        <span class="cov0" title="0">if elem.ValueId == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/value-id",
                        Message: "Required field 'value-id' is missing or empty",
                })
        }</span>
        // Validate ExportName
        <span class="cov0" title="0">if elem.ExportName == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/export-name",
                        Message: "Required field 'export-name' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCheckImportType validates a CheckImportType element.
func (s *XMLDocumentState) validateCheckImportType(elem *xccdf1_2.CheckImportType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ImportName
        <span class="cov0" title="0">if elem.ImportName == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/import-name",
                        Message: "Required field 'import-name' is missing or empty",
                })
        }</span>
        // Validate ImportXpath

        <span class="cov0" title="0">return errors</span>
}

// validateCheckType validates a CheckType element.
func (s *XMLDocumentState) validateCheckType(elem *xccdf1_2.CheckType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate CheckImport
        // Validate CheckExport
        // Validate CheckContentRef
        // Validate CheckContent
        // Validate System
        <span class="cov0" title="0">if elem.System == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/system",
                        Message: "Required field 'system' is missing or empty",
                })
        }</span>
        // Validate Negate
        // Validate Id
        // Validate Selector
        // Validate MultiCheck

        <span class="cov0" title="0">return errors</span>
}

// validateCidrElementType validates a CidrElementType element.
func (s *XMLDocumentState) validateCidrElementType(elem *asset_identification1_1.CidrElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCircuitElement validates a CircuitElement element.
func (s *XMLDocumentState) validateCircuitElement(elem *asset_identification1_1.CircuitElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate CircuitName

        <span class="cov0" title="0">return errors</span>
}

// validateCircuitNameElementType validates a CircuitNameElementType element.
func (s *XMLDocumentState) validateCircuitNameElementType(elem *asset_identification1_1.CircuitNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCircuitType validates a CircuitType element.
func (s *XMLDocumentState) validateCircuitType(elem *asset_identification1_1.CircuitType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate CircuitName

        <span class="cov0" title="0">return errors</span>
}

// validateComplexCheckType validates a ComplexCheckType element.
func (s *XMLDocumentState) validateComplexCheckType(elem *xccdf1_2.ComplexCheckType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Check
        // Validate ComplexCheck
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/operator",
                        Message: "Required field 'operator' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"OR", "AND"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(elem.Operator)),
                        })
                }</span>
        }
        // Validate Negate

        <span class="cov0" title="0">return errors</span>
}

// validateComplexValueType validates a ComplexValueType element.
func (s *XMLDocumentState) validateComplexValueType(elem *xccdf1_2.ComplexValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Item

        <span class="cov0" title="0">return errors</span>
}

// validateComputingDeviceElement validates a ComputingDeviceElement element.
func (s *XMLDocumentState) validateComputingDeviceElement(elem *asset_identification1_1.ComputingDeviceElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DistinguishedName
        // Validate Connections
        // Validate Hostname
        // Validate MotherboardGuid

        <span class="cov0" title="0">return errors</span>
}

// validateComputingDeviceType validates a ComputingDeviceType element.
func (s *XMLDocumentState) validateComputingDeviceType(elem *asset_identification1_1.ComputingDeviceType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DistinguishedName
        // Validate Connections
        // Validate Hostname
        // Validate MotherboardGuid

        <span class="cov0" title="0">return errors</span>
}

// validateConnectionsElementType validates a ConnectionsElementType element.
func (s *XMLDocumentState) validateConnectionsElementType(elem *asset_identification1_1.ConnectionsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Connection
        <span class="cov0" title="0">if len(elem.Connection) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/connection",
                        Message: "Required field 'connection' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Connection) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/connection",
                        Message: fmt.Sprintf("Field 'connection' requires at least 1 elements, got %d", len(elem.Connection)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateConstant_variableElement validates a Constant_variableElement element.
func (s *XMLDocumentState) validateConstant_variableElement(elem *xmlschemaoval_definitions_5.Constant_variableElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Value
        <span class="cov0" title="0">if len(elem.Value) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/value",
                        Message: "Required field 'value' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Value) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/value",
                        Message: fmt.Sprintf("Field 'value' requires at least 1 elements, got %d", len(elem.Value)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateConstant_variableElementType validates a Constant_variableElementType element.
func (s *XMLDocumentState) validateConstant_variableElementType(elem *xmlschemaoval_definitions_5.Constant_variableElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Value
        <span class="cov0" title="0">if len(elem.Value) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/value",
                        Message: "Required field 'value' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Value) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/value",
                        Message: fmt.Sprintf("Field 'value' requires at least 1 elements, got %d", len(elem.Value)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateContentElementType validates a ContentElementType element.
func (s *XMLDocumentState) validateContentElementType(elem *asset_reporting_format1_1.ContentElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DataValidStartDate
        // Validate DataValidEndDate

        <span class="cov0" title="0">return errors</span>
}

// validateCountryElementType validates a CountryElementType element.
func (s *XMLDocumentState) validateCountryElementType(elem *pkg_2_01.CountryElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate CountryNameCode

        <span class="cov0" title="0">return errors</span>
}

// validateCountryNameCodeElementType validates a CountryNameCodeElementType element.
func (s *XMLDocumentState) validateCountryNameCodeElementType(elem *pkg_2_01.CountryNameCodeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Scheme

        <span class="cov0" title="0">return errors</span>
}

// validateCountryNameElement validates a CountryNameElement element.
func (s *XMLDocumentState) validateCountryNameElement(elem *pkg_2_01.CountryNameElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateCountryNameElementType validates a CountryNameElementType element.
func (s *XMLDocumentState) validateCountryNameElementType(elem *pkg_2_01.CountryNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateCpeElement validates a CpeElement element.
func (s *XMLDocumentState) validateCpeElement(elem *asset_identification1_1.CpeElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCpeElementType validates a CpeElementType element.
func (s *XMLDocumentState) validateCpeElementType(elem *asset_identification1_1.CpeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCpeItemElement validates a CpeItemElement element.
func (s *XMLDocumentState) validateCpeItemElement(elem *dictionary2_0.CpeItemElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Title
        <span class="cov0" title="0">if len(elem.Title) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/title",
                        Message: "Required field 'title' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Title) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/title",
                        Message: fmt.Sprintf("Field 'title' requires at least 1 elements, got %d", len(elem.Title)),
                })
        }</span>
        // Validate Notes
        // Validate References
        // Validate Check
        // Validate Name
        <span class="cov0" title="0">if elem.Name == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/name",
                        Message: "Required field 'name' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Name) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\._\-~%]*){0,6}`, string(elem.Name))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/name",
                                Message: "Field 'name' does not match required pattern",
                        })
                }</span>
        }
        // Validate Deprecated
        // Validate Deprecated_by
        <span class="cov0" title="0">if elem.Deprecated_by != nil &amp;&amp; string(*elem.Deprecated_by) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\._\-~%]*){0,6}`, string(*elem.Deprecated_by))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/deprecated_by",
                                Message: "Field 'deprecated_by' does not match required pattern",
                        })
                }</span>
        }
        // Validate Deprecation_date

        <span class="cov0" title="0">return errors</span>
}

// validateCpeListElement validates a CpeListElement element.
func (s *XMLDocumentState) validateCpeListElement(elem *dictionary2_0.CpeListElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Generator

        <span class="cov0" title="0">return errors</span>
}

// validateCriteriaType validates a CriteriaType element.
func (s *XMLDocumentState) validateCriteriaType(elem *xmlschemaoval_definitions_5.CriteriaType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Criteria
        // Validate Criterion
        // Validate Extend_definition
        // Validate Applicability_check
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator != nil &amp;&amp; string(*elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"AND", "OR"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(*elem.Operator)),
                        })
                }</span>
        }
        // Validate Negate
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment != nil &amp;&amp; string(*elem.Comment) != "" &amp;&amp; len(string(*elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateCriterionType validates a CriterionType element.
func (s *XMLDocumentState) validateCriterionType(elem *xmlschemaoval_definitions_5.CriterionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Applicability_check
        // Validate Test_ref
        <span class="cov0" title="0">if elem.Test_ref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/test_ref",
                        Message: "Required field 'test_ref' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Test_ref) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:tst:[1-9][0-9]*`, string(elem.Test_ref))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/test_ref",
                                Message: "Field 'test_ref' does not match required pattern",
                        })
                }</span>
        }
        // Validate Negate
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment != nil &amp;&amp; string(*elem.Comment) != "" &amp;&amp; len(string(*elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateDSAKeyValueElement validates a DSAKeyValueElement element.
func (s *XMLDocumentState) validateDSAKeyValueElement(elem *pkg_200009xmldsig.DSAKeyValueElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate G
        // Validate Y
        // Validate J
        // Validate P
        // Validate Q
        // Validate Seed
        // Validate PgenCounter

        <span class="cov0" title="0">return errors</span>
}

// validateDSAKeyValueType validates a DSAKeyValueType element.
func (s *XMLDocumentState) validateDSAKeyValueType(elem *pkg_200009xmldsig.DSAKeyValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate G
        // Validate Y
        // Validate J
        // Validate P
        // Validate Q
        // Validate Seed
        // Validate PgenCounter

        <span class="cov0" title="0">return errors</span>
}

// validateDatabaseElement validates a DatabaseElement element.
func (s *XMLDocumentState) validateDatabaseElement(elem *asset_identification1_1.DatabaseElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate InstanceName

        <span class="cov0" title="0">return errors</span>
}

// validateDatabaseType validates a DatabaseType element.
func (s *XMLDocumentState) validateDatabaseType(elem *asset_identification1_1.DatabaseType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate InstanceName

        <span class="cov0" title="0">return errors</span>
}

// validateDefinitionElement validates a DefinitionElement element.
func (s *XMLDocumentState) validateDefinitionElement(elem *xmlschemaoval_definitions_5.DefinitionElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Metadata
        // Validate Criteria
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:def:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Class
        <span class="cov0" title="0">if elem.Class == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/class",
                        Message: "Required field 'class' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Class) != "" </span><span class="cov0" title="0">{
                validValues := []string{"compliance", "inventory", "miscellaneous", "patch", "vulnerability"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Class) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/class",
                                Message: fmt.Sprintf("Field 'class' has invalid value '%s'", string(elem.Class)),
                        })
                }</span>
        }
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateDefinitionType validates a DefinitionType element.
func (s *XMLDocumentState) validateDefinitionType(elem *xmlschemaoval_definitions_5.DefinitionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Metadata
        // Validate Criteria
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:def:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Class
        <span class="cov0" title="0">if elem.Class == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/class",
                        Message: "Required field 'class' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Class) != "" </span><span class="cov0" title="0">{
                validValues := []string{"compliance", "inventory", "miscellaneous", "patch", "vulnerability"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Class) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/class",
                                Message: fmt.Sprintf("Field 'class' has invalid value '%s'", string(elem.Class)),
                        })
                }</span>
        }
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateDefinitionsType validates a DefinitionsType element.
func (s *XMLDocumentState) validateDefinitionsType(elem *xmlschemaoval_definitions_5.DefinitionsType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateDepartmentElement validates a DepartmentElement element.
func (s *XMLDocumentState) validateDepartmentElement(elem *pkg_2_01.DepartmentElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DepartmentName
        // Validate MailStop
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateDepartmentElementType validates a DepartmentElementType element.
func (s *XMLDocumentState) validateDepartmentElementType(elem *pkg_2_01.DepartmentElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DepartmentName
        // Validate MailStop
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateDepartmentNameElementType validates a DepartmentNameElementType element.
func (s *XMLDocumentState) validateDepartmentNameElementType(elem *pkg_2_01.DepartmentNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateDependencyNameElementType validates a DependencyNameElementType element.
func (s *XMLDocumentState) validateDependencyNameElementType(elem *pkg_2_0.DependencyNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DependencyType

        <span class="cov0" title="0">return errors</span>
}

// validateDependentLocalityNameElementType validates a DependentLocalityNameElementType element.
func (s *XMLDocumentState) validateDependentLocalityNameElementType(elem *pkg_2_01.DependentLocalityNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateDependentLocalityNumberElementType validates a DependentLocalityNumberElementType element.
func (s *XMLDocumentState) validateDependentLocalityNumberElementType(elem *pkg_2_01.DependentLocalityNumberElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NameNumberOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validateDependentLocalityType validates a DependentLocalityType element.
func (s *XMLDocumentState) validateDependentLocalityType(elem *pkg_2_01.DependentLocalityType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DependentLocalityName
        // Validate DependentLocalityNumber
        // Validate DependentLocality
        // Validate LargeMailUser
        // Validate PostalRoute
        // Validate Type
        // Validate UsageType
        // Validate Connector
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validateDependentThoroughfareElementType validates a DependentThoroughfareElementType element.
func (s *XMLDocumentState) validateDependentThoroughfareElementType(elem *pkg_2_01.DependentThoroughfareElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ThoroughfarePreDirection
        // Validate ThoroughfareLeadingType
        // Validate ThoroughfareName
        // Validate ThoroughfareTrailingType
        // Validate ThoroughfarePostDirection
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateDeprecatedInfoType validates a DeprecatedInfoType element.
func (s *XMLDocumentState) validateDeprecatedInfoType(elem *xmlschemaoval_common_5.DeprecatedInfoType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Version
        // Validate Reason
        // Validate Comment

        <span class="cov0" title="0">return errors</span>
}

// validateDeprecated_infoElement validates a Deprecated_infoElement element.
func (s *XMLDocumentState) validateDeprecated_infoElement(elem *xmlschemaoval_common_5.Deprecated_infoElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Version
        // Validate Reason
        // Validate Comment

        <span class="cov0" title="0">return errors</span>
}

// validateDigestMethodElement validates a DigestMethodElement element.
func (s *XMLDocumentState) validateDigestMethodElement(elem *pkg_200009xmldsig.DigestMethodElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Algorithm
        <span class="cov0" title="0">if elem.Algorithm == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Algorithm",
                        Message: "Required field 'Algorithm' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateDigestMethodType validates a DigestMethodType element.
func (s *XMLDocumentState) validateDigestMethodType(elem *pkg_200009xmldsig.DigestMethodType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Algorithm
        <span class="cov0" title="0">if elem.Algorithm == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Algorithm",
                        Message: "Required field 'Algorithm' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateDistinguishedNameElementType validates a DistinguishedNameElementType element.
func (s *XMLDocumentState) validateDistinguishedNameElementType(elem *asset_identification1_1.DistinguishedNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateDocumentRootElementType validates a DocumentRootElementType element.
func (s *XMLDocumentState) validateDocumentRootElementType(elem *asset_identification1_1.DocumentRootElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateElementMapItemType validates a ElementMapItemType element.
func (s *XMLDocumentState) validateElementMapItemType(elem *xmlschemaoval_common_5.ElementMapItemType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Target_namespace

        <span class="cov0" title="0">return errors</span>
}

// validateElementMapType validates a ElementMapType element.
func (s *XMLDocumentState) validateElementMapType(elem *xmlschemaoval_common_5.ElementMapType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Test
        // Validate Object
        // Validate State
        // Validate Item

        <span class="cov0" title="0">return errors</span>
}

// validateElement_mappingElement validates a Element_mappingElement element.
func (s *XMLDocumentState) validateElement_mappingElement(elem *xmlschemaoval_common_5.Element_mappingElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Test
        // Validate Object
        // Validate State
        // Validate Item

        <span class="cov0" title="0">return errors</span>
}

// validateEmailAddressElement validates a EmailAddressElement element.
func (s *XMLDocumentState) validateEmailAddressElement(elem *asset_identification1_1.EmailAddressElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateEmailAddressElementType validates a EmailAddressElementType element.
func (s *XMLDocumentState) validateEmailAddressElementType(elem *asset_identification1_1.EmailAddressElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateEndFunctionType validates a EndFunctionType element.
func (s *XMLDocumentState) validateEndFunctionType(elem *xmlschemaoval_definitions_5.EndFunctionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Character
        <span class="cov0" title="0">if elem.Character == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/character",
                        Message: "Required field 'character' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateEndorsementLineCodeElementType validates a EndorsementLineCodeElementType element.
func (s *XMLDocumentState) validateEndorsementLineCodeElementType(elem *pkg_2_01.EndorsementLineCodeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectAnySimpleType validates a EntityObjectAnySimpleType element.
func (s *XMLDocumentState) validateEntityObjectAnySimpleType(elem *xmlschemaoval_definitions_5.EntityObjectAnySimpleType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype != nil &amp;&amp; string(*elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(*elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectBinaryType validates a EntityObjectBinaryType element.
func (s *XMLDocumentState) validateEntityObjectBinaryType(elem *xmlschemaoval_definitions_5.EntityObjectBinaryType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectBoolType validates a EntityObjectBoolType element.
func (s *XMLDocumentState) validateEntityObjectBoolType(elem *xmlschemaoval_definitions_5.EntityObjectBoolType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectFieldType validates a EntityObjectFieldType element.
func (s *XMLDocumentState) validateEntityObjectFieldType(elem *xmlschemaoval_definitions_5.EntityObjectFieldType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Name
        // Validate Entity_check
        <span class="cov0" title="0">if elem.Entity_check != nil &amp;&amp; string(*elem.Entity_check) != "" </span><span class="cov0" title="0">{
                validValues := []string{"all", "at least one", "none exist", "none satisfy", "only one"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Entity_check) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/entity_check",
                                Message: fmt.Sprintf("Field 'entity_check' has invalid value '%s'", string(*elem.Entity_check)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectFloatType validates a EntityObjectFloatType element.
func (s *XMLDocumentState) validateEntityObjectFloatType(elem *xmlschemaoval_definitions_5.EntityObjectFloatType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectIPAddressStringType validates a EntityObjectIPAddressStringType element.
func (s *XMLDocumentState) validateEntityObjectIPAddressStringType(elem *xmlschemaoval_definitions_5.EntityObjectIPAddressStringType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectIPAddressType validates a EntityObjectIPAddressType element.
func (s *XMLDocumentState) validateEntityObjectIPAddressType(elem *xmlschemaoval_definitions_5.EntityObjectIPAddressType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectIntType validates a EntityObjectIntType element.
func (s *XMLDocumentState) validateEntityObjectIntType(elem *xmlschemaoval_definitions_5.EntityObjectIntType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectRecordType validates a EntityObjectRecordType element.
func (s *XMLDocumentState) validateEntityObjectRecordType(elem *xmlschemaoval_definitions_5.EntityObjectRecordType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Field

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectStringType validates a EntityObjectStringType element.
func (s *XMLDocumentState) validateEntityObjectStringType(elem *xmlschemaoval_definitions_5.EntityObjectStringType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype != nil &amp;&amp; string(*elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(*elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityObjectVersionType validates a EntityObjectVersionType element.
func (s *XMLDocumentState) validateEntityObjectVersionType(elem *xmlschemaoval_definitions_5.EntityObjectVersionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateAnySimpleType validates a EntityStateAnySimpleType element.
func (s *XMLDocumentState) validateEntityStateAnySimpleType(elem *xmlschemaoval_definitions_5.EntityStateAnySimpleType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype != nil &amp;&amp; string(*elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(*elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateBinaryType validates a EntityStateBinaryType element.
func (s *XMLDocumentState) validateEntityStateBinaryType(elem *xmlschemaoval_definitions_5.EntityStateBinaryType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateBoolType validates a EntityStateBoolType element.
func (s *XMLDocumentState) validateEntityStateBoolType(elem *xmlschemaoval_definitions_5.EntityStateBoolType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateDebianEVRStringType validates a EntityStateDebianEVRStringType element.
func (s *XMLDocumentState) validateEntityStateDebianEVRStringType(elem *xmlschemaoval_definitions_5.EntityStateDebianEVRStringType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateEVRStringType validates a EntityStateEVRStringType element.
func (s *XMLDocumentState) validateEntityStateEVRStringType(elem *xmlschemaoval_definitions_5.EntityStateEVRStringType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateFieldType validates a EntityStateFieldType element.
func (s *XMLDocumentState) validateEntityStateFieldType(elem *xmlschemaoval_definitions_5.EntityStateFieldType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Name
        // Validate Entity_check
        <span class="cov0" title="0">if elem.Entity_check != nil &amp;&amp; string(*elem.Entity_check) != "" </span><span class="cov0" title="0">{
                validValues := []string{"all", "at least one", "none exist", "none satisfy", "only one"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Entity_check) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/entity_check",
                                Message: fmt.Sprintf("Field 'entity_check' has invalid value '%s'", string(*elem.Entity_check)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateFileSetRevisionType validates a EntityStateFileSetRevisionType element.
func (s *XMLDocumentState) validateEntityStateFileSetRevisionType(elem *xmlschemaoval_definitions_5.EntityStateFileSetRevisionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateFloatType validates a EntityStateFloatType element.
func (s *XMLDocumentState) validateEntityStateFloatType(elem *xmlschemaoval_definitions_5.EntityStateFloatType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateIOSVersionType validates a EntityStateIOSVersionType element.
func (s *XMLDocumentState) validateEntityStateIOSVersionType(elem *xmlschemaoval_definitions_5.EntityStateIOSVersionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateIPAddressStringType validates a EntityStateIPAddressStringType element.
func (s *XMLDocumentState) validateEntityStateIPAddressStringType(elem *xmlschemaoval_definitions_5.EntityStateIPAddressStringType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateIPAddressType validates a EntityStateIPAddressType element.
func (s *XMLDocumentState) validateEntityStateIPAddressType(elem *xmlschemaoval_definitions_5.EntityStateIPAddressType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateIntType validates a EntityStateIntType element.
func (s *XMLDocumentState) validateEntityStateIntType(elem *xmlschemaoval_definitions_5.EntityStateIntType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateRecordType validates a EntityStateRecordType element.
func (s *XMLDocumentState) validateEntityStateRecordType(elem *xmlschemaoval_definitions_5.EntityStateRecordType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Field

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateStringType validates a EntityStateStringType element.
func (s *XMLDocumentState) validateEntityStateStringType(elem *xmlschemaoval_definitions_5.EntityStateStringType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype != nil &amp;&amp; string(*elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(*elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateEntityStateVersionType validates a EntityStateVersionType element.
func (s *XMLDocumentState) validateEntityStateVersionType(elem *xmlschemaoval_definitions_5.EntityStateVersionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateExtendDefinitionType validates a ExtendDefinitionType element.
func (s *XMLDocumentState) validateExtendDefinitionType(elem *xmlschemaoval_definitions_5.ExtendDefinitionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Applicability_check
        // Validate Definition_ref
        <span class="cov0" title="0">if elem.Definition_ref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/definition_ref",
                        Message: "Required field 'definition_ref' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Definition_ref) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:def:[1-9][0-9]*`, string(elem.Definition_ref))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/definition_ref",
                                Message: "Field 'definition_ref' does not match required pattern",
                        })
                }</span>
        }
        // Validate Negate
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment != nil &amp;&amp; string(*elem.Comment) != "" &amp;&amp; len(string(*elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateExtendedInfoElementType validates a ExtendedInfoElementType element.
func (s *XMLDocumentState) validateExtendedInfoElementType(elem *asset_reporting_format1_1.ExtendedInfoElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateExtendedInfosElementType validates a ExtendedInfosElementType element.
func (s *XMLDocumentState) validateExtendedInfosElementType(elem *asset_reporting_format1_1.ExtendedInfosElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ExtendedInfo
        <span class="cov0" title="0">if len(elem.ExtendedInfo) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/extended-info",
                        Message: "Required field 'extended-info' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.ExtendedInfo) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/extended-info",
                        Message: fmt.Sprintf("Field 'extended-info' requires at least 1 elements, got %d", len(elem.ExtendedInfo)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateExternal_variableElement validates a External_variableElement element.
func (s *XMLDocumentState) validateExternal_variableElement(elem *xmlschemaoval_definitions_5.External_variableElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Possible_value
        // Validate Possible_restriction

        <span class="cov0" title="0">return errors</span>
}

// validateExternal_variableElementType validates a External_variableElementType element.
func (s *XMLDocumentState) validateExternal_variableElementType(elem *xmlschemaoval_definitions_5.External_variableElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Possible_value
        // Validate Possible_restriction

        <span class="cov0" title="0">return errors</span>
}

// validateFactRefType validates a FactRefType element.
func (s *XMLDocumentState) validateFactRefType(elem *language2_0.FactRefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Name
        <span class="cov0" title="0">if elem.Name == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/name",
                        Message: "Required field 'name' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Name) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`cpe:/([aho](:[A-Za-z0-9\._\-~]*(:[A-Za-z0-9\._\-~]*(:[A-Za-z0-9\._\.\-~]*(:[A-Za-z0-9\._\-~]*)?)?)?)?)?`, string(elem.Name))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/name",
                                Message: "Field 'name' does not match required pattern",
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateFactType validates a FactType element.
func (s *XMLDocumentState) validateFactType(elem *xccdf1_2.FactType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Name
        <span class="cov0" title="0">if elem.Name == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/name",
                        Message: "Required field 'name' is missing or empty",
                })
        }</span>
        // Validate Type
        <span class="cov0" title="0">if elem.Type != nil &amp;&amp; string(*elem.Type) != "" </span><span class="cov0" title="0">{
                validValues := []string{"number", "string", "boolean"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Type) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/type",
                                Message: fmt.Sprintf("Field 'type' has invalid value '%s'", string(*elem.Type)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateFilterElement validates a FilterElement element.
func (s *XMLDocumentState) validateFilterElement(elem *xmlschemaoval_definitions_5.FilterElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Action
        <span class="cov0" title="0">if elem.Action != nil &amp;&amp; string(*elem.Action) != "" </span><span class="cov0" title="0">{
                validValues := []string{"exclude", "include"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Action) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/action",
                                Message: fmt.Sprintf("Field 'action' has invalid value '%s'", string(*elem.Action)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateFilterElementType validates a FilterElementType element.
func (s *XMLDocumentState) validateFilterElementType(elem *xmlschemaoval_definitions_5.FilterElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Action
        <span class="cov0" title="0">if elem.Action != nil &amp;&amp; string(*elem.Action) != "" </span><span class="cov0" title="0">{
                validValues := []string{"exclude", "include"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Action) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/action",
                                Message: fmt.Sprintf("Field 'action' has invalid value '%s'", string(*elem.Action)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateFirmNameElementType validates a FirmNameElementType element.
func (s *XMLDocumentState) validateFirmNameElementType(elem *pkg_2_01.FirmNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateFirmType validates a FirmType element.
func (s *XMLDocumentState) validateFirmType(elem *pkg_2_01.FirmType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate FirmName
        // Validate MailStop
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateFirstNameElementType validates a FirstNameElementType element.
func (s *XMLDocumentState) validateFirstNameElementType(elem *pkg_2_0.FirstNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateFixTextType validates a FixTextType element.
func (s *XMLDocumentState) validateFixTextType(elem *xccdf1_2.FixTextType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Fixref
        // Validate Reboot
        // Validate Strategy
        <span class="cov0" title="0">if elem.Strategy != nil &amp;&amp; string(*elem.Strategy) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "configure", "combination", "disable", "enable", "patch", "policy", "restrict", "update"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Strategy) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/strategy",
                                Message: fmt.Sprintf("Field 'strategy' has invalid value '%s'", string(*elem.Strategy)),
                        })
                }</span>
        }
        // Validate Disruption
        <span class="cov0" title="0">if elem.Disruption != nil &amp;&amp; string(*elem.Disruption) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "low", "medium", "high"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Disruption) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/disruption",
                                Message: fmt.Sprintf("Field 'disruption' has invalid value '%s'", string(*elem.Disruption)),
                        })
                }</span>
        }
        // Validate Complexity
        <span class="cov0" title="0">if elem.Complexity != nil &amp;&amp; string(*elem.Complexity) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "low", "medium", "high"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Complexity) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/complexity",
                                Message: fmt.Sprintf("Field 'complexity' has invalid value '%s'", string(*elem.Complexity)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateFixType validates a FixType element.
func (s *XMLDocumentState) validateFixType(elem *xccdf1_2.FixType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Sub
        // Validate Instance
        // Validate Id
        // Validate Reboot
        // Validate Strategy
        <span class="cov0" title="0">if elem.Strategy != nil &amp;&amp; string(*elem.Strategy) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "configure", "combination", "disable", "enable", "patch", "policy", "restrict", "update"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Strategy) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/strategy",
                                Message: fmt.Sprintf("Field 'strategy' has invalid value '%s'", string(*elem.Strategy)),
                        })
                }</span>
        }
        // Validate Disruption
        <span class="cov0" title="0">if elem.Disruption != nil &amp;&amp; string(*elem.Disruption) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "low", "medium", "high"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Disruption) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/disruption",
                                Message: fmt.Sprintf("Field 'disruption' has invalid value '%s'", string(*elem.Disruption)),
                        })
                }</span>
        }
        // Validate Complexity
        <span class="cov0" title="0">if elem.Complexity != nil &amp;&amp; string(*elem.Complexity) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "low", "medium", "high"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Complexity) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/complexity",
                                Message: fmt.Sprintf("Field 'complexity' has invalid value '%s'", string(*elem.Complexity)),
                        })
                }</span>
        }
        // Validate System
        // Validate Platform

        <span class="cov0" title="0">return errors</span>
}

// validateFormerNameElementType validates a FormerNameElementType element.
func (s *XMLDocumentState) validateFormerNameElementType(elem *pkg_2_0.FormerNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ValidFrom
        // Validate ValidTo

        <span class="cov0" title="0">return errors</span>
}

// validateFqdnElement validates a FqdnElement element.
func (s *XMLDocumentState) validateFqdnElement(elem *asset_identification1_1.FqdnElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateFqdnElementType validates a FqdnElementType element.
func (s *XMLDocumentState) validateFqdnElementType(elem *asset_identification1_1.FqdnElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateFunction validates a Function element.
func (s *XMLDocumentState) validateFunction(elem *pkg_2_0.Function, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateFunctionElement validates a FunctionElement element.
func (s *XMLDocumentState) validateFunctionElement(elem *pkg_2_0.FunctionElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateGeneralSuffixElementType validates a GeneralSuffixElementType element.
func (s *XMLDocumentState) validateGeneralSuffixElementType(elem *pkg_2_0.GeneralSuffixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateGenerationIdentifierElementType validates a GenerationIdentifierElementType element.
func (s *XMLDocumentState) validateGenerationIdentifierElementType(elem *pkg_2_0.GenerationIdentifierElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateGeneratorType validates a GeneratorType element.
func (s *XMLDocumentState) validateGeneratorType(elem *xmlschemaoval_common_5.GeneratorType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Product_name
        // Validate Product_version
        // Validate Schema_version
        <span class="cov0" title="0">if len(elem.Schema_version) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/schema_version",
                        Message: "Required field 'schema_version' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Schema_version) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/schema_version",
                        Message: fmt.Sprintf("Field 'schema_version' requires at least 1 elements, got %d", len(elem.Schema_version)),
                })
        }</span>
        // Validate Timestamp

        <span class="cov0" title="0">return errors</span>
}

// validateGlobToRegexFunctionType validates a GlobToRegexFunctionType element.
func (s *XMLDocumentState) validateGlobToRegexFunctionType(elem *xmlschemaoval_definitions_5.GlobToRegexFunctionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Glob_noescape

        <span class="cov0" title="0">return errors</span>
}

// validateGroupElement validates a GroupElement element.
func (s *XMLDocumentState) validateGroupElement(elem *xccdf1_2.GroupElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Signature
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_group_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateGroupType validates a GroupType element.
func (s *XMLDocumentState) validateGroupType(elem *xccdf1_2.GroupType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Signature
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_group_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateHostElementType validates a HostElementType element.
func (s *XMLDocumentState) validateHostElementType(elem *asset_identification1_1.HostElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateHostnameElementType validates a HostnameElementType element.
func (s *XMLDocumentState) validateHostnameElementType(elem *asset_identification1_1.HostnameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateHtmlTextType validates a HtmlTextType element.
func (s *XMLDocumentState) validateHtmlTextType(elem *xccdf1_2.HtmlTextType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Override

        <span class="cov0" title="0">return errors</span>
}

// validateHtmlTextWithSubType validates a HtmlTextWithSubType element.
func (s *XMLDocumentState) validateHtmlTextWithSubType(elem *xccdf1_2.HtmlTextWithSubType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Sub
        // Validate Override

        <span class="cov0" title="0">return errors</span>
}

// validateIdentType validates a IdentType element.
func (s *XMLDocumentState) validateIdentType(elem *xccdf1_2.IdentType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate System
        <span class="cov0" title="0">if elem.System == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/system",
                        Message: "Required field 'system' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateIdentityType validates a IdentityType element.
func (s *XMLDocumentState) validateIdentityType(elem *xccdf1_2.IdentityType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Authenticated
        // Validate Privileged

        <span class="cov0" title="0">return errors</span>
}

// validateIdrefListType validates a IdrefListType element.
func (s *XMLDocumentState) validateIdrefListType(elem *xccdf1_2.IdrefListType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Idref
        <span class="cov0" title="0">if len(elem.Idref) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' must have at least one element",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateIdrefType validates a IdrefType element.
func (s *XMLDocumentState) validateIdrefType(elem *xccdf1_2.IdrefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Idref
        <span class="cov0" title="0">if elem.Idref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateInstallationIdElementType validates a InstallationIdElementType element.
func (s *XMLDocumentState) validateInstallationIdElementType(elem *asset_identification1_1.InstallationIdElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateInstanceFixType validates a InstanceFixType element.
func (s *XMLDocumentState) validateInstanceFixType(elem *xccdf1_2.InstanceFixType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Context

        <span class="cov0" title="0">return errors</span>
}

// validateInstanceNameElementType validates a InstanceNameElementType element.
func (s *XMLDocumentState) validateInstanceNameElementType(elem *asset_identification1_1.InstanceNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateInstanceResultType validates a InstanceResultType element.
func (s *XMLDocumentState) validateInstanceResultType(elem *xccdf1_2.InstanceResultType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Context
        // Validate ParentContext

        <span class="cov0" title="0">return errors</span>
}

// validateIpAddressElement validates a IpAddressElement element.
func (s *XMLDocumentState) validateIpAddressElement(elem *asset_identification1_1.IpAddressElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate IpV4
        // Validate IpV6

        <span class="cov0" title="0">return errors</span>
}

// validateIpAddressType validates a IpAddressType element.
func (s *XMLDocumentState) validateIpAddressType(elem *asset_identification1_1.IpAddressType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate IpV4
        // Validate IpV6

        <span class="cov0" title="0">return errors</span>
}

// validateIpNetRangeElementType validates a IpNetRangeElementType element.
func (s *XMLDocumentState) validateIpNetRangeElementType(elem *asset_identification1_1.IpNetRangeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate IpNetRangeStart
        // Validate IpNetRangeEnd

        <span class="cov0" title="0">return errors</span>
}

// validateIpV4ElementType validates a IpV4ElementType element.
func (s *XMLDocumentState) validateIpV4ElementType(elem *asset_identification1_1.IpV4ElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateIpV6ElementType validates a IpV6ElementType element.
func (s *XMLDocumentState) validateIpV6ElementType(elem *asset_identification1_1.IpV6ElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateItemElement validates a ItemElement element.
func (s *XMLDocumentState) validateItemElement(elem *xccdf1_2.ItemElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DcStatus
        // Validate Version
        // Validate Title
        // Validate Description
        // Validate Warning
        // Validate Question
        // Validate Reference
        // Validate Metadata
        // Validate Abstract
        // Validate ClusterId
        // Validate Extends
        // Validate Hidden
        // Validate ProhibitChanges
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateJointPersonNameElement validates a JointPersonNameElement element.
func (s *XMLDocumentState) validateJointPersonNameElement(elem *pkg_2_0.JointPersonNameElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NameLine
        <span class="cov0" title="0">if len(elem.NameLine) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/NameLine",
                        Message: "Required field 'NameLine' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.NameLine) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/NameLine",
                        Message: fmt.Sprintf("Field 'NameLine' requires at least 1 elements, got %d", len(elem.NameLine)),
                })
        }</span>
        // Validate JointNameConnector
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateJointPersonNameElementType validates a JointPersonNameElementType element.
func (s *XMLDocumentState) validateJointPersonNameElementType(elem *pkg_2_0.JointPersonNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NameLine
        <span class="cov0" title="0">if len(elem.NameLine) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/NameLine",
                        Message: "Required field 'NameLine' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.NameLine) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/NameLine",
                        Message: fmt.Sprintf("Field 'NameLine' requires at least 1 elements, got %d", len(elem.NameLine)),
                })
        }</span>
        // Validate JointNameConnector
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateKeyInfoElement validates a KeyInfoElement element.
func (s *XMLDocumentState) validateKeyInfoElement(elem *pkg_200009xmldsig.KeyInfoElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateKeyInfoType validates a KeyInfoType element.
func (s *XMLDocumentState) validateKeyInfoType(elem *pkg_200009xmldsig.KeyInfoType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateKeyLineCodeElementType validates a KeyLineCodeElementType element.
func (s *XMLDocumentState) validateKeyLineCodeElementType(elem *pkg_2_01.KeyLineCodeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateKeyValueElement validates a KeyValueElement element.
func (s *XMLDocumentState) validateKeyValueElement(elem *pkg_200009xmldsig.KeyValueElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateKeyValueType validates a KeyValueType element.
func (s *XMLDocumentState) validateKeyValueType(elem *pkg_200009xmldsig.KeyValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateKnownAsElementType validates a KnownAsElementType element.
func (s *XMLDocumentState) validateKnownAsElementType(elem *pkg_2_0.KnownAsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ValidFrom
        // Validate ValidTo

        <span class="cov0" title="0">return errors</span>
}

// validateLargeMailUserIdentifierElementType validates a LargeMailUserIdentifierElementType element.
func (s *XMLDocumentState) validateLargeMailUserIdentifierElementType(elem *pkg_2_01.LargeMailUserIdentifierElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validateLargeMailUserNameElementType validates a LargeMailUserNameElementType element.
func (s *XMLDocumentState) validateLargeMailUserNameElementType(elem *pkg_2_01.LargeMailUserNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateLargeMailUserType validates a LargeMailUserType element.
func (s *XMLDocumentState) validateLargeMailUserType(elem *pkg_2_01.LargeMailUserType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate LargeMailUserName
        // Validate LargeMailUserIdentifier
        // Validate BuildingName
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateLastNameElementType validates a LastNameElementType element.
func (s *XMLDocumentState) validateLastNameElementType(elem *pkg_2_0.LastNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateLicenseElementType validates a LicenseElementType element.
func (s *XMLDocumentState) validateLicenseElementType(elem *asset_identification1_1.LicenseElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateListType validates a ListType element.
func (s *XMLDocumentState) validateListType(elem *dictionary2_0.ListType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Generator

        <span class="cov0" title="0">return errors</span>
}

// validateLiteralComponentType validates a LiteralComponentType element.
func (s *XMLDocumentState) validateLiteralComponentType(elem *xmlschemaoval_definitions_5.LiteralComponentType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype != nil &amp;&amp; string(*elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(*elem.Datatype)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateLocaleElementType validates a LocaleElementType element.
func (s *XMLDocumentState) validateLocaleElementType(elem *asset_identification1_1.LocaleElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateLocalityElement validates a LocalityElement element.
func (s *XMLDocumentState) validateLocalityElement(elem *pkg_2_01.LocalityElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate LocalityName
        // Validate DependentLocality
        // Validate LargeMailUser
        // Validate PostalRoute
        // Validate Type
        // Validate UsageType
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validateLocalityElementType validates a LocalityElementType element.
func (s *XMLDocumentState) validateLocalityElementType(elem *pkg_2_01.LocalityElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate LocalityName
        // Validate DependentLocality
        // Validate LargeMailUser
        // Validate PostalRoute
        // Validate Type
        // Validate UsageType
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validateLocalityNameElementType validates a LocalityNameElementType element.
func (s *XMLDocumentState) validateLocalityNameElementType(elem *pkg_2_01.LocalityNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateLocationPointElement validates a LocationPointElement element.
func (s *XMLDocumentState) validateLocationPointElement(elem *asset_identification1_1.LocationPointElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Latitude
        // Validate Longitude
        // Validate Elevation
        // Validate Radius

        <span class="cov0" title="0">return errors</span>
}

// validateLocationPointElementType validates a LocationPointElementType element.
func (s *XMLDocumentState) validateLocationPointElementType(elem *asset_identification1_1.LocationPointElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Latitude
        // Validate Longitude
        // Validate Elevation
        // Validate Radius

        <span class="cov0" title="0">return errors</span>
}

// validateLocationRegionElement validates a LocationRegionElement element.
func (s *XMLDocumentState) validateLocationRegionElement(elem *asset_identification1_1.LocationRegionElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateLocationRegionElementType validates a LocationRegionElementType element.
func (s *XMLDocumentState) validateLocationRegionElementType(elem *asset_identification1_1.LocationRegionElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateLocationsElement validates a LocationsElement element.
func (s *XMLDocumentState) validateLocationsElement(elem *asset_identification1_1.LocationsElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateLocationsElementType validates a LocationsElementType element.
func (s *XMLDocumentState) validateLocationsElementType(elem *asset_identification1_1.LocationsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateLogicalTestType validates a LogicalTestType element.
func (s *XMLDocumentState) validateLogicalTestType(elem *language2_0.LogicalTestType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate LogicalTest
        // Validate FactRef
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/operator",
                        Message: "Required field 'operator' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"AND", "OR"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(elem.Operator)),
                        })
                }</span>
        }
        // Validate Negate

        <span class="cov0" title="0">return errors</span>
}

// validateMacAddressElementType validates a MacAddressElementType element.
func (s *XMLDocumentState) validateMacAddressElementType(elem *asset_identification1_1.MacAddressElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateMailStopNameElementType validates a MailStopNameElementType element.
func (s *XMLDocumentState) validateMailStopNameElementType(elem *pkg_2_01.MailStopNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateMailStopNumberElementType validates a MailStopNumberElementType element.
func (s *XMLDocumentState) validateMailStopNumberElementType(elem *pkg_2_01.MailStopNumberElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NameNumberSeparator

        <span class="cov0" title="0">return errors</span>
}

// validateMailStopType validates a MailStopType element.
func (s *XMLDocumentState) validateMailStopType(elem *pkg_2_01.MailStopType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate MailStopName
        // Validate MailStopNumber
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateManifestElement validates a ManifestElement element.
func (s *XMLDocumentState) validateManifestElement(elem *pkg_200009xmldsig.ManifestElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateManifestType validates a ManifestType element.
func (s *XMLDocumentState) validateManifestType(elem *pkg_200009xmldsig.ManifestType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateMessageType validates a MessageType element.
func (s *XMLDocumentState) validateMessageType(elem *xmlschemaoval_common_5.MessageType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Level
        <span class="cov0" title="0">if elem.Level != nil &amp;&amp; string(*elem.Level) != "" </span><span class="cov0" title="0">{
                validValues := []string{"debug", "error", "fatal", "info", "warning"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Level) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/level",
                                Message: fmt.Sprintf("Field 'level' has invalid value '%s'", string(*elem.Level)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateMiddleNameElementType validates a MiddleNameElementType element.
func (s *XMLDocumentState) validateMiddleNameElementType(elem *pkg_2_0.MiddleNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateModelElement validates a ModelElement element.
func (s *XMLDocumentState) validateModelElement(elem *xccdf1_2.ModelElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Param
        // Validate System
        <span class="cov0" title="0">if elem.System == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/system",
                        Message: "Required field 'system' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateModelElementType validates a ModelElementType element.
func (s *XMLDocumentState) validateModelElementType(elem *xccdf1_2.ModelElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Param
        // Validate System
        <span class="cov0" title="0">if elem.System == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/system",
                        Message: "Required field 'system' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateMotherboardGuidElementType validates a MotherboardGuidElementType element.
func (s *XMLDocumentState) validateMotherboardGuidElementType(elem *asset_identification1_1.MotherboardGuidElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateNameDetails validates a NameDetails element.
func (s *XMLDocumentState) validateNameDetails(elem *pkg_2_0.NameDetails, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NameLine
        <span class="cov0" title="0">if len(elem.NameLine) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/NameLine",
                        Message: "Required field 'NameLine' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.NameLine) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/NameLine",
                        Message: fmt.Sprintf("Field 'NameLine' requires at least 1 elements, got %d", len(elem.NameLine)),
                })
        }</span>
        // Validate PartyType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateNameDetailsElement validates a NameDetailsElement element.
func (s *XMLDocumentState) validateNameDetailsElement(elem *pkg_2_0.NameDetailsElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate AddresseeIndicator
        // Validate DependencyName
        // Validate NameDetailsKey

        <span class="cov0" title="0">return errors</span>
}

// validateNameDetailsElementType validates a NameDetailsElementType element.
func (s *XMLDocumentState) validateNameDetailsElementType(elem *pkg_2_0.NameDetailsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate AddresseeIndicator
        // Validate DependencyName
        // Validate NameDetailsKey

        <span class="cov0" title="0">return errors</span>
}

// validateNameLineType validates a NameLineType element.
func (s *XMLDocumentState) validateNameLineType(elem *pkg_2_0.NameLineType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateNamePrefixElementType validates a NamePrefixElementType element.
func (s *XMLDocumentState) validateNamePrefixElementType(elem *pkg_2_0.NamePrefixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateNetworkElement validates a NetworkElement element.
func (s *XMLDocumentState) validateNetworkElement(elem *asset_identification1_1.NetworkElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NetworkName
        // Validate IpNetRange
        // Validate Cidr

        <span class="cov0" title="0">return errors</span>
}

// validateNetworkInterfaceType validates a NetworkInterfaceType element.
func (s *XMLDocumentState) validateNetworkInterfaceType(elem *asset_identification1_1.NetworkInterfaceType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate MacAddress
        // Validate Url
        // Validate SubnetMask
        // Validate DefaultRoute

        <span class="cov0" title="0">return errors</span>
}

// validateNetworkNameElementType validates a NetworkNameElementType element.
func (s *XMLDocumentState) validateNetworkNameElementType(elem *asset_identification1_1.NetworkNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateNetworkType validates a NetworkType element.
func (s *XMLDocumentState) validateNetworkType(elem *asset_identification1_1.NetworkType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NetworkName
        // Validate IpNetRange
        // Validate Cidr

        <span class="cov0" title="0">return errors</span>
}

// validateNotesElement validates a NotesElement element.
func (s *XMLDocumentState) validateNotesElement(elem *xmlschemaoval_common_5.NotesElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Note

        <span class="cov0" title="0">return errors</span>
}

// validateNotesElementType validates a NotesElementType element.
func (s *XMLDocumentState) validateNotesElementType(elem *xmlschemaoval_definitions_5.NotesElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Note

        <span class="cov0" title="0">return errors</span>
}

// validateNotesType validates a NotesType element.
func (s *XMLDocumentState) validateNotesType(elem *xmlschemaoval_common_5.NotesType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Note

        <span class="cov0" title="0">return errors</span>
}

// validateNoticeType validates a NoticeType element.
func (s *XMLDocumentState) validateNoticeType(elem *xccdf1_2.NoticeType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateObjectComponentType validates a ObjectComponentType element.
func (s *XMLDocumentState) validateObjectComponentType(elem *xmlschemaoval_definitions_5.ObjectComponentType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Object_ref
        <span class="cov0" title="0">if elem.Object_ref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/object_ref",
                        Message: "Required field 'object_ref' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Object_ref) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:obj:[1-9][0-9]*`, string(elem.Object_ref))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/object_ref",
                                Message: "Field 'object_ref' does not match required pattern",
                        })
                }</span>
        }
        // Validate Item_field
        <span class="cov0" title="0">if elem.Item_field == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/item_field",
                        Message: "Required field 'item_field' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Item_field) != "" &amp;&amp; len(string(elem.Item_field)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/item_field",
                        Message: fmt.Sprintf("Field 'item_field' must be at least 1 characters"),
                })
        }</span>
        // Validate Record_field
        <span class="cov0" title="0">if elem.Record_field != nil &amp;&amp; string(*elem.Record_field) != "" &amp;&amp; len(string(*elem.Record_field)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/record_field",
                        Message: fmt.Sprintf("Field 'record_field' must be at least 1 characters"),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateObjectElement validates a ObjectElement element.
func (s *XMLDocumentState) validateObjectElement(elem *xmlschemaoval_definitions_5.ObjectElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:obj:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment != nil &amp;&amp; string(*elem.Comment) != "" &amp;&amp; len(string(*elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateObjectRefElement validates a ObjectRefElement element.
func (s *XMLDocumentState) validateObjectRefElement(elem *asset_reporting_format1_1.ObjectRefElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate RefId

        <span class="cov0" title="0">return errors</span>
}

// validateObjectRefElementType validates a ObjectRefElementType element.
func (s *XMLDocumentState) validateObjectRefElementType(elem *asset_reporting_format1_1.ObjectRefElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate RefId

        <span class="cov0" title="0">return errors</span>
}

// validateObjectRefType validates a ObjectRefType element.
func (s *XMLDocumentState) validateObjectRefType(elem *xmlschemaoval_definitions_5.ObjectRefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Object_ref
        <span class="cov0" title="0">if elem.Object_ref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/object_ref",
                        Message: "Required field 'object_ref' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Object_ref) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:obj:[1-9][0-9]*`, string(elem.Object_ref))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/object_ref",
                                Message: "Field 'object_ref' does not match required pattern",
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateObjectType validates a ObjectType element.
func (s *XMLDocumentState) validateObjectType(elem *pkg_200009xmldsig.ObjectType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        // Validate MimeType
        // Validate Encoding

        <span class="cov0" title="0">return errors</span>
}

// validateObjectsType validates a ObjectsType element.
func (s *XMLDocumentState) validateObjectsType(elem *xmlschemaoval_definitions_5.ObjectsType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateOrganisationFormerNameElementType validates a OrganisationFormerNameElementType element.
func (s *XMLDocumentState) validateOrganisationFormerNameElementType(elem *pkg_2_0.OrganisationFormerNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ValidFrom
        // Validate ValidTo

        <span class="cov0" title="0">return errors</span>
}

// validateOrganisationKnownAsElementType validates a OrganisationKnownAsElementType element.
func (s *XMLDocumentState) validateOrganisationKnownAsElementType(elem *pkg_2_0.OrganisationKnownAsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ValidFrom
        // Validate ValidTo

        <span class="cov0" title="0">return errors</span>
}

// validateOrganisationNameDetails validates a OrganisationNameDetails element.
func (s *XMLDocumentState) validateOrganisationNameDetails(elem *pkg_2_0.OrganisationNameDetails, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NameLine
        // Validate OrganisationName
        // Validate OrganisationType
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateOrganisationNameDetailsElement validates a OrganisationNameDetailsElement element.
func (s *XMLDocumentState) validateOrganisationNameDetailsElement(elem *pkg_2_0.OrganisationNameDetailsElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate OrganisationFormerName
        // Validate OrganisationKnownAs

        <span class="cov0" title="0">return errors</span>
}

// validateOrganisationNameDetailsElementType validates a OrganisationNameDetailsElementType element.
func (s *XMLDocumentState) validateOrganisationNameDetailsElementType(elem *pkg_2_0.OrganisationNameDetailsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate OrganisationFormerName
        // Validate OrganisationKnownAs

        <span class="cov0" title="0">return errors</span>
}

// validateOrganisationNameElementType validates a OrganisationNameElementType element.
func (s *XMLDocumentState) validateOrganisationNameElementType(elem *pkg_2_0.OrganisationNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateOrganisationTypeElementType validates a OrganisationTypeElementType element.
func (s *XMLDocumentState) validateOrganisationTypeElementType(elem *pkg_2_0.OrganisationTypeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateOrganizationElement validates a OrganizationElement element.
func (s *XMLDocumentState) validateOrganizationElement(elem *asset_identification1_1.OrganizationElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateOrganizationType validates a OrganizationType element.
func (s *XMLDocumentState) validateOrganizationType(elem *asset_identification1_1.OrganizationType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateOtherNameElementType validates a OtherNameElementType element.
func (s *XMLDocumentState) validateOtherNameElementType(elem *pkg_2_0.OtherNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NameType
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateOval_definitionsElement validates a Oval_definitionsElement element.
func (s *XMLDocumentState) validateOval_definitionsElement(elem *xmlschemaoval_definitions_5.Oval_definitionsElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Generator
        // Validate Definitions
        // Validate Tests
        // Validate Objects
        // Validate States
        // Validate Variables

        <span class="cov0" title="0">return errors</span>
}

// validateOval_definitionsElementType validates a Oval_definitionsElementType element.
func (s *XMLDocumentState) validateOval_definitionsElementType(elem *xmlschemaoval_definitions_5.Oval_definitionsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Generator
        // Validate Definitions
        // Validate Tests
        // Validate Objects
        // Validate States
        // Validate Variables

        <span class="cov0" title="0">return errors</span>
}

// validateOverrideType validates a OverrideType element.
func (s *XMLDocumentState) validateOverrideType(elem *xccdf1_2.OverrideType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate OldResult
        // Validate NewResult
        // Validate Remark
        // Validate Time
        // Validate Authority
        <span class="cov0" title="0">if elem.Authority == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/authority",
                        Message: "Required field 'authority' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateOverrideableCPE2idrefType validates a OverrideableCPE2idrefType element.
func (s *XMLDocumentState) validateOverrideableCPE2idrefType(elem *xccdf1_2.OverrideableCPE2idrefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Override

        <span class="cov0" title="0">return errors</span>
}

// validatePGPDataElement validates a PGPDataElement element.
func (s *XMLDocumentState) validatePGPDataElement(elem *pkg_200009xmldsig.PGPDataElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PGPKeyID
        // Validate PGPKeyPacket
        // Validate PGPKeyPacket2

        <span class="cov0" title="0">return errors</span>
}

// validatePGPDataType validates a PGPDataType element.
func (s *XMLDocumentState) validatePGPDataType(elem *pkg_200009xmldsig.PGPDataType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PGPKeyID
        // Validate PGPKeyPacket
        // Validate PGPKeyPacket2

        <span class="cov0" title="0">return errors</span>
}

// validateParamType validates a ParamType element.
func (s *XMLDocumentState) validateParamType(elem *xccdf1_2.ParamType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Name
        <span class="cov0" title="0">if elem.Name == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/name",
                        Message: "Required field 'name' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePersonElement validates a PersonElement element.
func (s *XMLDocumentState) validatePersonElement(elem *asset_identification1_1.PersonElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Birthdate

        <span class="cov0" title="0">return errors</span>
}

// validatePersonName validates a PersonName element.
func (s *XMLDocumentState) validatePersonName(elem *pkg_2_0.PersonName, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NameLine
        // Validate PrecedingTitle
        // Validate Title
        // Validate FirstName
        // Validate MiddleName
        // Validate NamePrefix
        // Validate LastName
        // Validate OtherName
        // Validate Alias
        // Validate GenerationIdentifier
        // Validate Suffix
        // Validate GeneralSuffix
        // Validate Type
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validatePersonNameElement validates a PersonNameElement element.
func (s *XMLDocumentState) validatePersonNameElement(elem *pkg_2_0.PersonNameElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate FormerName
        // Validate KnownAs

        <span class="cov0" title="0">return errors</span>
}

// validatePersonNameElementType validates a PersonNameElementType element.
func (s *XMLDocumentState) validatePersonNameElementType(elem *pkg_2_0.PersonNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate FormerName
        // Validate KnownAs

        <span class="cov0" title="0">return errors</span>
}

// validatePersonType validates a PersonType element.
func (s *XMLDocumentState) validatePersonType(elem *asset_identification1_1.PersonType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Birthdate

        <span class="cov0" title="0">return errors</span>
}

// validatePlainTextType validates a PlainTextType element.
func (s *XMLDocumentState) validatePlainTextType(elem *xccdf1_2.PlainTextType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePlatformSpecificationElement validates a PlatformSpecificationElement element.
func (s *XMLDocumentState) validatePlatformSpecificationElement(elem *language2_0.PlatformSpecificationElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Platform
        <span class="cov0" title="0">if len(elem.Platform) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/platform",
                        Message: "Required field 'platform' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Platform) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/platform",
                        Message: fmt.Sprintf("Field 'platform' requires at least 1 elements, got %d", len(elem.Platform)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePlatformSpecificationElementType validates a PlatformSpecificationElementType element.
func (s *XMLDocumentState) validatePlatformSpecificationElementType(elem *language2_0.PlatformSpecificationElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Platform
        <span class="cov0" title="0">if len(elem.Platform) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/platform",
                        Message: "Required field 'platform' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Platform) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/platform",
                        Message: fmt.Sprintf("Field 'platform' requires at least 1 elements, got %d", len(elem.Platform)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePlatformType validates a PlatformType element.
func (s *XMLDocumentState) validatePlatformType(elem *language2_0.PlatformType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Title
        // Validate Remark
        // Validate LogicalTest
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePortElementType validates a PortElementType element.
func (s *XMLDocumentState) validatePortElementType(elem *asset_identification1_1.PortElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePortRangeElementType validates a PortRangeElementType element.
func (s *XMLDocumentState) validatePortRangeElementType(elem *asset_identification1_1.PortRangeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate LowerBound
        // Validate UpperBound

        <span class="cov0" title="0">return errors</span>
}

// validatePossibleRestrictionType validates a PossibleRestrictionType element.
func (s *XMLDocumentState) validatePossibleRestrictionType(elem *xmlschemaoval_definitions_5.PossibleRestrictionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Restriction
        <span class="cov0" title="0">if len(elem.Restriction) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/restriction",
                        Message: "Required field 'restriction' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Restriction) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/restriction",
                        Message: fmt.Sprintf("Field 'restriction' requires at least 1 elements, got %d", len(elem.Restriction)),
                })
        }</span>
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator != nil &amp;&amp; string(*elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"AND", "OR"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(*elem.Operator)),
                        })
                }</span>
        }
        // Validate Hint
        <span class="cov0" title="0">if elem.Hint == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/hint",
                        Message: "Required field 'hint' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePossibleValueType validates a PossibleValueType element.
func (s *XMLDocumentState) validatePossibleValueType(elem *xmlschemaoval_definitions_5.PossibleValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Hint
        <span class="cov0" title="0">if elem.Hint == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/hint",
                        Message: "Required field 'hint' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePostBoxElement validates a PostBoxElement element.
func (s *XMLDocumentState) validatePostBoxElement(elem *pkg_2_01.PostBoxElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostBoxNumber
        // Validate PostBoxNumberPrefix
        // Validate PostBoxNumberSuffix
        // Validate PostBoxNumberExtension
        // Validate Firm
        // Validate Type
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validatePostBoxElementType validates a PostBoxElementType element.
func (s *XMLDocumentState) validatePostBoxElementType(elem *pkg_2_01.PostBoxElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostBoxNumber
        // Validate PostBoxNumberPrefix
        // Validate PostBoxNumberSuffix
        // Validate PostBoxNumberExtension
        // Validate Firm
        // Validate Type
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validatePostBoxNumberExtensionElementType validates a PostBoxNumberExtensionElementType element.
func (s *XMLDocumentState) validatePostBoxNumberExtensionElementType(elem *pkg_2_01.PostBoxNumberExtensionElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberExtensionSeparator

        <span class="cov0" title="0">return errors</span>
}

// validatePostBoxNumberPrefixElementType validates a PostBoxNumberPrefixElementType element.
func (s *XMLDocumentState) validatePostBoxNumberPrefixElementType(elem *pkg_2_01.PostBoxNumberPrefixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberPrefixSeparator

        <span class="cov0" title="0">return errors</span>
}

// validatePostBoxNumberSuffixElementType validates a PostBoxNumberSuffixElementType element.
func (s *XMLDocumentState) validatePostBoxNumberSuffixElementType(elem *pkg_2_01.PostBoxNumberSuffixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberSuffixSeparator

        <span class="cov0" title="0">return errors</span>
}

// validatePostOfficeElement validates a PostOfficeElement element.
func (s *XMLDocumentState) validatePostOfficeElement(elem *pkg_2_01.PostOfficeElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostalRoute
        // Validate PostOfficeName
        // Validate PostOfficeNumber
        // Validate Type
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validatePostOfficeElementType validates a PostOfficeElementType element.
func (s *XMLDocumentState) validatePostOfficeElementType(elem *pkg_2_01.PostOfficeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostalRoute
        // Validate PostOfficeName
        // Validate PostOfficeNumber
        // Validate Type
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validatePostOfficeNameElementType validates a PostOfficeNameElementType element.
func (s *XMLDocumentState) validatePostOfficeNameElementType(elem *pkg_2_01.PostOfficeNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePostOfficeNumberElementType validates a PostOfficeNumberElementType element.
func (s *XMLDocumentState) validatePostOfficeNumberElementType(elem *pkg_2_01.PostOfficeNumberElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Indicator
        // Validate IndicatorOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validatePostTownElementType validates a PostTownElementType element.
func (s *XMLDocumentState) validatePostTownElementType(elem *pkg_2_01.PostTownElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostTownName
        // Validate PostTownSuffix
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePostTownNameElementType validates a PostTownNameElementType element.
func (s *XMLDocumentState) validatePostTownNameElementType(elem *pkg_2_01.PostTownNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePostalCodeElement validates a PostalCodeElement element.
func (s *XMLDocumentState) validatePostalCodeElement(elem *pkg_2_01.PostalCodeElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostalCodeNumber
        // Validate PostalCodeNumberExtension
        // Validate PostTown
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePostalCodeElementType validates a PostalCodeElementType element.
func (s *XMLDocumentState) validatePostalCodeElementType(elem *pkg_2_01.PostalCodeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostalCodeNumber
        // Validate PostalCodeNumberExtension
        // Validate PostTown
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePostalCodeNumberElementType validates a PostalCodeNumberElementType element.
func (s *XMLDocumentState) validatePostalCodeNumberElementType(elem *pkg_2_01.PostalCodeNumberElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePostalCodeNumberExtensionElementType validates a PostalCodeNumberExtensionElementType element.
func (s *XMLDocumentState) validatePostalCodeNumberExtensionElementType(elem *pkg_2_01.PostalCodeNumberExtensionElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate NumberExtensionSeparator

        <span class="cov0" title="0">return errors</span>
}

// validatePostalRouteNameElementType validates a PostalRouteNameElementType element.
func (s *XMLDocumentState) validatePostalRouteNameElementType(elem *pkg_2_01.PostalRouteNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePostalRouteType validates a PostalRouteType element.
func (s *XMLDocumentState) validatePostalRouteType(elem *pkg_2_01.PostalRouteType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PostalRouteName
        <span class="cov0" title="0">if len(elem.PostalRouteName) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/PostalRouteName",
                        Message: "Required field 'PostalRouteName' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.PostalRouteName) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/PostalRouteName",
                        Message: fmt.Sprintf("Field 'PostalRouteName' requires at least 1 elements, got %d", len(elem.PostalRouteName)),
                })
        }</span>
        // Validate PostalRouteNumber
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePostalServiceElementsElementType validates a PostalServiceElementsElementType element.
func (s *XMLDocumentState) validatePostalServiceElementsElementType(elem *pkg_2_01.PostalServiceElementsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate AddressIdentifier
        // Validate EndorsementLineCode
        // Validate KeyLineCode
        // Validate Barcode
        // Validate SortingCode
        // Validate AddressLatitude
        // Validate AddressLatitudeDirection
        // Validate AddressLongitude
        // Validate AddressLongitudeDirection
        // Validate SupplementaryPostalServiceData
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePrecedingTitleElementType validates a PrecedingTitleElementType element.
func (s *XMLDocumentState) validatePrecedingTitleElementType(elem *pkg_2_0.PrecedingTitleElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseElement validates a PremiseElement element.
func (s *XMLDocumentState) validatePremiseElement(elem *pkg_2_01.PremiseElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PremiseName
        // Validate BuildingName
        // Validate MailStop
        // Validate PremiseLocation
        // Validate PremiseNumberRange
        // Validate SubPremise
        // Validate Firm
        // Validate Type
        // Validate PremiseDependency
        // Validate PremiseDependencyType
        // Validate PremiseThoroughfareConnector

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseElementType validates a PremiseElementType element.
func (s *XMLDocumentState) validatePremiseElementType(elem *pkg_2_01.PremiseElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PremiseName
        // Validate BuildingName
        // Validate MailStop
        // Validate PremiseLocation
        // Validate PremiseNumberRange
        // Validate SubPremise
        // Validate Firm
        // Validate Type
        // Validate PremiseDependency
        // Validate PremiseDependencyType
        // Validate PremiseThoroughfareConnector

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNameElementType validates a PremiseNameElementType element.
func (s *XMLDocumentState) validatePremiseNameElementType(elem *pkg_2_01.PremiseNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate TypeOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberElement validates a PremiseNumberElement element.
func (s *XMLDocumentState) validatePremiseNumberElement(elem *pkg_2_01.PremiseNumberElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberType
        // Validate Type
        // Validate Indicator
        // Validate IndicatorOccurrence
        // Validate NumberTypeOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberElementType validates a PremiseNumberElementType element.
func (s *XMLDocumentState) validatePremiseNumberElementType(elem *pkg_2_01.PremiseNumberElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberType
        // Validate Type
        // Validate Indicator
        // Validate IndicatorOccurrence
        // Validate NumberTypeOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberPrefixElement validates a PremiseNumberPrefixElement element.
func (s *XMLDocumentState) validatePremiseNumberPrefixElement(elem *pkg_2_01.PremiseNumberPrefixElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberPrefixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberPrefixElementType validates a PremiseNumberPrefixElementType element.
func (s *XMLDocumentState) validatePremiseNumberPrefixElementType(elem *pkg_2_01.PremiseNumberPrefixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberPrefixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberRangeElementType validates a PremiseNumberRangeElementType element.
func (s *XMLDocumentState) validatePremiseNumberRangeElementType(elem *pkg_2_01.PremiseNumberRangeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate PremiseNumberRangeFrom
        // Validate PremiseNumberRangeTo
        // Validate RangeType
        // Validate Indicator
        // Validate Separator
        // Validate Type
        // Validate IndicatorOccurence
        // Validate NumberRangeOccurence

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberRangeFromElementType validates a PremiseNumberRangeFromElementType element.
func (s *XMLDocumentState) validatePremiseNumberRangeFromElementType(elem *pkg_2_01.PremiseNumberRangeFromElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberRangeToElementType validates a PremiseNumberRangeToElementType element.
func (s *XMLDocumentState) validatePremiseNumberRangeToElementType(elem *pkg_2_01.PremiseNumberRangeToElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberSuffixElement validates a PremiseNumberSuffixElement element.
func (s *XMLDocumentState) validatePremiseNumberSuffixElement(elem *pkg_2_01.PremiseNumberSuffixElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberSuffixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validatePremiseNumberSuffixElementType validates a PremiseNumberSuffixElementType element.
func (s *XMLDocumentState) validatePremiseNumberSuffixElementType(elem *pkg_2_01.PremiseNumberSuffixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberSuffixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateProfileElement validates a ProfileElement element.
func (s *XMLDocumentState) validateProfileElement(elem *xccdf1_2.ProfileElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DcStatus
        // Validate Version
        // Validate Title
        <span class="cov0" title="0">if len(elem.Title) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/title",
                        Message: "Required field 'title' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Title) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/title",
                        Message: fmt.Sprintf("Field 'title' requires at least 1 elements, got %d", len(elem.Title)),
                })
        }</span>
        // Validate Description
        // Validate Reference
        // Validate Platform
        // Validate Metadata
        // Validate Signature
        // Validate Select
        // Validate SetComplexValue
        // Validate SetValue
        // Validate RefineValue
        // Validate RefineRule
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_profile_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate ProhibitChanges
        // Validate Abstract
        // Validate NoteTag
        // Validate Extends
        // Validate Id2

        <span class="cov0" title="0">return errors</span>
}

// validateProfileNoteType validates a ProfileNoteType element.
func (s *XMLDocumentState) validateProfileNoteType(elem *xccdf1_2.ProfileNoteType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Sub
        // Validate Tag
        <span class="cov0" title="0">if elem.Tag == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/tag",
                        Message: "Required field 'tag' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateProfileRefineRuleType validates a ProfileRefineRuleType element.
func (s *XMLDocumentState) validateProfileRefineRuleType(elem *xccdf1_2.ProfileRefineRuleType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Remark
        // Validate Idref
        <span class="cov0" title="0">if elem.Idref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' is missing or empty",
                })
        }</span>
        // Validate Weight
        // Validate Selector
        // Validate Severity
        <span class="cov0" title="0">if elem.Severity != nil &amp;&amp; string(*elem.Severity) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "info", "low", "medium", "high"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Severity) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/severity",
                                Message: fmt.Sprintf("Field 'severity' has invalid value '%s'", string(*elem.Severity)),
                        })
                }</span>
        }
        // Validate Role
        <span class="cov0" title="0">if elem.Role != nil &amp;&amp; string(*elem.Role) != "" </span><span class="cov0" title="0">{
                validValues := []string{"full", "unscored", "unchecked"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Role) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/role",
                                Message: fmt.Sprintf("Field 'role' has invalid value '%s'", string(*elem.Role)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateProfileRefineValueType validates a ProfileRefineValueType element.
func (s *XMLDocumentState) validateProfileRefineValueType(elem *xccdf1_2.ProfileRefineValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Remark
        // Validate Idref
        <span class="cov0" title="0">if elem.Idref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' is missing or empty",
                })
        }</span>
        // Validate Selector
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator != nil &amp;&amp; string(*elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"equals", "not equal", "greater than", "less than", "greater than or equal", "less than or equal", "pattern match"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(*elem.Operator)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateProfileSelectType validates a ProfileSelectType element.
func (s *XMLDocumentState) validateProfileSelectType(elem *xccdf1_2.ProfileSelectType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Remark
        // Validate Idref
        <span class="cov0" title="0">if elem.Idref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' is missing or empty",
                })
        }</span>
        // Validate Selected

        <span class="cov0" title="0">return errors</span>
}

// validateProfileSetComplexValueType validates a ProfileSetComplexValueType element.
func (s *XMLDocumentState) validateProfileSetComplexValueType(elem *xccdf1_2.ProfileSetComplexValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Idref
        <span class="cov0" title="0">if elem.Idref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateProfileSetValueType validates a ProfileSetValueType element.
func (s *XMLDocumentState) validateProfileSetValueType(elem *xccdf1_2.ProfileSetValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Idref
        <span class="cov0" title="0">if elem.Idref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateProfileType validates a ProfileType element.
func (s *XMLDocumentState) validateProfileType(elem *xccdf1_2.ProfileType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DcStatus
        // Validate Version
        // Validate Title
        <span class="cov0" title="0">if len(elem.Title) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/title",
                        Message: "Required field 'title' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Title) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/title",
                        Message: fmt.Sprintf("Field 'title' requires at least 1 elements, got %d", len(elem.Title)),
                })
        }</span>
        // Validate Description
        // Validate Reference
        // Validate Platform
        // Validate Metadata
        // Validate Signature
        // Validate Select
        // Validate SetComplexValue
        // Validate SetValue
        // Validate RefineValue
        // Validate RefineRule
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_profile_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate ProhibitChanges
        // Validate Abstract
        // Validate NoteTag
        // Validate Extends
        // Validate Id2

        <span class="cov0" title="0">return errors</span>
}

// validateProtocolElementType validates a ProtocolElementType element.
func (s *XMLDocumentState) validateProtocolElementType(elem *asset_identification1_1.ProtocolElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateRSAKeyValueElement validates a RSAKeyValueElement element.
func (s *XMLDocumentState) validateRSAKeyValueElement(elem *pkg_200009xmldsig.RSAKeyValueElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Modulus
        // Validate Exponent

        <span class="cov0" title="0">return errors</span>
}

// validateRSAKeyValueType validates a RSAKeyValueType element.
func (s *XMLDocumentState) validateRSAKeyValueType(elem *pkg_200009xmldsig.RSAKeyValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Modulus
        // Validate Exponent

        <span class="cov0" title="0">return errors</span>
}

// validateReferenceElement validates a ReferenceElement element.
func (s *XMLDocumentState) validateReferenceElement(elem *pkg_200009xmldsig.ReferenceElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        // Validate URI
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateReferenceElementType validates a ReferenceElementType element.
func (s *XMLDocumentState) validateReferenceElementType(elem *dictionary2_0.ReferenceElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Href

        <span class="cov0" title="0">return errors</span>
}

// validateReferenceType validates a ReferenceType element.
func (s *XMLDocumentState) validateReferenceType(elem *xccdf1_2.ReferenceType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Href
        // Validate Override

        <span class="cov0" title="0">return errors</span>
}

// validateReferencesType validates a ReferencesType element.
func (s *XMLDocumentState) validateReferencesType(elem *dictionary2_0.ReferencesType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Reference
        <span class="cov0" title="0">if len(elem.Reference) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/reference",
                        Message: "Required field 'reference' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Reference) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/reference",
                        Message: fmt.Sprintf("Field 'reference' requires at least 1 elements, got %d", len(elem.Reference)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateRegexCaptureFunctionType validates a RegexCaptureFunctionType element.
func (s *XMLDocumentState) validateRegexCaptureFunctionType(elem *xmlschemaoval_definitions_5.RegexCaptureFunctionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Pattern

        <span class="cov0" title="0">return errors</span>
}

// validateRelationshipType validates a RelationshipType element.
func (s *XMLDocumentState) validateRelationshipType(elem *reporting_core1_1.RelationshipType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Ref
        <span class="cov0" title="0">if len(elem.Ref) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/ref",
                        Message: "Required field 'ref' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Ref) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/ref",
                        Message: fmt.Sprintf("Field 'ref' requires at least 1 elements, got %d", len(elem.Ref)),
                })
        }</span>
        // Validate Type
        <span class="cov0" title="0">if elem.Type == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/type",
                        Message: "Required field 'type' is missing or empty",
                })
        }</span>
        // Validate Scope
        // Validate Subject
        <span class="cov0" title="0">if elem.Subject == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/subject",
                        Message: "Required field 'subject' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateRelationshipsContainerType validates a RelationshipsContainerType element.
func (s *XMLDocumentState) validateRelationshipsContainerType(elem *reporting_core1_1.RelationshipsContainerType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Relationships

        <span class="cov0" title="0">return errors</span>
}

// validateRelationshipsElementType validates a RelationshipsElementType element.
func (s *XMLDocumentState) validateRelationshipsElementType(elem *reporting_core1_1.RelationshipsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Relationship
        <span class="cov0" title="0">if len(elem.Relationship) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/relationship",
                        Message: "Required field 'relationship' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Relationship) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/relationship",
                        Message: fmt.Sprintf("Field 'relationship' requires at least 1 elements, got %d", len(elem.Relationship)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateRemoteResourceElement validates a RemoteResourceElement element.
func (s *XMLDocumentState) validateRemoteResourceElement(elem *asset_reporting_format1_1.RemoteResourceElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateRemoteResourceElementType validates a RemoteResourceElementType element.
func (s *XMLDocumentState) validateRemoteResourceElementType(elem *asset_reporting_format1_1.RemoteResourceElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateReportRequestType validates a ReportRequestType element.
func (s *XMLDocumentState) validateReportRequestType(elem *asset_reporting_format1_1.ReportRequestType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Content
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateReportRequestsElementType validates a ReportRequestsElementType element.
func (s *XMLDocumentState) validateReportRequestsElementType(elem *asset_reporting_format1_1.ReportRequestsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ReportRequest
        <span class="cov0" title="0">if len(elem.ReportRequest) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/report-request",
                        Message: "Required field 'report-request' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.ReportRequest) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/report-request",
                        Message: fmt.Sprintf("Field 'report-request' requires at least 1 elements, got %d", len(elem.ReportRequest)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateReportType validates a ReportType element.
func (s *XMLDocumentState) validateReportType(elem *asset_reporting_format1_1.ReportType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Content
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateReportsElementType validates a ReportsElementType element.
func (s *XMLDocumentState) validateReportsElementType(elem *asset_reporting_format1_1.ReportsElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Report
        <span class="cov0" title="0">if len(elem.Report) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/report",
                        Message: "Required field 'report' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Report) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/report",
                        Message: fmt.Sprintf("Field 'report' requires at least 1 elements, got %d", len(elem.Report)),
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateRestrictionType validates a RestrictionType element.
func (s *XMLDocumentState) validateRestrictionType(elem *xmlschemaoval_definitions_5.RestrictionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Operation
        <span class="cov0" title="0">if elem.Operation == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/operation",
                        Message: "Required field 'operation' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Operation) != "" </span><span class="cov0" title="0">{
                validValues := []string{"equals", "not equal", "case insensitive equals", "case insensitive not equal", "greater than", "less than", "greater than or equal", "less than or equal", "bitwise and", "bitwise or", "pattern match", "subset of", "superset of"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Operation) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operation",
                                Message: fmt.Sprintf("Field 'operation' has invalid value '%s'", string(elem.Operation)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateRetrievalMethodElement validates a RetrievalMethodElement element.
func (s *XMLDocumentState) validateRetrievalMethodElement(elem *pkg_200009xmldsig.RetrievalMethodElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate URI
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateRetrievalMethodType validates a RetrievalMethodType element.
func (s *XMLDocumentState) validateRetrievalMethodType(elem *pkg_200009xmldsig.RetrievalMethodType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate URI
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateRuleElement validates a RuleElement element.
func (s *XMLDocumentState) validateRuleElement(elem *xccdf1_2.RuleElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Ident
        // Validate ImpactMetric
        // Validate ProfileNote
        // Validate Fixtext
        // Validate Fix
        // Validate Signature
        // Validate Check
        // Validate ComplexCheck
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_rule_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Role
        <span class="cov0" title="0">if elem.Role != nil &amp;&amp; string(*elem.Role) != "" </span><span class="cov0" title="0">{
                validValues := []string{"full", "unscored", "unchecked"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Role) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/role",
                                Message: fmt.Sprintf("Field 'role' has invalid value '%s'", string(*elem.Role)),
                        })
                }</span>
        }
        // Validate Severity
        <span class="cov0" title="0">if elem.Severity != nil &amp;&amp; string(*elem.Severity) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "info", "low", "medium", "high"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Severity) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/severity",
                                Message: fmt.Sprintf("Field 'severity' has invalid value '%s'", string(*elem.Severity)),
                        })
                }</span>
        }
        // Validate Multiple

        <span class="cov0" title="0">return errors</span>
}

// validateRuleResultType validates a RuleResultType element.
func (s *XMLDocumentState) validateRuleResultType(elem *xccdf1_2.RuleResultType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Result
        // Validate Override
        // Validate Ident
        // Validate Metadata
        // Validate Message
        // Validate Instance
        // Validate Fix
        // Validate Check
        // Validate ComplexCheck
        // Validate Idref
        <span class="cov0" title="0">if elem.Idref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/idref",
                        Message: "Required field 'idref' is missing or empty",
                })
        }</span>
        // Validate Role
        <span class="cov0" title="0">if elem.Role != nil &amp;&amp; string(*elem.Role) != "" </span><span class="cov0" title="0">{
                validValues := []string{"full", "unscored", "unchecked"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Role) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/role",
                                Message: fmt.Sprintf("Field 'role' has invalid value '%s'", string(*elem.Role)),
                        })
                }</span>
        }
        // Validate Severity
        <span class="cov0" title="0">if elem.Severity != nil &amp;&amp; string(*elem.Severity) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "info", "low", "medium", "high"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Severity) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/severity",
                                Message: fmt.Sprintf("Field 'severity' has invalid value '%s'", string(*elem.Severity)),
                        })
                }</span>
        }
        // Validate Time
        // Validate Version
        // Validate Weight

        <span class="cov0" title="0">return errors</span>
}

// validateRuleType validates a RuleType element.
func (s *XMLDocumentState) validateRuleType(elem *xccdf1_2.RuleType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Ident
        // Validate ImpactMetric
        // Validate ProfileNote
        // Validate Fixtext
        // Validate Fix
        // Validate Signature
        // Validate Check
        // Validate ComplexCheck
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_rule_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Role
        <span class="cov0" title="0">if elem.Role != nil &amp;&amp; string(*elem.Role) != "" </span><span class="cov0" title="0">{
                validValues := []string{"full", "unscored", "unchecked"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Role) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/role",
                                Message: fmt.Sprintf("Field 'role' has invalid value '%s'", string(*elem.Role)),
                        })
                }</span>
        }
        // Validate Severity
        <span class="cov0" title="0">if elem.Severity != nil &amp;&amp; string(*elem.Severity) != "" </span><span class="cov0" title="0">{
                validValues := []string{"unknown", "info", "low", "medium", "high"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Severity) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/severity",
                                Message: fmt.Sprintf("Field 'severity' has invalid value '%s'", string(*elem.Severity)),
                        })
                }</span>
        }
        // Validate Multiple

        <span class="cov0" title="0">return errors</span>
}

// validateSPKIDataElement validates a SPKIDataElement element.
func (s *XMLDocumentState) validateSPKIDataElement(elem *pkg_200009xmldsig.SPKIDataElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate SPKISexp

        <span class="cov0" title="0">return errors</span>
}

// validateSPKIDataType validates a SPKIDataType element.
func (s *XMLDocumentState) validateSPKIDataType(elem *pkg_200009xmldsig.SPKIDataType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate SPKISexp

        <span class="cov0" title="0">return errors</span>
}

// validateSchemaVersionType validates a SchemaVersionType element.
func (s *XMLDocumentState) validateSchemaVersionType(elem *xmlschemaoval_common_5.SchemaVersionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Platform

        <span class="cov0" title="0">return errors</span>
}

// validateScoreType validates a ScoreType element.
func (s *XMLDocumentState) validateScoreType(elem *xccdf1_2.ScoreType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate System
        // Validate Maximum

        <span class="cov0" title="0">return errors</span>
}

// validateSelChoicesType validates a SelChoicesType element.
func (s *XMLDocumentState) validateSelChoicesType(elem *xccdf1_2.SelChoicesType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Choice
        // Validate ComplexChoice
        // Validate MustMatch
        // Validate Selector

        <span class="cov0" title="0">return errors</span>
}

// validateSelComplexValueType validates a SelComplexValueType element.
func (s *XMLDocumentState) validateSelComplexValueType(elem *xccdf1_2.SelComplexValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Selector

        <span class="cov0" title="0">return errors</span>
}

// validateSelNumType validates a SelNumType element.
func (s *XMLDocumentState) validateSelNumType(elem *xccdf1_2.SelNumType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Selector

        <span class="cov0" title="0">return errors</span>
}

// validateSelStringType validates a SelStringType element.
func (s *XMLDocumentState) validateSelStringType(elem *xccdf1_2.SelStringType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Selector

        <span class="cov0" title="0">return errors</span>
}

// validateServedByElement validates a ServedByElement element.
func (s *XMLDocumentState) validateServedByElement(elem *asset_identification1_1.ServedByElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Host
        // Validate Port
        // Validate PortRange
        // Validate Protocol

        <span class="cov0" title="0">return errors</span>
}

// validateServiceElement validates a ServiceElement element.
func (s *XMLDocumentState) validateServiceElement(elem *asset_identification1_1.ServiceElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Host
        // Validate Port
        // Validate PortRange
        // Validate Protocol

        <span class="cov0" title="0">return errors</span>
}

// validateServiceType validates a ServiceType element.
func (s *XMLDocumentState) validateServiceType(elem *asset_identification1_1.ServiceType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Host
        // Validate Port
        // Validate PortRange
        // Validate Protocol

        <span class="cov0" title="0">return errors</span>
}

// validateSetElement validates a SetElement element.
func (s *XMLDocumentState) validateSetElement(elem *xmlschemaoval_definitions_5.SetElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Object_reference
        <span class="cov0" title="0">if len(elem.Object_reference) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/object_reference",
                        Message: "Required field 'object_reference' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Object_reference) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/object_reference",
                        Message: fmt.Sprintf("Field 'object_reference' requires at least 1 elements, got %d", len(elem.Object_reference)),
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Object_reference) &gt; 2 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/object_reference",
                        Message: fmt.Sprintf("Field 'object_reference' allows at most 2 elements, got %d", len(elem.Object_reference)),
                })
        }</span>
        // Validate Set_operator
        <span class="cov0" title="0">if elem.Set_operator != nil &amp;&amp; string(*elem.Set_operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"COMPLEMENT", "INTERSECTION", "UNION"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Set_operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/set_operator",
                                Message: fmt.Sprintf("Field 'set_operator' has invalid value '%s'", string(*elem.Set_operator)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateSetElementType validates a SetElementType element.
func (s *XMLDocumentState) validateSetElementType(elem *xmlschemaoval_definitions_5.SetElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Object_reference
        <span class="cov0" title="0">if len(elem.Object_reference) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/object_reference",
                        Message: "Required field 'object_reference' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Object_reference) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/object_reference",
                        Message: fmt.Sprintf("Field 'object_reference' requires at least 1 elements, got %d", len(elem.Object_reference)),
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Object_reference) &gt; 2 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/object_reference",
                        Message: fmt.Sprintf("Field 'object_reference' allows at most 2 elements, got %d", len(elem.Object_reference)),
                })
        }</span>
        // Validate Set_operator
        <span class="cov0" title="0">if elem.Set_operator != nil &amp;&amp; string(*elem.Set_operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"COMPLEMENT", "INTERSECTION", "UNION"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Set_operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/set_operator",
                                Message: fmt.Sprintf("Field 'set_operator' has invalid value '%s'", string(*elem.Set_operator)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateSignatureElement validates a SignatureElement element.
func (s *XMLDocumentState) validateSignatureElement(elem *pkg_200009xmldsig.SignatureElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSignatureMethodElement validates a SignatureMethodElement element.
func (s *XMLDocumentState) validateSignatureMethodElement(elem *pkg_200009xmldsig.SignatureMethodElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate HMACOutputLength
        // Validate Algorithm
        <span class="cov0" title="0">if elem.Algorithm == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Algorithm",
                        Message: "Required field 'Algorithm' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateSignatureMethodType validates a SignatureMethodType element.
func (s *XMLDocumentState) validateSignatureMethodType(elem *pkg_200009xmldsig.SignatureMethodType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate HMACOutputLength
        // Validate Algorithm
        <span class="cov0" title="0">if elem.Algorithm == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Algorithm",
                        Message: "Required field 'Algorithm' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateSignaturePropertiesElement validates a SignaturePropertiesElement element.
func (s *XMLDocumentState) validateSignaturePropertiesElement(elem *pkg_200009xmldsig.SignaturePropertiesElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSignaturePropertiesType validates a SignaturePropertiesType element.
func (s *XMLDocumentState) validateSignaturePropertiesType(elem *pkg_200009xmldsig.SignaturePropertiesType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSignaturePropertyElement validates a SignaturePropertyElement element.
func (s *XMLDocumentState) validateSignaturePropertyElement(elem *pkg_200009xmldsig.SignaturePropertyElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Target
        <span class="cov0" title="0">if elem.Target == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Target",
                        Message: "Required field 'Target' is missing or empty",
                })
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSignaturePropertyType validates a SignaturePropertyType element.
func (s *XMLDocumentState) validateSignaturePropertyType(elem *pkg_200009xmldsig.SignaturePropertyType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Target
        <span class="cov0" title="0">if elem.Target == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Target",
                        Message: "Required field 'Target' is missing or empty",
                })
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSignatureValueElement validates a SignatureValueElement element.
func (s *XMLDocumentState) validateSignatureValueElement(elem *pkg_200009xmldsig.SignatureValueElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSignatureValueType validates a SignatureValueType element.
func (s *XMLDocumentState) validateSignatureValueType(elem *pkg_200009xmldsig.SignatureValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSignedInfoElement validates a SignedInfoElement element.
func (s *XMLDocumentState) validateSignedInfoElement(elem *pkg_200009xmldsig.SignedInfoElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSignedInfoType validates a SignedInfoType element.
func (s *XMLDocumentState) validateSignedInfoType(elem *pkg_200009xmldsig.SignedInfoType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id

        <span class="cov0" title="0">return errors</span>
}

// validateSoftwareElement validates a SoftwareElement element.
func (s *XMLDocumentState) validateSoftwareElement(elem *asset_identification1_1.SoftwareElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate InstallationId
        // Validate License

        <span class="cov0" title="0">return errors</span>
}

// validateSoftwareType validates a SoftwareType element.
func (s *XMLDocumentState) validateSoftwareType(elem *asset_identification1_1.SoftwareType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate InstallationId
        // Validate License

        <span class="cov0" title="0">return errors</span>
}

// validateSortingCodeElementType validates a SortingCodeElementType element.
func (s *XMLDocumentState) validateSortingCodeElementType(elem *pkg_2_01.SortingCodeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateSplitFunctionType validates a SplitFunctionType element.
func (s *XMLDocumentState) validateSplitFunctionType(elem *xmlschemaoval_definitions_5.SplitFunctionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Delimiter
        <span class="cov0" title="0">if elem.Delimiter == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/delimiter",
                        Message: "Required field 'delimiter' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateStateElement validates a StateElement element.
func (s *XMLDocumentState) validateStateElement(elem *xmlschemaoval_definitions_5.StateElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:ste:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator != nil &amp;&amp; string(*elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"AND", "OR"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(*elem.Operator)),
                        })
                }</span>
        }
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment != nil &amp;&amp; string(*elem.Comment) != "" &amp;&amp; len(string(*elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateStateRefType validates a StateRefType element.
func (s *XMLDocumentState) validateStateRefType(elem *xmlschemaoval_definitions_5.StateRefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate State_ref
        <span class="cov0" title="0">if elem.State_ref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/state_ref",
                        Message: "Required field 'state_ref' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.State_ref) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:ste:[1-9][0-9]*`, string(elem.State_ref))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/state_ref",
                                Message: "Field 'state_ref' does not match required pattern",
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateStateType validates a StateType element.
func (s *XMLDocumentState) validateStateType(elem *xmlschemaoval_definitions_5.StateType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:ste:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator != nil &amp;&amp; string(*elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"AND", "OR"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(*elem.Operator)),
                        })
                }</span>
        }
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment != nil &amp;&amp; string(*elem.Comment) != "" &amp;&amp; len(string(*elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateStatesType validates a StatesType element.
func (s *XMLDocumentState) validateStatesType(elem *xmlschemaoval_definitions_5.StatesType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateStatusElement validates a StatusElement element.
func (s *XMLDocumentState) validateStatusElement(elem *xccdf1_2.StatusElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Date

        <span class="cov0" title="0">return errors</span>
}

// validateStatusElementType validates a StatusElementType element.
func (s *XMLDocumentState) validateStatusElementType(elem *xccdf1_2.StatusElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Date

        <span class="cov0" title="0">return errors</span>
}

// validateSubAdministrativeAreaElementType validates a SubAdministrativeAreaElementType element.
func (s *XMLDocumentState) validateSubAdministrativeAreaElementType(elem *pkg_2_01.SubAdministrativeAreaElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate SubAdministrativeAreaName
        // Validate Type
        // Validate UsageType
        // Validate Indicator

        <span class="cov0" title="0">return errors</span>
}

// validateSubAdministrativeAreaNameElementType validates a SubAdministrativeAreaNameElementType element.
func (s *XMLDocumentState) validateSubAdministrativeAreaNameElementType(elem *pkg_2_01.SubAdministrativeAreaNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateSubPremiseNameElementType validates a SubPremiseNameElementType element.
func (s *XMLDocumentState) validateSubPremiseNameElementType(elem *pkg_2_01.SubPremiseNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate TypeOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validateSubPremiseNumberElementType validates a SubPremiseNumberElementType element.
func (s *XMLDocumentState) validateSubPremiseNumberElementType(elem *pkg_2_01.SubPremiseNumberElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Indicator
        // Validate IndicatorOccurrence
        // Validate NumberTypeOccurrence
        // Validate PremiseNumberSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateSubPremiseNumberPrefixElementType validates a SubPremiseNumberPrefixElementType element.
func (s *XMLDocumentState) validateSubPremiseNumberPrefixElementType(elem *pkg_2_01.SubPremiseNumberPrefixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberPrefixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateSubPremiseNumberSuffixElementType validates a SubPremiseNumberSuffixElementType element.
func (s *XMLDocumentState) validateSubPremiseNumberSuffixElementType(elem *pkg_2_01.SubPremiseNumberSuffixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberSuffixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateSubPremiseType validates a SubPremiseType element.
func (s *XMLDocumentState) validateSubPremiseType(elem *pkg_2_01.SubPremiseType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate SubPremiseName
        // Validate SubPremiseNumberPrefix
        // Validate SubPremiseNumberSuffix
        // Validate BuildingName
        // Validate Firm
        // Validate MailStop
        // Validate SubPremise
        // Validate SubPremiseLocation
        // Validate SubPremiseNumber
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateSubType validates a SubType element.
func (s *XMLDocumentState) validateSubType(elem *xccdf1_2.SubType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Use
        <span class="cov0" title="0">if elem.Use != nil &amp;&amp; string(*elem.Use) != "" </span><span class="cov0" title="0">{
                validValues := []string{"value", "title", "legacy"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Use) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/use",
                                Message: fmt.Sprintf("Field 'use' has invalid value '%s'", string(*elem.Use)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateSubstringFunctionType validates a SubstringFunctionType element.
func (s *XMLDocumentState) validateSubstringFunctionType(elem *xmlschemaoval_definitions_5.SubstringFunctionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Substring_start
        // Validate Substring_length

        <span class="cov0" title="0">return errors</span>
}

// validateSuffixElementType validates a SuffixElementType element.
func (s *XMLDocumentState) validateSuffixElementType(elem *pkg_2_0.SuffixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateSupplementaryPostalServiceDataElementType validates a SupplementaryPostalServiceDataElementType element.
func (s *XMLDocumentState) validateSupplementaryPostalServiceDataElementType(elem *pkg_2_01.SupplementaryPostalServiceDataElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateSyntheticIdElement validates a SyntheticIdElement element.
func (s *XMLDocumentState) validateSyntheticIdElement(elem *asset_identification1_1.SyntheticIdElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Resource
        <span class="cov0" title="0">if elem.Resource == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/resource",
                        Message: "Required field 'resource' is missing or empty",
                })
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateSyntheticIdElementType validates a SyntheticIdElementType element.
func (s *XMLDocumentState) validateSyntheticIdElementType(elem *asset_identification1_1.SyntheticIdElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Resource
        <span class="cov0" title="0">if elem.Resource == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/resource",
                        Message: "Required field 'resource' is missing or empty",
                })
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateSystemElement validates a SystemElement element.
func (s *XMLDocumentState) validateSystemElement(elem *asset_identification1_1.SystemElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate SystemName
        // Validate Version

        <span class="cov0" title="0">return errors</span>
}

// validateSystemNameElementType validates a SystemNameElementType element.
func (s *XMLDocumentState) validateSystemNameElementType(elem *asset_identification1_1.SystemNameElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateSystemType validates a SystemType element.
func (s *XMLDocumentState) validateSystemType(elem *asset_identification1_1.SystemType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate SystemName
        // Validate Version

        <span class="cov0" title="0">return errors</span>
}

// validateTailoringBenchmarkReferenceType validates a TailoringBenchmarkReferenceType element.
func (s *XMLDocumentState) validateTailoringBenchmarkReferenceType(elem *xccdf1_2.TailoringBenchmarkReferenceType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Version

        <span class="cov0" title="0">return errors</span>
}

// validateTailoringElement validates a TailoringElement element.
func (s *XMLDocumentState) validateTailoringElement(elem *xccdf1_2.TailoringElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Benchmark
        // Validate DcStatus
        // Validate Version
        // Validate Metadata
        // Validate Signature
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_tailoring_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Id2

        <span class="cov0" title="0">return errors</span>
}

// validateTailoringReferenceType validates a TailoringReferenceType element.
func (s *XMLDocumentState) validateTailoringReferenceType(elem *xccdf1_2.TailoringReferenceType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Href
        <span class="cov0" title="0">if elem.Href == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/href",
                        Message: "Required field 'href' is missing or empty",
                })
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        // Validate Version
        <span class="cov0" title="0">if elem.Version == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/version",
                        Message: "Required field 'version' is missing or empty",
                })
        }</span>
        // Validate Time

        <span class="cov0" title="0">return errors</span>
}

// validateTailoringType validates a TailoringType element.
func (s *XMLDocumentState) validateTailoringType(elem *xccdf1_2.TailoringType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Benchmark
        // Validate DcStatus
        // Validate Version
        // Validate Metadata
        // Validate Signature
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_tailoring_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Id2

        <span class="cov0" title="0">return errors</span>
}

// validateTailoringVersionType validates a TailoringVersionType element.
func (s *XMLDocumentState) validateTailoringVersionType(elem *xccdf1_2.TailoringVersionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Time

        <span class="cov0" title="0">return errors</span>
}

// validateTargetFactsType validates a TargetFactsType element.
func (s *XMLDocumentState) validateTargetFactsType(elem *xccdf1_2.TargetFactsType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Fact

        <span class="cov0" title="0">return errors</span>
}

// validateTargetIdRefType validates a TargetIdRefType element.
func (s *XMLDocumentState) validateTargetIdRefType(elem *xccdf1_2.TargetIdRefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate System
        <span class="cov0" title="0">if elem.System == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/system",
                        Message: "Required field 'system' is missing or empty",
                })
        }</span>
        // Validate Href
        <span class="cov0" title="0">if elem.Href == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/href",
                        Message: "Required field 'href' is missing or empty",
                })
        }</span>
        // Validate Name

        <span class="cov0" title="0">return errors</span>
}

// validateTelephoneNumberElement validates a TelephoneNumberElement element.
func (s *XMLDocumentState) validateTelephoneNumberElement(elem *asset_identification1_1.TelephoneNumberElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateTelephoneNumberElementType validates a TelephoneNumberElementType element.
func (s *XMLDocumentState) validateTelephoneNumberElementType(elem *asset_identification1_1.TelephoneNumberElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateTestElement validates a TestElement element.
func (s *XMLDocumentState) validateTestElement(elem *xmlschemaoval_definitions_5.TestElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:tst:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Check_existence
        <span class="cov0" title="0">if elem.Check_existence != nil &amp;&amp; string(*elem.Check_existence) != "" </span><span class="cov0" title="0">{
                validValues := []string{"all_exist", "any_exist", "at_least_one_exists", "none_exist", "only_one_exists"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Check_existence) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/check_existence",
                                Message: fmt.Sprintf("Field 'check_existence' has invalid value '%s'", string(*elem.Check_existence)),
                        })
                }</span>
        }
        // Validate Check
        <span class="cov0" title="0">if elem.Check == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/check",
                        Message: "Required field 'check' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Check) != "" </span><span class="cov0" title="0">{
                validValues := []string{"all", "at least one", "none exist", "none satisfy", "only one"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Check) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/check",
                                Message: fmt.Sprintf("Field 'check' has invalid value '%s'", string(elem.Check)),
                        })
                }</span>
        }
        // Validate State_operator
        <span class="cov0" title="0">if elem.State_operator != nil &amp;&amp; string(*elem.State_operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"AND", "OR"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.State_operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/state_operator",
                                Message: fmt.Sprintf("Field 'state_operator' has invalid value '%s'", string(*elem.State_operator)),
                        })
                }</span>
        }
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: "Required field 'comment' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Comment) != "" &amp;&amp; len(string(elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateTestResultElement validates a TestResultElement element.
func (s *XMLDocumentState) validateTestResultElement(elem *xccdf1_2.TestResultElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Benchmark
        // Validate TailoringFile
        // Validate Title
        // Validate Remark
        // Validate Organization
        // Validate Identity
        // Validate Profile
        // Validate Target
        <span class="cov0" title="0">if len(elem.Target) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/target",
                        Message: "Required field 'target' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Target) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/target",
                        Message: fmt.Sprintf("Field 'target' requires at least 1 elements, got %d", len(elem.Target)),
                })
        }</span>
        // Validate TargetAddress
        // Validate TargetFacts
        // Validate Platform
        // Validate RuleResult
        // Validate Score
        <span class="cov0" title="0">if len(elem.Score) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/score",
                        Message: "Required field 'score' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Score) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/score",
                        Message: fmt.Sprintf("Field 'score' requires at least 1 elements, got %d", len(elem.Score)),
                })
        }</span>
        // Validate Metadata
        // Validate Signature
        // Validate TargetIdRef
        // Validate SetValue
        // Validate SetComplexValue
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_testresult_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate StartTime
        // Validate EndTime
        // Validate TestSystem
        // Validate Version
        // Validate Id2

        <span class="cov0" title="0">return errors</span>
}

// validateTestResultType validates a TestResultType element.
func (s *XMLDocumentState) validateTestResultType(elem *xccdf1_2.TestResultType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Benchmark
        // Validate TailoringFile
        // Validate Title
        // Validate Remark
        // Validate Organization
        // Validate Identity
        // Validate Profile
        // Validate Target
        <span class="cov0" title="0">if len(elem.Target) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/target",
                        Message: "Required field 'target' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Target) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/target",
                        Message: fmt.Sprintf("Field 'target' requires at least 1 elements, got %d", len(elem.Target)),
                })
        }</span>
        // Validate TargetAddress
        // Validate TargetFacts
        // Validate Platform
        // Validate RuleResult
        // Validate Score
        <span class="cov0" title="0">if len(elem.Score) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/score",
                        Message: "Required field 'score' must have at least one element",
                })
        }</span>
        <span class="cov0" title="0">if len(elem.Score) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/score",
                        Message: fmt.Sprintf("Field 'score' requires at least 1 elements, got %d", len(elem.Score)),
                })
        }</span>
        // Validate Metadata
        // Validate Signature
        // Validate TargetIdRef
        // Validate SetValue
        // Validate SetComplexValue
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_testresult_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate StartTime
        // Validate EndTime
        // Validate TestSystem
        // Validate Version
        // Validate Id2

        <span class="cov0" title="0">return errors</span>
}

// validateTestType validates a TestType element.
func (s *XMLDocumentState) validateTestType(elem *xmlschemaoval_definitions_5.TestType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:tst:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Check_existence
        <span class="cov0" title="0">if elem.Check_existence != nil &amp;&amp; string(*elem.Check_existence) != "" </span><span class="cov0" title="0">{
                validValues := []string{"all_exist", "any_exist", "at_least_one_exists", "none_exist", "only_one_exists"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Check_existence) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/check_existence",
                                Message: fmt.Sprintf("Field 'check_existence' has invalid value '%s'", string(*elem.Check_existence)),
                        })
                }</span>
        }
        // Validate Check
        <span class="cov0" title="0">if elem.Check == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/check",
                        Message: "Required field 'check' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Check) != "" </span><span class="cov0" title="0">{
                validValues := []string{"all", "at least one", "none exist", "none satisfy", "only one"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Check) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/check",
                                Message: fmt.Sprintf("Field 'check' has invalid value '%s'", string(elem.Check)),
                        })
                }</span>
        }
        // Validate State_operator
        <span class="cov0" title="0">if elem.State_operator != nil &amp;&amp; string(*elem.State_operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"AND", "OR"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.State_operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/state_operator",
                                Message: fmt.Sprintf("Field 'state_operator' has invalid value '%s'", string(*elem.State_operator)),
                        })
                }</span>
        }
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: "Required field 'comment' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Comment) != "" &amp;&amp; len(string(elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateTestsType validates a TestsType element.
func (s *XMLDocumentState) validateTestsType(elem *xmlschemaoval_definitions_5.TestsType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateTextType validates a TextType element.
func (s *XMLDocumentState) validateTextType(elem *language2_0.TextType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateTextWithSubType validates a TextWithSubType element.
func (s *XMLDocumentState) validateTextWithSubType(elem *xccdf1_2.TextWithSubType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Sub
        // Validate Override

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareElement validates a ThoroughfareElement element.
func (s *XMLDocumentState) validateThoroughfareElement(elem *pkg_2_01.ThoroughfareElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ThoroughfarePreDirection
        // Validate ThoroughfareLeadingType
        // Validate ThoroughfareName
        // Validate ThoroughfareTrailingType
        // Validate ThoroughfarePostDirection
        // Validate DependentThoroughfare
        // Validate ThoroughfareNumberRange
        // Validate DependentLocality
        // Validate Firm
        // Validate Type
        // Validate DependentThoroughfares
        // Validate DependentThoroughfaresIndicator
        // Validate DependentThoroughfaresConnector
        // Validate DependentThoroughfaresType

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareElementType validates a ThoroughfareElementType element.
func (s *XMLDocumentState) validateThoroughfareElementType(elem *pkg_2_01.ThoroughfareElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ThoroughfarePreDirection
        // Validate ThoroughfareLeadingType
        // Validate ThoroughfareName
        // Validate ThoroughfareTrailingType
        // Validate ThoroughfarePostDirection
        // Validate DependentThoroughfare
        // Validate ThoroughfareNumberRange
        // Validate DependentLocality
        // Validate Firm
        // Validate Type
        // Validate DependentThoroughfares
        // Validate DependentThoroughfaresIndicator
        // Validate DependentThoroughfaresConnector
        // Validate DependentThoroughfaresType

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareLeadingTypeType validates a ThoroughfareLeadingTypeType element.
func (s *XMLDocumentState) validateThoroughfareLeadingTypeType(elem *pkg_2_01.ThoroughfareLeadingTypeType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNameType validates a ThoroughfareNameType element.
func (s *XMLDocumentState) validateThoroughfareNameType(elem *pkg_2_01.ThoroughfareNameType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberElement validates a ThoroughfareNumberElement element.
func (s *XMLDocumentState) validateThoroughfareNumberElement(elem *pkg_2_01.ThoroughfareNumberElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberType
        // Validate Type
        // Validate Indicator
        // Validate IndicatorOccurrence
        // Validate NumberOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberElementType validates a ThoroughfareNumberElementType element.
func (s *XMLDocumentState) validateThoroughfareNumberElementType(elem *pkg_2_01.ThoroughfareNumberElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberType
        // Validate Type
        // Validate Indicator
        // Validate IndicatorOccurrence
        // Validate NumberOccurrence

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberFromElementType validates a ThoroughfareNumberFromElementType element.
func (s *XMLDocumentState) validateThoroughfareNumberFromElementType(elem *pkg_2_01.ThoroughfareNumberFromElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberPrefixElement validates a ThoroughfareNumberPrefixElement element.
func (s *XMLDocumentState) validateThoroughfareNumberPrefixElement(elem *pkg_2_01.ThoroughfareNumberPrefixElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberPrefixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberPrefixElementType validates a ThoroughfareNumberPrefixElementType element.
func (s *XMLDocumentState) validateThoroughfareNumberPrefixElementType(elem *pkg_2_01.ThoroughfareNumberPrefixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberPrefixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberRangeElementType validates a ThoroughfareNumberRangeElementType element.
func (s *XMLDocumentState) validateThoroughfareNumberRangeElementType(elem *pkg_2_01.ThoroughfareNumberRangeElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate ThoroughfareNumberFrom
        // Validate ThoroughfareNumberTo
        // Validate RangeType
        // Validate Indicator
        // Validate Separator
        // Validate IndicatorOccurrence
        // Validate NumberRangeOccurrence
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberSuffixElement validates a ThoroughfareNumberSuffixElement element.
func (s *XMLDocumentState) validateThoroughfareNumberSuffixElement(elem *pkg_2_01.ThoroughfareNumberSuffixElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberSuffixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberSuffixElementType validates a ThoroughfareNumberSuffixElementType element.
func (s *XMLDocumentState) validateThoroughfareNumberSuffixElementType(elem *pkg_2_01.ThoroughfareNumberSuffixElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate NumberSuffixSeparator
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareNumberToElementType validates a ThoroughfareNumberToElementType element.
func (s *XMLDocumentState) validateThoroughfareNumberToElementType(elem *pkg_2_01.ThoroughfareNumberToElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfarePostDirectionType validates a ThoroughfarePostDirectionType element.
func (s *XMLDocumentState) validateThoroughfarePostDirectionType(elem *pkg_2_01.ThoroughfarePostDirectionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfarePreDirectionType validates a ThoroughfarePreDirectionType element.
func (s *XMLDocumentState) validateThoroughfarePreDirectionType(elem *pkg_2_01.ThoroughfarePreDirectionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateThoroughfareTrailingTypeType validates a ThoroughfareTrailingTypeType element.
func (s *XMLDocumentState) validateThoroughfareTrailingTypeType(elem *pkg_2_01.ThoroughfareTrailingTypeType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type

        <span class="cov0" title="0">return errors</span>
}

// validateTimeDifferenceFunctionType validates a TimeDifferenceFunctionType element.
func (s *XMLDocumentState) validateTimeDifferenceFunctionType(elem *xmlschemaoval_definitions_5.TimeDifferenceFunctionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Format_1
        <span class="cov0" title="0">if elem.Format_1 != nil &amp;&amp; string(*elem.Format_1) != "" </span><span class="cov0" title="0">{
                validValues := []string{"year_month_day", "month_day_year", "day_month_year", "win_filetime", "seconds_since_epoch", "cim_datetime"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Format_1) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/format_1",
                                Message: fmt.Sprintf("Field 'format_1' has invalid value '%s'", string(*elem.Format_1)),
                        })
                }</span>
        }
        // Validate Format_2
        <span class="cov0" title="0">if elem.Format_2 != nil &amp;&amp; string(*elem.Format_2) != "" </span><span class="cov0" title="0">{
                validValues := []string{"year_month_day", "month_day_year", "day_month_year", "win_filetime", "seconds_since_epoch", "cim_datetime"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Format_2) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/format_2",
                                Message: fmt.Sprintf("Field 'format_2' has invalid value '%s'", string(*elem.Format_2)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateTitleElementType validates a TitleElementType element.
func (s *XMLDocumentState) validateTitleElementType(elem *pkg_2_0.TitleElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Type
        // Validate Code

        <span class="cov0" title="0">return errors</span>
}

// validateTransformElement validates a TransformElement element.
func (s *XMLDocumentState) validateTransformElement(elem *pkg_200009xmldsig.TransformElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate XPath
        // Validate Algorithm
        <span class="cov0" title="0">if elem.Algorithm == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Algorithm",
                        Message: "Required field 'Algorithm' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateTransformType validates a TransformType element.
func (s *XMLDocumentState) validateTransformType(elem *pkg_200009xmldsig.TransformType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate XPath
        // Validate Algorithm
        <span class="cov0" title="0">if elem.Algorithm == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/Algorithm",
                        Message: "Required field 'Algorithm' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateTransformsElement validates a TransformsElement element.
func (s *XMLDocumentState) validateTransformsElement(elem *pkg_200009xmldsig.TransformsElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateTransformsType validates a TransformsType element.
func (s *XMLDocumentState) validateTransformsType(elem *pkg_200009xmldsig.TransformsType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateUriRefType validates a UriRefType element.
func (s *XMLDocumentState) validateUriRefType(elem *xccdf1_2.UriRefType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Uri
        <span class="cov0" title="0">if elem.Uri == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/uri",
                        Message: "Required field 'uri' is missing or empty",
                })
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateUrlElementType validates a UrlElementType element.
func (s *XMLDocumentState) validateUrlElementType(elem *asset_identification1_1.UrlElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateValueElement validates a ValueElement element.
func (s *XMLDocumentState) validateValueElement(elem *xccdf1_2.ValueElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Match
        // Validate LowerBound
        // Validate UpperBound
        // Validate Choices
        // Validate Source
        // Validate Signature
        // Validate Value
        // Validate ComplexValue
        // Validate Default
        // Validate ComplexDefault
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_value_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Type
        <span class="cov0" title="0">if elem.Type != nil &amp;&amp; string(*elem.Type) != "" </span><span class="cov0" title="0">{
                validValues := []string{"number", "string", "boolean"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Type) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/type",
                                Message: fmt.Sprintf("Field 'type' has invalid value '%s'", string(*elem.Type)),
                        })
                }</span>
        }
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator != nil &amp;&amp; string(*elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"equals", "not equal", "greater than", "less than", "greater than or equal", "less than or equal", "pattern match"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(*elem.Operator)),
                        })
                }</span>
        }
        // Validate Interactive
        // Validate InterfaceHint
        <span class="cov0" title="0">if elem.InterfaceHint != nil &amp;&amp; string(*elem.InterfaceHint) != "" </span><span class="cov0" title="0">{
                validValues := []string{"choice", "textline", "text", "date", "datetime"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.InterfaceHint) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/interfaceHint",
                                Message: fmt.Sprintf("Field 'interfaceHint' has invalid value '%s'", string(*elem.InterfaceHint)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateValueType validates a ValueType element.
func (s *XMLDocumentState) validateValueType(elem *xccdf1_2.ValueType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Match
        // Validate LowerBound
        // Validate UpperBound
        // Validate Choices
        // Validate Source
        // Validate Signature
        // Validate Value
        // Validate ComplexValue
        // Validate Default
        // Validate ComplexDefault
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`xccdf_[^_]+_value_.+`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Type
        <span class="cov0" title="0">if elem.Type != nil &amp;&amp; string(*elem.Type) != "" </span><span class="cov0" title="0">{
                validValues := []string{"number", "string", "boolean"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Type) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/type",
                                Message: fmt.Sprintf("Field 'type' has invalid value '%s'", string(*elem.Type)),
                        })
                }</span>
        }
        // Validate Operator
        <span class="cov0" title="0">if elem.Operator != nil &amp;&amp; string(*elem.Operator) != "" </span><span class="cov0" title="0">{
                validValues := []string{"equals", "not equal", "greater than", "less than", "greater than or equal", "less than or equal", "pattern match"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Operator) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/operator",
                                Message: fmt.Sprintf("Field 'operator' has invalid value '%s'", string(*elem.Operator)),
                        })
                }</span>
        }
        // Validate Interactive
        // Validate InterfaceHint
        <span class="cov0" title="0">if elem.InterfaceHint != nil &amp;&amp; string(*elem.InterfaceHint) != "" </span><span class="cov0" title="0">{
                validValues := []string{"choice", "textline", "text", "date", "datetime"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.InterfaceHint) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/interfaceHint",
                                Message: fmt.Sprintf("Field 'interfaceHint' has invalid value '%s'", string(*elem.InterfaceHint)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateVariableComponentType validates a VariableComponentType element.
func (s *XMLDocumentState) validateVariableComponentType(elem *xmlschemaoval_definitions_5.VariableComponentType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Var_ref
        <span class="cov0" title="0">if elem.Var_ref == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/var_ref",
                        Message: "Required field 'var_ref' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Var_ref) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:var:[1-9][0-9]*`, string(elem.Var_ref))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/var_ref",
                                Message: "Field 'var_ref' does not match required pattern",
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateVariableElement validates a VariableElement element.
func (s *XMLDocumentState) validateVariableElement(elem *xmlschemaoval_definitions_5.VariableElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:var:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: "Required field 'comment' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Comment) != "" &amp;&amp; len(string(elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateVariableType validates a VariableType element.
func (s *XMLDocumentState) validateVariableType(elem *xmlschemaoval_definitions_5.VariableType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Id
        <span class="cov0" title="0">if elem.Id == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/id",
                        Message: "Required field 'id' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Id) != "" </span><span class="cov0" title="0">{
                matched, _ := regexp.MatchString(`oval:[A-Za-z0-9_\-\.]+:var:[1-9][0-9]*`, string(elem.Id))
                if !matched </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/id",
                                Message: "Field 'id' does not match required pattern",
                        })
                }</span>
        }
        // Validate Version
        // Validate Datatype
        <span class="cov0" title="0">if elem.Datatype == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/datatype",
                        Message: "Required field 'datatype' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Datatype) != "" </span><span class="cov0" title="0">{
                validValues := []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(elem.Datatype) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/datatype",
                                Message: fmt.Sprintf("Field 'datatype' has invalid value '%s'", string(elem.Datatype)),
                        })
                }</span>
        }
        // Validate Comment
        <span class="cov0" title="0">if elem.Comment == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: "Required field 'comment' is missing or empty",
                })
        }</span>
        <span class="cov0" title="0">if string(elem.Comment) != "" &amp;&amp; len(string(elem.Comment)) &lt; 1 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Path:    path + "/comment",
                        Message: fmt.Sprintf("Field 'comment' must be at least 1 characters"),
                })
        }</span>
        // Validate Deprecated

        <span class="cov0" title="0">return errors</span>
}

// validateVariablesType validates a VariablesType element.
func (s *XMLDocumentState) validateVariablesType(elem *xmlschemaoval_definitions_5.VariablesType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateVersionType validates a VersionType element.
func (s *XMLDocumentState) validateVersionType(elem *xccdf1_2.VersionType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Time
        // Validate Update

        <span class="cov0" title="0">return errors</span>
}

// validateWarningType validates a WarningType element.
func (s *XMLDocumentState) validateWarningType(elem *xccdf1_2.WarningType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Category
        <span class="cov0" title="0">if elem.Category != nil &amp;&amp; string(*elem.Category) != "" </span><span class="cov0" title="0">{
                validValues := []string{"general", "functionality", "performance", "hardware", "legal", "regulatory", "management", "audit", "dependency"}
                isValid := false
                for _, v := range validValues </span><span class="cov0" title="0">{
                        if string(*elem.Category) == v </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Path:    path + "/category",
                                Message: fmt.Sprintf("Field 'category' has invalid value '%s'", string(*elem.Category)),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

// validateWebsiteElement validates a WebsiteElement element.
func (s *XMLDocumentState) validateWebsiteElement(elem *asset_identification1_1.WebsiteElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DocumentRoot
        // Validate Locale

        <span class="cov0" title="0">return errors</span>
}

// validateWebsiteType validates a WebsiteType element.
func (s *XMLDocumentState) validateWebsiteType(elem *asset_identification1_1.WebsiteType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate DocumentRoot
        // Validate Locale

        <span class="cov0" title="0">return errors</span>
}

// validateWebsiteUrlElement validates a WebsiteUrlElement element.
func (s *XMLDocumentState) validateWebsiteUrlElement(elem *asset_identification1_1.WebsiteUrlElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateWebsiteUrlElementType validates a WebsiteUrlElementType element.
func (s *XMLDocumentState) validateWebsiteUrlElementType(elem *asset_identification1_1.WebsiteUrlElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        <span class="cov0" title="0">return errors</span>
}

// validateX509DataElement validates a X509DataElement element.
func (s *XMLDocumentState) validateX509DataElement(elem *pkg_200009xmldsig.X509DataElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate X509IssuerSerial
        // Validate X509SKI
        // Validate X509SubjectName
        // Validate X509Certificate
        // Validate X509CRL

        <span class="cov0" title="0">return errors</span>
}

// validateX509DataType validates a X509DataType element.
func (s *XMLDocumentState) validateX509DataType(elem *pkg_200009xmldsig.X509DataType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate X509IssuerSerial
        // Validate X509SKI
        // Validate X509SubjectName
        // Validate X509Certificate
        // Validate X509CRL

        <span class="cov0" title="0">return errors</span>
}

// validateX509IssuerSerialType validates a X509IssuerSerialType element.
func (s *XMLDocumentState) validateX509IssuerSerialType(elem *pkg_200009xmldsig.X509IssuerSerialType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate X509IssuerName
        // Validate X509SerialNumber

        <span class="cov0" title="0">return errors</span>
}

// validateXALElement validates a XALElement element.
func (s *XMLDocumentState) validateXALElement(elem *pkg_2_01.XALElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Version

        <span class="cov0" title="0">return errors</span>
}

// validateXALElementType validates a XALElementType element.
func (s *XMLDocumentState) validateXALElementType(elem *pkg_2_01.XALElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Version

        <span class="cov0" title="0">return errors</span>
}

// validateXNLElement validates a XNLElement element.
func (s *XMLDocumentState) validateXNLElement(elem *pkg_2_0.XNLElement, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Version

        <span class="cov0" title="0">return errors</span>
}

// validateXNLElementType validates a XNLElementType element.
func (s *XMLDocumentState) validateXNLElementType(elem *pkg_2_0.XNLElementType, path string) []ValidationError <span class="cov0" title="0">{
        var errors []ValidationError
        if elem == nil </span><span class="cov0" title="0">{
                return errors
        }</span>
        // Validate Version

        <span class="cov0" title="0">return errors</span>
}

// GetAvailableTypes returns all available element types.
func (s *XMLDocumentState) GetAvailableTypes() []string <span class="cov8" title="1">{
        return []string{
                "ActuateType",
                "AddressDetails",
                "AddressDetailsElement",
                "AddressElementType",
                "AddressIdentifierElementType",
                "AddressLatitudeDirectionElementType",
                "AddressLatitudeElementType",
                "AddressLineElement",
                "AddressLineElementType",
                "AddressLinesType",
                "AddressLongitudeDirectionElementType",
                "AddressLongitudeElementType",
                "AddresseeIndicatorElementType",
                "AdministrativeAreaElement",
                "AdministrativeAreaElementType",
                "AdministrativeAreaNameElementType",
                "AffectedType",
                "AliasElementType",
                "ArcElement",
                "ArcType",
                "ArcroleType",
                "ArithmeticEnumeration",
                "ArithmeticFunctionType",
                "AssetElement",
                "AssetElementType",
                "AssetIdentificationType",
                "AssetRelatedElement",
                "AssetReportCollectionElement",
                "AssetReportCollectionElementType",
                "AssetType",
                "AssetsElement",
                "AssetsElementType",
                "AssetsType",
                "BarcodeElementType",
                "BeginFunctionType",
                "BenchmarkElement",
                "BenchmarkElementType",
                "BenchmarkIdType",
                "BenchmarkReferenceType",
                "BirthdateElementType",
                "BuildingNameType",
                "CPE2idrefType",
                "CanonicalizationMethodElement",
                "CanonicalizationMethodType",
                "CcOperatorEnumType",
                "CheckContentRefType",
                "CheckContentType",
                "CheckEnumeration",
                "CheckExportType",
                "CheckImportType",
                "CheckType",
                "CidrElementType",
                "CidrType",
                "CircuitElement",
                "CircuitNameElementType",
                "CircuitType",
                "ClassEnumeration",
                "ComplexCheckType",
                "ComplexDatatypeEnumeration",
                "ComplexValueType",
                "ComputingDeviceElement",
                "ComputingDeviceType",
                "ConcatFunctionType",
                "ConnectionsElementType",
                "Constant_variableElement",
                "Constant_variableElementType",
                "ContentElementType",
                "ContentElementType1",
                "CountFunctionType",
                "CountryElementType",
                "CountryNameCodeElementType",
                "CountryNameElement",
                "CountryNameElementType",
                "CpeElement",
                "CpeElementType",
                "CpeItemElement",
                "CpeListElement",
                "CpeType",
                "CriteriaType",
                "CriterionType",
                "CryptoBinary",
                "DSAKeyValueElement",
                "DSAKeyValueType",
                "DataElement",
                "DataType",
                "DatabaseElement",
                "DatabaseType",
                "DatatypeEnumeration",
                "DateTimeFormatEnumeration",
                "DcStatusType",
                "DefinitionElement",
                "DefinitionIDPattern",
                "DefinitionType",
                "DefinitionsType",
                "DepartmentElement",
                "DepartmentElementType",
                "DepartmentNameElementType",
                "DependencyNameElementType",
                "DependentLocalityNameElementType",
                "DependentLocalityNumberElementType",
                "DependentLocalityType",
                "DependentThoroughfareElementType",
                "DeprecatedInfoType",
                "Deprecated_infoElement",
                "DigestMethodElement",
                "DigestMethodType",
                "DigestValueElement",
                "DigestValueType",
                "DistinguishedNameElementType",
                "DocumentRootElementType",
                "ElementMapItemType",
                "ElementMapType",
                "Element_mappingElement",
                "EmailAddressElement",
                "EmailAddressElementType",
                "EmptyStringType",
                "EndFunctionType",
                "EndorsementLineCodeElementType",
                "EntityComplexBaseType",
                "EntityObjectAnySimpleType",
                "EntityObjectBinaryType",
                "EntityObjectBoolType",
                "EntityObjectFieldType",
                "EntityObjectFloatType",
                "EntityObjectIPAddressStringType",
                "EntityObjectIPAddressType",
                "EntityObjectIntType",
                "EntityObjectRecordType",
                "EntityObjectStringType",
                "EntityObjectVersionType",
                "EntitySimpleBaseType",
                "EntityStateAnySimpleType",
                "EntityStateBinaryType",
                "EntityStateBoolType",
                "EntityStateComplexBaseType",
                "EntityStateDebianEVRStringType",
                "EntityStateEVRStringType",
                "EntityStateFieldType",
                "EntityStateFileSetRevisionType",
                "EntityStateFloatType",
                "EntityStateIOSVersionType",
                "EntityStateIPAddressStringType",
                "EntityStateIPAddressType",
                "EntityStateIntType",
                "EntityStateRecordType",
                "EntityStateSimpleBaseType",
                "EntityStateStringType",
                "EntityStateVersionType",
                "EscapeRegexFunctionType",
                "ExistenceEnumeration",
                "ExtendDefinitionType",
                "Extended",
                "ExtendedInfoElementType",
                "ExtendedInformationElementType",
                "ExtendedInfosElementType",
                "External_variableElement",
                "External_variableElementType",
                "FactRefType",
                "FactType",
                "FamilyEnumeration",
                "FilterActionEnumeration",
                "FilterElement",
                "FilterElementType",
                "FirmNameElementType",
                "FirmType",
                "FirstNameElementType",
                "FixStrategyEnumType",
                "FixTextType",
                "FixType",
                "FormerNameElementType",
                "FqdnElement",
                "FqdnElementType",
                "FromType",
                "Function",
                "FunctionElement",
                "GeneralSuffixElementType",
                "GenerationIdentifierElementType",
                "GeneratorType",
                "GlobToRegexFunctionType",
                "GroupElement",
                "GroupIdType",
                "GroupType",
                "HMACOutputLengthType",
                "HostElementType",
                "HostnameElementType",
                "HostnameType",
                "HrefType",
                "HtmlTextType",
                "HtmlTextWithSubType",
                "IdentType",
                "IdentityType",
                "IdrefListType",
                "IdrefType",
                "InstallationIdElementType",
                "InstanceFixType",
                "InstanceNameElementType",
                "InstanceResultType",
                "InterfaceHintType",
                "IpAddressElement",
                "IpAddressType",
                "IpNetRangeElementType",
                "IpV4ElementType",
                "IpV6ElementType",
                "Ipv4Type",
                "Ipv6Type",
                "ItAssetElement",
                "ItAssetType",
                "ItemElement",
                "ItemIDPattern",
                "ItemType",
                "JointPersonNameElement",
                "JointPersonNameElementType",
                "KeyInfoElement",
                "KeyInfoType",
                "KeyLineCodeElementType",
                "KeyNameElement",
                "KeyValueElement",
                "KeyValueType",
                "KnownAsElementType",
                "LabelType",
                "LargeMailUserIdentifierElementType",
                "LargeMailUserNameElementType",
                "LargeMailUserType",
                "LastNameElementType",
                "LicenseElementType",
                "ListType",
                "LiteralComponentType",
                "Local_variableElement",
                "Local_variableElementType",
                "LocaleElementType",
                "LocaleType",
                "LocalityElement",
                "LocalityElementType",
                "LocalityNameElementType",
                "LocationAddressElement",
                "LocationElement",
                "LocationPointElement",
                "LocationPointElementType",
                "LocationRegionElement",
                "LocationRegionElementType",
                "LocationsElement",
                "LocationsElementType",
                "LocatorElement",
                "LocatorType",
                "LogicalTestType",
                "MacAddressElementType",
                "MacAddressType",
                "MailStopNameElementType",
                "MailStopNumberElementType",
                "MailStopType",
                "ManifestElement",
                "ManifestType",
                "MessageLevelEnumeration",
                "MessageType",
                "MetadataType",
                "MgmtDataElement",
                "MiddleNameElementType",
                "ModelElement",
                "ModelElementType",
                "MotherboardGuidElementType",
                "MsgSevEnumType",
                "NameDetails",
                "NameDetailsElement",
                "NameDetailsElementType",
                "NameLineType",
                "NamePattern",
                "NamePrefixElementType",
                "NetworkElement",
                "NetworkInterfaceType",
                "NetworkNameElementType",
                "NetworkType",
                "NonEmptyStringType",
                "NotesElement",
                "NotesElementType",
                "NotesType",
                "NoticeType",
                "ObjectComponentType",
                "ObjectElement",
                "ObjectIDPattern",
                "ObjectRefElement",
                "ObjectRefElementType",
                "ObjectRefType",
                "ObjectType",
                "ObjectsType",
                "OperationEnumeration",
                "OperatorEnumeration",
                "OrganisationFormerNameElementType",
                "OrganisationKnownAsElementType",
                "OrganisationNameDetails",
                "OrganisationNameDetailsElement",
                "OrganisationNameDetailsElementType",
                "OrganisationNameElementType",
                "OrganisationTypeElementType",
                "OrganizationElement",
                "OrganizationType",
                "OtherNameElementType",
                "Oval_definitionsElement",
                "Oval_definitionsElementType",
                "OverrideType",
                "OverrideableCPE2idrefType",
                "PGPDataElement",
                "PGPDataType",
                "ParamType",
                "PersonElement",
                "PersonName",
                "PersonNameElement",
                "PersonNameElementType",
                "PersonType",
                "PlainTextType",
                "PlatformSpecificationElement",
                "PlatformSpecificationElementType",
                "PlatformType",
                "PortElementType",
                "PortRangeElementType",
                "PortType",
                "PossibleRestrictionType",
                "PossibleValueType",
                "PostBoxElement",
                "PostBoxElementType",
                "PostBoxNumberElementType",
                "PostBoxNumberExtensionElementType",
                "PostBoxNumberPrefixElementType",
                "PostBoxNumberSuffixElementType",
                "PostOfficeElement",
                "PostOfficeElementType",
                "PostOfficeNameElementType",
                "PostOfficeNumberElementType",
                "PostTownElementType",
                "PostTownNameElementType",
                "PostTownSuffixElementType",
                "PostalCodeElement",
                "PostalCodeElementType",
                "PostalCodeNumberElementType",
                "PostalCodeNumberExtensionElementType",
                "PostalRouteNameElementType",
                "PostalRouteNumberElementType",
                "PostalRouteType",
                "PostalServiceElementsElementType",
                "PrecedingTitleElementType",
                "PremiseElement",
                "PremiseElementType",
                "PremiseLocationElementType",
                "PremiseNameElementType",
                "PremiseNumberElement",
                "PremiseNumberElementType",
                "PremiseNumberPrefixElement",
                "PremiseNumberPrefixElementType",
                "PremiseNumberRangeElementType",
                "PremiseNumberRangeFromElementType",
                "PremiseNumberRangeToElementType",
                "PremiseNumberSuffixElement",
                "PremiseNumberSuffixElementType",
                "ProfileElement",
                "ProfileIdType",
                "ProfileNoteType",
                "ProfileRefineRuleType",
                "ProfileRefineValueType",
                "ProfileSelectType",
                "ProfileSetComplexValueType",
                "ProfileSetValueType",
                "ProfileType",
                "ProtocolElementType",
                "RSAKeyValueElement",
                "RSAKeyValueType",
                "RatingEnumType",
                "ReferenceElement",
                "ReferenceElementType",
                "ReferenceType",
                "ReferencesType",
                "RegexCaptureFunctionType",
                "RelationshipType",
                "RelationshipsContainerType",
                "RelationshipsElementType",
                "RemoteResourceElement",
                "RemoteResourceElementType",
                "ReportRequestType",
                "ReportRequestsElementType",
                "ReportType",
                "ReportsElementType",
                "ResourceElement",
                "ResourceType",
                "RestrictionType",
                "ResultEnumType",
                "RetrievalMethodElement",
                "RetrievalMethodType",
                "RoleEnumType",
                "RoleType",
                "RuleElement",
                "RuleIdType",
                "RuleResultType",
                "RuleType",
                "SPKIDataElement",
                "SPKIDataType",
                "SchemaVersionPattern",
                "SchemaVersionType",
                "ScoreType",
                "SelChoicesType",
                "SelComplexValueType",
                "SelNumType",
                "SelStringType",
                "SelectableItemType",
                "ServedByElement",
                "ServiceElement",
                "ServiceType",
                "SetElement",
                "SetElementType",
                "SetOperatorEnumeration",
                "SeverityEnumType",
                "ShowType",
                "SignatureElement",
                "SignatureMethodElement",
                "SignatureMethodType",
                "SignaturePropertiesElement",
                "SignaturePropertiesType",
                "SignaturePropertyElement",
                "SignaturePropertyType",
                "SignatureType",
                "SignatureValueElement",
                "SignatureValueType",
                "SignedInfoElement",
                "SignedInfoType",
                "Simple",
                "SimpleDatatypeEnumeration",
                "SoftwareElement",
                "SoftwareType",
                "SortingCodeElementType",
                "SplitFunctionType",
                "StateElement",
                "StateIDPattern",
                "StateRefType",
                "StateType",
                "StatesType",
                "StatusElement",
                "StatusElementType",
                "StatusType",
                "SubAdministrativeAreaElementType",
                "SubAdministrativeAreaNameElementType",
                "SubPremiseLocationElementType",
                "SubPremiseNameElementType",
                "SubPremiseNumberElementType",
                "SubPremiseNumberPrefixElementType",
                "SubPremiseNumberSuffixElementType",
                "SubPremiseType",
                "SubType",
                "SubUseEnumType",
                "SubstringFunctionType",
                "SuffixElementType",
                "SupplementaryPostalServiceDataElementType",
                "SyntheticIdElement",
                "SyntheticIdElementType",
                "SystemElement",
                "SystemNameElementType",
                "SystemType",
                "TailoringBenchmarkReferenceType",
                "TailoringElement",
                "TailoringIdType",
                "TailoringReferenceType",
                "TailoringType",
                "TailoringVersionType",
                "TargetFactsType",
                "TargetIdRefType",
                "TelephoneNumberElement",
                "TelephoneNumberElementType",
                "TelephoneNumberType",
                "TestElement",
                "TestIDPattern",
                "TestResultElement",
                "TestResultType",
                "TestType",
                "TestresultIdType",
                "TestsType",
                "TextType",
                "TextWithSubType",
                "ThoroughfareElement",
                "ThoroughfareElementType",
                "ThoroughfareLeadingTypeType",
                "ThoroughfareNameType",
                "ThoroughfareNumberElement",
                "ThoroughfareNumberElementType",
                "ThoroughfareNumberFromElementType",
                "ThoroughfareNumberPrefixElement",
                "ThoroughfareNumberPrefixElementType",
                "ThoroughfareNumberRangeElementType",
                "ThoroughfareNumberSuffixElement",
                "ThoroughfareNumberSuffixElementType",
                "ThoroughfareNumberToElementType",
                "ThoroughfarePostDirectionType",
                "ThoroughfarePreDirectionType",
                "ThoroughfareTrailingTypeType",
                "TimeDifferenceFunctionType",
                "TitleAttrType",
                "TitleElement",
                "TitleElementType",
                "TitleEltType",
                "ToType",
                "TransformElement",
                "TransformType",
                "TransformsElement",
                "TransformsType",
                "TypeType",
                "UniqueFunctionType",
                "UriRefType",
                "UrlElementType",
                "ValueElement",
                "ValueIdType",
                "ValueOperatorType",
                "ValueType",
                "ValueTypeType",
                "VariableComponentType",
                "VariableElement",
                "VariableIDPattern",
                "VariableType",
                "VariablesType",
                "VersionElementType",
                "VersionType",
                "WarningCategoryEnumType",
                "WarningType",
                "WebsiteElement",
                "WebsiteType",
                "WebsiteUrlElement",
                "WebsiteUrlElementType",
                "WeightType",
                "X509DataElement",
                "X509DataType",
                "X509IssuerSerialType",
                "XALElement",
                "XALElementType",
                "XNLElement",
                "XNLElementType",
        }
}</span>

// GetRootElementTypes returns types that can be used as document root elements.
func (s *XMLDocumentState) GetRootElementTypes() []string <span class="cov8" title="1">{
        return []string{
                "BenchmarkElement",
        }
}</span>

// GetValidChildTypes returns types that can be children of the given parent type.
func (s *XMLDocumentState) GetValidChildTypes(parentType string) []string <span class="cov8" title="1">{
        switch parentType </span>{
        case "AddressDetails":<span class="cov0" title="0">
                return []string{
                        "PostalServiceElements",
                        "Address",
                        "AddressLinesType",
                        "Country",
                        "",
                        "",
                        "",
                }</span>
        case "AddressDetailsElement":<span class="cov0" title="0">
                return []string{
                        "PostalServiceElements",
                        "Address",
                        "AddressLinesType",
                        "Country",
                        "",
                        "",
                        "",
                }</span>
        case "AddressLinesType":<span class="cov0" title="0">
                return []string{
                        "",
                }</span>
        case "AdministrativeAreaElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "AdministrativeAreaName",
                        "SubAdministrativeArea",
                        "",
                        "",
                        "",
                }</span>
        case "AdministrativeAreaElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "AdministrativeAreaName",
                        "SubAdministrativeArea",
                        "",
                        "",
                        "",
                }</span>
        case "AssetElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "ExtendedInformation",
                }</span>
        case "AssetElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                }</span>
        case "AssetReportCollectionElement":<span class="cov0" title="0">
                return []string{
                        "ReportRequests",
                        "AssetsElement",
                        "Reports",
                        "ExtendedInfos",
                }</span>
        case "AssetReportCollectionElementType":<span class="cov0" title="0">
                return []string{
                        "ReportRequests",
                        "AssetsElement",
                        "Reports",
                        "ExtendedInfos",
                }</span>
        case "AssetType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "ExtendedInformation",
                }</span>
        case "AssetsElement":<span class="cov0" title="0">
                return []string{
                        "AssetElement",
                        "OrganizationElement",
                        "DataElement",
                        "ItAssetElement",
                        "SoftwareElement",
                        "CircuitElement",
                        "WebsiteElement",
                        "SystemElement",
                        "ServiceElement",
                        "NetworkElement",
                        "PersonElement",
                }</span>
        case "AssetsElementType":<span class="cov0" title="0">
                return []string{
                        "AssetElement",
                        "OrganizationElement",
                        "DataElement",
                        "ItAssetElement",
                        "SoftwareElement",
                        "CircuitElement",
                        "WebsiteElement",
                        "SystemElement",
                        "ServiceElement",
                        "NetworkElement",
                        "PersonElement",
                }</span>
        case "AssetsType":<span class="cov0" title="0">
                return []string{
                        "AssetElement",
                        "OrganizationElement",
                        "DataElement",
                        "ItAssetElement",
                        "SoftwareElement",
                        "CircuitElement",
                        "WebsiteElement",
                        "SystemElement",
                        "ServiceElement",
                        "NetworkElement",
                        "PersonElement",
                }</span>
        case "BenchmarkElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "DcStatusType",
                        "TextType",
                        "HtmlTextWithSubType",
                        "NoticeType",
                        "HtmlTextWithSubType",
                        "HtmlTextWithSubType",
                        "ReferenceType",
                        "PlainTextType",
                        "",
                        "CPE2idrefType",
                        "VersionType",
                        "MetadataType",
                        "",
                        "",
                        "",
                        "",
                        "SignatureType",
                        "",
                        "",
                }</span>
        case "BenchmarkElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "DcStatusType",
                        "TextType",
                        "HtmlTextWithSubType",
                        "NoticeType",
                        "HtmlTextWithSubType",
                        "HtmlTextWithSubType",
                        "ReferenceType",
                        "PlainTextType",
                        "",
                        "CPE2idrefType",
                        "VersionType",
                        "MetadataType",
                        "",
                        "",
                        "",
                        "",
                        "SignatureType",
                        "",
                        "",
                }</span>
        case "CheckType":<span class="cov0" title="0">
                return []string{
                        "CheckImportType",
                        "CheckExportType",
                        "CheckContentRefType",
                        "CheckContentType",
                }</span>
        case "CircuitElement":<span class="cov0" title="0">
                return []string{
                        "CircuitName",
                }</span>
        case "CircuitType":<span class="cov0" title="0">
                return []string{
                        "CircuitName",
                }</span>
        case "ComplexCheckType":<span class="cov0" title="0">
                return []string{
                        "CheckType",
                        "ComplexCheckType",
                }</span>
        case "ComputingDeviceElement":<span class="cov0" title="0">
                return []string{
                        "DistinguishedName",
                        "",
                        "Connections",
                        "",
                        "Hostname",
                        "MotherboardGuid",
                }</span>
        case "ComputingDeviceType":<span class="cov0" title="0">
                return []string{
                        "DistinguishedName",
                        "",
                        "Connections",
                        "",
                        "Hostname",
                        "MotherboardGuid",
                }</span>
        case "ConnectionsElementType":<span class="cov0" title="0">
                return []string{
                        "NetworkInterfaceType",
                }</span>
        case "Constant_variableElement":<span class="cov0" title="0">
                return []string{
                        "ValueType",
                }</span>
        case "Constant_variableElementType":<span class="cov0" title="0">
                return []string{
                        "ValueType",
                }</span>
        case "CountryElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "CountryNameCode",
                        "",
                        "",
                        "",
                        "",
                }</span>
        case "CpeItemElement":<span class="cov0" title="0">
                return []string{
                        "TextType",
                        "NotesType",
                        "ReferencesType",
                        "CheckType",
                }</span>
        case "CpeListElement":<span class="cov0" title="0">
                return []string{
                        "GeneratorType",
                        "ItemType",
                }</span>
        case "CriteriaType":<span class="cov0" title="0">
                return []string{
                        "CriteriaType",
                        "CriterionType",
                        "ExtendDefinitionType",
                }</span>
        case "DSAKeyValueElement":<span class="cov0" title="0">
                return []string{
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                }</span>
        case "DSAKeyValueType":<span class="cov0" title="0">
                return []string{
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                        "CryptoBinary",
                }</span>
        case "DatabaseElement":<span class="cov0" title="0">
                return []string{
                        "InstanceName",
                }</span>
        case "DatabaseType":<span class="cov0" title="0">
                return []string{
                        "InstanceName",
                }</span>
        case "DefinitionElement":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "MetadataType",
                        "NotesType",
                        "CriteriaType",
                }</span>
        case "DefinitionType":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "MetadataType",
                        "NotesType",
                        "CriteriaType",
                }</span>
        case "DefinitionsType":<span class="cov0" title="0">
                return []string{
                        "DefinitionType",
                }</span>
        case "DepartmentElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "DepartmentName",
                        "MailStopType",
                        "",
                }</span>
        case "DepartmentElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "DepartmentName",
                        "MailStopType",
                        "",
                }</span>
        case "DependentLocalityType":<span class="cov0" title="0">
                return []string{
                        "",
                        "DependentLocalityName",
                        "DependentLocalityNumber",
                        "",
                        "",
                        "DependentLocalityType",
                        "",
                        "",
                        "LargeMailUserType",
                        "",
                        "PostalRouteType",
                }</span>
        case "DependentThoroughfareElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "ThoroughfarePreDirectionType",
                        "ThoroughfareLeadingTypeType",
                        "ThoroughfareNameType",
                        "ThoroughfareTrailingTypeType",
                        "ThoroughfarePostDirectionType",
                }</span>
        case "DeprecatedInfoType":<span class="cov0" title="0">
                return []string{
                        "Version",
                }</span>
        case "Deprecated_infoElement":<span class="cov0" title="0">
                return []string{
                        "Version",
                }</span>
        case "ElementMapType":<span class="cov0" title="0">
                return []string{
                        "ElementMapItemType",
                        "ElementMapItemType",
                        "ElementMapItemType",
                        "ElementMapItemType",
                }</span>
        case "Element_mappingElement":<span class="cov0" title="0">
                return []string{
                        "ElementMapItemType",
                        "ElementMapItemType",
                        "ElementMapItemType",
                        "ElementMapItemType",
                }</span>
        case "EntityObjectRecordType":<span class="cov0" title="0">
                return []string{
                        "EntityObjectFieldType",
                }</span>
        case "EntityStateRecordType":<span class="cov0" title="0">
                return []string{
                        "EntityStateFieldType",
                }</span>
        case "ExtendedInfosElementType":<span class="cov0" title="0">
                return []string{
                        "ExtendedInfo",
                }</span>
        case "External_variableElement":<span class="cov0" title="0">
                return []string{
                        "PossibleValueType",
                        "PossibleRestrictionType",
                }</span>
        case "External_variableElementType":<span class="cov0" title="0">
                return []string{
                        "PossibleValueType",
                        "PossibleRestrictionType",
                }</span>
        case "FirmType":<span class="cov0" title="0">
                return []string{
                        "",
                        "FirmName",
                        "",
                        "MailStopType",
                        "",
                }</span>
        case "FixType":<span class="cov0" title="0">
                return []string{
                        "SubType",
                        "InstanceFixType",
                }</span>
        case "GeneratorType":<span class="cov0" title="0">
                return []string{
                        "SchemaVersionType",
                }</span>
        case "GroupElement":<span class="cov0" title="0">
                return []string{
                        "ValueType",
                        "SignatureType",
                        "GroupType",
                        "RuleType",
                }</span>
        case "GroupType":<span class="cov0" title="0">
                return []string{
                        "ValueType",
                        "SignatureType",
                        "GroupType",
                        "RuleType",
                }</span>
        case "HostElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                }</span>
        case "HtmlTextWithSubType":<span class="cov0" title="0">
                return []string{
                        "SubType",
                }</span>
        case "IpAddressElement":<span class="cov0" title="0">
                return []string{
                        "IpV4",
                        "IpV6",
                }</span>
        case "IpAddressType":<span class="cov0" title="0">
                return []string{
                        "IpV4",
                        "IpV6",
                }</span>
        case "IpNetRangeElementType":<span class="cov0" title="0">
                return []string{
                        "IpAddressType",
                        "IpAddressType",
                }</span>
        case "ItemElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "DcStatusType",
                        "VersionType",
                        "TextWithSubType",
                        "HtmlTextWithSubType",
                        "WarningType",
                        "TextType",
                        "ReferenceType",
                        "MetadataType",
                }</span>
        case "ItemType":<span class="cov0" title="0">
                return []string{
                        "",
                        "DcStatusType",
                        "VersionType",
                        "TextWithSubType",
                        "HtmlTextWithSubType",
                        "WarningType",
                        "TextType",
                        "ReferenceType",
                        "MetadataType",
                }</span>
        case "JointPersonNameElement":<span class="cov0" title="0">
                return []string{
                        "NameLineType",
                        "",
                }</span>
        case "JointPersonNameElementType":<span class="cov0" title="0">
                return []string{
                        "NameLineType",
                        "",
                }</span>
        case "KeyInfoElement":<span class="cov0" title="0">
                return []string{
                        "KeyValueType",
                        "RetrievalMethodType",
                        "X509DataType",
                        "PGPDataType",
                        "SPKIDataType",
                }</span>
        case "KeyInfoType":<span class="cov0" title="0">
                return []string{
                        "KeyValueType",
                        "RetrievalMethodType",
                        "X509DataType",
                        "PGPDataType",
                        "SPKIDataType",
                }</span>
        case "KeyValueElement":<span class="cov0" title="0">
                return []string{
                        "DSAKeyValueType",
                        "RSAKeyValueType",
                }</span>
        case "KeyValueType":<span class="cov0" title="0">
                return []string{
                        "DSAKeyValueType",
                        "RSAKeyValueType",
                }</span>
        case "LargeMailUserType":<span class="cov0" title="0">
                return []string{
                        "",
                        "LargeMailUserName",
                        "LargeMailUserIdentifier",
                        "BuildingNameType",
                        "",
                        "",
                        "",
                        "",
                }</span>
        case "ListType":<span class="cov0" title="0">
                return []string{
                        "GeneratorType",
                        "ItemType",
                }</span>
        case "LocalityElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "LocalityName",
                        "",
                        "",
                        "DependentLocalityType",
                        "",
                        "",
                        "LargeMailUserType",
                        "",
                        "PostalRouteType",
                }</span>
        case "LocalityElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "LocalityName",
                        "",
                        "",
                        "DependentLocalityType",
                        "",
                        "",
                        "LargeMailUserType",
                        "",
                        "PostalRouteType",
                }</span>
        case "LocationsElement":<span class="cov0" title="0">
                return []string{
                        "",
                }</span>
        case "LocationsElementType":<span class="cov0" title="0">
                return []string{
                        "",
                }</span>
        case "LogicalTestType":<span class="cov0" title="0">
                return []string{
                        "LogicalTestType",
                        "FactRefType",
                }</span>
        case "MailStopType":<span class="cov0" title="0">
                return []string{
                        "",
                        "MailStopName",
                        "MailStopNumber",
                }</span>
        case "ManifestElement":<span class="cov0" title="0">
                return []string{
                        "ReferenceType",
                }</span>
        case "ManifestType":<span class="cov0" title="0">
                return []string{
                        "ReferenceType",
                }</span>
        case "ModelElement":<span class="cov0" title="0">
                return []string{
                        "ParamType",
                }</span>
        case "ModelElementType":<span class="cov0" title="0">
                return []string{
                        "ParamType",
                }</span>
        case "NameDetails":<span class="cov0" title="0">
                return []string{
                        "NameLineType",
                        "",
                        "",
                        "",
                }</span>
        case "NameDetailsElement":<span class="cov0" title="0">
                return []string{
                        "AddresseeIndicator",
                        "",
                        "DependencyName",
                }</span>
        case "NameDetailsElementType":<span class="cov0" title="0">
                return []string{
                        "AddresseeIndicator",
                        "",
                        "DependencyName",
                }</span>
        case "NetworkElement":<span class="cov0" title="0">
                return []string{
                        "NetworkName",
                        "IpNetRange",
                        "Cidr",
                }</span>
        case "NetworkInterfaceType":<span class="cov0" title="0">
                return []string{
                        "IpAddressType",
                        "MacAddress",
                        "Url",
                        "IpAddressType",
                        "IpAddressType",
                }</span>
        case "NetworkType":<span class="cov0" title="0">
                return []string{
                        "NetworkName",
                        "IpNetRange",
                        "Cidr",
                }</span>
        case "ObjectElement":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "NotesType",
                }</span>
        case "ObjectsType":<span class="cov0" title="0">
                return []string{
                        "ObjectType",
                }</span>
        case "OrganisationNameDetails":<span class="cov0" title="0">
                return []string{
                        "NameLineType",
                        "OrganisationName",
                        "OrganisationType",
                }</span>
        case "OrganisationNameDetailsElement":<span class="cov0" title="0">
                return []string{
                        "OrganisationFormerName",
                        "OrganisationKnownAs",
                }</span>
        case "OrganisationNameDetailsElementType":<span class="cov0" title="0">
                return []string{
                        "OrganisationFormerName",
                        "OrganisationKnownAs",
                }</span>
        case "OrganizationElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "",
                }</span>
        case "OrganizationType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "",
                }</span>
        case "Oval_definitionsElement":<span class="cov0" title="0">
                return []string{
                        "GeneratorType",
                        "DefinitionsType",
                        "TestsType",
                        "ObjectsType",
                        "StatesType",
                        "VariablesType",
                        "",
                }</span>
        case "Oval_definitionsElementType":<span class="cov0" title="0">
                return []string{
                        "GeneratorType",
                        "DefinitionsType",
                        "TestsType",
                        "ObjectsType",
                        "StatesType",
                        "VariablesType",
                        "",
                }</span>
        case "OverrideType":<span class="cov0" title="0">
                return []string{
                        "ResultEnumType",
                        "ResultEnumType",
                        "TextType",
                }</span>
        case "PersonElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "Birthdate",
                }</span>
        case "PersonName":<span class="cov0" title="0">
                return []string{
                        "NameLineType",
                        "PrecedingTitle",
                        "TitleElement",
                        "FirstName",
                        "MiddleName",
                        "NamePrefix",
                        "LastName",
                        "OtherName",
                        "Alias",
                        "GenerationIdentifier",
                        "Suffix",
                        "GeneralSuffix",
                }</span>
        case "PersonNameElement":<span class="cov0" title="0">
                return []string{
                        "FormerName",
                        "KnownAs",
                }</span>
        case "PersonNameElementType":<span class="cov0" title="0">
                return []string{
                        "FormerName",
                        "KnownAs",
                }</span>
        case "PersonType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "Birthdate",
                }</span>
        case "PlatformSpecificationElement":<span class="cov0" title="0">
                return []string{
                        "PlatformType",
                }</span>
        case "PlatformSpecificationElementType":<span class="cov0" title="0">
                return []string{
                        "PlatformType",
                }</span>
        case "PlatformType":<span class="cov0" title="0">
                return []string{
                        "TextType",
                        "TextType",
                        "LogicalTestType",
                }</span>
        case "PossibleRestrictionType":<span class="cov0" title="0">
                return []string{
                        "RestrictionType",
                }</span>
        case "PostBoxElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "PostBoxNumber",
                        "PostBoxNumberPrefix",
                        "PostBoxNumberSuffix",
                        "PostBoxNumberExtension",
                        "FirmType",
                        "",
                }</span>
        case "PostBoxElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "PostBoxNumber",
                        "PostBoxNumberPrefix",
                        "PostBoxNumberSuffix",
                        "PostBoxNumberExtension",
                        "FirmType",
                        "",
                }</span>
        case "PostOfficeElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "PostalRouteType",
                        "",
                        "",
                        "PostOfficeName",
                        "PostOfficeNumber",
                }</span>
        case "PostOfficeElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "PostalRouteType",
                        "",
                        "",
                        "PostOfficeName",
                        "PostOfficeNumber",
                }</span>
        case "PostTownElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "PostTownName",
                        "PostTownSuffix",
                }</span>
        case "PostalCodeElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "PostalCodeNumber",
                        "PostalCodeNumberExtension",
                        "PostTown",
                }</span>
        case "PostalCodeElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "PostalCodeNumber",
                        "PostalCodeNumberExtension",
                        "PostTown",
                }</span>
        case "PostalRouteType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "PostalRouteName",
                        "PostalRouteNumber",
                }</span>
        case "PostalServiceElementsElementType":<span class="cov0" title="0">
                return []string{
                        "AddressIdentifier",
                        "EndorsementLineCode",
                        "KeyLineCode",
                        "Barcode",
                        "SortingCode",
                        "AddressLatitude",
                        "AddressLatitudeDirection",
                        "AddressLongitude",
                        "AddressLongitudeDirection",
                        "SupplementaryPostalServiceData",
                }</span>
        case "PremiseElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "PremiseName",
                        "",
                        "",
                        "BuildingNameType",
                        "MailStopType",
                        "",
                        "",
                        "PremiseLocation",
                        "",
                        "PremiseNumberRange",
                        "SubPremiseType",
                        "FirmType",
                }</span>
        case "PremiseElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "PremiseName",
                        "",
                        "",
                        "BuildingNameType",
                        "MailStopType",
                        "",
                        "",
                        "PremiseLocation",
                        "",
                        "PremiseNumberRange",
                        "SubPremiseType",
                        "FirmType",
                }</span>
        case "PremiseNumberRangeElementType":<span class="cov0" title="0">
                return []string{
                        "PremiseNumberRangeFrom",
                        "PremiseNumberRangeTo",
                }</span>
        case "PremiseNumberRangeFromElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "",
                }</span>
        case "PremiseNumberRangeToElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "",
                }</span>
        case "ProfileElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "DcStatusType",
                        "VersionType",
                        "TextWithSubType",
                        "HtmlTextWithSubType",
                        "ReferenceType",
                        "OverrideableCPE2idrefType",
                        "MetadataType",
                        "SignatureType",
                        "ProfileSelectType",
                        "ProfileSetComplexValueType",
                        "ProfileSetValueType",
                        "ProfileRefineValueType",
                        "ProfileRefineRuleType",
                }</span>
        case "ProfileNoteType":<span class="cov0" title="0">
                return []string{
                        "SubType",
                }</span>
        case "ProfileRefineRuleType":<span class="cov0" title="0">
                return []string{
                        "TextType",
                }</span>
        case "ProfileRefineValueType":<span class="cov0" title="0">
                return []string{
                        "TextType",
                }</span>
        case "ProfileSelectType":<span class="cov0" title="0">
                return []string{
                        "TextType",
                }</span>
        case "ProfileType":<span class="cov0" title="0">
                return []string{
                        "",
                        "DcStatusType",
                        "VersionType",
                        "TextWithSubType",
                        "HtmlTextWithSubType",
                        "ReferenceType",
                        "OverrideableCPE2idrefType",
                        "MetadataType",
                        "SignatureType",
                        "ProfileSelectType",
                        "ProfileSetComplexValueType",
                        "ProfileSetValueType",
                        "ProfileRefineValueType",
                        "ProfileRefineRuleType",
                }</span>
        case "RSAKeyValueElement":<span class="cov0" title="0">
                return []string{
                        "CryptoBinary",
                        "CryptoBinary",
                }</span>
        case "RSAKeyValueType":<span class="cov0" title="0">
                return []string{
                        "CryptoBinary",
                        "CryptoBinary",
                }</span>
        case "ReferenceElement":<span class="cov0" title="0">
                return []string{
                        "TransformsType",
                        "DigestMethodType",
                        "DigestValueType",
                }</span>
        case "ReferencesType":<span class="cov0" title="0">
                return []string{
                        "ReferenceElement",
                }</span>
        case "RelationshipsContainerType":<span class="cov0" title="0">
                return []string{
                        "Relationships",
                }</span>
        case "RelationshipsElementType":<span class="cov0" title="0">
                return []string{
                        "RelationshipType",
                }</span>
        case "ReportRequestType":<span class="cov0" title="0">
                return []string{
                        "Content",
                        "",
                }</span>
        case "ReportRequestsElementType":<span class="cov0" title="0">
                return []string{
                        "ReportRequestType",
                }</span>
        case "ReportType":<span class="cov0" title="0">
                return []string{
                        "Content",
                        "",
                }</span>
        case "ReportsElementType":<span class="cov0" title="0">
                return []string{
                        "ReportType",
                }</span>
        case "RetrievalMethodElement":<span class="cov0" title="0">
                return []string{
                        "TransformsType",
                }</span>
        case "RetrievalMethodType":<span class="cov0" title="0">
                return []string{
                        "TransformsType",
                }</span>
        case "RuleElement":<span class="cov0" title="0">
                return []string{
                        "IdentType",
                        "ProfileNoteType",
                        "FixTextType",
                        "FixType",
                        "SignatureType",
                        "CheckType",
                        "ComplexCheckType",
                }</span>
        case "RuleResultType":<span class="cov0" title="0">
                return []string{
                        "ResultEnumType",
                        "OverrideType",
                        "IdentType",
                        "MetadataType",
                        "MessageType",
                        "InstanceResultType",
                        "FixType",
                        "CheckType",
                        "ComplexCheckType",
                }</span>
        case "RuleType":<span class="cov0" title="0">
                return []string{
                        "IdentType",
                        "ProfileNoteType",
                        "FixTextType",
                        "FixType",
                        "SignatureType",
                        "CheckType",
                        "ComplexCheckType",
                }</span>
        case "SelChoicesType":<span class="cov0" title="0">
                return []string{
                        "ComplexValueType",
                }</span>
        case "SelectableItemType":<span class="cov0" title="0">
                return []string{
                        "HtmlTextWithSubType",
                        "OverrideableCPE2idrefType",
                        "IdrefListType",
                        "IdrefType",
                }</span>
        case "ServedByElement":<span class="cov0" title="0">
                return []string{
                        "Host",
                        "Port",
                        "PortRange",
                        "Protocol",
                }</span>
        case "ServiceElement":<span class="cov0" title="0">
                return []string{
                        "Host",
                        "Port",
                        "PortRange",
                        "Protocol",
                }</span>
        case "ServiceType":<span class="cov0" title="0">
                return []string{
                        "Host",
                        "Port",
                        "PortRange",
                        "Protocol",
                }</span>
        case "SetElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "ObjectIDPattern",
                        "",
                }</span>
        case "SetElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "ObjectIDPattern",
                        "",
                }</span>
        case "SignatureElement":<span class="cov0" title="0">
                return []string{
                        "SignedInfoType",
                        "SignatureValueType",
                        "KeyInfoType",
                        "ObjectType",
                }</span>
        case "SignatureMethodElement":<span class="cov0" title="0">
                return []string{
                        "HMACOutputLengthType",
                }</span>
        case "SignatureMethodType":<span class="cov0" title="0">
                return []string{
                        "HMACOutputLengthType",
                }</span>
        case "SignaturePropertiesElement":<span class="cov0" title="0">
                return []string{
                        "SignaturePropertyType",
                }</span>
        case "SignaturePropertiesType":<span class="cov0" title="0">
                return []string{
                        "SignaturePropertyType",
                }</span>
        case "SignedInfoElement":<span class="cov0" title="0">
                return []string{
                        "CanonicalizationMethodType",
                        "SignatureMethodType",
                        "ReferenceType",
                }</span>
        case "SignedInfoType":<span class="cov0" title="0">
                return []string{
                        "CanonicalizationMethodType",
                        "SignatureMethodType",
                        "ReferenceType",
                }</span>
        case "SoftwareElement":<span class="cov0" title="0">
                return []string{
                        "InstallationId",
                        "",
                        "License",
                }</span>
        case "SoftwareType":<span class="cov0" title="0">
                return []string{
                        "InstallationId",
                        "",
                        "License",
                }</span>
        case "StateElement":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "NotesType",
                }</span>
        case "StateType":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "NotesType",
                }</span>
        case "StatesType":<span class="cov0" title="0">
                return []string{
                        "StateType",
                }</span>
        case "SubAdministrativeAreaElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "SubAdministrativeAreaName",
                        "",
                        "",
                        "",
                }</span>
        case "SubPremiseType":<span class="cov0" title="0">
                return []string{
                        "",
                        "SubPremiseName",
                        "SubPremiseNumberPrefix",
                        "SubPremiseNumberSuffix",
                        "BuildingNameType",
                        "FirmType",
                        "MailStopType",
                        "",
                        "SubPremiseType",
                        "SubPremiseLocation",
                        "SubPremiseNumber",
                }</span>
        case "SystemElement":<span class="cov0" title="0">
                return []string{
                        "SystemName",
                        "Version",
                }</span>
        case "SystemType":<span class="cov0" title="0">
                return []string{
                        "SystemName",
                        "Version",
                }</span>
        case "TailoringElement":<span class="cov0" title="0">
                return []string{
                        "TailoringBenchmarkReferenceType",
                        "",
                        "DcStatusType",
                        "TailoringVersionType",
                        "MetadataType",
                        "ProfileType",
                        "SignatureType",
                }</span>
        case "TailoringType":<span class="cov0" title="0">
                return []string{
                        "TailoringBenchmarkReferenceType",
                        "",
                        "DcStatusType",
                        "TailoringVersionType",
                        "MetadataType",
                        "ProfileType",
                        "SignatureType",
                }</span>
        case "TargetFactsType":<span class="cov0" title="0">
                return []string{
                        "FactType",
                }</span>
        case "TestElement":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "NotesType",
                }</span>
        case "TestResultElement":<span class="cov0" title="0">
                return []string{
                        "BenchmarkReferenceType",
                        "TailoringReferenceType",
                        "TextType",
                        "TextType",
                        "IdentityType",
                        "IdrefType",
                        "TargetFactsType",
                        "CPE2idrefType",
                        "RuleResultType",
                        "ScoreType",
                        "MetadataType",
                        "SignatureType",
                        "TargetIdRefType",
                        "ProfileSetValueType",
                        "ProfileSetComplexValueType",
                }</span>
        case "TestResultType":<span class="cov0" title="0">
                return []string{
                        "BenchmarkReferenceType",
                        "TailoringReferenceType",
                        "TextType",
                        "TextType",
                        "IdentityType",
                        "IdrefType",
                        "TargetFactsType",
                        "CPE2idrefType",
                        "RuleResultType",
                        "ScoreType",
                        "MetadataType",
                        "SignatureType",
                        "TargetIdRefType",
                        "ProfileSetValueType",
                        "ProfileSetComplexValueType",
                }</span>
        case "TestType":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "NotesType",
                }</span>
        case "TestsType":<span class="cov0" title="0">
                return []string{
                        "TestType",
                }</span>
        case "TextWithSubType":<span class="cov0" title="0">
                return []string{
                        "SubType",
                }</span>
        case "ThoroughfareElement":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "ThoroughfarePreDirectionType",
                        "ThoroughfareLeadingTypeType",
                        "ThoroughfareNameType",
                        "ThoroughfareTrailingTypeType",
                        "ThoroughfarePostDirectionType",
                        "DependentThoroughfare",
                        "",
                        "ThoroughfareNumberRange",
                        "DependentLocalityType",
                        "",
                        "FirmType",
                        "",
                }</span>
        case "ThoroughfareElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "ThoroughfarePreDirectionType",
                        "ThoroughfareLeadingTypeType",
                        "ThoroughfareNameType",
                        "ThoroughfareTrailingTypeType",
                        "ThoroughfarePostDirectionType",
                        "DependentThoroughfare",
                        "",
                        "ThoroughfareNumberRange",
                        "DependentLocalityType",
                        "",
                        "FirmType",
                        "",
                }</span>
        case "ThoroughfareNumberFromElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "",
                }</span>
        case "ThoroughfareNumberRangeElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "ThoroughfareNumberFrom",
                        "ThoroughfareNumberTo",
                }</span>
        case "ThoroughfareNumberToElementType":<span class="cov0" title="0">
                return []string{
                        "",
                        "",
                        "",
                        "",
                }</span>
        case "TransformsElement":<span class="cov0" title="0">
                return []string{
                        "TransformType",
                }</span>
        case "TransformsType":<span class="cov0" title="0">
                return []string{
                        "TransformType",
                }</span>
        case "ValueElement":<span class="cov0" title="0">
                return []string{
                        "SelStringType",
                        "SelNumType",
                        "SelNumType",
                        "SelChoicesType",
                        "UriRefType",
                        "SignatureType",
                        "SelStringType",
                        "SelComplexValueType",
                        "SelStringType",
                        "SelComplexValueType",
                }</span>
        case "ValueType":<span class="cov0" title="0">
                return []string{
                        "SelStringType",
                        "SelNumType",
                        "SelNumType",
                        "SelChoicesType",
                        "UriRefType",
                        "SignatureType",
                        "SelStringType",
                        "SelComplexValueType",
                        "SelStringType",
                        "SelComplexValueType",
                }</span>
        case "VariableElement":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "NotesType",
                }</span>
        case "VariableType":<span class="cov0" title="0">
                return []string{
                        "SignatureType",
                        "NotesType",
                }</span>
        case "VariablesType":<span class="cov0" title="0">
                return []string{
                        "VariableType",
                }</span>
        case "WebsiteElement":<span class="cov0" title="0">
                return []string{
                        "DocumentRoot",
                        "Locale",
                }</span>
        case "WebsiteType":<span class="cov0" title="0">
                return []string{
                        "DocumentRoot",
                        "Locale",
                }</span>
        case "X509DataElement":<span class="cov0" title="0">
                return []string{
                        "X509IssuerSerialType",
                }</span>
        case "X509DataType":<span class="cov0" title="0">
                return []string{
                        "X509IssuerSerialType",
                }</span>
        case "XALElement":<span class="cov0" title="0">
                return []string{
                        "",
                }</span>
        case "XALElementType":<span class="cov0" title="0">
                return []string{
                        "",
                }</span>
        case "XNLElement":<span class="cov0" title="0">
                return []string{
                        "",
                }</span>
        case "XNLElementType":<span class="cov0" title="0">
                return []string{
                        "",
                }</span>
        default:<span class="cov8" title="1">
                return []string{}</span>
        }
}

// GetTypeMetadata returns metadata for a type.
func (s *XMLDocumentState) GetTypeMetadata(name string) (*TypeMetadata, error) <span class="cov8" title="1">{
        switch name </span>{
        case "ActuateType":<span class="cov8" title="1">
                return &amp;TypeMetadata{
                        Name:          "ActuateType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "AddressDetails":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressDetails",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "PostalServiceElements",
                                        Type:          "PostalServiceElements",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Address",
                                        Type:          "Address",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressLines",
                                        Type:          "AddressLinesType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Country",
                                        Type:          "Country",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "CurrentStatus",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ValidFromDate",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ValidToDate",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Usage",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressDetailsKey",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressDetailsElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressDetailsElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "PostalServiceElements",
                                        Type:          "PostalServiceElements",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Address",
                                        Type:          "Address",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressLines",
                                        Type:          "AddressLinesType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Country",
                                        Type:          "Country",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "CurrentStatus",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ValidFromDate",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ValidToDate",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Usage",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressDetailsKey",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressIdentifierElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressIdentifierElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "IdentifierType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressLatitudeDirectionElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressLatitudeDirectionElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressLatitudeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressLatitudeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressLineElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressLineElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressLineElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressLineElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressLinesType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressLinesType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressLongitudeDirectionElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressLongitudeDirectionElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddressLongitudeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddressLongitudeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AddresseeIndicatorElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AddresseeIndicatorElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AdministrativeAreaElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AdministrativeAreaElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "AdministrativeAreaName",
                                        Type:          "AdministrativeAreaName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubAdministrativeArea",
                                        Type:          "SubAdministrativeArea",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "UsageType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AdministrativeAreaElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AdministrativeAreaElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "AdministrativeAreaName",
                                        Type:          "AdministrativeAreaName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubAdministrativeArea",
                                        Type:          "SubAdministrativeArea",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "UsageType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AdministrativeAreaNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AdministrativeAreaNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AffectedType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AffectedType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "platform",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "product",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "family",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"android", "asa", "apple_ios", "catos", "ios", "iosxe", "junos", "macos", "pixos", "undefined", "unix", "vmware_infrastructure", "windows"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AliasElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AliasElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ArcElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ArcElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ArcType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ArcType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ArcroleType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ArcroleType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ArithmeticEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ArithmeticEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ArithmeticFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ArithmeticFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "arithmetic_operation",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"add", "multiply"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "extended-information",
                                        Type:          "ExtendedInformation",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetIdentificationType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetIdentificationType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "asset-ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetRelatedElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetRelatedElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "asset-ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetReportCollectionElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetReportCollectionElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "report-requests",
                                        Type:          "ReportRequests",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "assets",
                                        Type:          "Assets",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reports",
                                        Type:          "Reports",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "extended-infos",
                                        Type:          "ExtendedInfos",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetReportCollectionElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetReportCollectionElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "report-requests",
                                        Type:          "ReportRequests",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "assets",
                                        Type:          "Assets",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reports",
                                        Type:          "Reports",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "extended-infos",
                                        Type:          "ExtendedInfos",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetType",
                        Documentation: "",
                        IsAbstract:    true,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "extended-information",
                                        Type:          "ExtendedInformation",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetsElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetsElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "asset",
                                        Type:          "Asset",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "asset",
                                        Type:          "Asset",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "AssetsType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "AssetsType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "asset",
                                        Type:          "Asset",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "BarcodeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "BarcodeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "BeginFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "BeginFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "character",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "BenchmarkElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "BenchmarkElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "dc-status",
                                        Type:          "DcStatusType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "title",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "description",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "notice",
                                        Type:          "NoticeType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "front-matter",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "rear-matter",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reference",
                                        Type:          "ReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "plain-text",
                                        Type:          "PlainTextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "platform",
                                        Type:          "CPE2idrefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "VersionType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_benchmark_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "resolved",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "style",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "style-href",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "BenchmarkElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "BenchmarkElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "dc-status",
                                        Type:          "DcStatusType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "title",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "description",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "notice",
                                        Type:          "NoticeType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "front-matter",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "rear-matter",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reference",
                                        Type:          "ReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "plain-text",
                                        Type:          "PlainTextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "platform",
                                        Type:          "CPE2idrefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "VersionType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_benchmark_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "resolved",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "style",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "style-href",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "BenchmarkIdType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "BenchmarkIdType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "BenchmarkReferenceType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "BenchmarkReferenceType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "href",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "BirthdateElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "BirthdateElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "BuildingNameType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "BuildingNameType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "TypeOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CPE2idrefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CPE2idrefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "idref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CanonicalizationMethodElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CanonicalizationMethodElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Algorithm",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CanonicalizationMethodType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CanonicalizationMethodType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Algorithm",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CcOperatorEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CcOperatorEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "CheckContentRefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CheckContentRefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "href",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "name",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CheckContentType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CheckContentType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "CheckEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CheckEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "CheckExportType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CheckExportType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "value-id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "export-name",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CheckImportType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CheckImportType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "import-name",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "import-xpath",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CheckType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CheckType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "check-import",
                                        Type:          "CheckImportType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check-export",
                                        Type:          "CheckExportType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check-content-ref",
                                        Type:          "CheckContentRefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check-content",
                                        Type:          "CheckContentType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "system",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "negate",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "selector",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "multi-check",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CidrElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CidrElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CidrType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CidrType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "CircuitElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CircuitElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "circuit-name",
                                        Type:          "CircuitName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CircuitNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CircuitNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CircuitType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CircuitType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "circuit-name",
                                        Type:          "CircuitName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ClassEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ClassEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ComplexCheckType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ComplexCheckType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "check",
                                        Type:          "CheckType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-check",
                                        Type:          "ComplexCheckType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"OR", "AND"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "negate",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ComplexDatatypeEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ComplexDatatypeEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ComplexValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ComplexValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "item",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ComputingDeviceElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ComputingDeviceElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "distinguished-name",
                                        Type:          "DistinguishedName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "connections",
                                        Type:          "Connections",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "hostname",
                                        Type:          "Hostname",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "motherboard-guid",
                                        Type:          "MotherboardGuid",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ComputingDeviceType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ComputingDeviceType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "distinguished-name",
                                        Type:          "DistinguishedName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "connections",
                                        Type:          "Connections",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "hostname",
                                        Type:          "Hostname",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "motherboard-guid",
                                        Type:          "MotherboardGuid",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ConcatFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ConcatFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ConnectionsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ConnectionsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "connection",
                                        Type:          "NetworkInterfaceType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Constant_variableElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Constant_variableElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "value",
                                        Type:          "ValueType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Constant_variableElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Constant_variableElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "value",
                                        Type:          "ValueType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ContentElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ContentElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "data-valid-start-date",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "data-valid-end-date",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ContentElementType1":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ContentElementType1",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "CountFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CountFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "CountryElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CountryElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "CountryNameCode",
                                        Type:          "CountryNameCode",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CountryNameCodeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CountryNameCodeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Scheme",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CountryNameElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CountryNameElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CountryNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CountryNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CpeElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CpeElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CpeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CpeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CpeItemElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CpeItemElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "title",
                                        Type:          "TextType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "notes",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "references",
                                        Type:          "ReferencesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check",
                                        Type:          "CheckType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "name",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\\._\\-~%]*){0,6}",
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated_by",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\\._\\-~%]*){0,6}",
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecation_date",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CpeListElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CpeListElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "generator",
                                        Type:          "GeneratorType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "ItemType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CpeType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CpeType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "CriteriaType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CriteriaType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "criteria",
                                        Type:          "CriteriaType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "criterion",
                                        Type:          "CriterionType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "extend_definition",
                                        Type:          "ExtendDefinitionType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "applicability_check",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"AND", "OR"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "negate",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CriterionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CriterionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "applicability_check",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "test_ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:tst:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "negate",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "CryptoBinary":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "CryptoBinary",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DSAKeyValueElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DSAKeyValueElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "G",
                                        Type:          "CryptoBinary",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Y",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "J",
                                        Type:          "CryptoBinary",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "P",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Q",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Seed",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PgenCounter",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DSAKeyValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DSAKeyValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "G",
                                        Type:          "CryptoBinary",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Y",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "J",
                                        Type:          "CryptoBinary",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "P",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Q",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Seed",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PgenCounter",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DataElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DataElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DataType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DataType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DatabaseElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DatabaseElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "instance-name",
                                        Type:          "InstanceName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DatabaseType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DatabaseType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "instance-name",
                                        Type:          "InstanceName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DatatypeEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DatatypeEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DateTimeFormatEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DateTimeFormatEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DcStatusType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DcStatusType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DefinitionElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DefinitionElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "criteria",
                                        Type:          "CriteriaType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:def:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "class",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"compliance", "inventory", "miscellaneous", "patch", "vulnerability"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DefinitionIDPattern":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DefinitionIDPattern",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DefinitionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DefinitionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "criteria",
                                        Type:          "CriteriaType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:def:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "class",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"compliance", "inventory", "miscellaneous", "patch", "vulnerability"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DefinitionsType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DefinitionsType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "DefinitionType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DepartmentElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DepartmentElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DepartmentName",
                                        Type:          "DepartmentName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MailStop",
                                        Type:          "MailStopType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DepartmentElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DepartmentElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DepartmentName",
                                        Type:          "DepartmentName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MailStop",
                                        Type:          "MailStopType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DepartmentNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DepartmentNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DependencyNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DependencyNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "DependencyType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DependentLocalityNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DependentLocalityNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DependentLocalityNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DependentLocalityNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NameNumberOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DependentLocalityType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DependentLocalityType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentLocalityName",
                                        Type:          "DependentLocalityName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentLocalityNumber",
                                        Type:          "DependentLocalityNumber",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentLocality",
                                        Type:          "DependentLocalityType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "LargeMailUser",
                                        Type:          "LargeMailUserType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalRoute",
                                        Type:          "PostalRouteType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "UsageType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Connector",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DependentThoroughfareElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DependentThoroughfareElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfarePreDirection",
                                        Type:          "ThoroughfarePreDirectionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareLeadingType",
                                        Type:          "ThoroughfareLeadingTypeType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareName",
                                        Type:          "ThoroughfareNameType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareTrailingType",
                                        Type:          "ThoroughfareTrailingTypeType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfarePostDirection",
                                        Type:          "ThoroughfarePostDirectionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DeprecatedInfoType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DeprecatedInfoType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "version",
                                        Type:          "Version",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reason",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Deprecated_infoElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Deprecated_infoElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "version",
                                        Type:          "Version",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reason",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DigestMethodElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DigestMethodElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Algorithm",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DigestMethodType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DigestMethodType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Algorithm",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DigestValueElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DigestValueElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DigestValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DigestValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "DistinguishedNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DistinguishedNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "DocumentRootElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "DocumentRootElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ElementMapItemType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ElementMapItemType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "target_namespace",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ElementMapType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ElementMapType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "test",
                                        Type:          "ElementMapItemType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "object",
                                        Type:          "ElementMapItemType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "state",
                                        Type:          "ElementMapItemType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "item",
                                        Type:          "ElementMapItemType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Element_mappingElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Element_mappingElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "test",
                                        Type:          "ElementMapItemType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "object",
                                        Type:          "ElementMapItemType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "state",
                                        Type:          "ElementMapItemType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "item",
                                        Type:          "ElementMapItemType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EmailAddressElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EmailAddressElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EmailAddressElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EmailAddressElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EmptyStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EmptyStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "EndFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EndFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "character",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EndorsementLineCodeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EndorsementLineCodeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityComplexBaseType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityComplexBaseType",
                        Documentation: "",
                        IsAbstract:    true,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "EntityObjectAnySimpleType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectAnySimpleType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectBinaryType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectBinaryType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectBoolType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectBoolType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectFieldType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectFieldType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "name",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "entity_check",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all", "at least one", "none exist", "none satisfy", "only one"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectFloatType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectFloatType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectIPAddressStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectIPAddressStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectIPAddressType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectIPAddressType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectIntType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectIntType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectRecordType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectRecordType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "field",
                                        Type:          "EntityObjectFieldType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityObjectVersionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityObjectVersionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntitySimpleBaseType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntitySimpleBaseType",
                        Documentation: "",
                        IsAbstract:    true,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "EntityStateAnySimpleType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateAnySimpleType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateBinaryType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateBinaryType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateBoolType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateBoolType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateComplexBaseType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateComplexBaseType",
                        Documentation: "",
                        IsAbstract:    true,
                        Fields: []FieldInfo{
                                {
                                        Name:          "entity_check",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all", "at least one", "none exist", "none satisfy", "only one"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "check_existence",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all_exist", "any_exist", "at_least_one_exists", "none_exist", "only_one_exists"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateDebianEVRStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateDebianEVRStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateEVRStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateEVRStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateFieldType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateFieldType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "name",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "entity_check",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all", "at least one", "none exist", "none satisfy", "only one"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateFileSetRevisionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateFileSetRevisionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateFloatType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateFloatType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateIOSVersionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateIOSVersionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateIPAddressStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateIPAddressStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateIPAddressType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateIPAddressType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateIntType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateIntType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateRecordType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateRecordType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "field",
                                        Type:          "EntityStateFieldType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateSimpleBaseType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateSimpleBaseType",
                        Documentation: "",
                        IsAbstract:    true,
                        Fields: []FieldInfo{
                                {
                                        Name:          "entity_check",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all", "at least one", "none exist", "none satisfy", "only one"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "check_existence",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all_exist", "any_exist", "at_least_one_exists", "none_exist", "only_one_exists"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EntityStateVersionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EntityStateVersionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "EscapeRegexFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "EscapeRegexFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ExistenceEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ExistenceEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ExtendDefinitionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ExtendDefinitionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "applicability_check",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "definition_ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:def:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "negate",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Extended":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Extended",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ExtendedInfoElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ExtendedInfoElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ExtendedInformationElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ExtendedInformationElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ExtendedInfosElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ExtendedInfosElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "extended-info",
                                        Type:          "ExtendedInfo",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "External_variableElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "External_variableElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "possible_value",
                                        Type:          "PossibleValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "possible_restriction",
                                        Type:          "PossibleRestrictionType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "External_variableElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "External_variableElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "possible_value",
                                        Type:          "PossibleValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "possible_restriction",
                                        Type:          "PossibleRestrictionType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FactRefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FactRefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "name",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "cpe:/([aho](:[A-Za-z0-9\\._\\-~]*(:[A-Za-z0-9\\._\\-~]*(:[A-Za-z0-9\\._\\.\\-~]*(:[A-Za-z0-9\\._\\-~]*)?)?)?)?)?",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FactType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FactType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "name",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"number", "string", "boolean"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FamilyEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FamilyEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "FilterActionEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FilterActionEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "FilterElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FilterElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "action",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"exclude", "include"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FilterElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FilterElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "action",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"exclude", "include"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FirmNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FirmNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FirmType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FirmType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "FirmName",
                                        Type:          "FirmName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MailStop",
                                        Type:          "MailStopType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FirstNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FirstNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FixStrategyEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FixStrategyEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "FixTextType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FixTextType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "fixref",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reboot",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "strategy",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "configure", "combination", "disable", "enable", "patch", "policy", "restrict", "update"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "disruption",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "low", "medium", "high"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "complexity",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "low", "medium", "high"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FixType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FixType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "sub",
                                        Type:          "SubType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "instance",
                                        Type:          "InstanceFixType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reboot",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "strategy",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "configure", "combination", "disable", "enable", "patch", "policy", "restrict", "update"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "disruption",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "low", "medium", "high"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "complexity",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "low", "medium", "high"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "system",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "platform",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FormerNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FormerNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ValidFrom",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ValidTo",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FqdnElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FqdnElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FqdnElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FqdnElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FromType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FromType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "Function":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Function",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "FunctionElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "FunctionElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "GeneralSuffixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "GeneralSuffixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "GenerationIdentifierElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "GenerationIdentifierElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "GeneratorType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "GeneratorType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "product_name",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "product_version",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "schema_version",
                                        Type:          "SchemaVersionType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "timestamp",
                                        Type:          "time.Time",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "GlobToRegexFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "GlobToRegexFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "glob_noescape",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "GroupElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "GroupElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "ValueType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "GroupType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "RuleType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_group_.+",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "GroupIdType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "GroupIdType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "GroupType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "GroupType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "ValueType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "GroupType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "RuleType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_group_.+",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "HMACOutputLengthType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "HMACOutputLengthType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "HostElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "HostElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "HostnameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "HostnameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "HostnameType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "HostnameType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "HrefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "HrefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "HtmlTextType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "HtmlTextType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "override",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "HtmlTextWithSubType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "HtmlTextWithSubType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "sub",
                                        Type:          "SubType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "override",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "IdentType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IdentType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "system",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "IdentityType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IdentityType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "authenticated",
                                        Type:          "bool",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "privileged",
                                        Type:          "bool",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "IdrefListType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IdrefListType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "idref",
                                        Type:          "[]string",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "IdrefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IdrefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "idref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "InstallationIdElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "InstallationIdElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "InstanceFixType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "InstanceFixType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "context",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "InstanceNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "InstanceNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "InstanceResultType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "InstanceResultType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "context",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "parentContext",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "InterfaceHintType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "InterfaceHintType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "IpAddressElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IpAddressElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ip-v4",
                                        Type:          "IpV4",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ip-v6",
                                        Type:          "IpV6",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "IpAddressType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IpAddressType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ip-v4",
                                        Type:          "IpV4",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ip-v6",
                                        Type:          "IpV6",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "IpNetRangeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IpNetRangeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ip-net-range-start",
                                        Type:          "IpAddressType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ip-net-range-end",
                                        Type:          "IpAddressType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "IpV4ElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IpV4ElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "IpV6ElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "IpV6ElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Ipv4Type":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Ipv4Type",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "Ipv6Type":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Ipv6Type",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ItAssetElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ItAssetElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ItAssetType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ItAssetType",
                        Documentation: "",
                        IsAbstract:    true,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ItemElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ItemElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "dc-status",
                                        Type:          "DcStatusType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "VersionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "title",
                                        Type:          "TextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "description",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "warning",
                                        Type:          "WarningType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "question",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reference",
                                        Type:          "ReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "abstract",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "cluster-id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "extends",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "hidden",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "prohibitChanges",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ItemIDPattern":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ItemIDPattern",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ItemType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ItemType",
                        Documentation: "",
                        IsAbstract:    true,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "dc-status",
                                        Type:          "DcStatusType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "VersionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "title",
                                        Type:          "TextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "description",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "warning",
                                        Type:          "WarningType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "question",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reference",
                                        Type:          "ReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "abstract",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "cluster-id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "extends",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "hidden",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "prohibitChanges",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "JointPersonNameElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "JointPersonNameElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NameLine",
                                        Type:          "NameLineType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "JointNameConnector",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "JointPersonNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "JointPersonNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NameLine",
                                        Type:          "NameLineType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "JointNameConnector",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "KeyInfoElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "KeyInfoElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "KeyValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "RetrievalMethodType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "X509DataType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "PGPDataType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "SPKIDataType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "KeyInfoType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "KeyInfoType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "KeyValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "RetrievalMethodType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "X509DataType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "PGPDataType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "SPKIDataType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "KeyLineCodeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "KeyLineCodeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "KeyNameElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "KeyNameElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "KeyValueElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "KeyValueElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "DSAKeyValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "RSAKeyValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "KeyValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "KeyValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "DSAKeyValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "RSAKeyValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "KnownAsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "KnownAsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ValidFrom",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ValidTo",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LabelType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LabelType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "LargeMailUserIdentifierElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LargeMailUserIdentifierElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LargeMailUserNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LargeMailUserNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LargeMailUserType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LargeMailUserType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "LargeMailUserName",
                                        Type:          "LargeMailUserName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "LargeMailUserIdentifier",
                                        Type:          "LargeMailUserIdentifier",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "BuildingName",
                                        Type:          "BuildingNameType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LastNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LastNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LicenseElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LicenseElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ListType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ListType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "generator",
                                        Type:          "GeneratorType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "ItemType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LiteralComponentType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LiteralComponentType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Local_variableElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Local_variableElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "Local_variableElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Local_variableElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "LocaleElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocaleElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocaleType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocaleType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "LocalityElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocalityElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "LocalityName",
                                        Type:          "LocalityName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentLocality",
                                        Type:          "DependentLocalityType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "LargeMailUser",
                                        Type:          "LargeMailUserType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalRoute",
                                        Type:          "PostalRouteType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "UsageType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocalityElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocalityElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "LocalityName",
                                        Type:          "LocalityName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentLocality",
                                        Type:          "DependentLocalityType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "LargeMailUser",
                                        Type:          "LargeMailUserType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalRoute",
                                        Type:          "PostalRouteType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "UsageType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocalityNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocalityNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocationAddressElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocationAddressElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "LocationElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocationElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "LocationPointElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocationPointElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "latitude",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "longitude",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "elevation",
                                        Type:          "float64",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "radius",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocationPointElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocationPointElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "latitude",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "longitude",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "elevation",
                                        Type:          "float64",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "radius",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocationRegionElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocationRegionElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocationRegionElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocationRegionElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocationsElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocationsElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocationsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocationsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "LocatorElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocatorElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "LocatorType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LocatorType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "LogicalTestType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "LogicalTestType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "logical-test",
                                        Type:          "LogicalTestType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "fact-ref",
                                        Type:          "FactRefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"AND", "OR"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "negate",
                                        Type:          "bool",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "MacAddressElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MacAddressElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "MacAddressType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MacAddressType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "MailStopNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MailStopNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "MailStopNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MailStopNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NameNumberSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "MailStopType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MailStopType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MailStopName",
                                        Type:          "MailStopName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MailStopNumber",
                                        Type:          "MailStopNumber",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ManifestElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ManifestElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "ReferenceType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ManifestType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ManifestType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "ReferenceType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "MessageLevelEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MessageLevelEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "MessageType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MessageType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "level",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"debug", "error", "fatal", "info", "warning"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "MetadataType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MetadataType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "MgmtDataElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MgmtDataElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "MiddleNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MiddleNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ModelElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ModelElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "param",
                                        Type:          "ParamType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "system",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ModelElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ModelElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "param",
                                        Type:          "ParamType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "system",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "MotherboardGuidElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MotherboardGuidElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "MsgSevEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "MsgSevEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "NameDetails":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NameDetails",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NameLine",
                                        Type:          "NameLineType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PartyType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NameDetailsElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NameDetailsElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "AddresseeIndicator",
                                        Type:          "AddresseeIndicator",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependencyName",
                                        Type:          "DependencyName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameDetailsKey",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NameDetailsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NameDetailsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "AddresseeIndicator",
                                        Type:          "AddresseeIndicator",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependencyName",
                                        Type:          "DependencyName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameDetailsKey",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NameLineType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NameLineType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NamePattern":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NamePattern",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "NamePrefixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NamePrefixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NetworkElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NetworkElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "network-name",
                                        Type:          "NetworkName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ip-net-range",
                                        Type:          "IpNetRange",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "cidr",
                                        Type:          "Cidr",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NetworkInterfaceType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NetworkInterfaceType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "IpAddressType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "mac-address",
                                        Type:          "MacAddress",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "url",
                                        Type:          "Url",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "subnet-mask",
                                        Type:          "IpAddressType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "default-route",
                                        Type:          "IpAddressType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NetworkNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NetworkNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NetworkType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NetworkType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "network-name",
                                        Type:          "NetworkName",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ip-net-range",
                                        Type:          "IpNetRange",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "cidr",
                                        Type:          "Cidr",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NonEmptyStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NonEmptyStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "NotesElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NotesElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "note",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NotesElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NotesElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "note",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NotesType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NotesType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "note",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "NoticeType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "NoticeType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ObjectComponentType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ObjectComponentType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "object_ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "item_field",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "record_field",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ObjectElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ObjectElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ObjectIDPattern":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ObjectIDPattern",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ObjectRefElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ObjectRefElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ref-id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ObjectRefElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ObjectRefElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ref-id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ObjectRefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ObjectRefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "object_ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ObjectType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ObjectType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MimeType",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Encoding",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ObjectsType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ObjectsType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "ObjectType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OperationEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OperationEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "OperatorEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OperatorEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "OrganisationFormerNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganisationFormerNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ValidFrom",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ValidTo",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OrganisationKnownAsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganisationKnownAsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ValidFrom",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ValidTo",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OrganisationNameDetails":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganisationNameDetails",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NameLine",
                                        Type:          "NameLineType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "OrganisationName",
                                        Type:          "OrganisationName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "OrganisationType",
                                        Type:          "OrganisationType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OrganisationNameDetailsElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganisationNameDetailsElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "OrganisationFormerName",
                                        Type:          "OrganisationFormerName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "OrganisationKnownAs",
                                        Type:          "OrganisationKnownAs",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OrganisationNameDetailsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganisationNameDetailsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "OrganisationFormerName",
                                        Type:          "OrganisationFormerName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "OrganisationKnownAs",
                                        Type:          "OrganisationKnownAs",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OrganisationNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganisationNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OrganisationTypeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganisationTypeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OrganizationElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganizationElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OrganizationType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OrganizationType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OtherNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OtherNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NameType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Oval_definitionsElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Oval_definitionsElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "generator",
                                        Type:          "GeneratorType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "definitions",
                                        Type:          "DefinitionsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "tests",
                                        Type:          "TestsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "objects",
                                        Type:          "ObjectsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "states",
                                        Type:          "StatesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "variables",
                                        Type:          "VariablesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Oval_definitionsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Oval_definitionsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "generator",
                                        Type:          "GeneratorType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "definitions",
                                        Type:          "DefinitionsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "tests",
                                        Type:          "TestsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "objects",
                                        Type:          "ObjectsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "states",
                                        Type:          "StatesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "variables",
                                        Type:          "VariablesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OverrideType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OverrideType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "old-result",
                                        Type:          "ResultEnumType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"pass", "fail", "error", "unknown", "notapplicable", "notchecked", "notselected", "informational", "fixed"},
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "new-result",
                                        Type:          "ResultEnumType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"pass", "fail", "error", "unknown", "notapplicable", "notchecked", "notselected", "informational", "fixed"},
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "remark",
                                        Type:          "TextType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "time",
                                        Type:          "time.Time",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "authority",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "OverrideableCPE2idrefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "OverrideableCPE2idrefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "override",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PGPDataElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PGPDataElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "PGPKeyID",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PGPKeyPacket",
                                        Type:          "[]byte",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PGPKeyPacket",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PGPDataType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PGPDataType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "PGPKeyID",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PGPKeyPacket",
                                        Type:          "[]byte",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PGPKeyPacket",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ParamType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ParamType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "name",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PersonElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PersonElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "birthdate",
                                        Type:          "Birthdate",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PersonName":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PersonName",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NameLine",
                                        Type:          "NameLineType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PrecedingTitle",
                                        Type:          "PrecedingTitle",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Title",
                                        Type:          "Title",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "FirstName",
                                        Type:          "FirstName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MiddleName",
                                        Type:          "MiddleName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NamePrefix",
                                        Type:          "NamePrefix",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "LastName",
                                        Type:          "LastName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "OtherName",
                                        Type:          "OtherName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Alias",
                                        Type:          "Alias",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "GenerationIdentifier",
                                        Type:          "GenerationIdentifier",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Suffix",
                                        Type:          "Suffix",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "GeneralSuffix",
                                        Type:          "GeneralSuffix",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PersonNameElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PersonNameElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "FormerName",
                                        Type:          "FormerName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "KnownAs",
                                        Type:          "KnownAs",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PersonNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PersonNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "FormerName",
                                        Type:          "FormerName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "KnownAs",
                                        Type:          "KnownAs",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PersonType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PersonType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "birthdate",
                                        Type:          "Birthdate",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PlainTextType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PlainTextType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PlatformSpecificationElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PlatformSpecificationElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "platform",
                                        Type:          "PlatformType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PlatformSpecificationElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PlatformSpecificationElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "platform",
                                        Type:          "PlatformType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PlatformType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PlatformType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "title",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "remark",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "logical-test",
                                        Type:          "LogicalTestType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PortElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PortElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PortRangeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PortRangeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "lower-bound",
                                        Type:          "int",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinValue:      "0",
                                        MaxValue:      "65535",
                                        Documentation: "",
                                },
                                {
                                        Name:          "upper-bound",
                                        Type:          "int",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinValue:      "0",
                                        MaxValue:      "65535",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PortType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PortType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "PossibleRestrictionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PossibleRestrictionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "restriction",
                                        Type:          "RestrictionType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"AND", "OR"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "hint",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PossibleValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PossibleValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "hint",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostBoxElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostBoxElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostBoxNumber",
                                        Type:          "PostBoxNumber",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostBoxNumberPrefix",
                                        Type:          "PostBoxNumberPrefix",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostBoxNumberSuffix",
                                        Type:          "PostBoxNumberSuffix",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostBoxNumberExtension",
                                        Type:          "PostBoxNumberExtension",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Firm",
                                        Type:          "FirmType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostBoxElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostBoxElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostBoxNumber",
                                        Type:          "PostBoxNumber",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostBoxNumberPrefix",
                                        Type:          "PostBoxNumberPrefix",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostBoxNumberSuffix",
                                        Type:          "PostBoxNumberSuffix",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostBoxNumberExtension",
                                        Type:          "PostBoxNumberExtension",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Firm",
                                        Type:          "FirmType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostBoxNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostBoxNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "PostBoxNumberExtensionElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostBoxNumberExtensionElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberExtensionSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostBoxNumberPrefixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostBoxNumberPrefixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberPrefixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostBoxNumberSuffixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostBoxNumberSuffixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberSuffixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostOfficeElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostOfficeElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalRoute",
                                        Type:          "PostalRouteType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostOfficeName",
                                        Type:          "PostOfficeName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostOfficeNumber",
                                        Type:          "PostOfficeNumber",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostOfficeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostOfficeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalRoute",
                                        Type:          "PostalRouteType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostOfficeName",
                                        Type:          "PostOfficeName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostOfficeNumber",
                                        Type:          "PostOfficeNumber",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostOfficeNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostOfficeNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostOfficeNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostOfficeNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "IndicatorOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostTownElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostTownElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostTownName",
                                        Type:          "PostTownName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostTownSuffix",
                                        Type:          "PostTownSuffix",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostTownNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostTownNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostTownSuffixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostTownSuffixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "PostalCodeElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostalCodeElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalCodeNumber",
                                        Type:          "PostalCodeNumber",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalCodeNumberExtension",
                                        Type:          "PostalCodeNumberExtension",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostTown",
                                        Type:          "PostTown",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostalCodeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostalCodeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalCodeNumber",
                                        Type:          "PostalCodeNumber",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalCodeNumberExtension",
                                        Type:          "PostalCodeNumberExtension",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostTown",
                                        Type:          "PostTown",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostalCodeNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostalCodeNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostalCodeNumberExtensionElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostalCodeNumberExtensionElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NumberExtensionSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostalRouteNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostalRouteNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostalRouteNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostalRouteNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "PostalRouteType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostalRouteType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalRouteName",
                                        Type:          "PostalRouteName",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PostalRouteNumber",
                                        Type:          "PostalRouteNumber",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PostalServiceElementsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PostalServiceElementsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "AddressIdentifier",
                                        Type:          "AddressIdentifier",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "EndorsementLineCode",
                                        Type:          "EndorsementLineCode",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "KeyLineCode",
                                        Type:          "KeyLineCode",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Barcode",
                                        Type:          "Barcode",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SortingCode",
                                        Type:          "SortingCode",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressLatitude",
                                        Type:          "AddressLatitude",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressLatitudeDirection",
                                        Type:          "AddressLatitudeDirection",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressLongitude",
                                        Type:          "AddressLongitude",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "AddressLongitudeDirection",
                                        Type:          "AddressLongitudeDirection",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SupplementaryPostalServiceData",
                                        Type:          "SupplementaryPostalServiceData",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PrecedingTitleElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PrecedingTitleElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseName",
                                        Type:          "PremiseName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "BuildingName",
                                        Type:          "BuildingNameType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MailStop",
                                        Type:          "MailStopType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseLocation",
                                        Type:          "PremiseLocation",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseNumberRange",
                                        Type:          "PremiseNumberRange",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubPremise",
                                        Type:          "SubPremiseType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Firm",
                                        Type:          "FirmType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseDependency",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseDependencyType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseThoroughfareConnector",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseName",
                                        Type:          "PremiseName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "BuildingName",
                                        Type:          "BuildingNameType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MailStop",
                                        Type:          "MailStopType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseLocation",
                                        Type:          "PremiseLocation",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseNumberRange",
                                        Type:          "PremiseNumberRange",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubPremise",
                                        Type:          "SubPremiseType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Firm",
                                        Type:          "FirmType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseDependency",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseDependencyType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseThoroughfareConnector",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseLocationElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseLocationElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "PremiseNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "TypeOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "IndicatorOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NumberTypeOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "IndicatorOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NumberTypeOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberPrefixElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberPrefixElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberPrefixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberPrefixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberPrefixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberPrefixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberRangeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberRangeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "PremiseNumberRangeFrom",
                                        Type:          "PremiseNumberRangeFrom",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseNumberRangeTo",
                                        Type:          "PremiseNumberRangeTo",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "RangeType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Separator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "IndicatorOccurence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NumberRangeOccurence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberRangeFromElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberRangeFromElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberRangeToElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberRangeToElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberSuffixElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberSuffixElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberSuffixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "PremiseNumberSuffixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "PremiseNumberSuffixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberSuffixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProfileElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "dc-status",
                                        Type:          "DcStatusType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "VersionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "title",
                                        Type:          "TextWithSubType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "description",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reference",
                                        Type:          "ReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "platform",
                                        Type:          "OverrideableCPE2idrefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "select",
                                        Type:          "ProfileSelectType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set-complex-value",
                                        Type:          "ProfileSetComplexValueType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set-value",
                                        Type:          "ProfileSetValueType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "refine-value",
                                        Type:          "ProfileRefineValueType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "refine-rule",
                                        Type:          "ProfileRefineRuleType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_profile_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "prohibitChanges",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "abstract",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "note-tag",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "extends",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProfileIdType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileIdType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ProfileNoteType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileNoteType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "sub",
                                        Type:          "SubType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "tag",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProfileRefineRuleType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileRefineRuleType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "remark",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "idref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "weight",
                                        Type:          "float32",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinValue:      "0.0",
                                        Documentation: "",
                                },
                                {
                                        Name:          "selector",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "severity",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "info", "low", "medium", "high"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "role",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"full", "unscored", "unchecked"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProfileRefineValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileRefineValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "remark",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "idref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "selector",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"equals", "not equal", "greater than", "less than", "greater than or equal", "less than or equal", "pattern match"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProfileSelectType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileSelectType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "remark",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "idref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "selected",
                                        Type:          "bool",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProfileSetComplexValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileSetComplexValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "idref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProfileSetValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileSetValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "idref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProfileType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProfileType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "dc-status",
                                        Type:          "DcStatusType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "VersionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "title",
                                        Type:          "TextWithSubType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "description",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "reference",
                                        Type:          "ReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "platform",
                                        Type:          "OverrideableCPE2idrefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "select",
                                        Type:          "ProfileSelectType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set-complex-value",
                                        Type:          "ProfileSetComplexValueType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set-value",
                                        Type:          "ProfileSetValueType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "refine-value",
                                        Type:          "ProfileRefineValueType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "refine-rule",
                                        Type:          "ProfileRefineRuleType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_profile_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "prohibitChanges",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "abstract",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "note-tag",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "extends",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ProtocolElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ProtocolElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RSAKeyValueElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RSAKeyValueElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Modulus",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Exponent",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RSAKeyValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RSAKeyValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Modulus",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Exponent",
                                        Type:          "CryptoBinary",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RatingEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RatingEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ReferenceElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ReferenceElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "TransformsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "DigestMethodType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "DigestValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "URI",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ReferenceElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ReferenceElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "href",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ReferenceType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ReferenceType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "href",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "override",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ReferencesType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ReferencesType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "reference",
                                        Type:          "Reference",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RegexCaptureFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RegexCaptureFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "pattern",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RelationshipType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RelationshipType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "type",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "scope",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "subject",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RelationshipsContainerType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RelationshipsContainerType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "relationships",
                                        Type:          "Relationships",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RelationshipsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RelationshipsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "relationship",
                                        Type:          "RelationshipType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RemoteResourceElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RemoteResourceElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RemoteResourceElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RemoteResourceElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ReportRequestType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ReportRequestType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "content",
                                        Type:          "Content",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ReportRequestsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ReportRequestsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "report-request",
                                        Type:          "ReportRequestType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ReportType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ReportType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "content",
                                        Type:          "Content",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ReportsElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ReportsElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "report",
                                        Type:          "ReportType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ResourceElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ResourceElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ResourceType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ResourceType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "RestrictionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RestrictionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "operation",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"equals", "not equal", "case insensitive equals", "case insensitive not equal", "greater than", "less than", "greater than or equal", "less than or equal", "bitwise and", "bitwise or", "pattern match", "subset of", "superset of"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ResultEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ResultEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "RetrievalMethodElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RetrievalMethodElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "TransformsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "URI",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RetrievalMethodType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RetrievalMethodType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "TransformsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "URI",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RoleEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RoleEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "RoleType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RoleType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "RuleElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RuleElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ident",
                                        Type:          "IdentType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "impact-metric",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "profile-note",
                                        Type:          "ProfileNoteType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "fixtext",
                                        Type:          "FixTextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "fix",
                                        Type:          "FixType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check",
                                        Type:          "CheckType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-check",
                                        Type:          "ComplexCheckType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_rule_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "role",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"full", "unscored", "unchecked"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "severity",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "info", "low", "medium", "high"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "multiple",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RuleIdType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RuleIdType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "RuleResultType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RuleResultType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "result",
                                        Type:          "ResultEnumType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"pass", "fail", "error", "unknown", "notapplicable", "notchecked", "notselected", "informational", "fixed"},
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "override",
                                        Type:          "OverrideType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ident",
                                        Type:          "IdentType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "message",
                                        Type:          "MessageType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "instance",
                                        Type:          "InstanceResultType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "fix",
                                        Type:          "FixType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check",
                                        Type:          "CheckType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-check",
                                        Type:          "ComplexCheckType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "idref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "role",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"full", "unscored", "unchecked"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "severity",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "info", "low", "medium", "high"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "time",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "weight",
                                        Type:          "float32",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinValue:      "0.0",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "RuleType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "RuleType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "ident",
                                        Type:          "IdentType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "impact-metric",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "profile-note",
                                        Type:          "ProfileNoteType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "fixtext",
                                        Type:          "FixTextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "fix",
                                        Type:          "FixType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check",
                                        Type:          "CheckType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-check",
                                        Type:          "ComplexCheckType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_rule_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "role",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"full", "unscored", "unchecked"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "severity",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"unknown", "info", "low", "medium", "high"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "multiple",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SPKIDataElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SPKIDataElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "SPKISexp",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SPKIDataType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SPKIDataType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "SPKISexp",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SchemaVersionPattern":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SchemaVersionPattern",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SchemaVersionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SchemaVersionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "platform",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ScoreType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ScoreType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "system",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "maximum",
                                        Type:          "float32",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SelChoicesType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SelChoicesType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "choice",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-choice",
                                        Type:          "ComplexValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "mustMatch",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "selector",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SelComplexValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SelComplexValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "selector",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SelNumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SelNumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "selector",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SelStringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SelStringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "selector",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SelectableItemType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SelectableItemType",
                        Documentation: "",
                        IsAbstract:    true,
                        Fields: []FieldInfo{
                                {
                                        Name:          "rationale",
                                        Type:          "HtmlTextWithSubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "platform",
                                        Type:          "OverrideableCPE2idrefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "requires",
                                        Type:          "IdrefListType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "conflicts",
                                        Type:          "IdrefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "selected",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "weight",
                                        Type:          "float32",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinValue:      "0.0",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ServedByElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ServedByElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "host",
                                        Type:          "Host",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "port",
                                        Type:          "Port",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "port-range",
                                        Type:          "PortRange",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "protocol",
                                        Type:          "Protocol",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ServiceElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ServiceElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "host",
                                        Type:          "Host",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "port",
                                        Type:          "Port",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "port-range",
                                        Type:          "PortRange",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "protocol",
                                        Type:          "Protocol",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ServiceType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ServiceType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "host",
                                        Type:          "Host",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "port",
                                        Type:          "Port",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "port-range",
                                        Type:          "PortRange",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "protocol",
                                        Type:          "Protocol",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SetElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SetElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     2,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "object_reference",
                                        Type:          "ObjectIDPattern",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*",
                                        MinOccurs:     1,
                                        MaxOccurs:     2,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set_operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"COMPLEMENT", "INTERSECTION", "UNION"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SetElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SetElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     2,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "object_reference",
                                        Type:          "ObjectIDPattern",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:obj:[1-9][0-9]*",
                                        MinOccurs:     1,
                                        MaxOccurs:     2,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set_operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"COMPLEMENT", "INTERSECTION", "UNION"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SetOperatorEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SetOperatorEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SeverityEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SeverityEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ShowType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ShowType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SignatureElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignatureElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignedInfoType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "SignatureValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "KeyInfoType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "ObjectType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignatureMethodElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignatureMethodElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "HMACOutputLength",
                                        Type:          "HMACOutputLengthType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Algorithm",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignatureMethodType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignatureMethodType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "HMACOutputLength",
                                        Type:          "HMACOutputLengthType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Algorithm",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignaturePropertiesElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignaturePropertiesElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignaturePropertyType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignaturePropertiesType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignaturePropertiesType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignaturePropertyType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignaturePropertyElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignaturePropertyElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Target",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignaturePropertyType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignaturePropertyType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Target",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignatureType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignatureType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SignatureValueElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignatureValueElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignatureValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignatureValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignedInfoElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignedInfoElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "CanonicalizationMethodType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "SignatureMethodType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "ReferenceType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SignedInfoType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SignedInfoType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "CanonicalizationMethodType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "SignatureMethodType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "ReferenceType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "Simple":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "Simple",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SimpleDatatypeEnumeration":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SimpleDatatypeEnumeration",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SoftwareElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SoftwareElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "installation-id",
                                        Type:          "InstallationId",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "license",
                                        Type:          "License",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SoftwareType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SoftwareType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "installation-id",
                                        Type:          "InstallationId",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "license",
                                        Type:          "License",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SortingCodeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SortingCodeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SplitFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SplitFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "delimiter",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "StateElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "StateElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:ste:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"AND", "OR"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "StateIDPattern":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "StateIDPattern",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "StateRefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "StateRefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "state_ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:ste:[1-9][0-9]*",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "StateType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "StateType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:ste:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"AND", "OR"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "StatesType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "StatesType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "StateType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "StatusElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "StatusElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "date",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "StatusElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "StatusElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "date",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "StatusType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "StatusType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SubAdministrativeAreaElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubAdministrativeAreaElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubAdministrativeAreaName",
                                        Type:          "SubAdministrativeAreaName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "UsageType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SubAdministrativeAreaNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubAdministrativeAreaNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SubPremiseLocationElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubPremiseLocationElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SubPremiseNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubPremiseNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "TypeOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SubPremiseNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubPremiseNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "IndicatorOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NumberTypeOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "PremiseNumberSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SubPremiseNumberPrefixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubPremiseNumberPrefixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberPrefixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SubPremiseNumberSuffixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubPremiseNumberSuffixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberSuffixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SubPremiseType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubPremiseType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubPremiseName",
                                        Type:          "SubPremiseName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubPremiseNumberPrefix",
                                        Type:          "SubPremiseNumberPrefix",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubPremiseNumberSuffix",
                                        Type:          "SubPremiseNumberSuffix",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "BuildingName",
                                        Type:          "BuildingNameType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Firm",
                                        Type:          "FirmType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "MailStop",
                                        Type:          "MailStopType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubPremise",
                                        Type:          "SubPremiseType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubPremiseLocation",
                                        Type:          "SubPremiseLocation",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "SubPremiseNumber",
                                        Type:          "SubPremiseNumber",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SubType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "use",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"value", "title", "legacy"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SubUseEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubUseEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "SubstringFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SubstringFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "substring_start",
                                        Type:          "int",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "substring_length",
                                        Type:          "int",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SuffixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SuffixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SupplementaryPostalServiceDataElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SupplementaryPostalServiceDataElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SyntheticIdElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SyntheticIdElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "resource",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SyntheticIdElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SyntheticIdElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "resource",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SystemElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SystemElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "system-name",
                                        Type:          "SystemName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "Version",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SystemNameElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SystemNameElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "SystemType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "SystemType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "system-name",
                                        Type:          "SystemName",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "Version",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TailoringBenchmarkReferenceType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TailoringBenchmarkReferenceType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "version",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TailoringElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TailoringElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "benchmark",
                                        Type:          "TailoringBenchmarkReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "dc-status",
                                        Type:          "DcStatusType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "TailoringVersionType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "ProfileType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_tailoring_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TailoringIdType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TailoringIdType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "TailoringReferenceType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TailoringReferenceType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "href",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "time",
                                        Type:          "time.Time",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TailoringType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TailoringType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "benchmark",
                                        Type:          "TailoringBenchmarkReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "dc-status",
                                        Type:          "DcStatusType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "TailoringVersionType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "ProfileType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_tailoring_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TailoringVersionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TailoringVersionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "time",
                                        Type:          "time.Time",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TargetFactsType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TargetFactsType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "fact",
                                        Type:          "FactType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TargetIdRefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TargetIdRefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "system",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "href",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "name",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TelephoneNumberElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TelephoneNumberElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TelephoneNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TelephoneNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TelephoneNumberType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TelephoneNumberType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "TestElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TestElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:tst:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check_existence",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all_exist", "any_exist", "at_least_one_exists", "none_exist", "only_one_exists"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "check",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all", "at least one", "none exist", "none satisfy", "only one"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "state_operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"AND", "OR"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TestIDPattern":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TestIDPattern",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "TestResultElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TestResultElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "benchmark",
                                        Type:          "BenchmarkReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "tailoring-file",
                                        Type:          "TailoringReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "title",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "remark",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "organization",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "identity",
                                        Type:          "IdentityType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "profile",
                                        Type:          "IdrefType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "target",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "target-address",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "target-facts",
                                        Type:          "TargetFactsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "platform",
                                        Type:          "CPE2idrefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "rule-result",
                                        Type:          "RuleResultType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "score",
                                        Type:          "ScoreType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "target-id-ref",
                                        Type:          "TargetIdRefType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set-value",
                                        Type:          "ProfileSetValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set-complex-value",
                                        Type:          "ProfileSetComplexValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_testresult_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "start-time",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "end-time",
                                        Type:          "time.Time",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "test-system",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TestResultType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TestResultType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "benchmark",
                                        Type:          "BenchmarkReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "tailoring-file",
                                        Type:          "TailoringReferenceType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "title",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "remark",
                                        Type:          "TextType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "organization",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "identity",
                                        Type:          "IdentityType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "profile",
                                        Type:          "IdrefType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "target",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "target-address",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "target-facts",
                                        Type:          "TargetFactsType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "platform",
                                        Type:          "CPE2idrefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "rule-result",
                                        Type:          "RuleResultType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "score",
                                        Type:          "ScoreType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "metadata",
                                        Type:          "MetadataType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "target-id-ref",
                                        Type:          "TargetIdRefType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set-value",
                                        Type:          "ProfileSetValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "set-complex-value",
                                        Type:          "ProfileSetComplexValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_testresult_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "start-time",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "end-time",
                                        Type:          "time.Time",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "test-system",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Id",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TestType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TestType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:tst:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "check_existence",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all_exist", "any_exist", "at_least_one_exists", "none_exist", "only_one_exists"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "check",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"all", "at least one", "none exist", "none satisfy", "only one"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "state_operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"AND", "OR"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TestresultIdType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TestresultIdType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "TestsType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TestsType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "TestType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TextType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TextType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TextWithSubType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TextWithSubType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "sub",
                                        Type:          "SubType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "override",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfarePreDirection",
                                        Type:          "ThoroughfarePreDirectionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareLeadingType",
                                        Type:          "ThoroughfareLeadingTypeType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareName",
                                        Type:          "ThoroughfareNameType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareTrailingType",
                                        Type:          "ThoroughfareTrailingTypeType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfarePostDirection",
                                        Type:          "ThoroughfarePostDirectionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfare",
                                        Type:          "DependentThoroughfare",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareNumberRange",
                                        Type:          "ThoroughfareNumberRange",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentLocality",
                                        Type:          "DependentLocalityType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Firm",
                                        Type:          "FirmType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfares",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfaresIndicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfaresConnector",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfaresType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfarePreDirection",
                                        Type:          "ThoroughfarePreDirectionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareLeadingType",
                                        Type:          "ThoroughfareLeadingTypeType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareName",
                                        Type:          "ThoroughfareNameType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareTrailingType",
                                        Type:          "ThoroughfareTrailingTypeType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfarePostDirection",
                                        Type:          "ThoroughfarePostDirectionType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfare",
                                        Type:          "DependentThoroughfare",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareNumberRange",
                                        Type:          "ThoroughfareNumberRange",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentLocality",
                                        Type:          "DependentLocalityType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Firm",
                                        Type:          "FirmType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfares",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfaresIndicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfaresConnector",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "DependentThoroughfaresType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareLeadingTypeType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareLeadingTypeType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNameType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNameType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "IndicatorOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NumberOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "IndicatorOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NumberOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberFromElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberFromElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberPrefixElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberPrefixElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberPrefixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberPrefixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberPrefixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberPrefixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberRangeElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberRangeElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareNumberFrom",
                                        Type:          "ThoroughfareNumberFrom",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "ThoroughfareNumberTo",
                                        Type:          "ThoroughfareNumberTo",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "RangeType",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Indicator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Separator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "IndicatorOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "NumberRangeOccurrence",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberSuffixElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberSuffixElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberSuffixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberSuffixElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberSuffixElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "NumberSuffixSeparator",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareNumberToElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareNumberToElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfarePostDirectionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfarePostDirectionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfarePreDirectionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfarePreDirectionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ThoroughfareTrailingTypeType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ThoroughfareTrailingTypeType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TimeDifferenceFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TimeDifferenceFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "format_1",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"year_month_day", "month_day_year", "day_month_year", "win_filetime", "seconds_since_epoch", "cim_datetime"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "format_2",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"year_month_day", "month_day_year", "day_month_year", "win_filetime", "seconds_since_epoch", "cim_datetime"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TitleAttrType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TitleAttrType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "TitleElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TitleElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "TitleElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TitleElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "Type",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Code",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TitleEltType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TitleEltType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ToType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ToType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "TransformElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TransformElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "XPath",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Algorithm",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TransformType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TransformType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "XPath",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "Algorithm",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TransformsElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TransformsElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "TransformType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TransformsType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TransformsType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "TransformType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "TypeType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "TypeType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "UniqueFunctionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "UniqueFunctionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "UriRefType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "UriRefType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "uri",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "UrlElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "UrlElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ValueElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ValueElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "match",
                                        Type:          "SelStringType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "lower-bound",
                                        Type:          "SelNumType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "upper-bound",
                                        Type:          "SelNumType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "choices",
                                        Type:          "SelChoicesType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "source",
                                        Type:          "UriRefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "value",
                                        Type:          "SelStringType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-value",
                                        Type:          "SelComplexValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "default",
                                        Type:          "SelStringType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-default",
                                        Type:          "SelComplexValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_value_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"number", "string", "boolean"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"equals", "not equal", "greater than", "less than", "greater than or equal", "less than or equal", "pattern match"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "interactive",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "interfaceHint",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"choice", "textline", "text", "date", "datetime"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ValueIdType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ValueIdType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ValueOperatorType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ValueOperatorType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "ValueType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ValueType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "match",
                                        Type:          "SelStringType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "lower-bound",
                                        Type:          "SelNumType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "upper-bound",
                                        Type:          "SelNumType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "choices",
                                        Type:          "SelChoicesType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "source",
                                        Type:          "UriRefType",
                                        IsRequired:    false,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "signature",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "value",
                                        Type:          "SelStringType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-value",
                                        Type:          "SelComplexValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "default",
                                        Type:          "SelStringType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "complex-default",
                                        Type:          "SelComplexValueType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "xccdf_[^_]+_value_.+",
                                        Documentation: "",
                                },
                                {
                                        Name:          "type",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"number", "string", "boolean"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "operator",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"equals", "not equal", "greater than", "less than", "greater than or equal", "less than or equal", "pattern match"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "interactive",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "interfaceHint",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"choice", "textline", "text", "date", "datetime"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "ValueTypeType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "ValueTypeType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "VariableComponentType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "VariableComponentType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "var_ref",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "VariableElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "VariableElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "VariableIDPattern":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "VariableIDPattern",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "VariableType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "VariableType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "SignatureType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "NotesType",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "id",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Pattern:       "oval:[A-Za-z0-9_\\-\\.]+:var:[1-9][0-9]*",
                                        Documentation: "",
                                },
                                {
                                        Name:          "version",
                                        Type:          "uint64",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "datatype",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"binary", "boolean", "evr_string", "debian_evr_string", "fileset_revision", "float", "ios_version", "int", "ipv4_address", "ipv6_address", "string", "version"},
                                        Documentation: "",
                                },
                                {
                                        Name:          "comment",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinLength:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "deprecated",
                                        Type:          "bool",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "VariablesType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "VariablesType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "VariableType",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "VersionElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "VersionElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "VersionType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "VersionType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "time",
                                        Type:          "time.Time",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "update",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "WarningCategoryEnumType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "WarningCategoryEnumType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "WarningType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "WarningType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "category",
                                        Type:          "string",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        true,
                                        EnumValues:    []string{"general", "functionality", "performance", "hardware", "legal", "regulatory", "management", "audit", "dependency"},
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "WebsiteElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "WebsiteElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "document-root",
                                        Type:          "DocumentRoot",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "locale",
                                        Type:          "Locale",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "WebsiteType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "WebsiteType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "document-root",
                                        Type:          "DocumentRoot",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "locale",
                                        Type:          "Locale",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "WebsiteUrlElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "WebsiteUrlElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "WebsiteUrlElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "WebsiteUrlElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "WeightType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "WeightType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields:        []FieldInfo{},
                }, nil</span>
        case "X509DataElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "X509DataElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "X509IssuerSerial",
                                        Type:          "X509IssuerSerialType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509SKI",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509SubjectName",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509Certificate",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509CRL",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "X509DataType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "X509DataType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "X509IssuerSerial",
                                        Type:          "X509IssuerSerialType",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509SKI",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509SubjectName",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509Certificate",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509CRL",
                                        Type:          "[]byte",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        IsChoice:      true,
                                        ChoiceGroup:   "choice_1",
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "X509IssuerSerialType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "X509IssuerSerialType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "X509IssuerName",
                                        Type:          "string",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "X509SerialNumber",
                                        Type:          "int",
                                        IsRequired:    true,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     1,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "XALElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "XALElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Version",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "XALElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "XALElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Version",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "XNLElement":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "XNLElement",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Version",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        case "XNLElementType":<span class="cov0" title="0">
                return &amp;TypeMetadata{
                        Name:          "XNLElementType",
                        Documentation: "",
                        IsAbstract:    false,
                        Fields: []FieldInfo{
                                {
                                        Name:          "",
                                        Type:          "",
                                        IsRequired:    true,
                                        IsRepeated:    true,
                                        IsEnum:        false,
                                        MinOccurs:     1,
                                        MaxOccurs:     -1,
                                        Documentation: "",
                                },
                                {
                                        Name:          "Version",
                                        Type:          "",
                                        IsRequired:    false,
                                        IsRepeated:    false,
                                        IsEnum:        false,
                                        Documentation: "",
                                },
                        },
                }, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unknown type: %s", name)</span>
        }
}

// GetConcreteTypes returns concrete types for an abstract type.
func (s *XMLDocumentState) GetConcreteTypes(abstractType string) ([]string, error) <span class="cov8" title="1">{
        switch abstractType </span>{
        case "AssetType":<span class="cov8" title="1">
                return []string{
                        "DataType",
                        "PersonType",
                        "OrganizationType",
                }, nil</span>
        case "EntityComplexBaseType":<span class="cov8" title="1">
                return []string{
                        "EntityObjectRecordType",
                }, nil</span>
        case "EntitySimpleBaseType":<span class="cov8" title="1">
                return []string{
                        "EntityObjectStringType",
                        "EntityObjectAnySimpleType",
                        "EntityObjectIPAddressStringType",
                        "EntityObjectBinaryType",
                        "EntityObjectIPAddressType",
                        "EntityObjectFloatType",
                        "EntityObjectIntType",
                        "EntityObjectBoolType",
                        "EntityObjectVersionType",
                }, nil</span>
        case "EntityStateComplexBaseType":<span class="cov8" title="1">
                return []string{
                        "EntityStateRecordType",
                }, nil</span>
        case "EntityStateSimpleBaseType":<span class="cov8" title="1">
                return []string{
                        "EntityStateEVRStringType",
                        "EntityStateIntType",
                        "EntityStateFileSetRevisionType",
                        "EntityStateFloatType",
                        "EntityStateDebianEVRStringType",
                        "EntityStateIPAddressStringType",
                        "EntityStateAnySimpleType",
                        "EntityStateIPAddressType",
                        "EntityStateVersionType",
                        "EntityStateBinaryType",
                        "EntityStateBoolType",
                        "EntityStateIOSVersionType",
                        "EntityStateStringType",
                }, nil</span>
        case "ItAssetType":<span class="cov8" title="1">
                return []string{
                        "NetworkType",
                        "SoftwareType",
                        "WebsiteType",
                        "DatabaseType",
                        "SystemType",
                        "ServiceType",
                        "ComputingDeviceType",
                        "CircuitType",
                }, nil</span>
        case "ItemType":<span class="cov8" title="1">
                return []string{
                        "ValueType",
                }, nil</span>
        case "SelectableItemType":<span class="cov8" title="1">
                return []string{
                        "GroupType",
                        "RuleType",
                }, nil</span>
        default:<span class="cov8" title="1">
                // Not an abstract type or no concrete implementations known
                return []string{}, nil</span>
        }
}

// IsDirty returns whether the document has unsaved changes.
func (s *XMLDocumentState) IsDirty() bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.isDirty
}</span>

// MarkClean marks the document as saved.
func (s *XMLDocumentState) MarkClean() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.isDirty = false
}</span>

// GetSourceFile returns the source filename.
func (s *XMLDocumentState) GetSourceFile() string <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.sourceFile
}</span>

// GetLastModified returns the last modification time.
func (s *XMLDocumentState) GetLastModified() time.Time <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.lastModified
}</span>

// HasDocument returns whether a document is loaded.
func (s *XMLDocumentState) HasDocument() bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.rootElement != nil
}</span>

// Clear clears the current document.
func (s *XMLDocumentState) Clear() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.rootElement = nil
        s.rootType = ""
        s.namespace = ""
        s.sourceFile = ""
        s.isDirty = false
}</span>

// GenerateInstanceDiagram generates a Mermaid diagram from the current XML document instance.
// diagramType can be "flowchart" (default), "mindmap", or "tree".
func (s *XMLDocumentState) GenerateInstanceDiagram(diagramType string) (string, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if s.rootElement == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no document loaded")
        }</span>

        <span class="cov8" title="1">var sb bytes.Buffer

        switch diagramType </span>{
        case "mindmap":<span class="cov8" title="1">
                sb.WriteString("mindmap\n")
                sb.WriteString("  root((Document))\n")
                s.generateMindmapNode(&amp;sb, s.rootElement, s.rootType, 2)</span>
        case "tree":<span class="cov8" title="1">
                sb.WriteString("graph TD\n")
                s.generateTreeDiagram(&amp;sb, s.rootElement, s.rootType, "root", 0)</span>
        default:<span class="cov8" title="1"> // flowchart
                sb.WriteString("flowchart TD\n")
                s.generateFlowchartNode(&amp;sb, s.rootElement, s.rootType, "root", 0)</span>
        }

        <span class="cov8" title="1">return sb.String(), nil</span>
}

// generateFlowchartNode recursively generates flowchart nodes for an element.
func (s *XMLDocumentState) generateFlowchartNode(sb *bytes.Buffer, element interface{}, typeName string, nodeID string, depth int) <span class="cov8" title="1">{
        if element == nil || depth &gt; 10 </span><span class="cov0" title="0">{
                return
        }</span>

        // Write the node
        <span class="cov8" title="1">label := s.getElementLabel(element, typeName)
        sb.WriteString(fmt.Sprintf("    %s[\"%s\"]\n", nodeID, escapeLabel(label)))

        // Get child nodes and connect them
        children := s.getChildElements(element)
        for i, child := range children </span><span class="cov8" title="1">{
                childID := fmt.Sprintf("%s_%d", nodeID, i)
                childType := s.getElementType(child.Value)
                childLabel := child.Name
                if childType != "" </span><span class="cov8" title="1">{
                        childLabel = childType
                }</span>

                // Write connection
                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("    %s --&gt; %s\n", nodeID, childID))

                // Recurse for child
                s.generateFlowchartNode(sb, child.Value, childLabel, childID, depth+1)</span>
        }
}

// generateTreeDiagram generates a tree-style diagram.
func (s *XMLDocumentState) generateTreeDiagram(sb *bytes.Buffer, element interface{}, typeName string, nodeID string, depth int) <span class="cov8" title="1">{
        if element == nil || depth &gt; 10 </span><span class="cov0" title="0">{
                return
        }</span>

        // Write the node with shape based on depth
        <span class="cov8" title="1">label := s.getElementLabel(element, typeName)
        if depth == 0 </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("    %s((\"%s\"))\n", nodeID, escapeLabel(label)))
        }</span> else<span class="cov8" title="1"> {
                sb.WriteString(fmt.Sprintf("    %s[\"%s\"]\n", nodeID, escapeLabel(label)))
        }</span>

        // Get child nodes and connect them
        <span class="cov8" title="1">children := s.getChildElements(element)
        for i, child := range children </span><span class="cov8" title="1">{
                childID := fmt.Sprintf("%s_%d", nodeID, i)
                childType := s.getElementType(child.Value)
                childLabel := child.Name
                if childType != "" </span><span class="cov8" title="1">{
                        childLabel = childType
                }</span>

                // Write connection
                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("    %s --&gt; %s\n", nodeID, childID))

                // Recurse for child
                s.generateTreeDiagram(sb, child.Value, childLabel, childID, depth+1)</span>
        }
}

// generateMindmapNode generates mindmap nodes with proper indentation.
func (s *XMLDocumentState) generateMindmapNode(sb *bytes.Buffer, element interface{}, typeName string, indent int) <span class="cov8" title="1">{
        if element == nil || indent &gt; 20 </span><span class="cov0" title="0">{
                return
        }</span>

        // Write the node with indentation
        <span class="cov8" title="1">label := s.getElementLabel(element, typeName)
        indentStr := ""
        for i := 0; i &lt; indent; i++ </span><span class="cov8" title="1">{
                indentStr += "  "
        }</span>
        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s%s\n", indentStr, escapeLabel(label)))

        // Get child nodes
        children := s.getChildElements(element)
        for _, child := range children </span><span class="cov8" title="1">{
                childType := s.getElementType(child.Value)
                childLabel := child.Name
                if childType != "" </span><span class="cov8" title="1">{
                        childLabel = childType
                }</span>
                <span class="cov8" title="1">s.generateMindmapNode(sb, child.Value, childLabel, indent+1)</span>
        }
}

// childElement represents a child element with its name and value.
type childElement struct {
        Name  string
        Value interface{}
}

// getChildElements extracts child elements from a struct using reflection.
func (s *XMLDocumentState) getChildElements(element interface{}) []childElement <span class="cov8" title="1">{
        var children []childElement
        if element == nil </span><span class="cov0" title="0">{
                return children
        }</span>

        // Use reflection to get struct fields
        <span class="cov8" title="1">val := reflect.ValueOf(element)
        if val.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if val.IsNil() </span><span class="cov0" title="0">{
                        return children
                }</span>
                <span class="cov8" title="1">val = val.Elem()</span>
        }
        <span class="cov8" title="1">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return children
        }</span>

        <span class="cov8" title="1">typ := val.Type()
        for i := 0; i &lt; val.NumField(); i++ </span><span class="cov8" title="1">{
                field := val.Field(i)
                fieldType := typ.Field(i)

                // Skip unexported fields
                if !fieldType.IsExported() </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Skip XMLName and simple attributes
                <span class="cov8" title="1">if fieldType.Name == "XMLName" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check XML tag to skip attributes
                <span class="cov8" title="1">xmlTag := fieldType.Tag.Get("xml")
                if xmlTag != "" &amp;&amp; (xmlTag[0] == ',' || xmlTag == "-") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Handle slices
                <span class="cov8" title="1">if field.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                        for j := 0; j &lt; field.Len(); j++ </span><span class="cov0" title="0">{
                                item := field.Index(j)
                                if item.Kind() == reflect.Ptr || item.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                        children = append(children, childElement{
                                                Name:  fieldType.Name,
                                                Value: item.Interface(),
                                        })
                                }</span>
                        }
                } else<span class="cov8" title="1"> if field.Kind() == reflect.Ptr &amp;&amp; !field.IsNil() </span><span class="cov0" title="0">{
                        // Handle pointer to struct
                        children = append(children, childElement{
                                Name:  fieldType.Name,
                                Value: field.Interface(),
                        })
                }</span> else<span class="cov8" title="1"> if field.Kind() == reflect.Struct &amp;&amp; fieldType.Name != "XMLName" </span><span class="cov8" title="1">{
                        // Handle embedded struct (but not XMLName)
                        children = append(children, childElement{
                                Name:  fieldType.Name,
                                Value: field.Addr().Interface(),
                        })
                }</span>
        }

        <span class="cov8" title="1">return children</span>
}

// getElementLabel returns a display label for an element.
func (s *XMLDocumentState) getElementLabel(element interface{}, typeName string) string <span class="cov8" title="1">{
        if element == nil </span><span class="cov0" title="0">{
                return typeName
        }</span>

        // Try to get an ID or Name field for a better label
        <span class="cov8" title="1">val := reflect.ValueOf(element)
        if val.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if val.IsNil() </span><span class="cov0" title="0">{
                        return typeName
                }</span>
                <span class="cov8" title="1">val = val.Elem()</span>
        }
        <span class="cov8" title="1">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return typeName
        }</span>

        // Look for common identifier fields
        <span class="cov8" title="1">for _, fieldName := range []string{"Id", "ID", "Name", "Title", "IdRef", "IDRef"} </span><span class="cov8" title="1">{
                field := val.FieldByName(fieldName)
                if field.IsValid() &amp;&amp; field.Kind() == reflect.String &amp;&amp; field.String() != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%s: %s", typeName, truncateString(field.String(), 30))
                }</span>
                // Handle pointer to string
                <span class="cov8" title="1">if field.IsValid() &amp;&amp; field.Kind() == reflect.Ptr &amp;&amp; !field.IsNil() </span><span class="cov0" title="0">{
                        if str, ok := field.Elem().Interface().(string); ok &amp;&amp; str != "" </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%s: %s", typeName, truncateString(str, 30))
                        }</span>
                }
        }

        <span class="cov8" title="1">return typeName</span>
}

// getElementType returns the type name for an element.
func (s *XMLDocumentState) getElementType(element interface{}) string <span class="cov8" title="1">{
        if element == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">typ := reflect.TypeOf(element)
        if typ.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                typ = typ.Elem()
        }</span>
        <span class="cov8" title="1">return typ.Name()</span>
}

// escapeLabel escapes special characters for Mermaid labels.
func escapeLabel(s string) string <span class="cov8" title="1">{
        s = bytes.NewBufferString(s).String()
        // Escape quotes and other special characters
        s = regexp.MustCompile(`"`).ReplaceAllString(s, "'")
        s = regexp.MustCompile(`[\[\]{}()&lt;&gt;]`).ReplaceAllString(s, "")
        return s
}</span>

// truncateString truncates a string to maxLen characters.
func truncateString(s string, maxLen int) string <span class="cov8" title="1">{
        if len(s) &lt;= maxLen </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return s[:maxLen-3] + "..."</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by forgexml UI generator. DO NOT EDIT.
// Source: /home/mmcnew/repos/forgexml-scap/schemas/xccdf/xccdf_1.2.xsd
// Schema: Xccdf 1.2

package main

import (
        "embed"
        "flag"
        "fmt"
        "log"
        "os"

        _ "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/checklists/xccdf/1-2"
        "github.com/aequo-labs/webserver-core-ui/pkg/webserver"

        "github.com/aequo-labs/forgexml-scap/cmd/ui/internal/handlers"
        "github.com/aequo-labs/forgexml-scap/cmd/ui/internal/state"
)

//go:embed static
var staticFiles embed.FS

//go:embed templates
var templateFiles embed.FS

//go:embed schemas
var schemaFiles embed.FS

//go:embed docs
var docsFiles embed.FS

var (
        version   = "dev"
        buildTime = "unknown"
        gitCommit = "unknown"
)

func main() <span class="cov0" title="0">{
        // Command line flags
        port := flag.Int("port", 8080, "Port to listen on")
        inputFile := flag.String("input", "", "XML file to load on startup")
        showVersion := flag.Bool("version", false, "Show version information")
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("Xccdf 1.2 UI Editor\n")
                fmt.Printf("Version: %s\n", version)
                fmt.Printf("Build Time: %s\n", buildTime)
                fmt.Printf("Git Commit: %s\n", gitCommit)
                os.Exit(0)
        }</span>

        // Create UI server
        <span class="cov0" title="0">srv, err := webserver.NewUIServer(nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create UI server: %v", err)
        }</span>

        // Add application templates from subdirectories
        <span class="cov0" title="0">templateDirs := []string{"templates/pages", "templates/forms", "templates/includes"}
        for _, dir := range templateDirs </span><span class="cov0" title="0">{
                if err := srv.AddTemplatesFromFS(templateFiles, dir); err != nil </span><span class="cov0" title="0">{
                        // Directory might not exist, that's okay
                        log.Printf("Note: Could not load templates from %s: %v", dir, err)
                }</span>
        }

        // Add application static assets
        <span class="cov0" title="0">srv.AddAssetsFromFS(staticFiles, "static", "/app-static/")

        // Initialize XML document state
        docState := state.NewXMLDocumentState()

        // Load input file if provided
        if *inputFile != "" </span><span class="cov0" title="0">{
                if err := docState.LoadFromFile(*inputFile); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to load input file %s: %v", *inputFile, err)
                }</span>
                <span class="cov0" title="0">log.Printf("Loaded XML document from %s", *inputFile)</span>
        }

        // Create handlers with state
        <span class="cov0" title="0">h := handlers.NewHandlers(srv, docState, schemaFiles)

        // Register routes
        router := srv.Router()

        // Page routes
        router.HandleFunc("GET /", h.HandleHome)
        router.HandleFunc("GET /tree", h.HandleTreeView)
        router.HandleFunc("GET /edit", h.HandleEditElement)
        router.HandleFunc("GET /create", h.HandleCreateElement)
        router.HandleFunc("GET /export", h.HandleExportPage)

        // Tree API endpoints
        router.HandleFunc("GET /api/tree/root", h.HandleTreeRoot)
        router.HandleFunc("GET /api/tree/children", h.HandleTreeChildren)
        router.HandleFunc("GET /api/tree/element", h.HandleTreeElement)

        // CRUD API endpoints
        router.HandleFunc("GET /api/elements/{type}", h.HandleListElements)
        router.HandleFunc("GET /api/element", h.HandleGetElement)
        router.HandleFunc("POST /api/element", h.HandleCreateElementAPI)
        router.HandleFunc("PUT /api/element", h.HandleUpdateElement)
        router.HandleFunc("DELETE /api/element", h.HandleDeleteElement)

        // Import/Export API endpoints
        router.HandleFunc("POST /api/import", h.HandleImport)
        router.HandleFunc("GET /api/export", h.HandleExport)
        router.HandleFunc("GET /api/export/preview", h.HandleExportPreview)
        router.HandleFunc("POST /api/validate", h.HandleValidate)

        // Health check endpoint for status indicator
        router.HandleFunc("GET /api/health", h.HandleHealth)

        // Diagram generation endpoint
        router.HandleFunc("GET /api/diagram/instance", h.HandleInstanceDiagram)

        // Type information API endpoints
        router.HandleFunc("GET /api/types", h.HandleListTypes)
        router.HandleFunc("GET /api/types/root", h.HandleGetRootTypes)
        router.HandleFunc("GET /api/types/{name}", h.HandleGetType)
        router.HandleFunc("GET /api/types/{name}/concrete", h.HandleGetConcreteTypes)
        router.HandleFunc("GET /api/types/{name}/children", h.HandleGetValidChildTypes)

        // Set about information
        srv.SetAboutInfo(webserver.AboutInfo{
                AppName:     "SCAP Editor",
                Version:     version,
                Description: "XML Editor for Xccdf 1.2 documents",
                Features: []string{
                        "Visual tree navigation of XML structure",
                        "CRUD operations on all element types",
                        "XSD validation",
                        "Import/Export XML files",
                        "Abstract type handling with dropdowns",
                        "Enum support with select inputs",
                },
                Links: []webserver.NavItem{
                        {Title: "ForgeXML", URL: "https://github.com/aequo-labs/forgexml"},
                },
                ExtraInfo: map[string]string{
                        "Schema":    "Xccdf 1.2",
                        "Namespace": "http://checklists.nist.gov/xccdf/1.2",
                        "Source":    "/home/mmcnew/repos/forgexml-scap/schemas/xccdf/xccdf_1.2.xsd",
                },
        })

        // Register documentation filesystem (XSD schema docs)
        srv.RegisterDocsFS(docsFiles, "docs")

        // Set navigation items
        srv.SetPageDataEnricher(func(data *webserver.PageData) </span><span class="cov0" title="0">{
                data.NavItems = []webserver.NavItem{
                        {Title: "Home", URL: "/"},
                        {Title: "Tree View", URL: "/tree"},
                        {Title: "Export", URL: "/export"},
                        {Title: "Diagrams", URL: "/docs/diagrams.md"},
                }
                data.AppName = "SCAP Editor"
                data.Version = version
                data.ShowAbout = true
        }</span>)

        // Start server
        <span class="cov0" title="0">addr := fmt.Sprintf(":%d", *port)
        log.Printf("Starting SCAP Editor on port %d", *port)
        log.Printf("Open http://localhost:%d in your browser", *port)
        if err := srv.ListenAndServe(addr); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server error: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package main provides a validator CLI for testing SCAP XML parsing
package main

import (
        "encoding/xml"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        xccdf "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/checklists/xccdf/1-2"
        oval "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage: validator &lt;xml-file&gt;")
                fmt.Println("Validates OVAL and XCCDF XML files against generated Go structs")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">xmlFile := os.Args[1]

        // Read the XML file
        data, err := os.ReadFile(xmlFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading file %s: %v\n", xmlFile, err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">filename := filepath.Base(xmlFile)

        // Detect type and parse accordingly
        if strings.Contains(strings.ToLower(filename), "oval") </span><span class="cov0" title="0">{
                validateOVAL(data, filename)
        }</span> else<span class="cov0" title="0"> if strings.Contains(strings.ToLower(filename), "xccdf") </span><span class="cov0" title="0">{
                validateXCCDF(data, filename)
        }</span> else<span class="cov0" title="0"> {
                // Try both
                fmt.Println("Auto-detecting file type...")
                if tryOVAL(data) </span><span class="cov0" title="0">{
                        validateOVAL(data, filename)
                }</span> else<span class="cov0" title="0"> if tryXCCDF(data) </span><span class="cov0" title="0">{
                        validateXCCDF(data, filename)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Could not determine file type for: %s\n", filename)
                        os.Exit(1)
                }</span>
        }
}

func tryOVAL(data []byte) bool <span class="cov0" title="0">{
        var ovalDef oval.Oval_definitionsElement
        return xml.Unmarshal(data, &amp;ovalDef) == nil &amp;&amp; ovalDef.XMLName.Local != ""
}</span>

func tryXCCDF(data []byte) bool <span class="cov0" title="0">{
        var benchmark xccdf.BenchmarkElement
        return xml.Unmarshal(data, &amp;benchmark) == nil &amp;&amp; benchmark.XMLName.Local != ""
}</span>

func validateOVAL(data []byte, filename string) <span class="cov0" title="0">{
        var ovalDef oval.Oval_definitionsElement
        err := xml.Unmarshal(data, &amp;ovalDef)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error parsing OVAL XML: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully parsed OVAL: %s\n", filename)
        fmt.Println("---")

        // Generator info
        fmt.Println("Generator:")
        if ovalDef.Generator.Product_name != nil </span><span class="cov0" title="0">{
                fmt.Printf("  Product: %s\n", *ovalDef.Generator.Product_name)
        }</span>
        <span class="cov0" title="0">if len(ovalDef.Generator.Schema_version) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Schema Version: %v\n", ovalDef.Generator.Schema_version[0])
        }</span>
        <span class="cov0" title="0">fmt.Printf("  Timestamp: %v\n", ovalDef.Generator.Timestamp)

        // Definitions count
        if ovalDef.Definitions != nil &amp;&amp; len(ovalDef.Definitions.Definition) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nDefinitions: %d\n", len(ovalDef.Definitions.Definition))
                for i, def := range ovalDef.Definitions.Definition </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{
                                fmt.Printf("  ... and %d more\n", len(ovalDef.Definitions.Definition)-3)
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("  - %s\n", def.Metadata.Title)</span>
                }
        }

        <span class="cov0" title="0">if ovalDef.Tests != nil </span><span class="cov0" title="0">{
                fmt.Printf("\nTests: %d\n", len(ovalDef.Tests.Test))
        }</span>
        <span class="cov0" title="0">if ovalDef.Objects != nil </span><span class="cov0" title="0">{
                fmt.Printf("Objects: %d\n", len(ovalDef.Objects.Object))
        }</span>
        <span class="cov0" title="0">if ovalDef.States != nil </span><span class="cov0" title="0">{
                fmt.Printf("States: %d\n", len(ovalDef.States.State))
        }</span>
        <span class="cov0" title="0">if ovalDef.Variables != nil </span><span class="cov0" title="0">{
                fmt.Printf("Variables: present\n")
        }</span>

        <span class="cov0" title="0">fmt.Println("\n OVAL validation successful!")</span>
}

func validateXCCDF(data []byte, filename string) <span class="cov0" title="0">{
        var benchmark xccdf.BenchmarkElement
        err := xml.Unmarshal(data, &amp;benchmark)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error parsing XCCDF XML: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully parsed XCCDF: %s\n", filename)
        fmt.Println("---")

        // Title
        if len(benchmark.Title) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Title: %s\n", benchmark.Title[0].Value)
        }</span>

        // Status
        <span class="cov0" title="0">if len(benchmark.Status) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Status: %s (date: %s)\n", benchmark.Status[0].Value, benchmark.Status[0].Date)
        }</span>

        // Version
        <span class="cov0" title="0">if benchmark.Version.Value != "" </span><span class="cov0" title="0">{
                fmt.Printf("Version: %s\n", benchmark.Version.Value)
        }</span>

        // Profiles
        <span class="cov0" title="0">if len(benchmark.Profile) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nProfiles: %d\n", len(benchmark.Profile))
                for i, profile := range benchmark.Profile </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{
                                fmt.Printf("  ... and %d more\n", len(benchmark.Profile)-3)
                                break</span>
                        }
                        <span class="cov0" title="0">if len(profile.Title) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  - %s\n", profile.Title[0].Value)
                        }</span>
                }
        }

        // Groups
        <span class="cov0" title="0">if len(benchmark.Group) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nGroups: %d\n", len(benchmark.Group))
        }</span>

        // Rules
        <span class="cov0" title="0">if len(benchmark.Rule) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Rules: %d\n", len(benchmark.Rule))
        }</span>

        // Values
        <span class="cov0" title="0">if len(benchmark.Value) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Values: %d\n", len(benchmark.Value))
        }</span>

        <span class="cov0" title="0">fmt.Println("\n XCCDF validation successful!")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "bytes"
        "encoding/xml"
        "fmt"
        "io"
        "reflect"
        "strings"
)

// XMLMetrics holds detailed XML counting with xmlns breakdown
type XMLMetrics struct {
        Elements      int
        Attributes    int
        XmlnsAttrs    int
        NonXmlnsAttrs int
}

// ValidationResult holds the results of struct validation
type ValidationResult struct {
        TotalFields         int
        PopulatedFields     int
        EmptyFields         []string
        UnknownElements     int
        UnknownAttrs        int
        UnknownElementsList []string // Actual unknown element names
        UnknownAttrsList    []string // Actual unknown attribute names
        Warnings            []string
        // XML Fidelity Metrics
        InputElements    int
        OutputElements   int
        InputAttributes  int
        OutputAttributes int
        FidelityPercent  float64
        // Detailed attribute breakdown
        InputXmlns     int
        OutputXmlns    int
        InputNonXmlns  int
        OutputNonXmlns int
}

// ValidateStruct performs reflection-based validation of the unmarshaled struct
func ValidateStruct(data interface{}) (*ValidationResult, error) <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                EmptyFields:         []string{},
                UnknownElementsList: []string{},
                UnknownAttrsList:    []string{},
                Warnings:            []string{},
        }

        val := reflect.ValueOf(data)
        if val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>

        <span class="cov0" title="0">if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected struct, got %v", val.Kind())
        }</span>

        <span class="cov0" title="0">validateStructFields(val, "", result)

        return result, nil</span>
}

// validateStructFields recursively validates struct fields
func validateStructFields(val reflect.Value, prefix string, result *ValidationResult) <span class="cov0" title="0">{
        typ := val.Type()

        for i := 0; i &lt; val.NumField(); i++ </span><span class="cov0" title="0">{
                field := val.Field(i)
                fieldType := typ.Field(i)
                fieldName := fieldType.Name

                // Skip unexported fields
                if !field.CanInterface() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Build full field path
                <span class="cov0" title="0">fullName := fieldName
                if prefix != "" </span><span class="cov0" title="0">{
                        fullName = prefix + "." + fieldName
                }</span>

                // Handle special fields
                <span class="cov0" title="0">if fieldName == "XMLName" </span><span class="cov0" title="0">{
                        continue</span> // Skip XMLName, it's always populated
                }

                <span class="cov0" title="0">if fieldName == "UnknownElements" </span><span class="cov0" title="0">{
                        result.UnknownElements = field.Len()
                        // Collect actual element names
                        for i := 0; i &lt; field.Len(); i++ </span><span class="cov0" title="0">{
                                elem := field.Index(i)
                                if elem.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                        // Look for XMLName field
                                        xmlNameField := elem.FieldByName("XMLName")
                                        if xmlNameField.IsValid() &amp;&amp; xmlNameField.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                                localField := xmlNameField.FieldByName("Local")
                                                if localField.IsValid() &amp;&amp; localField.Kind() == reflect.String </span><span class="cov0" title="0">{
                                                        elemName := localField.String()
                                                        result.UnknownElementsList = append(result.UnknownElementsList, elemName)
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if fieldName == "UnknownAttrs" </span><span class="cov0" title="0">{
                        result.UnknownAttrs = field.Len()
                        // Collect actual attribute names
                        for i := 0; i &lt; field.Len(); i++ </span><span class="cov0" title="0">{
                                attr := field.Index(i)
                                if attr.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                        // xml.Attr has Name.Local field
                                        nameField := attr.FieldByName("Name")
                                        if nameField.IsValid() &amp;&amp; nameField.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                                localField := nameField.FieldByName("Local")
                                                if localField.IsValid() &amp;&amp; localField.Kind() == reflect.String </span><span class="cov0" title="0">{
                                                        attrName := localField.String()
                                                        result.UnknownAttrsList = append(result.UnknownAttrsList, attrName)
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">result.TotalFields++

                // Check if field is populated
                if isFieldEmpty(field, fieldType) </span><span class="cov0" title="0">{
                        result.EmptyFields = append(result.EmptyFields, fullName)
                }</span> else<span class="cov0" title="0"> {
                        result.PopulatedFields++

                        // Recursively validate nested structs
                        if field.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                validateStructFields(field, fullName, result)
                        }</span> else<span class="cov0" title="0"> if field.Kind() == reflect.Ptr &amp;&amp; !field.IsNil() &amp;&amp; field.Elem().Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                validateStructFields(field.Elem(), fullName, result)
                        }</span> else<span class="cov0" title="0"> if field.Kind() == reflect.Slice &amp;&amp; field.Len() &gt; 0 </span><span class="cov0" title="0">{
                                // Validate slice elements
                                for j := 0; j &lt; field.Len(); j++ </span><span class="cov0" title="0">{
                                        elem := field.Index(j)
                                        elemPath := fmt.Sprintf("%s[%d]", fullName, j)

                                        if elem.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                                validateStructFields(elem, elemPath, result)
                                        }</span> else<span class="cov0" title="0"> if elem.Kind() == reflect.Ptr &amp;&amp; !elem.IsNil() &amp;&amp; elem.Elem().Kind() == reflect.Struct </span><span class="cov0" title="0">{
                                                validateStructFields(elem.Elem(), elemPath, result)
                                        }</span>
                                }
                        }
                }
        }
}

// isFieldEmpty checks if a field is empty/zero value
func isFieldEmpty(field reflect.Value, fieldType reflect.StructField) bool <span class="cov0" title="0">{
        // Check for omitempty tag
        xmlTag := fieldType.Tag.Get("xml")
        hasOmitEmpty := strings.Contains(xmlTag, "omitempty")

        switch field.Kind() </span>{
        case reflect.String:<span class="cov0" title="0">
                return field.String() == ""</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return field.Int() == 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return field.Uint() == 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return field.Float() == 0.0</span>
        case reflect.Bool:<span class="cov0" title="0">
                return !field.Bool()</span>
        case reflect.Ptr:<span class="cov0" title="0">
                return field.IsNil()</span>
        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                return field.Len() == 0</span>
        case reflect.Map:<span class="cov0" title="0">
                return field.Len() == 0</span>
        case reflect.Interface:<span class="cov0" title="0">
                return field.IsNil()</span>
        case reflect.Struct:<span class="cov0" title="0">
                // For structs, only consider empty if omitempty and all fields are zero
                if hasOmitEmpty </span><span class="cov0" title="0">{
                        return field.IsZero()
                }</span>
                <span class="cov0" title="0">return false</span> // Non-omitempty structs are considered populated
        default:<span class="cov0" title="0">
                return field.IsZero()</span>
        }
}

// CountXMLItems counts elements and attributes in XML data
func CountXMLItems(xmlData []byte) (elements int, attributes int, err error) <span class="cov0" title="0">{
        decoder := xml.NewDecoder(bytes.NewReader(xmlData))
        elements = 0
        attributes = 0

        for </span><span class="cov0" title="0">{
                token, err := decoder.Token()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, fmt.Errorf("error parsing XML: %w", err)
                }</span>

                <span class="cov0" title="0">switch t := token.(type) </span>{
                case xml.StartElement:<span class="cov0" title="0">
                        elements++
                        attributes += len(t.Attr)</span>
                }
        }

        <span class="cov0" title="0">return elements, attributes, nil</span>
}

// CountXMLItemsDetailed counts elements and attributes with xmlns breakdown
func CountXMLItemsDetailed(xmlData []byte) XMLMetrics <span class="cov0" title="0">{
        decoder := xml.NewDecoder(bytes.NewReader(xmlData))
        metrics := XMLMetrics{}

        for </span><span class="cov0" title="0">{
                token, err := decoder.Token()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return metrics
                }</span>

                <span class="cov0" title="0">switch t := token.(type) </span>{
                case xml.StartElement:<span class="cov0" title="0">
                        metrics.Elements++
                        for _, attr := range t.Attr </span><span class="cov0" title="0">{
                                metrics.Attributes++
                                // Count xmlns attributes separately
                                if attr.Name.Space == "xmlns" || (attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "") </span><span class="cov0" title="0">{
                                        metrics.XmlnsAttrs++
                                }</span> else<span class="cov0" title="0"> {
                                        metrics.NonXmlnsAttrs++
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return metrics</span>
}

// CalculateFidelity calculates the fidelity percentage between input and output XML
func CalculateFidelity(inputElems, outputElems, inputAttrs, outputAttrs int) float64 <span class="cov0" title="0">{
        totalInput := inputElems + inputAttrs
        totalOutput := outputElems + outputAttrs

        if totalInput == 0 </span><span class="cov0" title="0">{
                return 100.0
        }</span>

        // Calculate what percentage of input items are preserved in output
        <span class="cov0" title="0">preserved := totalOutput
        if totalOutput &gt; totalInput </span><span class="cov0" title="0">{
                // If output has more items, cap preserved at input total
                preserved = totalInput
        }</span>

        <span class="cov0" title="0">return (float64(preserved) / float64(totalInput)) * 100.0</span>
}

// FidelityResult contains fidelity calculation results (DEPRECATED - use CalculateFidelity float64 return)
type FidelityResult struct {
        Percentage float64
        Status     string
        Message    string
}

// XMLComparisonResult contains detailed XML comparison results
type XMLComparisonResult struct {
        InputElements    int
        OutputElements   int
        InputAttributes  int
        OutputAttributes int

        MissingElements  []string // Elements in input but not in output
        ExtraElements    []string // Elements in output but not in input
        MismatchedValues []string // Elements with different text content
        MissingAttrs     []string // Attributes in input but not in output
        ExtraAttrs       []string // Attributes in output but not in input
        MismatchedAttrs  []string // Attributes with different values
        NamespaceIssues  []string // Namespace prefix or declaration issues

        TotalDifferences int
        IsPerfectMatch   bool
}

// XMLElement represents a parsed XML element for comparison
type XMLElement struct {
        Name       xml.Name
        Attributes []xml.Attr
        Value      string
        Path       string // XPath-like path to element
        Children   []*XMLElement
}

// ParseXMLTree parses XML data into a tree structure for comparison
func ParseXMLTree(xmlData []byte) (*XMLElement, error) <span class="cov0" title="0">{
        decoder := xml.NewDecoder(bytes.NewReader(xmlData))
        root := &amp;XMLElement{Path: "/"}
        var stack []*XMLElement
        var currentPath []string

        for </span><span class="cov0" title="0">{
                token, err := decoder.Token()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing XML: %w", err)
                }</span>

                <span class="cov0" title="0">switch t := token.(type) </span>{
                case xml.StartElement:<span class="cov0" title="0">
                        elem := &amp;XMLElement{
                                Name:       t.Name,
                                Attributes: t.Attr,
                                Path:       "/" + strings.Join(append(currentPath, t.Name.Local), "/"),
                        }

                        if len(stack) == 0 </span><span class="cov0" title="0">{
                                root = elem
                        }</span> else<span class="cov0" title="0"> {
                                parent := stack[len(stack)-1]
                                parent.Children = append(parent.Children, elem)
                        }</span>

                        <span class="cov0" title="0">stack = append(stack, elem)
                        currentPath = append(currentPath, t.Name.Local)</span>

                case xml.EndElement:<span class="cov0" title="0">
                        if len(stack) &gt; 0 </span><span class="cov0" title="0">{
                                stack = stack[:len(stack)-1]
                        }</span>
                        <span class="cov0" title="0">if len(currentPath) &gt; 0 </span><span class="cov0" title="0">{
                                currentPath = currentPath[:len(currentPath)-1]
                        }</span>

                case xml.CharData:<span class="cov0" title="0">
                        text := strings.TrimSpace(string(t))
                        if text != "" &amp;&amp; len(stack) &gt; 0 </span><span class="cov0" title="0">{
                                current := stack[len(stack)-1]
                                current.Value = text
                        }</span>
                }
        }

        <span class="cov0" title="0">return root, nil</span>
}

// CompareXMLTrees performs deep comparison of two XML trees
func CompareXMLTrees(input, output *XMLElement) *XMLComparisonResult <span class="cov0" title="0">{
        result := &amp;XMLComparisonResult{
                MissingElements:  []string{},
                ExtraElements:    []string{},
                MismatchedValues: []string{},
                MissingAttrs:     []string{},
                ExtraAttrs:       []string{},
                MismatchedAttrs:  []string{},
                NamespaceIssues:  []string{},
        }

        // Count totals
        result.InputElements, result.InputAttributes = countElementsAndAttrs(input)
        result.OutputElements, result.OutputAttributes = countElementsAndAttrs(output)

        // Perform deep comparison
        compareElements(input, output, result)

        // Calculate totals
        result.TotalDifferences = len(result.MissingElements) + len(result.ExtraElements) +
                len(result.MismatchedValues) + len(result.MissingAttrs) +
                len(result.ExtraAttrs) + len(result.MismatchedAttrs) +
                len(result.NamespaceIssues)

        result.IsPerfectMatch = result.TotalDifferences == 0

        return result
}</span>

// countElementsAndAttrs counts elements and attributes in a tree
func countElementsAndAttrs(elem *XMLElement) (int, int) <span class="cov0" title="0">{
        if elem == nil </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        <span class="cov0" title="0">elements := 1
        attrs := len(elem.Attributes)

        for _, child := range elem.Children </span><span class="cov0" title="0">{
                childElems, childAttrs := countElementsAndAttrs(child)
                elements += childElems
                attrs += childAttrs
        }</span>

        <span class="cov0" title="0">return elements, attrs</span>
}

// compareElements recursively compares two elements
func compareElements(input, output *XMLElement, result *XMLComparisonResult) <span class="cov0" title="0">{
        if input == nil &amp;&amp; output == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check for missing/extra elements
        <span class="cov0" title="0">if input == nil </span><span class="cov0" title="0">{
                result.ExtraElements = append(result.ExtraElements,
                        fmt.Sprintf("%s (extra in output)", output.Path))
                return
        }</span>
        <span class="cov0" title="0">if output == nil </span><span class="cov0" title="0">{
                result.MissingElements = append(result.MissingElements,
                        fmt.Sprintf("%s (missing from output)", input.Path))
                return
        }</span>

        // Check namespace differences
        <span class="cov0" title="0">if input.Name.Space != output.Name.Space </span><span class="cov0" title="0">{
                result.NamespaceIssues = append(result.NamespaceIssues,
                        fmt.Sprintf("%s: namespace changed from '%s' to '%s'",
                                input.Path, input.Name.Space, output.Name.Space))
        }</span>

        // Check local name differences
        <span class="cov0" title="0">if input.Name.Local != output.Name.Local </span><span class="cov0" title="0">{
                result.MismatchedValues = append(result.MismatchedValues,
                        fmt.Sprintf("%s: element name changed from '%s' to '%s'",
                                input.Path, input.Name.Local, output.Name.Local))
        }</span>

        // Check text content
        <span class="cov0" title="0">if input.Value != output.Value </span><span class="cov0" title="0">{
                result.MismatchedValues = append(result.MismatchedValues,
                        fmt.Sprintf("%s: value changed from '%s' to '%s'",
                                input.Path, truncate(input.Value, 50), truncate(output.Value, 50)))
        }</span>

        // Compare attributes
        <span class="cov0" title="0">compareAttributes(input, output, result)

        // Compare children
        compareChildren(input, output, result)</span>
}

// compareAttributes compares attributes of two elements
func compareAttributes(input, output *XMLElement, result *XMLComparisonResult) <span class="cov0" title="0">{
        inputAttrs := make(map[string]xml.Attr)
        for _, attr := range input.Attributes </span><span class="cov0" title="0">{
                key := attr.Name.Space + ":" + attr.Name.Local
                inputAttrs[key] = attr
        }</span>

        <span class="cov0" title="0">outputAttrs := make(map[string]xml.Attr)
        for _, attr := range output.Attributes </span><span class="cov0" title="0">{
                key := attr.Name.Space + ":" + attr.Name.Local
                outputAttrs[key] = attr

                // Check for namespace corruption (xmlns: becoming _xmlns:)
                if strings.HasPrefix(attr.Name.Space, "_xmlns") || strings.HasPrefix(attr.Name.Local, "_xmlns") </span><span class="cov0" title="0">{
                        result.NamespaceIssues = append(result.NamespaceIssues,
                                fmt.Sprintf("%s: corrupted namespace attribute '%s:%s' = '%s'",
                                        output.Path, attr.Name.Space, attr.Name.Local, attr.Value))
                }</span>
        }

        // Check for missing attributes
        <span class="cov0" title="0">for key, attr := range inputAttrs </span><span class="cov0" title="0">{
                if _, exists := outputAttrs[key]; !exists </span><span class="cov0" title="0">{
                        result.MissingAttrs = append(result.MissingAttrs,
                                fmt.Sprintf("%s/@%s:%s (missing from output)",
                                        input.Path, attr.Name.Space, attr.Name.Local))
                }</span>
        }

        // Check for extra attributes
        <span class="cov0" title="0">for key, attr := range outputAttrs </span><span class="cov0" title="0">{
                if _, exists := inputAttrs[key]; !exists </span><span class="cov0" title="0">{
                        // Skip corrupted namespace attributes in the report
                        if !strings.HasPrefix(attr.Name.Space, "_xmlns") &amp;&amp; !strings.HasPrefix(attr.Name.Local, "_xmlns") </span><span class="cov0" title="0">{
                                result.ExtraAttrs = append(result.ExtraAttrs,
                                        fmt.Sprintf("%s/@%s:%s (extra in output)",
                                                output.Path, attr.Name.Space, attr.Name.Local))
                        }</span>
                }
        }

        // Check for mismatched attribute values
        <span class="cov0" title="0">for key, inputAttr := range inputAttrs </span><span class="cov0" title="0">{
                if outputAttr, exists := outputAttrs[key]; exists </span><span class="cov0" title="0">{
                        if inputAttr.Value != outputAttr.Value </span><span class="cov0" title="0">{
                                result.MismatchedAttrs = append(result.MismatchedAttrs,
                                        fmt.Sprintf("%s/@%s:%s: value changed from '%s' to '%s'",
                                                input.Path, inputAttr.Name.Space, inputAttr.Name.Local,
                                                truncate(inputAttr.Value, 50), truncate(outputAttr.Value, 50)))
                        }</span>
                }
        }
}

// compareChildren compares children of two elements
func compareChildren(input, output *XMLElement, result *XMLComparisonResult) <span class="cov0" title="0">{
        // Build maps for quick lookup
        inputChildren := make(map[string][]*XMLElement)
        for _, child := range input.Children </span><span class="cov0" title="0">{
                key := child.Name.Space + ":" + child.Name.Local
                inputChildren[key] = append(inputChildren[key], child)
        }</span>

        <span class="cov0" title="0">outputChildren := make(map[string][]*XMLElement)
        for _, child := range output.Children </span><span class="cov0" title="0">{
                key := child.Name.Space + ":" + child.Name.Local
                outputChildren[key] = append(outputChildren[key], child)
        }</span>

        // Compare matching children
        <span class="cov0" title="0">for key, inputList := range inputChildren </span><span class="cov0" title="0">{
                outputList, exists := outputChildren[key]
                if !exists </span><span class="cov0" title="0">{
                        // All input children of this type are missing
                        for _, child := range inputList </span><span class="cov0" title="0">{
                                result.MissingElements = append(result.MissingElements,
                                        fmt.Sprintf("%s (missing from output)", child.Path))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Compare matching pairs
                <span class="cov0" title="0">maxLen := len(inputList)
                if len(outputList) &gt; maxLen </span><span class="cov0" title="0">{
                        maxLen = len(outputList)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; maxLen; i++ </span><span class="cov0" title="0">{
                        var inputChild, outputChild *XMLElement
                        if i &lt; len(inputList) </span><span class="cov0" title="0">{
                                inputChild = inputList[i]
                        }</span>
                        <span class="cov0" title="0">if i &lt; len(outputList) </span><span class="cov0" title="0">{
                                outputChild = outputList[i]
                        }</span>

                        <span class="cov0" title="0">compareElements(inputChild, outputChild, result)</span>
                }
        }

        // Check for extra children in output
        <span class="cov0" title="0">for key, outputList := range outputChildren </span><span class="cov0" title="0">{
                if _, exists := inputChildren[key]; !exists </span><span class="cov0" title="0">{
                        for _, child := range outputList </span><span class="cov0" title="0">{
                                result.ExtraElements = append(result.ExtraElements,
                                        fmt.Sprintf("%s (extra in output)", child.Path))
                        }</span>
                }
        }
}

// truncate truncates a string to maxLen characters
func truncate(s string, maxLen int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen] + "..."</span>
}

// PrintValidationReport prints a formatted validation report
func PrintValidationReport(result *ValidationResult) <span class="cov0" title="0">{
        fmt.Println(" Validation Report:")
        fmt.Println("=====================")
        fmt.Printf("Total Fields:      %d\n", result.TotalFields)
        fmt.Printf("Populated Fields:  %d\n", result.PopulatedFields)
        fmt.Printf("Empty Fields:      %d\n", len(result.EmptyFields))
        fmt.Printf("Unknown Elements:  %d\n", result.UnknownElements)
        fmt.Printf("Unknown Attrs:     %d\n", result.UnknownAttrs)

        // Show actual unknown elements only if count &gt; 0 (elements not defined in schema)
        if result.UnknownElements &gt; 0 &amp;&amp; len(result.UnknownElementsList) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\n Unknown Elements (not defined in schema, captured via xs:any):")
                seen := make(map[string]bool)
                for _, elemName := range result.UnknownElementsList </span><span class="cov0" title="0">{
                        if !seen[elemName] </span><span class="cov0" title="0">{
                                fmt.Printf("  - %s\n", elemName)
                                seen[elemName] = true
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println("   Note: These elements are from other namespaces, allowed by schema xs:any wildcard")</span>
        }

        // Show actual unknown attributes only if count &gt; 0 (attributes not defined in schema)
        <span class="cov0" title="0">if result.UnknownAttrs &gt; 0 &amp;&amp; len(result.UnknownAttrsList) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\n Unknown Attributes (not defined in schema, captured via xs:anyAttribute):")
                seen := make(map[string]bool)
                for _, attrName := range result.UnknownAttrsList </span><span class="cov0" title="0">{
                        if !seen[attrName] </span><span class="cov0" title="0">{
                                fmt.Printf("  - %s\n", attrName)
                                seen[attrName] = true
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println("   Note: These attributes are from other namespaces, allowed by schema xs:anyAttribute wildcard")</span>
        }

        // Calculate completeness percentage
        <span class="cov0" title="0">if result.TotalFields &gt; 0 </span><span class="cov0" title="0">{
                completeness := float64(result.PopulatedFields) / float64(result.TotalFields) * 100
                fmt.Printf("\n Struct Completeness: %.1f%% (%d of %d fields populated)\n",
                        completeness, result.PopulatedFields, result.TotalFields)
                fmt.Println("   Note: Empty fields indicate optional schema elements not present in this XML instance")
        }</span>

        // Display XML fidelity metrics
        <span class="cov0" title="0">if result.InputElements &gt; 0 || result.OutputElements &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\n XML Fidelity Metrics:")
                fmt.Println("========================")
                fmt.Printf("Input Elements:     %d\n", result.InputElements)
                fmt.Printf("Output Elements:    %d\n", result.OutputElements)
                fmt.Printf("Input Attributes:   %d\n", result.InputAttributes)
                fmt.Printf("Output Attributes:  %d\n", result.OutputAttributes)

                // Display detailed xmlns breakdown
                fmt.Println("\n Attribute Breakdown:")
                fmt.Printf("Input xmlns attrs:     %d\n", result.InputXmlns)
                fmt.Printf("Output xmlns attrs:    %d\n", result.OutputXmlns)
                fmt.Printf("Input non-xmlns attrs: %d\n", result.InputNonXmlns)
                fmt.Printf("Output non-xmlns attrs:%d\n", result.OutputNonXmlns)

                xmlnsDelta := result.OutputXmlns - result.InputXmlns
                nonXmlnsDelta := result.OutputNonXmlns - result.InputNonXmlns
                if xmlnsDelta == 0 &amp;&amp; nonXmlnsDelta == 0 </span><span class="cov0" title="0">{
                        fmt.Println("\n Perfect xmlns fidelity - no attribute delta!")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("\nxmlns delta:     %+d\n", xmlnsDelta)
                        fmt.Printf("non-xmlns delta: %+d\n", nonXmlnsDelta)
                }</span>

                <span class="cov0" title="0">totalInput := result.InputElements + result.InputAttributes
                totalOutput := result.OutputElements + result.OutputAttributes
                fmt.Printf("\nTotal Items (Input):  %d\n", totalInput)
                fmt.Printf("Total Items (Output): %d\n", totalOutput)

                if result.FidelityPercent &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\n XML Fidelity: %.1f%% (%d/%d items)\n",
                                result.FidelityPercent, totalOutput, totalInput)

                        if result.FidelityPercent &lt; 100.0 </span><span class="cov0" title="0">{
                                fmt.Println(" CRITICAL: Data loss detected!")
                                fmt.Println("   Zero tolerance for data loss - ALL items must be preserved")
                                fmt.Println("   Check for:")
                                fmt.Println("   - Missing struct fields for elements/attributes")
                                fmt.Println("   - Incorrect xml tags or omitempty usage")
                                fmt.Println("   - Type mismatches preventing unmarshaling")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println(" Perfect fidelity - all XML items preserved!")
                        }</span>
                }
        }
}

// Deep XML comparison functions for comprehensive validation

// DeepComparisonResult contains detailed comparison results
type DeepComparisonResult struct {
        // Count validation
        ElementCount   CountMatch
        AttributeCount CountMatch
        XmlnsCount     CountMatch
        NonXmlnsCount  CountMatch

        // Name validation
        ElementNames   NameMatch
        AttributeNames NameMatch
        NamespaceURIs  NameMatch

        // Value validation (CRITICAL)
        ElementValues   ValueMatch
        AttributeValues ValueMatch

        // Structural validation
        MaxDepth      DepthMatch
        ElementOrder  bool
        NestingIntact bool

        // Overall verdict
        IsPerfectMatch bool
        TotalIssues    int
}

type CountMatch struct {
        Input  int
        Output int
        Delta  int
        Match  bool
}

type NameMatch struct {
        UniqueNames   int
        MatchCount    int
        MismatchCount int
        Missing       []string
        Extra         []string
        Changed       []NameChange
}

type NameChange struct {
        Path    string
        OldName string
        NewName string
}

type ValueMatch struct {
        Total         int
        MatchCount    int
        MismatchCount int
        Mismatches    []ValueMismatch
}

type ValueMismatch struct {
        Path        string
        Name        string
        InputValue  string
        OutputValue string
}

type DepthMatch struct {
        Input  int
        Output int
        Match  bool
}

// ParseXMLForComparison parses XML into a comparable structure
func ParseXMLForComparison(xmlData []byte) (*XMLNode, error) <span class="cov0" title="0">{
        decoder := xml.NewDecoder(bytes.NewReader(xmlData))
        var root *XMLNode
        var current *XMLNode
        var stack []*XMLNode

        for </span><span class="cov0" title="0">{
                token, err := decoder.Token()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse error: %w", err)
                }</span>

                <span class="cov0" title="0">switch t := token.(type) </span>{
                case xml.StartElement:<span class="cov0" title="0">
                        node := &amp;XMLNode{
                                Name:       t.Name,
                                Attributes: t.Attr,
                                Path:       buildPath(stack, t.Name),
                                Children:   []*XMLNode{},
                        }

                        if current != nil </span><span class="cov0" title="0">{
                                current.Children = append(current.Children, node)
                                stack = append(stack, current)
                        }</span> else<span class="cov0" title="0"> {
                                root = node
                        }</span>
                        <span class="cov0" title="0">current = node</span>

                case xml.EndElement:<span class="cov0" title="0">
                        if len(stack) &gt; 0 </span><span class="cov0" title="0">{
                                current = stack[len(stack)-1]
                                stack = stack[:len(stack)-1]
                        }</span> else<span class="cov0" title="0"> {
                                current = nil
                        }</span>

                case xml.CharData:<span class="cov0" title="0">
                        if current != nil </span><span class="cov0" title="0">{
                                text := strings.TrimSpace(string(t))
                                if text != "" </span><span class="cov0" title="0">{
                                        current.Value = text
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return root, nil</span>
}

type XMLNode struct {
        Name       xml.Name
        Attributes []xml.Attr
        Value      string
        Path       string
        Children   []*XMLNode
}

func buildPath(stack []*XMLNode, name xml.Name) string <span class="cov0" title="0">{
        var path strings.Builder
        for _, node := range stack </span><span class="cov0" title="0">{
                path.WriteString("/")
                if node.Name.Space != "" </span><span class="cov0" title="0">{
                        path.WriteString("{")
                        path.WriteString(node.Name.Space)
                        path.WriteString("}")
                }</span>
                <span class="cov0" title="0">path.WriteString(node.Name.Local)</span>
        }
        <span class="cov0" title="0">path.WriteString("/")
        if name.Space != "" </span><span class="cov0" title="0">{
                path.WriteString("{")
                path.WriteString(name.Space)
                path.WriteString("}")
        }</span>
        <span class="cov0" title="0">path.WriteString(name.Local)
        return path.String()</span>
}

// DeepCompareXML performs comprehensive comparison
func DeepCompareXML(inputXML, outputXML []byte) (*DeepComparisonResult, error) <span class="cov0" title="0">{
        result := &amp;DeepComparisonResult{}

        // Parse both trees
        inputTree, err := ParseXMLForComparison(inputXML)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse input: %w", err)
        }</span>

        <span class="cov0" title="0">outputTree, err := ParseXMLForComparison(outputXML)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse output: %w", err)
        }</span>

        // Level 1: Count validation
        <span class="cov0" title="0">inputMetrics := CountXMLItemsDetailed(inputXML)
        outputMetrics := CountXMLItemsDetailed(outputXML)

        result.ElementCount = CountMatch{
                Input:  inputMetrics.Elements,
                Output: outputMetrics.Elements,
                Delta:  outputMetrics.Elements - inputMetrics.Elements,
                Match:  inputMetrics.Elements == outputMetrics.Elements,
        }

        result.AttributeCount = CountMatch{
                Input:  inputMetrics.Attributes,
                Output: outputMetrics.Attributes,
                Delta:  outputMetrics.Attributes - inputMetrics.Attributes,
                Match:  inputMetrics.Attributes == outputMetrics.Attributes,
        }

        result.XmlnsCount = CountMatch{
                Input:  inputMetrics.XmlnsAttrs,
                Output: outputMetrics.XmlnsAttrs,
                Delta:  outputMetrics.XmlnsAttrs - inputMetrics.XmlnsAttrs,
                Match:  inputMetrics.XmlnsAttrs == outputMetrics.XmlnsAttrs,
        }

        result.NonXmlnsCount = CountMatch{
                Input:  inputMetrics.NonXmlnsAttrs,
                Output: outputMetrics.NonXmlnsAttrs,
                Delta:  outputMetrics.NonXmlnsAttrs - inputMetrics.NonXmlnsAttrs,
                Match:  inputMetrics.NonXmlnsAttrs == outputMetrics.NonXmlnsAttrs,
        }

        // Level 2: Name validation
        result.ElementNames = compareElementNames(inputTree, outputTree)
        result.AttributeNames = compareAttributeNames(inputTree, outputTree)
        result.NamespaceURIs = compareNamespaceURIs(inputTree, outputTree)

        // Level 3: Value validation (CRITICAL)
        result.ElementValues = compareElementValues(inputTree, outputTree)
        result.AttributeValues = compareAttributeValues(inputTree, outputTree)

        // Level 4: Structural validation
        result.MaxDepth = DepthMatch{
                Input:  calculateDepth(inputTree),
                Output: calculateDepth(outputTree),
                Match:  calculateDepth(inputTree) == calculateDepth(outputTree),
        }
        result.ElementOrder = compareOrder(inputTree, outputTree)
        result.NestingIntact = compareNesting(inputTree, outputTree)

        // Calculate overall verdict
        result.IsPerfectMatch = result.ElementCount.Match &amp;&amp;
                result.AttributeCount.Match &amp;&amp;
                result.XmlnsCount.Match &amp;&amp;
                result.NonXmlnsCount.Match &amp;&amp;
                result.ElementNames.MismatchCount == 0 &amp;&amp;
                result.AttributeNames.MismatchCount == 0 &amp;&amp;
                result.NamespaceURIs.MismatchCount == 0 &amp;&amp;
                result.ElementValues.MismatchCount == 0 &amp;&amp;
                result.AttributeValues.MismatchCount == 0 &amp;&amp;
                result.MaxDepth.Match &amp;&amp;
                result.ElementOrder &amp;&amp;
                result.NestingIntact

        result.TotalIssues =
                result.ElementNames.MismatchCount +
                        result.AttributeNames.MismatchCount +
                        result.NamespaceURIs.MismatchCount +
                        result.ElementValues.MismatchCount +
                        result.AttributeValues.MismatchCount

        if !result.ElementCount.Match </span><span class="cov0" title="0">{
                result.TotalIssues++
        }</span>
        <span class="cov0" title="0">if !result.AttributeCount.Match </span><span class="cov0" title="0">{
                result.TotalIssues++
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Helper comparison functions
func compareElementNames(input, output *XMLNode) NameMatch <span class="cov0" title="0">{
        inputNames := collectElementNames(input, make(map[string]bool))
        outputNames := collectElementNames(output, make(map[string]bool))

        match := NameMatch{
                UniqueNames: len(inputNames),
                Missing:     []string{},
                Extra:       []string{},
                Changed:     []NameChange{},
        }

        for name := range inputNames </span><span class="cov0" title="0">{
                if !outputNames[name] </span><span class="cov0" title="0">{
                        match.Missing = append(match.Missing, name)
                        match.MismatchCount++
                }</span> else<span class="cov0" title="0"> {
                        match.MatchCount++
                }</span>
        }

        <span class="cov0" title="0">for name := range outputNames </span><span class="cov0" title="0">{
                if !inputNames[name] </span><span class="cov0" title="0">{
                        match.Extra = append(match.Extra, name)
                        match.MismatchCount++
                }</span>
        }

        <span class="cov0" title="0">return match</span>
}

func collectElementNames(node *XMLNode, names map[string]bool) map[string]bool <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return names
        }</span>
        <span class="cov0" title="0">names[node.Name.Local] = true
        for _, child := range node.Children </span><span class="cov0" title="0">{
                collectElementNames(child, names)
        }</span>
        <span class="cov0" title="0">return names</span>
}

func compareAttributeNames(input, output *XMLNode) NameMatch <span class="cov0" title="0">{
        inputAttrs := collectAttributeNames(input, make(map[string]bool))
        outputAttrs := collectAttributeNames(output, make(map[string]bool))

        match := NameMatch{
                UniqueNames: len(inputAttrs),
                Missing:     []string{},
                Extra:       []string{},
        }

        for name := range inputAttrs </span><span class="cov0" title="0">{
                if !outputAttrs[name] </span><span class="cov0" title="0">{
                        match.Missing = append(match.Missing, name)
                        match.MismatchCount++
                }</span> else<span class="cov0" title="0"> {
                        match.MatchCount++
                }</span>
        }

        <span class="cov0" title="0">for name := range outputAttrs </span><span class="cov0" title="0">{
                if !inputAttrs[name] </span><span class="cov0" title="0">{
                        match.Extra = append(match.Extra, name)
                        match.MismatchCount++
                }</span>
        }

        <span class="cov0" title="0">return match</span>
}

func collectAttributeNames(node *XMLNode, names map[string]bool) map[string]bool <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return names
        }</span>
        <span class="cov0" title="0">for _, attr := range node.Attributes </span><span class="cov0" title="0">{
                if attr.Name.Space != "xmlns" &amp;&amp; attr.Name.Local != "xmlns" </span><span class="cov0" title="0">{
                        names[attr.Name.Local] = true
                }</span>
        }
        <span class="cov0" title="0">for _, child := range node.Children </span><span class="cov0" title="0">{
                collectAttributeNames(child, names)
        }</span>
        <span class="cov0" title="0">return names</span>
}

func compareNamespaceURIs(input, output *XMLNode) NameMatch <span class="cov0" title="0">{
        inputNS := collectNamespaceURIs(input, make(map[string]bool))
        outputNS := collectNamespaceURIs(output, make(map[string]bool))

        match := NameMatch{
                UniqueNames: len(inputNS),
                Missing:     []string{},
                Extra:       []string{},
        }

        for uri := range inputNS </span><span class="cov0" title="0">{
                if !outputNS[uri] </span><span class="cov0" title="0">{
                        match.Missing = append(match.Missing, uri)
                        match.MismatchCount++
                }</span> else<span class="cov0" title="0"> {
                        match.MatchCount++
                }</span>
        }

        <span class="cov0" title="0">for uri := range outputNS </span><span class="cov0" title="0">{
                if !inputNS[uri] </span><span class="cov0" title="0">{
                        match.Extra = append(match.Extra, uri)
                        match.MismatchCount++
                }</span>
        }

        <span class="cov0" title="0">return match</span>
}

func collectNamespaceURIs(node *XMLNode, uris map[string]bool) map[string]bool <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return uris
        }</span>
        <span class="cov0" title="0">for _, attr := range node.Attributes </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" || attr.Name.Local == "xmlns" </span><span class="cov0" title="0">{
                        uris[attr.Value] = true
                }</span>
        }
        <span class="cov0" title="0">for _, child := range node.Children </span><span class="cov0" title="0">{
                collectNamespaceURIs(child, uris)
        }</span>
        <span class="cov0" title="0">return uris</span>
}

func compareElementValues(input, output *XMLNode) ValueMatch <span class="cov0" title="0">{
        match := ValueMatch{
                Mismatches: []ValueMismatch{},
        }

        compareValuesRecursive(input, output, &amp;match)
        match.Total = match.MatchCount + match.MismatchCount

        return match
}</span>

func compareValuesRecursive(input, output *XMLNode, match *ValueMatch) <span class="cov0" title="0">{
        if input == nil || output == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Compare this node's value
        <span class="cov0" title="0">if input.Value != "" || output.Value != "" </span><span class="cov0" title="0">{
                if input.Value == output.Value </span><span class="cov0" title="0">{
                        match.MatchCount++
                }</span> else<span class="cov0" title="0"> {
                        match.MismatchCount++
                        if len(match.Mismatches) &lt; 20 </span><span class="cov0" title="0">{ // Limit to first 20
                                match.Mismatches = append(match.Mismatches, ValueMismatch{
                                        Path:        input.Path,
                                        Name:        input.Name.Local,
                                        InputValue:  input.Value,
                                        OutputValue: output.Value,
                                })
                        }</span>
                }
        }

        // Compare children by identity (namespace + local name), not by position
        // Build map of output children by identity for efficient matching
        <span class="cov0" title="0">outputMap := make(map[string][]*XMLNode)
        for _, outputChild := range output.Children </span><span class="cov0" title="0">{
                key := outputChild.Name.Space + ":" + outputChild.Name.Local
                outputMap[key] = append(outputMap[key], outputChild)
        }</span>

        // Match input children by identity
        <span class="cov0" title="0">for _, inputChild := range input.Children </span><span class="cov0" title="0">{
                key := inputChild.Name.Space + ":" + inputChild.Name.Local
                if matchingNodes := outputMap[key]; len(matchingNodes) &gt; 0 </span><span class="cov0" title="0">{
                        // Compare with first matching element (consume it)
                        compareValuesRecursive(inputChild, matchingNodes[0], match)
                        // Remove the matched node so we don't match it again
                        outputMap[key] = matchingNodes[1:]
                }</span>
                // If no match found, the element is missing in output (already counted in name validation)
        }
}

func compareAttributeValues(input, output *XMLNode) ValueMatch <span class="cov0" title="0">{
        match := ValueMatch{
                Mismatches: []ValueMismatch{},
        }

        compareAttrValuesRecursive(input, output, &amp;match)
        match.Total = match.MatchCount + match.MismatchCount

        return match
}</span>

func compareAttrValuesRecursive(input, output *XMLNode, match *ValueMatch) <span class="cov0" title="0">{
        if input == nil || output == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Build attribute maps
        <span class="cov0" title="0">inputAttrs := make(map[string]string)
        outputAttrs := make(map[string]string)

        for _, attr := range input.Attributes </span><span class="cov0" title="0">{
                if attr.Name.Space != "xmlns" &amp;&amp; attr.Name.Local != "xmlns" </span><span class="cov0" title="0">{
                        inputAttrs[attr.Name.Local] = attr.Value
                }</span>
        }

        <span class="cov0" title="0">for _, attr := range output.Attributes </span><span class="cov0" title="0">{
                if attr.Name.Space != "xmlns" &amp;&amp; attr.Name.Local != "xmlns" </span><span class="cov0" title="0">{
                        outputAttrs[attr.Name.Local] = attr.Value
                }</span>
        }

        // Compare attribute values
        <span class="cov0" title="0">for name, inputVal := range inputAttrs </span><span class="cov0" title="0">{
                if outputVal, exists := outputAttrs[name]; exists </span><span class="cov0" title="0">{
                        if inputVal == outputVal </span><span class="cov0" title="0">{
                                match.MatchCount++
                        }</span> else<span class="cov0" title="0"> {
                                match.MismatchCount++
                                if len(match.Mismatches) &lt; 20 </span><span class="cov0" title="0">{
                                        match.Mismatches = append(match.Mismatches, ValueMismatch{
                                                Path:        input.Path,
                                                Name:        "@" + name,
                                                InputValue:  inputVal,
                                                OutputValue: outputVal,
                                        })
                                }</span>
                        }
                }
        }

        // Recurse to children by identity, not position
        // Build map of output children by identity
        <span class="cov0" title="0">outputMap := make(map[string][]*XMLNode)
        for _, outputChild := range output.Children </span><span class="cov0" title="0">{
                key := outputChild.Name.Space + ":" + outputChild.Name.Local
                outputMap[key] = append(outputMap[key], outputChild)
        }</span>

        // Match input children by identity
        <span class="cov0" title="0">for _, inputChild := range input.Children </span><span class="cov0" title="0">{
                key := inputChild.Name.Space + ":" + inputChild.Name.Local
                if matchingNodes := outputMap[key]; len(matchingNodes) &gt; 0 </span><span class="cov0" title="0">{
                        compareAttrValuesRecursive(inputChild, matchingNodes[0], match)
                        outputMap[key] = matchingNodes[1:]
                }</span>
        }
}

func calculateDepth(node *XMLNode) int <span class="cov0" title="0">{
        if node == nil || len(node.Children) == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">maxChildDepth := 0
        for _, child := range node.Children </span><span class="cov0" title="0">{
                depth := calculateDepth(child)
                if depth &gt; maxChildDepth </span><span class="cov0" title="0">{
                        maxChildDepth = depth
                }</span>
        }

        <span class="cov0" title="0">return 1 + maxChildDepth</span>
}

func compareOrder(input, output *XMLNode) bool <span class="cov0" title="0">{
        if input == nil || output == nil </span><span class="cov0" title="0">{
                return input == output
        }</span>

        <span class="cov0" title="0">if len(input.Children) != len(output.Children) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for i := range input.Children </span><span class="cov0" title="0">{
                if input.Children[i].Name != output.Children[i].Name </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if !compareOrder(input.Children[i], output.Children[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func compareNesting(input, output *XMLNode) bool <span class="cov0" title="0">{
        if input == nil || output == nil </span><span class="cov0" title="0">{
                return input == output
        }</span>

        <span class="cov0" title="0">if len(input.Children) != len(output.Children) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for i := range input.Children </span><span class="cov0" title="0">{
                if !compareNesting(input.Children[i], output.Children[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// PrintDeepComparisonReport prints comprehensive validation report
func PrintDeepComparisonReport(result *DeepComparisonResult) <span class="cov0" title="0">{
        fmt.Println("")
        fmt.Println(" COMPREHENSIVE ROUND-TRIP VALIDATION REPORT")
        fmt.Println("")

        // Level 1: Count Validation
        fmt.Println("\nLEVEL 1: COUNT VALIDATION")
        fmt.Println("")
        printCountMatch("Elements", result.ElementCount)
        printCountMatch("Attributes", result.AttributeCount)
        printCountMatch("  xmlns", result.XmlnsCount)
        printCountMatch("  non-xmlns", result.NonXmlnsCount)

        // Level 2: Name Validation
        fmt.Println("\nLEVEL 2: NAME VALIDATION")
        fmt.Println("")
        printNameMatch("Element Names", result.ElementNames)
        printNameMatch("Attribute Names", result.AttributeNames)
        printNameMatch("Namespace URIs", result.NamespaceURIs)

        // Level 3: Value Validation (CRITICAL)
        fmt.Println("\nLEVEL 3: VALUE VALIDATION  CRITICAL")
        fmt.Println("")
        printValueMatch("Element Content", result.ElementValues)
        printValueMatch("Attribute Values", result.AttributeValues)

        // Level 4: Structural Validation
        fmt.Println("\nLEVEL 4: STRUCTURAL VALIDATION")
        fmt.Println("")
        printDepthMatch("Max Depth", result.MaxDepth)
        printBoolMatch("Element Order", result.ElementOrder)
        printBoolMatch("Nesting", result.NestingIntact)

        // Cross-Check Analysis
        fmt.Println("\n")
        fmt.Println("CROSS-CHECK ANALYSIS")
        fmt.Println("")

        silentCorruption := result.ElementCount.Match &amp;&amp; result.AttributeCount.Match &amp;&amp;
                (result.ElementValues.MismatchCount &gt; 0 || result.AttributeValues.MismatchCount &gt; 0)

        if silentCorruption </span><span class="cov0" title="0">{
                fmt.Println("\n  SILENT CORRUPTION DETECTED:")
                fmt.Println("   Counts match but values differ!")
                fmt.Println("   This is DATA CORRUPTION, not just count loss!")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("\n No silent corruption detected")
        }</span>

        <span class="cov0" title="0">namespaceCorruption := result.XmlnsCount.Match &amp;&amp; result.NamespaceURIs.MismatchCount &gt; 0
        if namespaceCorruption </span><span class="cov0" title="0">{
                fmt.Println("\n  NAMESPACE CORRUPTION:")
                fmt.Println("   xmlns count matches but URIs differ!")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(" No namespace corruption detected")
        }</span>

        <span class="cov0" title="0">if len(result.ElementNames.Changed) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\n  ELEMENT SUBSTITUTION:")
                fmt.Println("   Element names changed!")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(" No element substitution detected")
        }</span>

        // Verdict
        <span class="cov0" title="0">fmt.Println("\n")

        // Check semantic fidelity (data preservation regardless of structure)
        hasSemanticFidelity := result.ElementNames.MismatchCount == 0 &amp;&amp;
                result.AttributeNames.MismatchCount == 0 &amp;&amp;
                result.NamespaceURIs.MismatchCount == 0 &amp;&amp;
                result.ElementValues.MismatchCount == 0 &amp;&amp;
                result.AttributeValues.MismatchCount == 0

        if result.IsPerfectMatch </span><span class="cov0" title="0">{
                fmt.Println("VERDICT:  PERFECT FIDELITY")
                fmt.Println("")
                fmt.Println("100% count match")
                fmt.Println("100% name match")
                fmt.Println("100% value match")
                fmt.Println("100% structure match")
                fmt.Println("\nZERO DATA LOSS. ZERO CORRUPTION. ZERO MUTATIONS.")
        }</span> else<span class="cov0" title="0"> if hasSemanticFidelity </span><span class="cov0" title="0">{
                fmt.Println("VERDICT:  SEMANTIC FIDELITY")
                fmt.Println("")
                fmt.Println("100% data preservation:")
                fmt.Println("   All element names preserved")
                fmt.Println("   All attribute names preserved")
                fmt.Println("   All element values preserved")
                fmt.Println("   All attribute values preserved")
                fmt.Println("   All namespaces preserved")
                fmt.Println("\nStructural differences detected (acceptable):")
                if !result.ElementCount.Match </span><span class="cov0" title="0">{
                        fmt.Printf("   Element count: %d  %d ( = %+d)\n",
                                result.ElementCount.Input, result.ElementCount.Output, result.ElementCount.Delta)
                }</span>
                <span class="cov0" title="0">if !result.AttributeCount.Match </span><span class="cov0" title="0">{
                        fmt.Printf("   Attribute count: %d  %d ( = %+d)\n",
                                result.AttributeCount.Input, result.AttributeCount.Output, result.AttributeCount.Delta)
                        fmt.Println("    Note: xmlns consolidation is normal XML marshaling behavior")
                }</span>
                <span class="cov0" title="0">if !result.ElementOrder </span><span class="cov0" title="0">{
                        fmt.Println("   Element ordering differs (unknown elements may appear at end)")
                }</span>
                <span class="cov0" title="0">if !result.NestingIntact </span><span class="cov0" title="0">{
                        fmt.Println("   Nesting structure differs")
                }</span>
                <span class="cov0" title="0">fmt.Println("\n NO DATA LOSS - All content successfully preserved!")</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("VERDICT:  CRITICAL FAILURE")
                fmt.Println("")
                fmt.Printf("\nTotal issues found: %d\n", result.TotalIssues)
                fmt.Println("\nDATA CORRUPTION DETECTED")
                fmt.Println("Zero tolerance for data loss - ALL items must be preserved")
        }</span>
        <span class="cov0" title="0">fmt.Println("")</span>
}

func printCountMatch(label string, match CountMatch) <span class="cov0" title="0">{
        status := ""
        if !match.Match </span><span class="cov0" title="0">{
                status = ""
        }</span>
        <span class="cov0" title="0">fmt.Printf("%-15s %d  %d %s ( = %+d)\n", label+":", match.Input, match.Output, status, match.Delta)</span>
}

func printNameMatch(label string, match NameMatch) <span class="cov0" title="0">{
        status := ""
        if match.MismatchCount &gt; 0 </span><span class="cov0" title="0">{
                status = ""
        }</span>
        <span class="cov0" title="0">fmt.Printf("%s: %d unique, %d/%d match %s\n", label, match.UniqueNames, match.MatchCount, match.UniqueNames, status)

        if len(match.Missing) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Missing: %v\n", match.Missing)
        }</span>
        <span class="cov0" title="0">if len(match.Extra) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Extra: %v\n", match.Extra)
        }</span>
        <span class="cov0" title="0">if len(match.Changed) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Changed: %d\n", len(match.Changed))
                for i, change := range match.Changed </span><span class="cov0" title="0">{
                        if i &lt; 5 </span><span class="cov0" title="0">{
                                fmt.Printf("    %s: %s  %s\n", change.Path, change.OldName, change.NewName)
                        }</span>
                }
                <span class="cov0" title="0">if len(match.Changed) &gt; 5 </span><span class="cov0" title="0">{
                        fmt.Printf("    ... and %d more\n", len(match.Changed)-5)
                }</span>
        }
}

func printValueMatch(label string, match ValueMatch) <span class="cov0" title="0">{
        status := ""
        if match.MismatchCount &gt; 0 </span><span class="cov0" title="0">{
                status = ""
        }</span>
        <span class="cov0" title="0">fmt.Printf("%s: %d total, %d/%d match %s\n", label, match.Total, match.MatchCount, match.Total, status)

        if len(match.Mismatches) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Mismatches: %d\n\n", match.MismatchCount)
                for i, mismatch := range match.Mismatches </span><span class="cov0" title="0">{
                        fmt.Printf("  %d. %s at %s\n", i+1, mismatch.Name, mismatch.Path)
                        fmt.Printf("     Input:  %q\n", mismatch.InputValue)
                        fmt.Printf("     Output: %q\n\n", mismatch.OutputValue)
                }</span>
                <span class="cov0" title="0">if match.MismatchCount &gt; len(match.Mismatches) </span><span class="cov0" title="0">{
                        fmt.Printf("  ... and %d more\n\n", match.MismatchCount-len(match.Mismatches))
                }</span>
        }
}

func printDepthMatch(label string, match DepthMatch) <span class="cov0" title="0">{
        status := ""
        if !match.Match </span><span class="cov0" title="0">{
                status = ""
        }</span>
        <span class="cov0" title="0">fmt.Printf("%s: %d  %d %s\n", label, match.Input, match.Output, status)</span>
}

func printBoolMatch(label string, match bool) <span class="cov0" title="0">{
        status := ""
        result := "PRESERVED"
        if !match </span><span class="cov0" title="0">{
                status = ""
                result = "ALTERED"
        }</span>
        <span class="cov0" title="0">fmt.Printf("%s: %s %s\n", label, result, status)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package xccdf1_2 generated from XSD schema
// Source namespace: http://checklists.nist.gov/xccdf/1.2
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/xccdf/xccdf_1.2.xsd
// Generated by forgexml - Do not edit manually

package xccdf1_2

import (
        "encoding/xml"
        "os"
        "strings"

        language2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/language/2-0"
        types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// TailoringElement represents the XSD element 'Tailoring'
// XSD element declaration (W3C XSD 3.3)
type TailoringElement struct {
        XMLName       xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 Tailoring"`
        TailoringType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *TailoringElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias TailoringElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *TailoringElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias TailoringElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *TailoringElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *TailoringElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *TailoringElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *TailoringElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *TailoringElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadTailoringFromBytes loads an element from bytes with namespace preservation
func LoadTailoringFromBytes(data []byte) (*TailoringElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element TailoringElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadTailoringFromFile loads an element from a file with namespace preservation
func LoadTailoringFromFile(path string) (*TailoringElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadTailoringFromBytes(data)</span>
}

// ItemElement represents the XSD element 'Item'
// XSD element declaration (W3C XSD 3.3)
type ItemElement struct {
        XMLName  xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 Item"`
        ItemType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ItemElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ItemElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ItemElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ItemElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ItemElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ItemElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ItemElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ItemElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ItemElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadItemFromBytes loads an element from bytes with namespace preservation
func LoadItemFromBytes(data []byte) (*ItemElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ItemElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadItemFromFile loads an element from a file with namespace preservation
func LoadItemFromFile(path string) (*ItemElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadItemFromBytes(data)</span>
}

// GroupElement represents the XSD element 'Group'
// XSD element declaration (W3C XSD 3.3)
type GroupElement struct {
        XMLName   xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 Group"`
        GroupType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *GroupElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias GroupElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *GroupElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias GroupElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *GroupElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *GroupElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *GroupElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *GroupElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *GroupElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadGroupFromBytes loads an element from bytes with namespace preservation
func LoadGroupFromBytes(data []byte) (*GroupElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element GroupElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadGroupFromFile loads an element from a file with namespace preservation
func LoadGroupFromFile(path string) (*GroupElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadGroupFromBytes(data)</span>
}

// ValueElement represents the XSD element 'Value'
// XSD element declaration (W3C XSD 3.3)
type ValueElement struct {
        XMLName   xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 Value"`
        ValueType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ValueElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ValueElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ValueElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ValueElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ValueElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ValueElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ValueElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ValueElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ValueElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadValueFromBytes loads an element from bytes with namespace preservation
func LoadValueFromBytes(data []byte) (*ValueElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ValueElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadValueFromFile loads an element from a file with namespace preservation
func LoadValueFromFile(path string) (*ValueElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadValueFromBytes(data)</span>
}

// BenchmarkElement represents the XSD element 'Benchmark'
// XSD element declaration (W3C XSD 3.3)
type BenchmarkElement struct {
        XMLName xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 Benchmark"`
        // Status represents XSD element 'status'
        // minOccurs=1, maxOccurs=-1
        Status []StatusElement `xml:"status"`
        // DcStatus represents XSD element 'dc-status'
        // minOccurs=0, maxOccurs=-1
        DcStatus []DcStatusType `xml:"dc-status,omitempty"`
        // Title represents XSD element 'title'
        // minOccurs=0, maxOccurs=-1
        Title []TextTypeWithAttrs `xml:"title,omitempty"`
        // Description represents XSD element 'description'
        // minOccurs=0, maxOccurs=-1
        Description []HtmlTextWithSubType `xml:"description,omitempty"`
        // Notice represents XSD element 'notice'
        // minOccurs=0, maxOccurs=-1
        Notice []NoticeType `xml:"notice,omitempty"`
        // FrontMatter represents XSD element 'front-matter'
        // minOccurs=0, maxOccurs=-1
        FrontMatter []HtmlTextWithSubType `xml:"front-matter,omitempty"`
        // RearMatter represents XSD element 'rear-matter'
        // minOccurs=0, maxOccurs=-1
        RearMatter []HtmlTextWithSubType `xml:"rear-matter,omitempty"`
        // Reference represents XSD element 'reference'
        // minOccurs=0, maxOccurs=-1
        Reference []ReferenceType `xml:"reference,omitempty"`
        // PlainText represents XSD element 'plain-text'
        // minOccurs=0, maxOccurs=-1
        PlainText []PlainTextTypeWithAttrs `xml:"plain-text,omitempty"`
        // PlatformSpecification represents XSD element 'platform-specification'
        // minOccurs=0, maxOccurs=1
        PlatformSpecification *language2_0.PlatformSpecificationElement `xml:"platform-specification,omitempty"`
        // Platform represents XSD element 'platform'
        // minOccurs=0, maxOccurs=-1
        Platform []CPE2idrefType `xml:"platform,omitempty"`
        // Version represents XSD element 'version'
        Version VersionTypeWithAttrs `xml:"version"`
        // Metadata represents XSD element 'metadata'
        // minOccurs=0, maxOccurs=-1
        Metadata []MetadataType `xml:"metadata,omitempty"`
        // Model represents XSD element 'model'
        // minOccurs=0, maxOccurs=-1
        Model []ModelElement `xml:"model,omitempty"`
        // Profile represents XSD element 'Profile'
        // minOccurs=0, maxOccurs=-1
        Profile []ProfileType `xml:"Profile,omitempty"`
        // Value represents XSD element 'Value'
        // minOccurs=0, maxOccurs=-1
        Value []ValueType `xml:"Value,omitempty"`
        // TestResult represents XSD element 'TestResult'
        // minOccurs=0, maxOccurs=-1
        TestResult []TestResultType `xml:"TestResult,omitempty"`
        // Signature represents XSD element 'signature'
        // minOccurs=0, maxOccurs=1
        Signature *SignatureType `xml:"signature,omitempty"`
        // Group represents XSD element 'Group'
        Group []GroupType `xml:"Group,omitempty"`
        // Rule represents XSD element 'Rule'
        Rule []RuleType `xml:"Rule,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id BenchmarkIdType `xml:"id,attr"`
        // Id2 represents XSD attribute 'Id'
        // use="optional"
        Id2 *string `xml:"Id,attr,omitempty"`
        // Resolved represents XSD attribute 'resolved'
        // use="optional"
        Resolved *bool `xml:"resolved,attr,omitempty"`
        // Style represents XSD attribute 'style'
        // use="optional"
        Style *string `xml:"style,attr,omitempty"`
        // StyleHref represents XSD attribute 'style-href'
        // use="optional"
        StyleHref *string `xml:"style-href,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *BenchmarkElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias BenchmarkElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *BenchmarkElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias BenchmarkElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *BenchmarkElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *BenchmarkElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *BenchmarkElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *BenchmarkElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *BenchmarkElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadBenchmarkFromBytes loads an element from bytes with namespace preservation
func LoadBenchmarkFromBytes(data []byte) (*BenchmarkElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element BenchmarkElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadBenchmarkFromFile loads an element from a file with namespace preservation
func LoadBenchmarkFromFile(path string) (*BenchmarkElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadBenchmarkFromBytes(data)</span>
}

// StatusElement represents the XSD element 'status'
// XSD element declaration (W3C XSD 3.3)
type StatusElement struct {
        XMLName xml.Name   `xml:"http://checklists.nist.gov/xccdf/1.2 status"`
        Value   StatusType `xml:",chardata"` // XSD simpleContent from statusType
        // Date represents XSD attribute 'date'
        // use="optional"
        Date *types.DateTime `xml:"date,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *StatusElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias StatusElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *StatusElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias StatusElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *StatusElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *StatusElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *StatusElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *StatusElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *StatusElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadStatusFromBytes loads an element from bytes with namespace preservation
func LoadStatusFromBytes(data []byte) (*StatusElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element StatusElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadStatusFromFile loads an element from a file with namespace preservation
func LoadStatusFromFile(path string) (*StatusElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadStatusFromBytes(data)</span>
}

// ModelElement represents the XSD element 'model'
// XSD element declaration (W3C XSD 3.3)
type ModelElement struct {
        XMLName xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 model"`
        // Param represents XSD element 'param'
        // minOccurs=0, maxOccurs=-1
        Param []ParamTypeWithAttrs `xml:"param,omitempty"`
        // System represents XSD attribute 'system'
        // use="required"
        System string `xml:"system,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ModelElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ModelElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ModelElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ModelElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ModelElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ModelElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ModelElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ModelElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ModelElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadModelFromBytes loads an element from bytes with namespace preservation
func LoadModelFromBytes(data []byte) (*ModelElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ModelElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadModelFromFile loads an element from a file with namespace preservation
func LoadModelFromFile(path string) (*ModelElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadModelFromBytes(data)</span>
}

// RuleElement represents the XSD element 'Rule'
// XSD element declaration (W3C XSD 3.3)
type RuleElement struct {
        XMLName  xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 Rule"`
        RuleType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *RuleElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias RuleElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *RuleElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias RuleElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *RuleElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *RuleElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *RuleElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *RuleElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *RuleElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadRuleFromBytes loads an element from bytes with namespace preservation
func LoadRuleFromBytes(data []byte) (*RuleElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element RuleElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadRuleFromFile loads an element from a file with namespace preservation
func LoadRuleFromFile(path string) (*RuleElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadRuleFromBytes(data)</span>
}

// ProfileElement represents the XSD element 'Profile'
// XSD element declaration (W3C XSD 3.3)
type ProfileElement struct {
        XMLName     xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 Profile"`
        ProfileType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ProfileElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ProfileElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ProfileElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ProfileElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ProfileElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ProfileElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ProfileElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ProfileElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ProfileElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadProfileFromBytes loads an element from bytes with namespace preservation
func LoadProfileFromBytes(data []byte) (*ProfileElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ProfileElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadProfileFromFile loads an element from a file with namespace preservation
func LoadProfileFromFile(path string) (*ProfileElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadProfileFromBytes(data)</span>
}

// TestResultElement represents the XSD element 'TestResult'
// XSD element declaration (W3C XSD 3.3)
type TestResultElement struct {
        XMLName        xml.Name `xml:"http://checklists.nist.gov/xccdf/1.2 TestResult"`
        TestResultType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *TestResultElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias TestResultElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *TestResultElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias TestResultElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *TestResultElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *TestResultElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *TestResultElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *TestResultElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *TestResultElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadTestResultFromBytes loads an element from bytes with namespace preservation
func LoadTestResultFromBytes(data []byte) (*TestResultElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element TestResultElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadTestResultFromFile loads an element from a file with namespace preservation
func LoadTestResultFromFile(path string) (*TestResultElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadTestResultFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package xccdf1_2 generated from XSD schema
// Source namespace: http://checklists.nist.gov/xccdf/1.2
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/xccdf/xccdf_1.2.xsd
// Generated by forgexml - Do not edit manually

package xccdf1_2

import (
        "encoding/xml"
        "regexp"
        "strings"

        language2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/language/2-0"
        types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// RoleEnumType represents the XSD type 'roleEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="full"
// enumeration="unscored"
// enumeration="unchecked"
type RoleEnumType string

// FixTextType represents the XSD type 'fixTextType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type FixTextType struct {
        HtmlTextWithSubType // XSD extension base
        // Fixref represents XSD attribute 'fixref'
        // use="optional"
        Fixref *string `xml:"fixref,attr,omitempty"`
        // Reboot represents XSD attribute 'reboot'
        // use="optional"
        Reboot *bool `xml:"reboot,attr,omitempty"`
        // Strategy represents XSD attribute 'strategy'
        // use="optional"
        Strategy *FixStrategyEnumType `xml:"strategy,attr,omitempty"`
        // Disruption represents XSD attribute 'disruption'
        // use="optional"
        Disruption *RatingEnumType `xml:"disruption,attr,omitempty"`
        // Complexity represents XSD attribute 'complexity'
        // use="optional"
        Complexity *RatingEnumType `xml:"complexity,attr,omitempty"`
        InnerXML   string          `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignatureType represents the XSD type 'signatureType'
// XSD complex type (W3C XSD 3.4)
type SignatureType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CheckExportType represents the XSD type 'checkExportType'
// XSD complex type (W3C XSD 3.4)
type CheckExportType struct {
        // ValueId represents XSD attribute 'value-id'
        // use="required"
        ValueId string `xml:"value-id,attr"`
        // ExportName represents XSD attribute 'export-name'
        // use="required"
        ExportName string `xml:"export-name,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ComplexValueType represents the XSD type 'complexValueType'
// XSD complex type (W3C XSD 3.4)
type ComplexValueType struct {
        // Item represents XSD element 'item'
        // minOccurs=0, maxOccurs=-1
        Item []string `xml:"item,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ProfileSetComplexValueType represents the XSD type 'profileSetComplexValueType'
// XSD complex type (W3C XSD 3.4)
type ProfileSetComplexValueType struct {
        ComplexValueType // XSD extension base
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref string `xml:"idref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// InstanceResultType represents the XSD type 'instanceResultType'
// XSD complex type (W3C XSD 3.4)
type InstanceResultTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Context represents XSD attribute 'context'
        // use="optional"
        Context *string `xml:"context,attr,omitempty"`
        // ParentContext represents XSD attribute 'parentContext'
        // use="optional"
        ParentContext *string `xml:"parentContext,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// InstanceResultType is an alias for InstanceResultTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type InstanceResultType = InstanceResultTypeWithAttrs

// ValueType represents the XSD type 'valueType'
// XSD complex type (W3C XSD 3.4)
type ValueType struct {
        ItemType // XSD extension base
        // Match represents XSD element 'match'
        // minOccurs=0, maxOccurs=-1
        Match []SelStringTypeWithAttrs `xml:"match,omitempty"`
        // LowerBound represents XSD element 'lower-bound'
        // minOccurs=0, maxOccurs=-1
        LowerBound []SelNumTypeWithAttrs `xml:"lower-bound,omitempty"`
        // UpperBound represents XSD element 'upper-bound'
        // minOccurs=0, maxOccurs=-1
        UpperBound []SelNumTypeWithAttrs `xml:"upper-bound,omitempty"`
        // Choices represents XSD element 'choices'
        // minOccurs=0, maxOccurs=-1
        Choices []SelChoicesType `xml:"choices,omitempty"`
        // Source represents XSD element 'source'
        // minOccurs=0, maxOccurs=-1
        Source []UriRefType `xml:"source,omitempty"`
        // Signature represents XSD element 'signature'
        // minOccurs=0, maxOccurs=1
        Signature *SignatureType `xml:"signature,omitempty"`
        // Value represents XSD element 'value'
        Value []SelStringTypeWithAttrs `xml:"value,omitempty"`
        // ComplexValue represents XSD element 'complex-value'
        ComplexValue []SelComplexValueType `xml:"complex-value,omitempty"`
        // Default represents XSD element 'default'
        Default []SelStringTypeWithAttrs `xml:"default,omitempty"`
        // ComplexDefault represents XSD element 'complex-default'
        ComplexDefault []SelComplexValueType `xml:"complex-default,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id ValueIdType `xml:"id,attr"`
        // Type represents XSD attribute 'type'
        // use="optional"
        Type *ValueTypeType `xml:"type,attr,omitempty"`
        // Operator represents XSD attribute 'operator'
        // use="optional"
        Operator *ValueOperatorType `xml:"operator,attr,omitempty"`
        // Interactive represents XSD attribute 'interactive'
        // use="optional"
        Interactive *bool `xml:"interactive,attr,omitempty"`
        // InterfaceHint represents XSD attribute 'interfaceHint'
        // use="optional"
        InterfaceHint *InterfaceHintType `xml:"interfaceHint,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ResultEnumType represents the XSD type 'resultEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="pass"
// enumeration="fail"
// enumeration="error"
// enumeration="unknown"
// enumeration="notapplicable"
// enumeration="notchecked"
// enumeration="notselected"
// enumeration="informational"
// enumeration="fixed"
type ResultEnumType string

// VersionType represents the XSD type 'versionType'
// XSD complex type (W3C XSD 3.4)
type VersionTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Time represents XSD attribute 'time'
        // use="optional"
        Time *types.DateTime `xml:"time,attr,omitempty"`
        // Update represents XSD attribute 'update'
        // use="optional"
        Update *string `xml:"update,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// VersionType is an alias for VersionTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type VersionType = VersionTypeWithAttrs

// ItemType represents the XSD type 'itemType'
// XSD complex type (W3C XSD 3.4)
// abstract="true"
type ItemType struct {
        // Status represents XSD element 'status'
        // minOccurs=0, maxOccurs=-1
        Status []StatusElement `xml:"status,omitempty"`
        // DcStatus represents XSD element 'dc-status'
        // minOccurs=0, maxOccurs=-1
        DcStatus []DcStatusType `xml:"dc-status,omitempty"`
        // Version represents XSD element 'version'
        // minOccurs=0, maxOccurs=1
        Version *VersionTypeWithAttrs `xml:"version,omitempty"`
        // Title represents XSD element 'title'
        // minOccurs=0, maxOccurs=-1
        Title []TextWithSubType `xml:"title,omitempty"`
        // Description represents XSD element 'description'
        // minOccurs=0, maxOccurs=-1
        Description []HtmlTextWithSubType `xml:"description,omitempty"`
        // Warning represents XSD element 'warning'
        // minOccurs=0, maxOccurs=-1
        Warning []WarningType `xml:"warning,omitempty"`
        // Question represents XSD element 'question'
        // minOccurs=0, maxOccurs=-1
        Question []TextTypeWithAttrs `xml:"question,omitempty"`
        // Reference represents XSD element 'reference'
        // minOccurs=0, maxOccurs=-1
        Reference []ReferenceType `xml:"reference,omitempty"`
        // Metadata represents XSD element 'metadata'
        // minOccurs=0, maxOccurs=-1
        Metadata []MetadataType `xml:"metadata,omitempty"`
        // Abstract represents XSD attribute 'abstract'
        // use="optional"
        Abstract *bool `xml:"abstract,attr,omitempty"`
        // ClusterId represents XSD attribute 'cluster-id'
        // use="optional"
        ClusterId *string `xml:"cluster-id,attr,omitempty"`
        // Extends represents XSD attribute 'extends'
        // use="optional"
        Extends *string `xml:"extends,attr,omitempty"`
        // Hidden represents XSD attribute 'hidden'
        // use="optional"
        Hidden *bool `xml:"hidden,attr,omitempty"`
        // ProhibitChanges represents XSD attribute 'prohibitChanges'
        // use="optional"
        ProhibitChanges *bool `xml:"prohibitChanges,attr,omitempty"`
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ProfileSelectType represents the XSD type 'profileSelectType'
// XSD complex type (W3C XSD 3.4)
type ProfileSelectType struct {
        // Remark represents XSD element 'remark'
        // minOccurs=0, maxOccurs=-1
        Remark []TextTypeWithAttrs `xml:"remark,omitempty"`
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref string `xml:"idref,attr"`
        // Selected represents XSD attribute 'selected'
        // use="required"
        Selected bool `xml:"selected,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TailoringVersionType represents the XSD type 'tailoringVersionType'
// XSD complex type (W3C XSD 3.4)
type TailoringVersionTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Time represents XSD attribute 'time'
        // use="required"
        Time types.DateTime `xml:"time,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TailoringVersionType is an alias for TailoringVersionTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type TailoringVersionType = TailoringVersionTypeWithAttrs

// BenchmarkElementType represents the XSD type 'BenchmarkElementType'
// XSD complex type (W3C XSD 3.4)
type BenchmarkElementType struct {
        // Status represents XSD element 'status'
        // minOccurs=1, maxOccurs=-1
        Status []StatusElement `xml:"status"`
        // DcStatus represents XSD element 'dc-status'
        // minOccurs=0, maxOccurs=-1
        DcStatus []DcStatusType `xml:"dc-status,omitempty"`
        // Title represents XSD element 'title'
        // minOccurs=0, maxOccurs=-1
        Title []TextTypeWithAttrs `xml:"title,omitempty"`
        // Description represents XSD element 'description'
        // minOccurs=0, maxOccurs=-1
        Description []HtmlTextWithSubType `xml:"description,omitempty"`
        // Notice represents XSD element 'notice'
        // minOccurs=0, maxOccurs=-1
        Notice []NoticeType `xml:"notice,omitempty"`
        // FrontMatter represents XSD element 'front-matter'
        // minOccurs=0, maxOccurs=-1
        FrontMatter []HtmlTextWithSubType `xml:"front-matter,omitempty"`
        // RearMatter represents XSD element 'rear-matter'
        // minOccurs=0, maxOccurs=-1
        RearMatter []HtmlTextWithSubType `xml:"rear-matter,omitempty"`
        // Reference represents XSD element 'reference'
        // minOccurs=0, maxOccurs=-1
        Reference []ReferenceType `xml:"reference,omitempty"`
        // PlainText represents XSD element 'plain-text'
        // minOccurs=0, maxOccurs=-1
        PlainText []PlainTextTypeWithAttrs `xml:"plain-text,omitempty"`
        // PlatformSpecification represents XSD element 'platform-specification'
        // minOccurs=0, maxOccurs=1
        PlatformSpecification *language2_0.PlatformSpecificationElement `xml:"platform-specification,omitempty"`
        // Platform represents XSD element 'platform'
        // minOccurs=0, maxOccurs=-1
        Platform []CPE2idrefType `xml:"platform,omitempty"`
        // Version represents XSD element 'version'
        Version VersionTypeWithAttrs `xml:"version"`
        // Metadata represents XSD element 'metadata'
        // minOccurs=0, maxOccurs=-1
        Metadata []MetadataType `xml:"metadata,omitempty"`
        // Model represents XSD element 'model'
        // minOccurs=0, maxOccurs=-1
        Model []ModelElement `xml:"model,omitempty"`
        // Profile represents XSD element 'Profile'
        // minOccurs=0, maxOccurs=-1
        Profile []ProfileType `xml:"Profile,omitempty"`
        // Value represents XSD element 'Value'
        // minOccurs=0, maxOccurs=-1
        Value []ValueType `xml:"Value,omitempty"`
        // TestResult represents XSD element 'TestResult'
        // minOccurs=0, maxOccurs=-1
        TestResult []TestResultType `xml:"TestResult,omitempty"`
        // Signature represents XSD element 'signature'
        // minOccurs=0, maxOccurs=1
        Signature *SignatureType `xml:"signature,omitempty"`
        // Group represents XSD element 'Group'
        Group []GroupType `xml:"Group,omitempty"`
        // Rule represents XSD element 'Rule'
        Rule []RuleType `xml:"Rule,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id BenchmarkIdType `xml:"id,attr"`
        // Id2 represents XSD attribute 'Id'
        // use="optional"
        Id2 *string `xml:"Id,attr,omitempty"`
        // Resolved represents XSD attribute 'resolved'
        // use="optional"
        Resolved *bool `xml:"resolved,attr,omitempty"`
        // Style represents XSD attribute 'style'
        // use="optional"
        Style *string `xml:"style,attr,omitempty"`
        // StyleHref represents XSD attribute 'style-href'
        // use="optional"
        StyleHref *string `xml:"style-href,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CheckContentType represents the XSD type 'checkContentType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type CheckContentType struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ValueIdType represents the XSD type 'valueIdType'
// XSD simple type (W3C XSD 4.1)
// pattern="xccdf_[^_]+_value_.+"
type ValueIdType string

// SubUseEnumType represents the XSD type 'subUseEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="value"
// enumeration="title"
// enumeration="legacy"
type SubUseEnumType string

// IdentType represents the XSD type 'identType'
// XSD complex type (W3C XSD 3.4)
type IdentTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // System represents XSD attribute 'system'
        // use="required"
        System string `xml:"system,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// IdentType is an alias for IdentTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type IdentType = IdentTypeWithAttrs

// SelComplexValueType represents the XSD type 'selComplexValueType'
// XSD complex type (W3C XSD 3.4)
type SelComplexValueType struct {
        ComplexValueType // XSD extension base
        // Selector represents XSD attribute 'selector'
        // use="optional"
        Selector *string `xml:"selector,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SelNumType represents the XSD type 'selNumType'
// XSD complex type (W3C XSD 3.4)
type SelNumTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Selector represents XSD attribute 'selector'
        // use="optional"
        Selector *string `xml:"selector,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SelNumType is an alias for SelNumTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type SelNumType = SelNumTypeWithAttrs

// ProfileType represents the XSD type 'profileType'
// XSD complex type (W3C XSD 3.4)
type ProfileType struct {
        // Status represents XSD element 'status'
        // minOccurs=0, maxOccurs=-1
        Status []StatusElement `xml:"status,omitempty"`
        // DcStatus represents XSD element 'dc-status'
        // minOccurs=0, maxOccurs=-1
        DcStatus []DcStatusType `xml:"dc-status,omitempty"`
        // Version represents XSD element 'version'
        // minOccurs=0, maxOccurs=1
        Version *VersionTypeWithAttrs `xml:"version,omitempty"`
        // Title represents XSD element 'title'
        // minOccurs=1, maxOccurs=-1
        Title []TextWithSubType `xml:"title"`
        // Description represents XSD element 'description'
        // minOccurs=0, maxOccurs=-1
        Description []HtmlTextWithSubType `xml:"description,omitempty"`
        // Reference represents XSD element 'reference'
        // minOccurs=0, maxOccurs=-1
        Reference []ReferenceType `xml:"reference,omitempty"`
        // Platform represents XSD element 'platform'
        // minOccurs=0, maxOccurs=-1
        Platform []OverrideableCPE2idrefType `xml:"platform,omitempty"`
        // Metadata represents XSD element 'metadata'
        // minOccurs=0, maxOccurs=-1
        Metadata []MetadataType `xml:"metadata,omitempty"`
        // Signature represents XSD element 'signature'
        // minOccurs=0, maxOccurs=1
        Signature *SignatureType `xml:"signature,omitempty"`
        // Select represents XSD element 'select'
        // minOccurs=0, maxOccurs=1
        Select []ProfileSelectType `xml:"select,omitempty"`
        // SetComplexValue represents XSD element 'set-complex-value'
        // minOccurs=0, maxOccurs=1
        SetComplexValue []ProfileSetComplexValueType `xml:"set-complex-value,omitempty"`
        // SetValue represents XSD element 'set-value'
        // minOccurs=0, maxOccurs=1
        SetValue []ProfileSetValueTypeWithAttrs `xml:"set-value,omitempty"`
        // RefineValue represents XSD element 'refine-value'
        // minOccurs=0, maxOccurs=1
        RefineValue []ProfileRefineValueType `xml:"refine-value,omitempty"`
        // RefineRule represents XSD element 'refine-rule'
        // minOccurs=0, maxOccurs=1
        RefineRule []ProfileRefineRuleType `xml:"refine-rule,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id ProfileIdType `xml:"id,attr"`
        // ProhibitChanges represents XSD attribute 'prohibitChanges'
        // use="optional"
        ProhibitChanges *bool `xml:"prohibitChanges,attr,omitempty"`
        // Abstract represents XSD attribute 'abstract'
        // use="optional"
        Abstract *bool `xml:"abstract,attr,omitempty"`
        // NoteTag represents XSD attribute 'note-tag'
        // use="optional"
        NoteTag *string `xml:"note-tag,attr,omitempty"`
        // Extends represents XSD attribute 'extends'
        // use="optional"
        Extends *string `xml:"extends,attr,omitempty"`
        // Id2 represents XSD attribute 'Id'
        // use="optional"
        Id2 *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TailoringReferenceType represents the XSD type 'tailoringReferenceType'
// XSD complex type (W3C XSD 3.4)
type TailoringReferenceType struct {
        // Href represents XSD attribute 'href'
        // use="required"
        Href string `xml:"href,attr"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // Version represents XSD attribute 'version'
        // use="required"
        Version string `xml:"version,attr"`
        // Time represents XSD attribute 'time'
        // use="required"
        Time types.DateTime `xml:"time,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TailoringIdType represents the XSD type 'tailoringIdType'
// XSD simple type (W3C XSD 4.1)
// pattern="xccdf_[^_]+_tailoring_.+"
type TailoringIdType string

// NoticeType represents the XSD type 'noticeType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type NoticeType struct {
        // Id represents XSD attribute 'id'
        // use="optional"
        Id       *string `xml:"id,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DcStatusType represents the XSD type 'dc-statusType'
// XSD complex type (W3C XSD 3.4)
type DcStatusType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// IdrefType represents the XSD type 'idrefType'
// XSD complex type (W3C XSD 3.4)
type IdrefType struct {
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref string `xml:"idref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SelStringType represents the XSD type 'selStringType'
// XSD complex type (W3C XSD 3.4)
type SelStringTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Selector represents XSD attribute 'selector'
        // use="optional"
        Selector *string `xml:"selector,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SelStringType is an alias for SelStringTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type SelStringType = SelStringTypeWithAttrs

// TestResultType represents the XSD type 'testResultType'
// XSD complex type (W3C XSD 3.4)
type TestResultType struct {
        // Benchmark represents XSD element 'benchmark'
        // minOccurs=0, maxOccurs=1
        Benchmark *BenchmarkReferenceType `xml:"benchmark,omitempty"`
        // TailoringFile represents XSD element 'tailoring-file'
        // minOccurs=0, maxOccurs=1
        TailoringFile *TailoringReferenceType `xml:"tailoring-file,omitempty"`
        // Title represents XSD element 'title'
        // minOccurs=0, maxOccurs=-1
        Title []TextTypeWithAttrs `xml:"title,omitempty"`
        // Remark represents XSD element 'remark'
        // minOccurs=0, maxOccurs=-1
        Remark []TextTypeWithAttrs `xml:"remark,omitempty"`
        // Organization represents XSD element 'organization'
        // minOccurs=0, maxOccurs=-1
        Organization []string `xml:"organization,omitempty"`
        // Identity represents XSD element 'identity'
        // minOccurs=0, maxOccurs=1
        Identity *IdentityTypeWithAttrs `xml:"identity,omitempty"`
        // Profile represents XSD element 'profile'
        // minOccurs=0, maxOccurs=1
        Profile *IdrefType `xml:"profile,omitempty"`
        // Target represents XSD element 'target'
        // minOccurs=1, maxOccurs=-1
        Target []string `xml:"target"`
        // TargetAddress represents XSD element 'target-address'
        // minOccurs=0, maxOccurs=-1
        TargetAddress []string `xml:"target-address,omitempty"`
        // TargetFacts represents XSD element 'target-facts'
        // minOccurs=0, maxOccurs=1
        TargetFacts *TargetFactsType `xml:"target-facts,omitempty"`
        // Platform represents XSD element 'platform'
        // minOccurs=0, maxOccurs=-1
        Platform []CPE2idrefType `xml:"platform,omitempty"`
        // RuleResult represents XSD element 'rule-result'
        // minOccurs=0, maxOccurs=-1
        RuleResult []*RuleResultType `xml:"rule-result,omitempty"`
        // Score represents XSD element 'score'
        // minOccurs=1, maxOccurs=-1
        Score []ScoreTypeWithAttrs `xml:"score"`
        // Metadata represents XSD element 'metadata'
        // minOccurs=0, maxOccurs=-1
        Metadata []MetadataType `xml:"metadata,omitempty"`
        // Signature represents XSD element 'signature'
        // minOccurs=0, maxOccurs=1
        Signature *SignatureType `xml:"signature,omitempty"`
        // TargetIdRef represents XSD element 'target-id-ref'
        TargetIdRef []TargetIdRefType `xml:"target-id-ref,omitempty"`
        // SetValue represents XSD element 'set-value'
        SetValue []ProfileSetValueTypeWithAttrs `xml:"set-value,omitempty"`
        // SetComplexValue represents XSD element 'set-complex-value'
        SetComplexValue []ProfileSetComplexValueType `xml:"set-complex-value,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id TestresultIdType `xml:"id,attr"`
        // StartTime represents XSD attribute 'start-time'
        // use="optional"
        StartTime *types.DateTime `xml:"start-time,attr,omitempty"`
        // EndTime represents XSD attribute 'end-time'
        // use="required"
        EndTime types.DateTime `xml:"end-time,attr"`
        // TestSystem represents XSD attribute 'test-system'
        // use="optional"
        TestSystem *string `xml:"test-system,attr,omitempty"`
        // Version represents XSD attribute 'version'
        // use="optional"
        Version *string `xml:"version,attr,omitempty"`
        // Id2 represents XSD attribute 'Id'
        // use="optional"
        Id2 *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TailoringBenchmarkReferenceType represents the XSD type 'tailoringBenchmarkReferenceType'
// XSD complex type (W3C XSD 3.4)
type TailoringBenchmarkReferenceType struct {
        BenchmarkReferenceType // XSD extension base
        // Version represents XSD attribute 'version'
        // use="optional"
        Version *string `xml:"version,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ModelElementType represents the XSD type 'ModelElementType'
// XSD complex type (W3C XSD 3.4)
type ModelElementType struct {
        // Param represents XSD element 'param'
        // minOccurs=0, maxOccurs=-1
        Param []ParamTypeWithAttrs `xml:"param,omitempty"`
        // System represents XSD attribute 'system'
        // use="required"
        System string `xml:"system,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RuleType represents the XSD type 'ruleType'
// XSD complex type (W3C XSD 3.4)
type RuleType struct {
        *SelectableItemType // XSD extension base
        // Ident represents XSD element 'ident'
        // minOccurs=0, maxOccurs=-1
        Ident []IdentTypeWithAttrs `xml:"ident,omitempty"`
        // ImpactMetric represents XSD element 'impact-metric'
        // minOccurs=0, maxOccurs=1
        ImpactMetric *string `xml:"impact-metric,omitempty"`
        // ProfileNote represents XSD element 'profile-note'
        // minOccurs=0, maxOccurs=-1
        ProfileNote []ProfileNoteType `xml:"profile-note,omitempty"`
        // Fixtext represents XSD element 'fixtext'
        // minOccurs=0, maxOccurs=-1
        Fixtext []FixTextType `xml:"fixtext,omitempty"`
        // Fix represents XSD element 'fix'
        // minOccurs=0, maxOccurs=-1
        Fix []FixType `xml:"fix,omitempty"`
        // Signature represents XSD element 'signature'
        // minOccurs=0, maxOccurs=1
        Signature *SignatureType `xml:"signature,omitempty"`
        // Check represents XSD element 'check'
        // minOccurs=0, maxOccurs=-1
        Check []CheckType `xml:"check,omitempty"`
        // ComplexCheck represents XSD element 'complex-check'
        // minOccurs=0, maxOccurs=1
        ComplexCheck *ComplexCheckType `xml:"complex-check,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id RuleIdType `xml:"id,attr"`
        // Role represents XSD attribute 'role'
        // use="optional"
        Role *RoleEnumType `xml:"role,attr,omitempty"`
        // Severity represents XSD attribute 'severity'
        // use="optional"
        Severity *SeverityEnumType `xml:"severity,attr,omitempty"`
        // Multiple represents XSD attribute 'multiple'
        // use="optional"
        Multiple *bool `xml:"multiple,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TargetIdRefType represents the XSD type 'targetIdRefType'
// XSD complex type (W3C XSD 3.4)
type TargetIdRefType struct {
        // System represents XSD attribute 'system'
        // use="required"
        System string `xml:"system,attr"`
        // Href represents XSD attribute 'href'
        // use="required"
        Href string `xml:"href,attr"`
        // Name represents XSD attribute 'name'
        // use="optional"
        Name *string `xml:"name,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ProfileIdType represents the XSD type 'profileIdType'
// XSD simple type (W3C XSD 4.1)
// pattern="xccdf_[^_]+_profile_.+"
type ProfileIdType string

// TestresultIdType represents the XSD type 'testresultIdType'
// XSD simple type (W3C XSD 4.1)
// pattern="xccdf_[^_]+_testresult_.+"
type TestresultIdType string

// TextType represents the XSD type 'textType'
// XSD complex type (W3C XSD 3.4)
type TextTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Override represents XSD attribute 'override'
        // use="optional"
        Override *bool `xml:"override,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TextType is an alias for TextTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type TextType = TextTypeWithAttrs

// ProfileRefineValueType represents the XSD type 'profileRefineValueType'
// XSD complex type (W3C XSD 3.4)
type ProfileRefineValueType struct {
        // Remark represents XSD element 'remark'
        // minOccurs=0, maxOccurs=-1
        Remark []TextTypeWithAttrs `xml:"remark,omitempty"`
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref string `xml:"idref,attr"`
        // Selector represents XSD attribute 'selector'
        // use="optional"
        Selector *string `xml:"selector,attr,omitempty"`
        // Operator represents XSD attribute 'operator'
        // use="optional"
        Operator *ValueOperatorType `xml:"operator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MessageType represents the XSD type 'messageType'
// XSD complex type (W3C XSD 3.4)
type MessageTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Severity represents XSD attribute 'severity'
        // use="required"
        Severity MsgSevEnumType `xml:"severity,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MessageType is an alias for MessageTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type MessageType = MessageTypeWithAttrs

// FixStrategyEnumType represents the XSD type 'fixStrategyEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="unknown"
// enumeration="configure"
// enumeration="combination"
// enumeration="disable"
// enumeration="enable"
// enumeration="patch"
// enumeration="policy"
// enumeration="restrict"
// enumeration="update"
type FixStrategyEnumType string

// RatingEnumType represents the XSD type 'ratingEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="unknown"
// enumeration="low"
// enumeration="medium"
// enumeration="high"
type RatingEnumType string

// CheckType represents the XSD type 'checkType'
// XSD complex type (W3C XSD 3.4)
type CheckType struct {
        // CheckImport represents XSD element 'check-import'
        // minOccurs=0, maxOccurs=-1
        CheckImport []CheckImportType `xml:"check-import,omitempty"`
        // CheckExport represents XSD element 'check-export'
        // minOccurs=0, maxOccurs=-1
        CheckExport []CheckExportType `xml:"check-export,omitempty"`
        // CheckContentRef represents XSD element 'check-content-ref'
        // minOccurs=0, maxOccurs=-1
        CheckContentRef []CheckContentRefType `xml:"check-content-ref,omitempty"`
        // CheckContent represents XSD element 'check-content'
        // minOccurs=0, maxOccurs=1
        CheckContent *CheckContentType `xml:"check-content,omitempty"`
        // System represents XSD attribute 'system'
        // use="required"
        System string `xml:"system,attr"`
        // Negate represents XSD attribute 'negate'
        // use="optional"
        Negate *bool `xml:"negate,attr,omitempty"`
        // Id represents XSD attribute 'id'
        // use="optional"
        Id *string `xml:"id,attr,omitempty"`
        // Selector represents XSD attribute 'selector'
        // use="optional"
        Selector *string `xml:"selector,attr,omitempty"`
        // MultiCheck represents XSD attribute 'multi-check'
        // use="optional"
        MultiCheck *bool `xml:"multi-check,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// BenchmarkIdType represents the XSD type 'benchmarkIdType'
// XSD simple type (W3C XSD 4.1)
// pattern="xccdf_[^_]+_benchmark_.+"
type BenchmarkIdType string

// PlainTextType represents the XSD type 'plainTextType'
// XSD complex type (W3C XSD 3.4)
type PlainTextTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PlainTextType is an alias for PlainTextTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type PlainTextType = PlainTextTypeWithAttrs

// ProfileNoteType represents the XSD type 'profileNoteType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ProfileNoteType struct {
        // Sub represents XSD element 'sub'
        Sub []SubType `xml:"sub,omitempty"`
        // Tag represents XSD attribute 'tag'
        // use="required"
        Tag   string `xml:"tag,attr"`
        Value string `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// WarningCategoryEnumType represents the XSD type 'warningCategoryEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="general"
// enumeration="functionality"
// enumeration="performance"
// enumeration="hardware"
// enumeration="legal"
// enumeration="regulatory"
// enumeration="management"
// enumeration="audit"
// enumeration="dependency"
type WarningCategoryEnumType string

// IdrefListType represents the XSD type 'idrefListType'
// XSD complex type (W3C XSD 3.4)
type IdrefListType struct {
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref []string `xml:"idref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// OverrideableCPE2idrefType represents the XSD type 'overrideableCPE2idrefType'
// XSD complex type (W3C XSD 3.4)
type OverrideableCPE2idrefType struct {
        CPE2idrefType // XSD extension base
        // Override represents XSD attribute 'override'
        // use="optional"
        Override *bool `xml:"override,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SelectableItemType represents the XSD type 'selectableItemType'
// XSD complex type (W3C XSD 3.4)
// abstract="true"
type SelectableItemType struct {
        ItemType // XSD extension base
        // Rationale represents XSD element 'rationale'
        // minOccurs=0, maxOccurs=-1
        Rationale []HtmlTextWithSubType `xml:"rationale,omitempty"`
        // Platform represents XSD element 'platform'
        // minOccurs=0, maxOccurs=-1
        Platform []OverrideableCPE2idrefType `xml:"platform,omitempty"`
        // Requires represents XSD element 'requires'
        // minOccurs=0, maxOccurs=-1
        Requires []IdrefListType `xml:"requires,omitempty"`
        // Conflicts represents XSD element 'conflicts'
        // minOccurs=0, maxOccurs=-1
        Conflicts []IdrefType `xml:"conflicts,omitempty"`
        // Selected represents XSD attribute 'selected'
        // use="optional"
        Selected *bool `xml:"selected,attr,omitempty"`
        // Weight represents XSD attribute 'weight'
        // use="optional"
        Weight *WeightType `xml:"weight,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SelChoicesType represents the XSD type 'selChoicesType'
// XSD complex type (W3C XSD 3.4)
type SelChoicesType struct {
        // Choice represents XSD element 'choice'
        Choice []string `xml:"choice,omitempty"`
        // ComplexChoice represents XSD element 'complex-choice'
        ComplexChoice []ComplexValueType `xml:"complex-choice,omitempty"`
        // MustMatch represents XSD attribute 'mustMatch'
        // use="optional"
        MustMatch *bool `xml:"mustMatch,attr,omitempty"`
        // Selector represents XSD attribute 'selector'
        // use="optional"
        Selector *string `xml:"selector,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ScoreType represents the XSD type 'scoreType'
// XSD complex type (W3C XSD 3.4)
type ScoreTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // System represents XSD attribute 'system'
        // use="optional"
        System *string `xml:"system,attr,omitempty"`
        // Maximum represents XSD attribute 'maximum'
        // use="optional"
        Maximum *string `xml:"maximum,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ScoreType is an alias for ScoreTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type ScoreType = ScoreTypeWithAttrs

// OverrideType represents the XSD type 'overrideType'
// XSD complex type (W3C XSD 3.4)
type OverrideType struct {
        // OldResult represents XSD element 'old-result'
        OldResult ResultEnumType `xml:"old-result"`
        // NewResult represents XSD element 'new-result'
        NewResult ResultEnumType `xml:"new-result"`
        // Remark represents XSD element 'remark'
        Remark TextTypeWithAttrs `xml:"remark"`
        // Time represents XSD attribute 'time'
        // use="required"
        Time types.DateTime `xml:"time,attr"`
        // Authority represents XSD attribute 'authority'
        // use="required"
        Authority string `xml:"authority,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// StatusType represents the XSD type 'statusType'
// XSD simple type (W3C XSD 4.1)
// enumeration="accepted"
// enumeration="deprecated"
// enumeration="draft"
// enumeration="incomplete"
// enumeration="interim"
type StatusType string

// RuleIdType represents the XSD type 'ruleIdType'
// XSD simple type (W3C XSD 4.1)
// pattern="xccdf_[^_]+_rule_.+"
type RuleIdType string

// CcOperatorEnumType represents the XSD type 'ccOperatorEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="OR"
// enumeration="AND"
type CcOperatorEnumType string

// ParamType represents the XSD type 'paramType'
// XSD complex type (W3C XSD 3.4)
type ParamTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Name represents XSD attribute 'name'
        // use="required"
        Name string `xml:"name,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ParamType is an alias for ParamTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type ParamType = ParamTypeWithAttrs

// TextWithSubType represents the XSD type 'textWithSubType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type TextWithSubType struct {
        // Sub represents XSD element 'sub'
        // minOccurs=0, maxOccurs=-1
        Sub []SubType `xml:"sub,omitempty"`
        // Override represents XSD attribute 'override'
        // use="optional"
        Override *bool  `xml:"override,attr,omitempty"`
        Value    string `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// IdentityType represents the XSD type 'identityType'
// XSD complex type (W3C XSD 3.4)
type IdentityTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Authenticated represents XSD attribute 'authenticated'
        // use="required"
        Authenticated bool `xml:"authenticated,attr"`
        // Privileged represents XSD attribute 'privileged'
        // use="required"
        Privileged bool `xml:"privileged,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// IdentityType is an alias for IdentityTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type IdentityType = IdentityTypeWithAttrs

// FixType represents the XSD type 'fixType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type FixType struct {
        // Sub represents XSD element 'sub'
        Sub []SubType `xml:"sub,omitempty"`
        // Instance represents XSD element 'instance'
        Instance []InstanceFixType `xml:"instance,omitempty"`
        // Id represents XSD attribute 'id'
        // use="optional"
        Id *string `xml:"id,attr,omitempty"`
        // Reboot represents XSD attribute 'reboot'
        // use="optional"
        Reboot *bool `xml:"reboot,attr,omitempty"`
        // Strategy represents XSD attribute 'strategy'
        // use="optional"
        Strategy *FixStrategyEnumType `xml:"strategy,attr,omitempty"`
        // Disruption represents XSD attribute 'disruption'
        // use="optional"
        Disruption *RatingEnumType `xml:"disruption,attr,omitempty"`
        // Complexity represents XSD attribute 'complexity'
        // use="optional"
        Complexity *RatingEnumType `xml:"complexity,attr,omitempty"`
        // System represents XSD attribute 'system'
        // use="optional"
        System *string `xml:"system,attr,omitempty"`
        // Platform represents XSD attribute 'platform'
        // use="optional"
        Platform *string `xml:"platform,attr,omitempty"`
        Value    string  `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MetadataType represents the XSD type 'metadataType'
// XSD complex type (W3C XSD 3.4)
type MetadataType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// InterfaceHintType represents the XSD type 'interfaceHintType'
// XSD simple type (W3C XSD 4.1)
// enumeration="choice"
// enumeration="textline"
// enumeration="text"
// enumeration="date"
// enumeration="datetime"
type InterfaceHintType string

// ReferenceType represents the XSD type 'referenceType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ReferenceType struct {
        // Href represents XSD attribute 'href'
        // use="optional"
        Href *string `xml:"href,attr,omitempty"`
        // Override represents XSD attribute 'override'
        // use="optional"
        Override *bool  `xml:"override,attr,omitempty"`
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// HtmlTextWithSubType represents the XSD type 'htmlTextWithSubType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type HtmlTextWithSubType struct {
        // Sub represents XSD element 'sub'
        Sub []SubType `xml:"sub,omitempty"`
        // Override represents XSD attribute 'override'
        // use="optional"
        Override *bool  `xml:"override,attr,omitempty"`
        Value    string `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// WarningType represents the XSD type 'warningType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type WarningType struct {
        HtmlTextWithSubType // XSD extension base
        // Category represents XSD attribute 'category'
        // use="optional"
        Category *WarningCategoryEnumType `xml:"category,attr,omitempty"`
        InnerXML string                   `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FactType represents the XSD type 'factType'
// XSD complex type (W3C XSD 3.4)
type FactTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Name represents XSD attribute 'name'
        // use="required"
        Name string `xml:"name,attr"`
        // Type represents XSD attribute 'type'
        // use="optional"
        Type *ValueTypeType `xml:"type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FactType is an alias for FactTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type FactType = FactTypeWithAttrs

// GroupIdType represents the XSD type 'groupIdType'
// XSD simple type (W3C XSD 4.1)
// pattern="xccdf_[^_]+_group_.+"
type GroupIdType string

// WeightType represents the XSD type 'weightType'
// XSD simple type (W3C XSD 4.1)
// minInclusive="0.0"
// totalDigits="3"
type WeightType string

// CPE2idrefType represents the XSD type 'CPE2idrefType'
// XSD complex type (W3C XSD 3.4)
type CPE2idrefType struct {
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref string `xml:"idref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// GroupType represents the XSD type 'groupType'
// XSD complex type (W3C XSD 3.4)
type GroupType struct {
        *SelectableItemType // XSD extension base
        // Value represents XSD element 'Value'
        // minOccurs=0, maxOccurs=-1
        Value []ValueType `xml:"Value,omitempty"`
        // Signature represents XSD element 'signature'
        // minOccurs=0, maxOccurs=1
        Signature *SignatureType `xml:"signature,omitempty"`
        // Group represents XSD element 'Group'
        Group []*GroupType `xml:"Group,omitempty"`
        // Rule represents XSD element 'Rule'
        Rule []*RuleType `xml:"Rule,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id GroupIdType `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ComplexCheckType represents the XSD type 'complexCheckType'
// XSD complex type (W3C XSD 3.4)
type ComplexCheckType struct {
        // Check represents XSD element 'check'
        Check []CheckType `xml:"check,omitempty"`
        // ComplexCheck represents XSD element 'complex-check'
        ComplexCheck []*ComplexCheckType `xml:"complex-check,omitempty"`
        // Operator represents XSD attribute 'operator'
        // use="required"
        Operator CcOperatorEnumType `xml:"operator,attr"`
        // Negate represents XSD attribute 'negate'
        // use="optional"
        Negate *bool `xml:"negate,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// UriRefType represents the XSD type 'uriRefType'
// XSD complex type (W3C XSD 3.4)
type UriRefType struct {
        // Uri represents XSD attribute 'uri'
        // use="required"
        Uri string `xml:"uri,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// StatusElementType represents the XSD type 'StatusElementType'
// XSD complex type (W3C XSD 3.4)
type StatusElementTypeWithAttrs struct {
        Value StatusType `xml:",chardata"` // XSD simple content
        // Date represents XSD attribute 'date'
        // use="optional"
        Date *types.DateTime `xml:"date,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// StatusElementType is an alias for StatusElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type StatusElementType = StatusElementTypeWithAttrs

// HtmlTextType represents the XSD type 'htmlTextType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type HtmlTextType struct {
        // Override represents XSD attribute 'override'
        // use="optional"
        Override *bool  `xml:"override,attr,omitempty"`
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ProfileSetValueType represents the XSD type 'profileSetValueType'
// XSD complex type (W3C XSD 3.4)
type ProfileSetValueTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref string `xml:"idref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ProfileSetValueType is an alias for ProfileSetValueTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type ProfileSetValueType = ProfileSetValueTypeWithAttrs

// TargetFactsType represents the XSD type 'targetFactsType'
// XSD complex type (W3C XSD 3.4)
type TargetFactsType struct {
        // Fact represents XSD element 'fact'
        // minOccurs=0, maxOccurs=-1
        Fact []FactTypeWithAttrs `xml:"fact,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SubType represents the XSD type 'subType'
// XSD complex type (W3C XSD 3.4)
type SubType struct {
        IdrefType // XSD extension base
        // Use represents XSD attribute 'use'
        // use="optional"
        Use *SubUseEnumType `xml:"use,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// InstanceFixType represents the XSD type 'instanceFixType'
// XSD complex type (W3C XSD 3.4)
type InstanceFixType struct {
        // Context represents XSD attribute 'context'
        // use="optional"
        Context *string `xml:"context,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CheckContentRefType represents the XSD type 'checkContentRefType'
// XSD complex type (W3C XSD 3.4)
type CheckContentRefType struct {
        // Href represents XSD attribute 'href'
        // use="required"
        Href string `xml:"href,attr"`
        // Name represents XSD attribute 'name'
        // use="optional"
        Name *string `xml:"name,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RuleResultType represents the XSD type 'ruleResultType'
// XSD complex type (W3C XSD 3.4)
type RuleResultType struct {
        // Result represents XSD element 'result'
        Result ResultEnumType `xml:"result"`
        // Override represents XSD element 'override'
        // minOccurs=0, maxOccurs=-1
        Override []OverrideType `xml:"override,omitempty"`
        // Ident represents XSD element 'ident'
        // minOccurs=0, maxOccurs=-1
        Ident []IdentTypeWithAttrs `xml:"ident,omitempty"`
        // Metadata represents XSD element 'metadata'
        // minOccurs=0, maxOccurs=-1
        Metadata []MetadataType `xml:"metadata,omitempty"`
        // Message represents XSD element 'message'
        // minOccurs=0, maxOccurs=-1
        Message []MessageTypeWithAttrs `xml:"message,omitempty"`
        // Instance represents XSD element 'instance'
        // minOccurs=0, maxOccurs=-1
        Instance []InstanceResultTypeWithAttrs `xml:"instance,omitempty"`
        // Fix represents XSD element 'fix'
        // minOccurs=0, maxOccurs=-1
        Fix []FixType `xml:"fix,omitempty"`
        // Check represents XSD element 'check'
        // minOccurs=0, maxOccurs=-1
        Check []CheckType `xml:"check,omitempty"`
        // ComplexCheck represents XSD element 'complex-check'
        // minOccurs=0, maxOccurs=1
        ComplexCheck *ComplexCheckType `xml:"complex-check,omitempty"`
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref string `xml:"idref,attr"`
        // Role represents XSD attribute 'role'
        // use="optional"
        Role *RoleEnumType `xml:"role,attr,omitempty"`
        // Severity represents XSD attribute 'severity'
        // use="optional"
        Severity *SeverityEnumType `xml:"severity,attr,omitempty"`
        // Time represents XSD attribute 'time'
        // use="optional"
        Time *types.DateTime `xml:"time,attr,omitempty"`
        // Version represents XSD attribute 'version'
        // use="optional"
        Version *string `xml:"version,attr,omitempty"`
        // Weight represents XSD attribute 'weight'
        // use="optional"
        Weight *WeightType `xml:"weight,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ValueTypeType represents the XSD type 'valueTypeType'
// XSD simple type (W3C XSD 4.1)
// enumeration="number"
// enumeration="string"
// enumeration="boolean"
type ValueTypeType string

// SeverityEnumType represents the XSD type 'severityEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="unknown"
// enumeration="info"
// enumeration="low"
// enumeration="medium"
// enumeration="high"
type SeverityEnumType string

// CheckImportType represents the XSD type 'checkImportType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type CheckImportType struct {
        // ImportName represents XSD attribute 'import-name'
        // use="required"
        ImportName string `xml:"import-name,attr"`
        // ImportXpath represents XSD attribute 'import-xpath'
        // use="optional"
        ImportXpath *string `xml:"import-xpath,attr,omitempty"`
        InnerXML    string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ProfileRefineRuleType represents the XSD type 'profileRefineRuleType'
// XSD complex type (W3C XSD 3.4)
type ProfileRefineRuleType struct {
        // Remark represents XSD element 'remark'
        // minOccurs=0, maxOccurs=-1
        Remark []TextTypeWithAttrs `xml:"remark,omitempty"`
        // Idref represents XSD attribute 'idref'
        // use="required"
        Idref string `xml:"idref,attr"`
        // Weight represents XSD attribute 'weight'
        // use="optional"
        Weight *WeightType `xml:"weight,attr,omitempty"`
        // Selector represents XSD attribute 'selector'
        // use="optional"
        Selector *string `xml:"selector,attr,omitempty"`
        // Severity represents XSD attribute 'severity'
        // use="optional"
        Severity *SeverityEnumType `xml:"severity,attr,omitempty"`
        // Role represents XSD attribute 'role'
        // use="optional"
        Role *RoleEnumType `xml:"role,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// BenchmarkReferenceType represents the XSD type 'benchmarkReferenceType'
// XSD complex type (W3C XSD 3.4)
type BenchmarkReferenceType struct {
        // Href represents XSD attribute 'href'
        // use="required"
        Href string `xml:"href,attr"`
        // Id represents XSD attribute 'id'
        // use="optional"
        Id *string `xml:"id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TailoringType represents the XSD type 'tailoringType'
// XSD complex type (W3C XSD 3.4)
type TailoringType struct {
        // Benchmark represents XSD element 'benchmark'
        // minOccurs=0, maxOccurs=1
        Benchmark *TailoringBenchmarkReferenceType `xml:"benchmark,omitempty"`
        // Status represents XSD element 'status'
        // minOccurs=0, maxOccurs=-1
        Status []StatusElement `xml:"status,omitempty"`
        // DcStatus represents XSD element 'dc-status'
        // minOccurs=0, maxOccurs=-1
        DcStatus []DcStatusType `xml:"dc-status,omitempty"`
        // Version represents XSD element 'version'
        Version TailoringVersionTypeWithAttrs `xml:"version"`
        // Metadata represents XSD element 'metadata'
        // minOccurs=0, maxOccurs=-1
        Metadata []MetadataType `xml:"metadata,omitempty"`
        // Profile represents XSD element 'Profile'
        // minOccurs=1, maxOccurs=-1
        Profile []ProfileType `xml:"Profile"`
        // Signature represents XSD element 'signature'
        // minOccurs=0, maxOccurs=1
        Signature *SignatureType `xml:"signature,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id TailoringIdType `xml:"id,attr"`
        // Id2 represents XSD attribute 'Id'
        // use="optional"
        Id2 *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ValueOperatorType represents the XSD type 'valueOperatorType'
// XSD simple type (W3C XSD 4.1)
// enumeration="equals"
// enumeration="not equal"
// enumeration="greater than"
// enumeration="less than"
// enumeration="greater than or equal"
// enumeration="less than or equal"
// enumeration="pattern match"
type ValueOperatorType string

// MsgSevEnumType represents the XSD type 'msgSevEnumType'
// XSD simple type (W3C XSD 4.1)
// enumeration="error"
// enumeration="warning"
// enumeration="info"
type MsgSevEnumType string
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package asset_identification1_1 generated from XSD schema
// Source namespace: http://scap.nist.gov/schema/asset-identification/1.1
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/asset-identification_1.1.0.xsd
// Generated by forgexml - Do not edit manually

package asset_identification1_1

import (
        "encoding/xml"
        "os"
        "strings"

        pkg_2_01 "github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xal/2-0"
)

// CircuitElement represents the XSD element 'circuit'
// XSD element declaration (W3C XSD 3.3)
type CircuitElement struct {
        XMLName     xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 circuit"`
        CircuitType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *CircuitElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias CircuitElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *CircuitElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias CircuitElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *CircuitElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *CircuitElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *CircuitElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *CircuitElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *CircuitElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadCircuitFromBytes loads an element from bytes with namespace preservation
func LoadCircuitFromBytes(data []byte) (*CircuitElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element CircuitElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadCircuitFromFile loads an element from a file with namespace preservation
func LoadCircuitFromFile(path string) (*CircuitElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadCircuitFromBytes(data)</span>
}

// DataElement represents the XSD element 'data'
// XSD element declaration (W3C XSD 3.3)
type DataElement struct {
        XMLName  xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 data"`
        DataType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *DataElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias DataElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *DataElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias DataElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *DataElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *DataElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *DataElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *DataElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *DataElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadDataFromBytes loads an element from bytes with namespace preservation
func LoadDataFromBytes(data []byte) (*DataElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element DataElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadDataFromFile loads an element from a file with namespace preservation
func LoadDataFromFile(path string) (*DataElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadDataFromBytes(data)</span>
}

// OrganizationElement represents the XSD element 'organization'
// XSD element declaration (W3C XSD 3.3)
type OrganizationElement struct {
        XMLName          xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 organization"`
        OrganizationType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *OrganizationElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias OrganizationElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *OrganizationElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias OrganizationElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *OrganizationElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *OrganizationElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *OrganizationElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *OrganizationElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *OrganizationElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadOrganizationFromBytes loads an element from bytes with namespace preservation
func LoadOrganizationFromBytes(data []byte) (*OrganizationElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element OrganizationElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadOrganizationFromFile loads an element from a file with namespace preservation
func LoadOrganizationFromFile(path string) (*OrganizationElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadOrganizationFromBytes(data)</span>
}

// SoftwareElement represents the XSD element 'software'
// XSD element declaration (W3C XSD 3.3)
type SoftwareElement struct {
        XMLName      xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 software"`
        SoftwareType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SoftwareElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SoftwareElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SoftwareElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SoftwareElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SoftwareElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SoftwareElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SoftwareElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SoftwareElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SoftwareElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSoftwareFromBytes loads an element from bytes with namespace preservation
func LoadSoftwareFromBytes(data []byte) (*SoftwareElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SoftwareElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSoftwareFromFile loads an element from a file with namespace preservation
func LoadSoftwareFromFile(path string) (*SoftwareElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSoftwareFromBytes(data)</span>
}

// CpeElement represents the XSD element 'cpe'
// XSD element declaration (W3C XSD 3.3)
type CpeElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 cpe"`
        CpeType          // XSD extension base
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *CpeElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias CpeElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *CpeElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias CpeElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *CpeElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *CpeElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *CpeElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *CpeElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *CpeElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadCpeFromBytes loads an element from bytes with namespace preservation
func LoadCpeFromBytes(data []byte) (*CpeElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element CpeElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadCpeFromFile loads an element from a file with namespace preservation
func LoadCpeFromFile(path string) (*CpeElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadCpeFromBytes(data)</span>
}

// EmailAddressElement represents the XSD element 'email-address'
// XSD element declaration (W3C XSD 3.3)
type EmailAddressElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 email-address"`
        Value   string   `xml:",chardata"` // XSD simpleContent from token
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *EmailAddressElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias EmailAddressElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *EmailAddressElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias EmailAddressElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *EmailAddressElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *EmailAddressElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *EmailAddressElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *EmailAddressElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *EmailAddressElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadEmailAddressFromBytes loads an element from bytes with namespace preservation
func LoadEmailAddressFromBytes(data []byte) (*EmailAddressElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element EmailAddressElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadEmailAddressFromFile loads an element from a file with namespace preservation
func LoadEmailAddressFromFile(path string) (*EmailAddressElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadEmailAddressFromBytes(data)</span>
}

// FqdnElement represents the XSD element 'fqdn'
// XSD element declaration (W3C XSD 3.3)
type FqdnElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 fqdn"`
        Value   string   `xml:",chardata"` // XSD simpleContent from token
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *FqdnElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias FqdnElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *FqdnElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias FqdnElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *FqdnElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *FqdnElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *FqdnElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *FqdnElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *FqdnElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadFqdnFromBytes loads an element from bytes with namespace preservation
func LoadFqdnFromBytes(data []byte) (*FqdnElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element FqdnElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadFqdnFromFile loads an element from a file with namespace preservation
func LoadFqdnFromFile(path string) (*FqdnElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadFqdnFromBytes(data)</span>
}

// DatabaseElement represents the XSD element 'database'
// XSD element declaration (W3C XSD 3.3)
type DatabaseElement struct {
        XMLName      xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 database"`
        DatabaseType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *DatabaseElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias DatabaseElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *DatabaseElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias DatabaseElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *DatabaseElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *DatabaseElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *DatabaseElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *DatabaseElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *DatabaseElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadDatabaseFromBytes loads an element from bytes with namespace preservation
func LoadDatabaseFromBytes(data []byte) (*DatabaseElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element DatabaseElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadDatabaseFromFile loads an element from a file with namespace preservation
func LoadDatabaseFromFile(path string) (*DatabaseElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadDatabaseFromBytes(data)</span>
}

// PersonElement represents the XSD element 'person'
// XSD element declaration (W3C XSD 3.3)
type PersonElement struct {
        XMLName    xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 person"`
        PersonType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PersonElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PersonElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PersonElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PersonElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PersonElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PersonElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PersonElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PersonElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PersonElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPersonFromBytes loads an element from bytes with namespace preservation
func LoadPersonFromBytes(data []byte) (*PersonElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PersonElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPersonFromFile loads an element from a file with namespace preservation
func LoadPersonFromFile(path string) (*PersonElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPersonFromBytes(data)</span>
}

// IpAddressElement represents the XSD element 'ip-address'
// XSD element declaration (W3C XSD 3.3)
type IpAddressElement struct {
        XMLName       xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 ip-address"`
        IpAddressType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *IpAddressElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias IpAddressElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *IpAddressElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias IpAddressElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *IpAddressElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *IpAddressElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *IpAddressElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *IpAddressElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *IpAddressElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadIpAddressFromBytes loads an element from bytes with namespace preservation
func LoadIpAddressFromBytes(data []byte) (*IpAddressElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element IpAddressElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadIpAddressFromFile loads an element from a file with namespace preservation
func LoadIpAddressFromFile(path string) (*IpAddressElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadIpAddressFromBytes(data)</span>
}

// LocationAddressElement represents the XSD element 'location-address'
// XSD element declaration (W3C XSD 3.3)
type LocationAddressElement struct {
        XMLName                 xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-address"`
        pkg_2_01.AddressDetails          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *LocationAddressElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias LocationAddressElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *LocationAddressElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias LocationAddressElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *LocationAddressElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *LocationAddressElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *LocationAddressElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *LocationAddressElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *LocationAddressElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadLocationAddressFromBytes loads an element from bytes with namespace preservation
func LoadLocationAddressFromBytes(data []byte) (*LocationAddressElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element LocationAddressElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadLocationAddressFromFile loads an element from a file with namespace preservation
func LoadLocationAddressFromFile(path string) (*LocationAddressElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadLocationAddressFromBytes(data)</span>
}

// LocationsElement represents the XSD element 'locations'
// XSD element declaration (W3C XSD 3.3)
type LocationsElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 locations"`
        // X1_1LocationAddress represents substitution group member 'location-address' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'location'
        X1_1LocationAddress []pkg_2_01.AddressDetails `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-address,omitempty"`
        // X1_1LocationRegion represents substitution group member 'location-region' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'location'
        X1_1LocationRegion []LocationRegionElement `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-region,omitempty"`
        // X1_1LocationPoint represents substitution group member 'location-point' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'location'
        X1_1LocationPoint []LocationPointElement `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-point,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *LocationsElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias LocationsElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *LocationsElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias LocationsElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *LocationsElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *LocationsElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *LocationsElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *LocationsElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *LocationsElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadLocationsFromBytes loads an element from bytes with namespace preservation
func LoadLocationsFromBytes(data []byte) (*LocationsElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element LocationsElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadLocationsFromFile loads an element from a file with namespace preservation
func LoadLocationsFromFile(path string) (*LocationsElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadLocationsFromBytes(data)</span>
}

// ServedByElement represents the XSD element 'served-by'
// XSD element declaration (W3C XSD 3.3)
type ServedByElement struct {
        XMLName     xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 served-by"`
        ServiceType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ServedByElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ServedByElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ServedByElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ServedByElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ServedByElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ServedByElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ServedByElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ServedByElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ServedByElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadServedByFromBytes loads an element from bytes with namespace preservation
func LoadServedByFromBytes(data []byte) (*ServedByElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ServedByElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadServedByFromFile loads an element from a file with namespace preservation
func LoadServedByFromFile(path string) (*ServedByElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadServedByFromBytes(data)</span>
}

// TelephoneNumberElement represents the XSD element 'telephone-number'
// XSD element declaration (W3C XSD 3.3)
type TelephoneNumberElement struct {
        XMLName xml.Name            `xml:"http://scap.nist.gov/schema/asset-identification/1.1 telephone-number"`
        Value   TelephoneNumberType `xml:",chardata"` // XSD simpleContent from telephone-number-type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *TelephoneNumberElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias TelephoneNumberElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *TelephoneNumberElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias TelephoneNumberElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *TelephoneNumberElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *TelephoneNumberElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *TelephoneNumberElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *TelephoneNumberElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *TelephoneNumberElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadTelephoneNumberFromBytes loads an element from bytes with namespace preservation
func LoadTelephoneNumberFromBytes(data []byte) (*TelephoneNumberElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element TelephoneNumberElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadTelephoneNumberFromFile loads an element from a file with namespace preservation
func LoadTelephoneNumberFromFile(path string) (*TelephoneNumberElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadTelephoneNumberFromBytes(data)</span>
}

// WebsiteUrlElement represents the XSD element 'website-url'
// XSD element declaration (W3C XSD 3.3)
type WebsiteUrlElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 website-url"`
        Value   string   `xml:",chardata"` // XSD simpleContent from anyURI
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *WebsiteUrlElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias WebsiteUrlElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *WebsiteUrlElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias WebsiteUrlElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *WebsiteUrlElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *WebsiteUrlElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *WebsiteUrlElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *WebsiteUrlElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *WebsiteUrlElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadWebsiteUrlFromBytes loads an element from bytes with namespace preservation
func LoadWebsiteUrlFromBytes(data []byte) (*WebsiteUrlElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element WebsiteUrlElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadWebsiteUrlFromFile loads an element from a file with namespace preservation
func LoadWebsiteUrlFromFile(path string) (*WebsiteUrlElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadWebsiteUrlFromBytes(data)</span>
}

// AssetElement represents the XSD element 'asset'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type AssetElement struct {
        XMLName   xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 asset"`
        AssetType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *AssetElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias AssetElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *AssetElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias AssetElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *AssetElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *AssetElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *AssetElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *AssetElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *AssetElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadAssetFromBytes loads an element from bytes with namespace preservation
func LoadAssetFromBytes(data []byte) (*AssetElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element AssetElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadAssetFromFile loads an element from a file with namespace preservation
func LoadAssetFromFile(path string) (*AssetElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadAssetFromBytes(data)</span>
}

// ComputingDeviceElement represents the XSD element 'computing-device'
// XSD element declaration (W3C XSD 3.3)
type ComputingDeviceElement struct {
        XMLName             xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 computing-device"`
        ComputingDeviceType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ComputingDeviceElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ComputingDeviceElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ComputingDeviceElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ComputingDeviceElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ComputingDeviceElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ComputingDeviceElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ComputingDeviceElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ComputingDeviceElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ComputingDeviceElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadComputingDeviceFromBytes loads an element from bytes with namespace preservation
func LoadComputingDeviceFromBytes(data []byte) (*ComputingDeviceElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ComputingDeviceElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadComputingDeviceFromFile loads an element from a file with namespace preservation
func LoadComputingDeviceFromFile(path string) (*ComputingDeviceElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadComputingDeviceFromBytes(data)</span>
}

// SyntheticIdElement represents the XSD element 'synthetic-id'
// XSD element declaration (W3C XSD 3.3)
type SyntheticIdElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 synthetic-id"`
        // Resource represents XSD attribute 'resource'
        // use="required"
        Resource string `xml:"resource,attr"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SyntheticIdElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SyntheticIdElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SyntheticIdElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SyntheticIdElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SyntheticIdElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SyntheticIdElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SyntheticIdElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SyntheticIdElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SyntheticIdElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSyntheticIdFromBytes loads an element from bytes with namespace preservation
func LoadSyntheticIdFromBytes(data []byte) (*SyntheticIdElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SyntheticIdElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSyntheticIdFromFile loads an element from a file with namespace preservation
func LoadSyntheticIdFromFile(path string) (*SyntheticIdElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSyntheticIdFromBytes(data)</span>
}

// LocationRegionElement represents the XSD element 'location-region'
// XSD element declaration (W3C XSD 3.3)
type LocationRegionElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-region"`
        Value   string   `xml:",chardata"` // XSD simpleContent from normalizedString
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *LocationRegionElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias LocationRegionElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *LocationRegionElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias LocationRegionElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *LocationRegionElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *LocationRegionElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *LocationRegionElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *LocationRegionElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *LocationRegionElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadLocationRegionFromBytes loads an element from bytes with namespace preservation
func LoadLocationRegionFromBytes(data []byte) (*LocationRegionElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element LocationRegionElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadLocationRegionFromFile loads an element from a file with namespace preservation
func LoadLocationRegionFromFile(path string) (*LocationRegionElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadLocationRegionFromBytes(data)</span>
}

// AssetsElement represents the XSD element 'assets'
// XSD element declaration (W3C XSD 3.3)
type AssetsElement struct {
        XMLName    xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 assets"`
        AssetsType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *AssetsElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias AssetsElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *AssetsElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias AssetsElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *AssetsElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *AssetsElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *AssetsElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *AssetsElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *AssetsElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadAssetsFromBytes loads an element from bytes with namespace preservation
func LoadAssetsFromBytes(data []byte) (*AssetsElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element AssetsElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadAssetsFromFile loads an element from a file with namespace preservation
func LoadAssetsFromFile(path string) (*AssetsElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadAssetsFromBytes(data)</span>
}

// ItAssetElement represents the XSD element 'it-asset'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type ItAssetElement struct {
        XMLName     xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 it-asset"`
        ItAssetType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ItAssetElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias ItAssetElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ItAssetElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias ItAssetElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ItAssetElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ItAssetElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ItAssetElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ItAssetElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ItAssetElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadItAssetFromBytes loads an element from bytes with namespace preservation
func LoadItAssetFromBytes(data []byte) (*ItAssetElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ItAssetElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadItAssetFromFile loads an element from a file with namespace preservation
func LoadItAssetFromFile(path string) (*ItAssetElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadItAssetFromBytes(data)</span>
}

// NetworkElement represents the XSD element 'network'
// XSD element declaration (W3C XSD 3.3)
type NetworkElement struct {
        XMLName     xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 network"`
        NetworkType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *NetworkElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias NetworkElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *NetworkElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias NetworkElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *NetworkElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *NetworkElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *NetworkElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *NetworkElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *NetworkElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadNetworkFromBytes loads an element from bytes with namespace preservation
func LoadNetworkFromBytes(data []byte) (*NetworkElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element NetworkElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadNetworkFromFile loads an element from a file with namespace preservation
func LoadNetworkFromFile(path string) (*NetworkElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadNetworkFromBytes(data)</span>
}

// ServiceElement represents the XSD element 'service'
// XSD element declaration (W3C XSD 3.3)
type ServiceElement struct {
        XMLName     xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 service"`
        ServiceType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ServiceElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ServiceElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ServiceElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ServiceElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ServiceElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ServiceElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ServiceElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ServiceElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ServiceElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadServiceFromBytes loads an element from bytes with namespace preservation
func LoadServiceFromBytes(data []byte) (*ServiceElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ServiceElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadServiceFromFile loads an element from a file with namespace preservation
func LoadServiceFromFile(path string) (*ServiceElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadServiceFromBytes(data)</span>
}

// SystemElement represents the XSD element 'system'
// XSD element declaration (W3C XSD 3.3)
type SystemElement struct {
        XMLName    xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 system"`
        SystemType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SystemElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SystemElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SystemElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SystemElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SystemElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SystemElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SystemElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SystemElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SystemElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSystemFromBytes loads an element from bytes with namespace preservation
func LoadSystemFromBytes(data []byte) (*SystemElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SystemElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSystemFromFile loads an element from a file with namespace preservation
func LoadSystemFromFile(path string) (*SystemElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSystemFromBytes(data)</span>
}

// WebsiteElement represents the XSD element 'website'
// XSD element declaration (W3C XSD 3.3)
type WebsiteElement struct {
        XMLName     xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 website"`
        WebsiteType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *WebsiteElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias WebsiteElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *WebsiteElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias WebsiteElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *WebsiteElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *WebsiteElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *WebsiteElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *WebsiteElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *WebsiteElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadWebsiteFromBytes loads an element from bytes with namespace preservation
func LoadWebsiteFromBytes(data []byte) (*WebsiteElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element WebsiteElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadWebsiteFromFile loads an element from a file with namespace preservation
func LoadWebsiteFromFile(path string) (*WebsiteElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadWebsiteFromBytes(data)</span>
}

// LocationElement represents the XSD element 'location'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type LocationElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *LocationElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias LocationElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *LocationElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias LocationElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *LocationElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *LocationElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *LocationElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *LocationElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *LocationElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadLocationFromBytes loads an element from bytes with namespace preservation
func LoadLocationFromBytes(data []byte) (*LocationElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element LocationElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadLocationFromFile loads an element from a file with namespace preservation
func LoadLocationFromFile(path string) (*LocationElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadLocationFromBytes(data)</span>
}

// LocationPointElement represents the XSD element 'location-point'
// XSD element declaration (W3C XSD 3.3)
type LocationPointElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-point"`
        // Latitude represents XSD attribute 'latitude'
        // use="required"
        Latitude string `xml:"latitude,attr"`
        // Longitude represents XSD attribute 'longitude'
        // use="required"
        Longitude string `xml:"longitude,attr"`
        // Elevation represents XSD attribute 'elevation'
        // use="optional"
        Elevation *float64 `xml:"elevation,attr,omitempty"`
        // Radius represents XSD attribute 'radius'
        // use="optional"
        Radius *string `xml:"radius,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *LocationPointElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias LocationPointElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *LocationPointElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias LocationPointElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *LocationPointElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *LocationPointElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *LocationPointElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *LocationPointElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *LocationPointElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadLocationPointFromBytes loads an element from bytes with namespace preservation
func LoadLocationPointFromBytes(data []byte) (*LocationPointElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element LocationPointElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadLocationPointFromFile loads an element from a file with namespace preservation
func LoadLocationPointFromFile(path string) (*LocationPointElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadLocationPointFromBytes(data)</span>
}

// AssetRelatedElement represents the XSD element 'asset-related'
// XSD element declaration (W3C XSD 3.3)
type AssetRelatedElement struct {
        XMLName                 xml.Name `xml:"http://scap.nist.gov/schema/asset-identification/1.1 asset-related"`
        AssetIdentificationType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *AssetRelatedElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias AssetRelatedElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *AssetRelatedElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias AssetRelatedElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *AssetRelatedElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *AssetRelatedElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *AssetRelatedElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *AssetRelatedElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *AssetRelatedElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadAssetRelatedFromBytes loads an element from bytes with namespace preservation
func LoadAssetRelatedFromBytes(data []byte) (*AssetRelatedElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element AssetRelatedElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadAssetRelatedFromFile loads an element from a file with namespace preservation
func LoadAssetRelatedFromFile(path string) (*AssetRelatedElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadAssetRelatedFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package asset_identification1_1 generated from XSD schema
// Source namespace: http://scap.nist.gov/schema/asset-identification/1.1
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/asset-identification_1.1.0.xsd
// Generated by forgexml - Do not edit manually

package asset_identification1_1

import (
        "encoding/xml"
        "regexp"
        "strings"

        reporting_core1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1"
        pkg_2_01 "github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xal/2-0"
        pkg_2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/oasis/names/tc/ciq/xsdschema/xnl/2-0"
        types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// InstanceNameElementType represents the XSD type 'InstanceNameElementType'
// XSD complex type (W3C XSD 3.4)
type InstanceNameElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// InstanceNameElementType is an alias for InstanceNameElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type InstanceNameElementType = InstanceNameElementTypeWithAttrs

// InstallationIdElementType represents the XSD type 'InstallationIdElementType'
// XSD complex type (W3C XSD 3.4)
type InstallationIdElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// InstallationIdElementType is an alias for InstallationIdElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type InstallationIdElementType = InstallationIdElementTypeWithAttrs

// ProtocolElementType represents the XSD type 'ProtocolElementType'
// XSD complex type (W3C XSD 3.4)
type ProtocolElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ProtocolElementType is an alias for ProtocolElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type ProtocolElementType = ProtocolElementTypeWithAttrs

// BirthdateElementType represents the XSD type 'BirthdateElementType'
// XSD complex type (W3C XSD 3.4)
type BirthdateElementTypeWithAttrs struct {
        Value types.DateTime `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// BirthdateElementType is an alias for BirthdateElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type BirthdateElementType = BirthdateElementTypeWithAttrs

// LicenseElementType represents the XSD type 'LicenseElementType'
// XSD complex type (W3C XSD 3.4)
type LicenseElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LicenseElementType is an alias for LicenseElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type LicenseElementType = LicenseElementTypeWithAttrs

// DocumentRootElementType represents the XSD type 'DocumentRootElementType'
// XSD complex type (W3C XSD 3.4)
type DocumentRootElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DocumentRootElementType is an alias for DocumentRootElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type DocumentRootElementType = DocumentRootElementTypeWithAttrs

// NetworkType represents the XSD type 'network-type'
// XSD complex type (W3C XSD 3.4)
type NetworkType struct {
        ItAssetType // XSD extension base
        // NetworkName represents XSD element 'network-name'
        // minOccurs=0, maxOccurs=1
        NetworkName *NetworkNameElementType `xml:"network-name,omitempty"`
        // IpNetRange represents XSD element 'ip-net-range'
        IpNetRange *IpNetRangeElementType `xml:"ip-net-range,omitempty"`
        // Cidr represents XSD element 'cidr'
        Cidr *CidrElementType `xml:"cidr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SoftwareType represents the XSD type 'software-type'
// XSD complex type (W3C XSD 3.4)
type SoftwareType struct {
        ItAssetType // XSD extension base
        // InstallationId represents XSD element 'installation-id'
        // minOccurs=0, maxOccurs=1
        InstallationId *InstallationIdElementType `xml:"installation-id,omitempty"`
        // Cpe represents XSD element 'cpe'
        // minOccurs=0, maxOccurs=1
        Cpe *CpeElement `xml:"cpe,omitempty"`
        // License represents XSD element 'license'
        // minOccurs=0, maxOccurs=-1
        License []LicenseElementType `xml:"license,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// WebsiteType represents the XSD type 'website-type'
// XSD complex type (W3C XSD 3.4)
type WebsiteType struct {
        ItAssetType // XSD extension base
        // DocumentRoot represents XSD element 'document-root'
        // minOccurs=0, maxOccurs=1
        DocumentRoot *DocumentRootElementType `xml:"document-root,omitempty"`
        // Locale represents XSD element 'locale'
        // minOccurs=0, maxOccurs=1
        Locale *LocaleElementType `xml:"locale,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CidrType represents the XSD type 'cidr-type'
// XSD simple type (W3C XSD 4.1)
// pattern="([0-9]|[1-9][0-9]|1([0-9][0-9])|2([0-4][0-9]|5[0-5]))\.([0-9]|[1-9][0-9]|1([0-9][0-9])|2([0-4][0-9]|5[0-5]))\.([0-9]|[1-9][0-9]|1([0-9][0-9])|2([0-4][0-9]|5[0-5]))\.([0-9]|[1-9][0-9]|1([0-9][0-9])|2([0-4][0-9]|5[0-5]))/([0-9]|[1-2][0-9]|3[0-2])"
type CidrType string

// IpAddressType represents the XSD type 'ip-address-type'
// XSD complex type (W3C XSD 3.4)
type IpAddressType struct {
        // IpV4 represents XSD element 'ip-v4'
        // minOccurs=0, maxOccurs=1
        IpV4 *IpV4ElementType `xml:"ip-v4,omitempty"`
        // IpV6 represents XSD element 'ip-v6'
        // minOccurs=0, maxOccurs=1
        IpV6 *IpV6ElementType `xml:"ip-v6,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LocationsElementType represents the XSD type 'LocationsElementType'
// XSD complex type (W3C XSD 3.4)
type LocationsElementType struct {
        // X1_1LocationRegion represents substitution group member 'location-region' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'location'
        X1_1LocationRegion []LocationRegionElement `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-region,omitempty"`
        // X1_1LocationPoint represents substitution group member 'location-point' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'location'
        X1_1LocationPoint []LocationPointElement `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-point,omitempty"`
        // X1_1LocationAddress represents substitution group member 'location-address' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'location'
        X1_1LocationAddress []pkg_2_01.AddressDetails `xml:"http://scap.nist.gov/schema/asset-identification/1.1 location-address,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// UrlElementType represents the XSD type 'UrlElementType'
// XSD complex type (W3C XSD 3.4)
type UrlElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// UrlElementType is an alias for UrlElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type UrlElementType = UrlElementTypeWithAttrs

// IpV6ElementType represents the XSD type 'IpV6ElementType'
// XSD complex type (W3C XSD 3.4)
type IpV6ElementTypeWithAttrs struct {
        Value Ipv6Type `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// IpV6ElementType is an alias for IpV6ElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type IpV6ElementType = IpV6ElementTypeWithAttrs

// HostnameType represents the XSD type 'hostname-type'
// XSD simple type (W3C XSD 4.1)
// pattern="[\w\-]+(\.[\w\-]+){0,}"
type HostnameType string

// LocaleType represents the XSD type 'locale-type'
// XSD simple type (W3C XSD 4.1)
// pattern="[a-zA-Z]{2,3}(-([a-zA-Z]{2}|[0-9]{3}))?"
type LocaleType string

// DatabaseType represents the XSD type 'database-type'
// XSD complex type (W3C XSD 3.4)
type DatabaseType struct {
        ItAssetType // XSD extension base
        // InstanceName represents XSD element 'instance-name'
        // minOccurs=0, maxOccurs=1
        InstanceName *InstanceNameElementType `xml:"instance-name,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SystemType represents the XSD type 'system-type'
// XSD complex type (W3C XSD 3.4)
type SystemType struct {
        ItAssetType // XSD extension base
        // SystemName represents XSD element 'system-name'
        // minOccurs=0, maxOccurs=-1
        SystemName []SystemNameElementType `xml:"system-name,omitempty"`
        // Version represents XSD element 'version'
        // minOccurs=0, maxOccurs=1
        Version *VersionElementType `xml:"version,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TelephoneNumberElementType represents the XSD type 'TelephoneNumberElementType'
// XSD complex type (W3C XSD 3.4)
type TelephoneNumberElementTypeWithAttrs struct {
        Value TelephoneNumberType `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TelephoneNumberElementType is an alias for TelephoneNumberElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type TelephoneNumberElementType = TelephoneNumberElementTypeWithAttrs

// WebsiteUrlElementType represents the XSD type 'WebsiteUrlElementType'
// XSD complex type (W3C XSD 3.4)
type WebsiteUrlElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// WebsiteUrlElementType is an alias for WebsiteUrlElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type WebsiteUrlElementType = WebsiteUrlElementTypeWithAttrs

// DataType represents the XSD type 'data-type'
// XSD complex type (W3C XSD 3.4)
type DataType struct {
        AssetType // XSD extension base
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ServiceType represents the XSD type 'service-type'
// XSD complex type (W3C XSD 3.4)
type ServiceType struct {
        ItAssetType // XSD extension base
        // Host represents XSD element 'host'
        // minOccurs=0, maxOccurs=1
        Host *HostElementType `xml:"host,omitempty"`
        // Port represents XSD element 'port'
        // minOccurs=0, maxOccurs=-1
        Port []PortElementType `xml:"port,omitempty"`
        // PortRange represents XSD element 'port-range'
        // minOccurs=0, maxOccurs=-1
        PortRange []PortRangeElementType `xml:"port-range,omitempty"`
        // Protocol represents XSD element 'protocol'
        // minOccurs=0, maxOccurs=1
        Protocol *ProtocolElementType `xml:"protocol,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DistinguishedNameElementType represents the XSD type 'DistinguishedNameElementType'
// XSD complex type (W3C XSD 3.4)
type DistinguishedNameElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DistinguishedNameElementType is an alias for DistinguishedNameElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type DistinguishedNameElementType = DistinguishedNameElementTypeWithAttrs

// MacAddressElementType represents the XSD type 'MacAddressElementType'
// XSD complex type (W3C XSD 3.4)
type MacAddressElementTypeWithAttrs struct {
        Value MacAddressType `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MacAddressElementType is an alias for MacAddressElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type MacAddressElementType = MacAddressElementTypeWithAttrs

// MotherboardGuidElementType represents the XSD type 'MotherboardGuidElementType'
// XSD complex type (W3C XSD 3.4)
type MotherboardGuidElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MotherboardGuidElementType is an alias for MotherboardGuidElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type MotherboardGuidElementType = MotherboardGuidElementTypeWithAttrs

// Ipv4Type represents the XSD type 'ipv4-type'
// XSD simple type (W3C XSD 4.1)
// pattern="([0-9]|[1-9][0-9]|1([0-9][0-9])|2([0-4][0-9]|5[0-5]))\.([0-9]|[1-9][0-9]|1([0-9][0-9])|2([0-4][0-9]|5[0-5]))\.([0-9]|[1-9][0-9]|1([0-9][0-9])|2([0-4][0-9]|5[0-5]))\.([0-9]|[1-9][0-9]|1([0-9][0-9])|2([0-4][0-9]|5[0-5]))"
type Ipv4Type string

// Ipv6Type represents the XSD type 'ipv6-type'
// XSD simple type (W3C XSD 4.1)
// pattern="([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}"
type Ipv6Type string

// AssetsType represents the XSD type 'assets-type'
// XSD complex type (W3C XSD 3.4)
type AssetsType struct {
        reporting_core1_1.RelationshipsContainerType // XSD extension base
        // Asset represents XSD element 'asset'
        // minOccurs=1, maxOccurs=-1
        Asset []AssetElementType `xml:"asset"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// NetworkNameElementType represents the XSD type 'NetworkNameElementType'
// XSD complex type (W3C XSD 3.4)
type NetworkNameElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// NetworkNameElementType is an alias for NetworkNameElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type NetworkNameElementType = NetworkNameElementTypeWithAttrs

// PortType represents the XSD type 'port-type'
// XSD simple type (W3C XSD 4.1)
// minInclusive="0"
// maxInclusive="65535"
type PortType int64

// ItAssetType represents the XSD type 'it-asset-type'
// XSD complex type (W3C XSD 3.4)
// abstract="true"
type ItAssetType struct {
        AssetType // XSD extension base
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FqdnElementType represents the XSD type 'FqdnElementType'
// XSD complex type (W3C XSD 3.4)
type FqdnElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FqdnElementType is an alias for FqdnElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type FqdnElementType = FqdnElementTypeWithAttrs

// PortRangeElementType represents the XSD type 'PortRangeElementType'
// XSD complex type (W3C XSD 3.4)
type PortRangeElementType struct {
        // LowerBound represents XSD attribute 'lower-bound'
        // use="required"
        LowerBound PortType `xml:"lower-bound,attr"`
        // UpperBound represents XSD attribute 'upper-bound'
        // use="required"
        UpperBound PortType `xml:"upper-bound,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// HostnameElementType represents the XSD type 'HostnameElementType'
// XSD complex type (W3C XSD 3.4)
type HostnameElementTypeWithAttrs struct {
        Value HostnameType `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// HostnameElementType is an alias for HostnameElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type HostnameElementType = HostnameElementTypeWithAttrs

// CidrElementType represents the XSD type 'CidrElementType'
// XSD complex type (W3C XSD 3.4)
type CidrElementTypeWithAttrs struct {
        Value CidrType `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CidrElementType is an alias for CidrElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type CidrElementType = CidrElementTypeWithAttrs

// ComputingDeviceType represents the XSD type 'computing-device-type'
// XSD complex type (W3C XSD 3.4)
type ComputingDeviceType struct {
        ItAssetType // XSD extension base
        // DistinguishedName represents XSD element 'distinguished-name'
        // minOccurs=0, maxOccurs=1
        DistinguishedName *DistinguishedNameElementType `xml:"distinguished-name,omitempty"`
        // Cpe represents XSD element 'cpe'
        // minOccurs=0, maxOccurs=-1
        Cpe []CpeElement `xml:"cpe,omitempty"`
        // Connections represents XSD element 'connections'
        // minOccurs=0, maxOccurs=1
        Connections *ConnectionsElementType `xml:"connections,omitempty"`
        // Fqdn represents XSD element 'fqdn'
        // minOccurs=0, maxOccurs=1
        Fqdn *FqdnElement `xml:"fqdn,omitempty"`
        // Hostname represents XSD element 'hostname'
        // minOccurs=0, maxOccurs=1
        Hostname *HostnameElementType `xml:"hostname,omitempty"`
        // MotherboardGuid represents XSD element 'motherboard-guid'
        // minOccurs=0, maxOccurs=1
        MotherboardGuid *MotherboardGuidElementType `xml:"motherboard-guid,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PersonType represents the XSD type 'person-type'
// XSD complex type (W3C XSD 3.4)
type PersonType struct {
        AssetType // XSD extension base
        // PersonName represents XSD element 'PersonName'
        // minOccurs=0, maxOccurs=1
        PersonName *pkg_2_0.PersonNameElement `xml:"PersonName,omitempty"`
        // EmailAddress represents XSD element 'email-address'
        // minOccurs=0, maxOccurs=-1
        EmailAddress []EmailAddressElement `xml:"email-address,omitempty"`
        // TelephoneNumber represents XSD element 'telephone-number'
        // minOccurs=0, maxOccurs=-1
        TelephoneNumber []TelephoneNumberElement `xml:"telephone-number,omitempty"`
        // Birthdate represents XSD element 'birthdate'
        // minOccurs=0, maxOccurs=1
        Birthdate *BirthdateElementType `xml:"birthdate,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SystemNameElementType represents the XSD type 'SystemNameElementType'
// XSD complex type (W3C XSD 3.4)
type SystemNameElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SystemNameElementType is an alias for SystemNameElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type SystemNameElementType = SystemNameElementTypeWithAttrs

// VersionElementType represents the XSD type 'VersionElementType'
// XSD complex type (W3C XSD 3.4)
type VersionElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// VersionElementType is an alias for VersionElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type VersionElementType = VersionElementTypeWithAttrs

// PortElementType represents the XSD type 'PortElementType'
// XSD complex type (W3C XSD 3.4)
type PortElementTypeWithAttrs struct {
        Value PortType `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PortElementType is an alias for PortElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type PortElementType = PortElementTypeWithAttrs

// AssetElementType represents the XSD type 'AssetElementType'
// XSD complex type (W3C XSD 3.4)
type AssetElementType struct {
        // X1_1Person represents substitution group member 'person' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'asset'
        X1_1Person []PersonType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 person,omitempty"`
        // X1_1ItAsset represents substitution group member 'it-asset' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'asset'
        X1_1ItAsset []ItAssetType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 it-asset,omitempty"`
        // X1_1Data represents substitution group member 'data' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'asset'
        X1_1Data []DataType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 data,omitempty"`
        // X1_1Organization represents substitution group member 'organization' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'asset'
        X1_1Organization []OrganizationType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 organization,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// IpNetRangeElementType represents the XSD type 'IpNetRangeElementType'
// XSD complex type (W3C XSD 3.4)
type IpNetRangeElementType struct {
        // IpNetRangeStart represents XSD element 'ip-net-range-start'
        IpNetRangeStart IpAddressType `xml:"ip-net-range-start"`
        // IpNetRangeEnd represents XSD element 'ip-net-range-end'
        IpNetRangeEnd IpAddressType `xml:"ip-net-range-end"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LocaleElementType represents the XSD type 'LocaleElementType'
// XSD complex type (W3C XSD 3.4)
type LocaleElementTypeWithAttrs struct {
        Value LocaleType `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LocaleElementType is an alias for LocaleElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type LocaleElementType = LocaleElementTypeWithAttrs

// TelephoneNumberType represents the XSD type 'telephone-number-type'
// XSD simple type (W3C XSD 4.1)
// pattern="(([2-9][0-8]\d-[2-9]\d{2}-[0-9]{4})|(\+([0-9] ?){6,14}[0-9]))"
type TelephoneNumberType string

// OrganizationType represents the XSD type 'organization-type'
// XSD complex type (W3C XSD 3.4)
type OrganizationType struct {
        AssetType // XSD extension base
        // OrganisationNameDetails represents XSD element 'OrganisationNameDetails'
        // minOccurs=0, maxOccurs=-1
        OrganisationNameDetails []pkg_2_0.OrganisationNameDetailsElement `xml:"OrganisationNameDetails,omitempty"`
        // EmailAddress represents XSD element 'email-address'
        // minOccurs=0, maxOccurs=-1
        EmailAddress []EmailAddressElement `xml:"email-address,omitempty"`
        // TelephoneNumber represents XSD element 'telephone-number'
        // minOccurs=0, maxOccurs=-1
        TelephoneNumber []TelephoneNumberElement `xml:"telephone-number,omitempty"`
        // WebsiteUrl represents XSD element 'website-url'
        // minOccurs=0, maxOccurs=-1
        WebsiteUrl []WebsiteUrlElement `xml:"website-url,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtendedInformationElementType represents the XSD type 'ExtendedInformationElementType'
// XSD complex type (W3C XSD 3.4)
type ExtendedInformationElementType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AssetType represents the XSD type 'asset-type'
// XSD complex type (W3C XSD 3.4)
// abstract="true"
type AssetType struct {
        // SyntheticId represents XSD element 'synthetic-id'
        // minOccurs=0, maxOccurs=-1
        SyntheticId []SyntheticIdElement `xml:"synthetic-id,omitempty"`
        // Locations represents XSD element 'locations'
        // minOccurs=0, maxOccurs=1
        Locations *LocationsElement `xml:"locations,omitempty"`
        // ExtendedInformation represents XSD element 'extended-information'
        // minOccurs=0, maxOccurs=1
        ExtendedInformation *ExtendedInformationElementType `xml:"extended-information,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CircuitType represents the XSD type 'circuit-type'
// XSD complex type (W3C XSD 3.4)
type CircuitType struct {
        ItAssetType // XSD extension base
        // CircuitName represents XSD element 'circuit-name'
        // minOccurs=0, maxOccurs=1
        CircuitName *CircuitNameElementType `xml:"circuit-name,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CircuitNameElementType represents the XSD type 'CircuitNameElementType'
// XSD complex type (W3C XSD 3.4)
type CircuitNameElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CircuitNameElementType is an alias for CircuitNameElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type CircuitNameElementType = CircuitNameElementTypeWithAttrs

// HostElementType represents the XSD type 'HostElementType'
// XSD complex type (W3C XSD 3.4)
type HostElementType struct {
        // Fqdn represents XSD element 'fqdn'
        Fqdn *FqdnElement `xml:"fqdn,omitempty"`
        // IpAddress represents XSD element 'ip-address'
        IpAddress *IpAddressType `xml:"ip-address,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CpeType represents the XSD type 'cpe-type'
// XSD union type (W3C XSD 4.2.3.3)
type CpeType struct {
        Value interface{} // Union type - can hold any member type
}

// MacAddressType represents the XSD type 'mac-address-type'
// XSD simple type (W3C XSD 4.1)
// pattern="([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}"
type MacAddressType string

// LocationPointElementType represents the XSD type 'LocationPointElementType'
// XSD complex type (W3C XSD 3.4)
type LocationPointElementType struct {
        // Latitude represents XSD attribute 'latitude'
        // use="required"
        Latitude string `xml:"latitude,attr"`
        // Longitude represents XSD attribute 'longitude'
        // use="required"
        Longitude string `xml:"longitude,attr"`
        // Elevation represents XSD attribute 'elevation'
        // use="optional"
        Elevation *float64 `xml:"elevation,attr,omitempty"`
        // Radius represents XSD attribute 'radius'
        // use="optional"
        Radius *string `xml:"radius,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AssetIdentificationType represents the XSD type 'asset-identification-type'
// XSD complex type (W3C XSD 3.4)
type AssetIdentificationType struct {
        AssetsType // XSD extension base
        // AssetRef represents XSD attribute 'asset-ref'
        // use="required"
        AssetRef string `xml:"asset-ref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// NetworkInterfaceType represents the XSD type 'network-interface-type'
// XSD complex type (W3C XSD 3.4)
type NetworkInterfaceType struct {
        // IpAddress represents XSD element 'ip-address'
        // minOccurs=0, maxOccurs=1
        IpAddress *IpAddressType `xml:"ip-address,omitempty"`
        // MacAddress represents XSD element 'mac-address'
        // minOccurs=0, maxOccurs=1
        MacAddress *MacAddressElementType `xml:"mac-address,omitempty"`
        // Url represents XSD element 'url'
        // minOccurs=0, maxOccurs=-1
        Url []UrlElementType `xml:"url,omitempty"`
        // SubnetMask represents XSD element 'subnet-mask'
        // minOccurs=0, maxOccurs=1
        SubnetMask *IpAddressType `xml:"subnet-mask,omitempty"`
        // DefaultRoute represents XSD element 'default-route'
        // minOccurs=0, maxOccurs=1
        DefaultRoute *IpAddressType `xml:"default-route,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ConnectionsElementType represents the XSD type 'ConnectionsElementType'
// XSD complex type (W3C XSD 3.4)
type ConnectionsElementType struct {
        // Connection represents XSD element 'connection'
        // minOccurs=1, maxOccurs=-1
        Connection []NetworkInterfaceType `xml:"connection"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// IpV4ElementType represents the XSD type 'IpV4ElementType'
// XSD complex type (W3C XSD 3.4)
type IpV4ElementTypeWithAttrs struct {
        Value Ipv4Type `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// IpV4ElementType is an alias for IpV4ElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type IpV4ElementType = IpV4ElementTypeWithAttrs

// CpeElementType represents the XSD type 'CpeElementType'
// XSD complex type (W3C XSD 3.4)
type CpeElementType struct {
        CpeType // XSD extension base
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EmailAddressElementType represents the XSD type 'EmailAddressElementType'
// XSD complex type (W3C XSD 3.4)
type EmailAddressElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EmailAddressElementType is an alias for EmailAddressElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type EmailAddressElementType = EmailAddressElementTypeWithAttrs

// SyntheticIdElementType represents the XSD type 'SyntheticIdElementType'
// XSD complex type (W3C XSD 3.4)
type SyntheticIdElementType struct {
        // Resource represents XSD attribute 'resource'
        // use="required"
        Resource string `xml:"resource,attr"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LocationRegionElementType represents the XSD type 'LocationRegionElementType'
// XSD complex type (W3C XSD 3.4)
type LocationRegionElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LocationRegionElementType is an alias for LocationRegionElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type LocationRegionElementType = LocationRegionElementTypeWithAttrs
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package asset_reporting_format1_1 generated from XSD schema
// Source namespace: http://scap.nist.gov/schema/asset-reporting-format/1.1
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/asset-reporting-format_1.1.0.xsd
// Generated by forgexml - Do not edit manually

package asset_reporting_format1_1

import (
        "encoding/xml"
        "os"
        "strings"

        reporting_core1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1"
)

// AssetReportCollectionElement represents the XSD element 'asset-report-collection'
// XSD element declaration (W3C XSD 3.3)
type AssetReportCollectionElement struct {
        XMLName                                      xml.Name `xml:"http://scap.nist.gov/schema/asset-reporting-format/1.1 asset-report-collection"`
        reporting_core1_1.RelationshipsContainerType          // XSD extension base
        // ReportRequests represents XSD element 'report-requests'
        // minOccurs=0, maxOccurs=1
        ReportRequests *ReportRequestsElementType `xml:"report-requests,omitempty"`
        // Assets represents XSD element 'assets'
        // minOccurs=0, maxOccurs=1
        Assets *AssetsElementType `xml:"assets,omitempty"`
        // Reports represents XSD element 'reports'
        Reports ReportsElementType `xml:"reports"`
        // ExtendedInfos represents XSD element 'extended-infos'
        // minOccurs=0, maxOccurs=1
        ExtendedInfos *ExtendedInfosElementType `xml:"extended-infos,omitempty"`
        // Id represents XSD attribute 'id'
        // use="optional"
        Id *string `xml:"id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *AssetReportCollectionElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias AssetReportCollectionElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *AssetReportCollectionElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias AssetReportCollectionElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *AssetReportCollectionElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *AssetReportCollectionElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *AssetReportCollectionElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *AssetReportCollectionElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *AssetReportCollectionElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadAssetReportCollectionFromBytes loads an element from bytes with namespace preservation
func LoadAssetReportCollectionFromBytes(data []byte) (*AssetReportCollectionElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element AssetReportCollectionElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadAssetReportCollectionFromFile loads an element from a file with namespace preservation
func LoadAssetReportCollectionFromFile(path string) (*AssetReportCollectionElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadAssetReportCollectionFromBytes(data)</span>
}

// ObjectRefElement represents the XSD element 'object-ref'
// XSD element declaration (W3C XSD 3.3)
type ObjectRefElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-reporting-format/1.1 object-ref"`
        // RefId represents XSD attribute 'ref-id'
        // use="optional"
        RefId *string `xml:"ref-id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ObjectRefElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ObjectRefElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ObjectRefElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ObjectRefElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ObjectRefElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ObjectRefElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ObjectRefElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ObjectRefElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ObjectRefElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadObjectRefFromBytes loads an element from bytes with namespace preservation
func LoadObjectRefFromBytes(data []byte) (*ObjectRefElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ObjectRefElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadObjectRefFromFile loads an element from a file with namespace preservation
func LoadObjectRefFromFile(path string) (*ObjectRefElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadObjectRefFromBytes(data)</span>
}

// RemoteResourceElement represents the XSD element 'remote-resource'
// XSD element declaration (W3C XSD 3.3)
type RemoteResourceElement struct {
        XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-reporting-format/1.1 remote-resource"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *RemoteResourceElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias RemoteResourceElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *RemoteResourceElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias RemoteResourceElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *RemoteResourceElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *RemoteResourceElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *RemoteResourceElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *RemoteResourceElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *RemoteResourceElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadRemoteResourceFromBytes loads an element from bytes with namespace preservation
func LoadRemoteResourceFromBytes(data []byte) (*RemoteResourceElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element RemoteResourceElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadRemoteResourceFromFile loads an element from a file with namespace preservation
func LoadRemoteResourceFromFile(path string) (*RemoteResourceElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadRemoteResourceFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package asset_reporting_format1_1 generated from XSD schema
// Source namespace: http://scap.nist.gov/schema/asset-reporting-format/1.1
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/asset-reporting-format_1.1.0.xsd
// Generated by forgexml - Do not edit manually

package asset_reporting_format1_1

import (
        "encoding/xml"
        "regexp"
        "strings"

        asset_identification1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-identification/1-1"
        reporting_core1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1"
        types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// ReportType represents the XSD type 'ReportType'
// XSD complex type (W3C XSD 3.4)
type ReportType struct {
        // Content represents XSD element 'content'
        Content *ContentElementType `xml:"content,omitempty"`
        // RemoteResource represents XSD element 'remote-resource'
        RemoteResource *RemoteResourceElement `xml:"remote-resource,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ObjectRefElementType represents the XSD type 'ObjectRefElementType'
// XSD complex type (W3C XSD 3.4)
type ObjectRefElementType struct {
        // RefId represents XSD attribute 'ref-id'
        // use="optional"
        RefId *string `xml:"ref-id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReportRequestsElementType represents the XSD type 'ReportRequestsElementType'
// XSD complex type (W3C XSD 3.4)
type ReportRequestsElementType struct {
        // ReportRequest represents XSD element 'report-request'
        // minOccurs=1, maxOccurs=-1
        ReportRequest []ReportRequestType `xml:"report-request"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AssetsElementType represents the XSD type 'AssetsElementType'
// XSD complex type (W3C XSD 3.4)
type AssetsElementType struct {
        // Asset represents XSD element 'asset'
        // minOccurs=1, maxOccurs=-1
        Asset []AssetElementType `xml:"asset"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReportsElementType represents the XSD type 'ReportsElementType'
// XSD complex type (W3C XSD 3.4)
type ReportsElementType struct {
        // Report represents XSD element 'report'
        // minOccurs=1, maxOccurs=-1
        Report []ReportType `xml:"report"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtendedInfosElementType represents the XSD type 'ExtendedInfosElementType'
// XSD complex type (W3C XSD 3.4)
type ExtendedInfosElementType struct {
        // ExtendedInfo represents XSD element 'extended-info'
        // minOccurs=1, maxOccurs=-1
        ExtendedInfo []ExtendedInfoElementType `xml:"extended-info"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ContentElementType represents the XSD type 'ContentElementType'
// XSD complex type (W3C XSD 3.4)
type ContentElementType struct {
        // DataValidStartDate represents XSD attribute 'data-valid-start-date'
        // use="optional"
        DataValidStartDate *types.DateTime `xml:"data-valid-start-date,attr,omitempty"`
        // DataValidEndDate represents XSD attribute 'data-valid-end-date'
        // use="optional"
        DataValidEndDate *types.DateTime `xml:"data-valid-end-date,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ContentElementType1 represents the XSD type 'ContentElementType1'
// XSD complex type (W3C XSD 3.4)
type ContentElementType1 struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReportRequestType represents the XSD type 'ReportRequestType'
// XSD complex type (W3C XSD 3.4)
type ReportRequestType struct {
        // Content represents XSD element 'content'
        Content *ContentElementType1 `xml:"content,omitempty"`
        // RemoteResource represents XSD element 'remote-resource'
        RemoteResource *RemoteResourceElement `xml:"remote-resource,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RemoteResourceElementType represents the XSD type 'RemoteResourceElementType'
// XSD complex type (W3C XSD 3.4)
type RemoteResourceElementType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AssetReportCollectionElementType represents the XSD type 'AssetReportCollectionElementType'
// XSD complex type (W3C XSD 3.4)
type AssetReportCollectionElementType struct {
        reporting_core1_1.RelationshipsContainerType // XSD extension base
        // ReportRequests represents XSD element 'report-requests'
        // minOccurs=0, maxOccurs=1
        ReportRequests *ReportRequestsElementType `xml:"report-requests,omitempty"`
        // Assets represents XSD element 'assets'
        // minOccurs=0, maxOccurs=1
        Assets *AssetsElementType `xml:"assets,omitempty"`
        // Reports represents XSD element 'reports'
        Reports ReportsElementType `xml:"reports"`
        // ExtendedInfos represents XSD element 'extended-infos'
        // minOccurs=0, maxOccurs=1
        ExtendedInfos *ExtendedInfosElementType `xml:"extended-infos,omitempty"`
        // Id represents XSD attribute 'id'
        // use="optional"
        Id *string `xml:"id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AssetElementType represents the XSD type 'AssetElementType'
// XSD complex type (W3C XSD 3.4)
type AssetElementType struct {
        // X1_1ItAsset represents substitution group member 'it-asset' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'asset'
        X1_1ItAsset []asset_identification1_1.ItAssetType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 it-asset,omitempty"`
        // X1_1Data represents substitution group member 'data' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'asset'
        X1_1Data []asset_identification1_1.DataType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 data,omitempty"`
        // X1_1Organization represents substitution group member 'organization' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'asset'
        X1_1Organization []asset_identification1_1.OrganizationType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 organization,omitempty"`
        // X1_1Person represents substitution group member 'person' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
        // Substitutes for abstract element 'asset'
        X1_1Person []asset_identification1_1.PersonType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 person,omitempty"`
        // RemoteResource represents XSD element 'remote-resource'
        RemoteResource *RemoteResourceElement `xml:"remote-resource,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtendedInfoElementType represents the XSD type 'ExtendedInfoElementType'
// XSD complex type (W3C XSD 3.4)
type ExtendedInfoElementType struct {
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package reporting_core1_1 generated from XSD schema
// Source namespace: http://scap.nist.gov/schema/reporting-core/1.1
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/reporting-core_1.1.0.xsd
// Generated by forgexml - Do not edit manually

package reporting_core1_1

import (
        "encoding/xml"
        "regexp"
        "strings"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// RelationshipsContainerType represents the XSD type 'relationships-container-type'
// XSD complex type (W3C XSD 3.4)
type RelationshipsContainerType struct {
        // Relationships represents XSD element 'relationships'
        // minOccurs=0, maxOccurs=1
        Relationships *RelationshipsElementType `xml:"relationships,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RelationshipType represents the XSD type 'relationship-type'
// XSD complex type (W3C XSD 3.4)
type RelationshipType struct {
        // Ref represents XSD element 'ref'
        // minOccurs=1, maxOccurs=-1
        Ref []string `xml:"ref"`
        // Type represents XSD attribute 'type'
        // use="required"
        Type string `xml:"type,attr"`
        // Scope represents XSD attribute 'scope'
        // use="optional"
        Scope *string `xml:"scope,attr,omitempty"`
        // Subject represents XSD attribute 'subject'
        // use="required"
        Subject string `xml:"subject,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RelationshipsElementType represents the XSD type 'RelationshipsElementType'
// XSD complex type (W3C XSD 3.4)
type RelationshipsElementType struct {
        // Relationship represents XSD element 'relationship'
        // minOccurs=1, maxOccurs=-1
        Relationship []RelationshipType `xml:"relationship"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package pkg_2_01 generated from XSD schema
// Source namespace: urn:oasis:names:tc:ciq:xsdschema:xAL:2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/xAL.xsd
// Generated by forgexml - Do not edit manually

package pkg_2_01

import (
        "encoding/xml"
        "os"
        "strings"
)

// XALElement represents the XSD element 'xAL'
// XSD element declaration (W3C XSD 3.3)
type XALElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 xAL"`
        // AddressDetails represents XSD element 'AddressDetails'
        // minOccurs=1, maxOccurs=-1
        AddressDetails []AddressDetails `xml:"AddressDetails"`
        // Version represents XSD attribute 'Version'
        // use="optional"
        Version *string `xml:"Version,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *XALElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias XALElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *XALElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias XALElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *XALElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *XALElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *XALElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *XALElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *XALElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadXALFromBytes loads an element from bytes with namespace preservation
func LoadXALFromBytes(data []byte) (*XALElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element XALElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadXALFromFile loads an element from a file with namespace preservation
func LoadXALFromFile(path string) (*XALElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadXALFromBytes(data)</span>
}

// AddressLineElement represents the XSD element 'AddressLine'
// XSD element declaration (W3C XSD 3.3)
type AddressLineElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 AddressLine"`
        Value   string   `xml:",chardata"` // XSD mixed content
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *AddressLineElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias AddressLineElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *AddressLineElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias AddressLineElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *AddressLineElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *AddressLineElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *AddressLineElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *AddressLineElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *AddressLineElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadAddressLineFromBytes loads an element from bytes with namespace preservation
func LoadAddressLineFromBytes(data []byte) (*AddressLineElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element AddressLineElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadAddressLineFromFile loads an element from a file with namespace preservation
func LoadAddressLineFromFile(path string) (*AddressLineElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadAddressLineFromBytes(data)</span>
}

// PostBoxElement represents the XSD element 'PostBox'
// XSD element declaration (W3C XSD 3.3)
type PostBoxElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 PostBox"`
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PostBoxNumber represents XSD element 'PostBoxNumber'
        PostBoxNumber PostBoxNumberElementType `xml:"PostBoxNumber"`
        // PostBoxNumberPrefix represents XSD element 'PostBoxNumberPrefix'
        // minOccurs=0, maxOccurs=1
        PostBoxNumberPrefix *PostBoxNumberPrefixElementType `xml:"PostBoxNumberPrefix,omitempty"`
        // PostBoxNumberSuffix represents XSD element 'PostBoxNumberSuffix'
        // minOccurs=0, maxOccurs=1
        PostBoxNumberSuffix *PostBoxNumberSuffixElementType `xml:"PostBoxNumberSuffix,omitempty"`
        // PostBoxNumberExtension represents XSD element 'PostBoxNumberExtension'
        // minOccurs=0, maxOccurs=1
        PostBoxNumberExtension *PostBoxNumberExtensionElementType `xml:"PostBoxNumberExtension,omitempty"`
        // Firm represents XSD element 'Firm'
        // minOccurs=0, maxOccurs=1
        Firm *FirmType `xml:"Firm,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PostBoxElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PostBoxElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PostBoxElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PostBoxElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PostBoxElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PostBoxElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PostBoxElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PostBoxElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PostBoxElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPostBoxFromBytes loads an element from bytes with namespace preservation
func LoadPostBoxFromBytes(data []byte) (*PostBoxElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PostBoxElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPostBoxFromFile loads an element from a file with namespace preservation
func LoadPostBoxFromFile(path string) (*PostBoxElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPostBoxFromBytes(data)</span>
}

// ThoroughfareNumberPrefixElement represents the XSD element 'ThoroughfareNumberPrefix'
// XSD element declaration (W3C XSD 3.3)
type ThoroughfareNumberPrefixElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 ThoroughfareNumberPrefix"`
        Value   string   `xml:",chardata"` // XSD mixed content
        // NumberPrefixSeparator represents XSD attribute 'NumberPrefixSeparator'
        // use="optional"
        NumberPrefixSeparator *string `xml:"NumberPrefixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ThoroughfareNumberPrefixElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ThoroughfareNumberPrefixElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ThoroughfareNumberPrefixElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ThoroughfareNumberPrefixElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ThoroughfareNumberPrefixElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ThoroughfareNumberPrefixElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ThoroughfareNumberPrefixElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ThoroughfareNumberPrefixElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ThoroughfareNumberPrefixElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadThoroughfareNumberPrefixFromBytes loads an element from bytes with namespace preservation
func LoadThoroughfareNumberPrefixFromBytes(data []byte) (*ThoroughfareNumberPrefixElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ThoroughfareNumberPrefixElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadThoroughfareNumberPrefixFromFile loads an element from a file with namespace preservation
func LoadThoroughfareNumberPrefixFromFile(path string) (*ThoroughfareNumberPrefixElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadThoroughfareNumberPrefixFromBytes(data)</span>
}

// PremiseNumberElement represents the XSD element 'PremiseNumber'
// XSD element declaration (W3C XSD 3.3)
type PremiseNumberElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 PremiseNumber"`
        Value   string   `xml:",chardata"` // XSD mixed content
        // NumberType represents XSD attribute 'NumberType'
        // use="optional"
        NumberType *string `xml:"NumberType,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // IndicatorOccurrence represents XSD attribute 'IndicatorOccurrence'
        // use="optional"
        IndicatorOccurrence *string `xml:"IndicatorOccurrence,attr,omitempty"`
        // NumberTypeOccurrence represents XSD attribute 'NumberTypeOccurrence'
        // use="optional"
        NumberTypeOccurrence *string `xml:"NumberTypeOccurrence,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PremiseNumberElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PremiseNumberElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PremiseNumberElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PremiseNumberElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PremiseNumberElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PremiseNumberElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PremiseNumberElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PremiseNumberElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PremiseNumberElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPremiseNumberFromBytes loads an element from bytes with namespace preservation
func LoadPremiseNumberFromBytes(data []byte) (*PremiseNumberElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PremiseNumberElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPremiseNumberFromFile loads an element from a file with namespace preservation
func LoadPremiseNumberFromFile(path string) (*PremiseNumberElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPremiseNumberFromBytes(data)</span>
}

// PremiseNumberPrefixElement represents the XSD element 'PremiseNumberPrefix'
// XSD element declaration (W3C XSD 3.3)
type PremiseNumberPrefixElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 PremiseNumberPrefix"`
        Value   string   `xml:",chardata"` // XSD simpleContent from string
        // NumberPrefixSeparator represents XSD attribute 'NumberPrefixSeparator'
        // use="optional"
        NumberPrefixSeparator *string `xml:"NumberPrefixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PremiseNumberPrefixElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PremiseNumberPrefixElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PremiseNumberPrefixElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PremiseNumberPrefixElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PremiseNumberPrefixElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PremiseNumberPrefixElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PremiseNumberPrefixElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PremiseNumberPrefixElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PremiseNumberPrefixElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPremiseNumberPrefixFromBytes loads an element from bytes with namespace preservation
func LoadPremiseNumberPrefixFromBytes(data []byte) (*PremiseNumberPrefixElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PremiseNumberPrefixElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPremiseNumberPrefixFromFile loads an element from a file with namespace preservation
func LoadPremiseNumberPrefixFromFile(path string) (*PremiseNumberPrefixElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPremiseNumberPrefixFromBytes(data)</span>
}

// PremiseNumberSuffixElement represents the XSD element 'PremiseNumberSuffix'
// XSD element declaration (W3C XSD 3.3)
type PremiseNumberSuffixElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 PremiseNumberSuffix"`
        Value   string   `xml:",chardata"` // XSD mixed content
        // NumberSuffixSeparator represents XSD attribute 'NumberSuffixSeparator'
        // use="optional"
        NumberSuffixSeparator *string `xml:"NumberSuffixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PremiseNumberSuffixElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PremiseNumberSuffixElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PremiseNumberSuffixElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PremiseNumberSuffixElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PremiseNumberSuffixElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PremiseNumberSuffixElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PremiseNumberSuffixElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PremiseNumberSuffixElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PremiseNumberSuffixElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPremiseNumberSuffixFromBytes loads an element from bytes with namespace preservation
func LoadPremiseNumberSuffixFromBytes(data []byte) (*PremiseNumberSuffixElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PremiseNumberSuffixElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPremiseNumberSuffixFromFile loads an element from a file with namespace preservation
func LoadPremiseNumberSuffixFromFile(path string) (*PremiseNumberSuffixElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPremiseNumberSuffixFromBytes(data)</span>
}

// CountryNameElement represents the XSD element 'CountryName'
// XSD element declaration (W3C XSD 3.3)
type CountryNameElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 CountryName"`
        Value   string   `xml:",chardata"` // XSD mixed content
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *CountryNameElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias CountryNameElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *CountryNameElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias CountryNameElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *CountryNameElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *CountryNameElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *CountryNameElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *CountryNameElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *CountryNameElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadCountryNameFromBytes loads an element from bytes with namespace preservation
func LoadCountryNameFromBytes(data []byte) (*CountryNameElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element CountryNameElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadCountryNameFromFile loads an element from a file with namespace preservation
func LoadCountryNameFromFile(path string) (*CountryNameElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadCountryNameFromBytes(data)</span>
}

// AddressDetailsElement represents the XSD element 'AddressDetails'
// XSD element declaration (W3C XSD 3.3)
type AddressDetailsElement struct {
        XMLName        xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 AddressDetails"`
        AddressDetails          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *AddressDetailsElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias AddressDetailsElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *AddressDetailsElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias AddressDetailsElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *AddressDetailsElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *AddressDetailsElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *AddressDetailsElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *AddressDetailsElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *AddressDetailsElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadAddressDetailsFromBytes loads an element from bytes with namespace preservation
func LoadAddressDetailsFromBytes(data []byte) (*AddressDetailsElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element AddressDetailsElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadAddressDetailsFromFile loads an element from a file with namespace preservation
func LoadAddressDetailsFromFile(path string) (*AddressDetailsElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadAddressDetailsFromBytes(data)</span>
}

// LocalityElement represents the XSD element 'Locality'
// XSD element declaration (W3C XSD 3.3)
type LocalityElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 Locality"`
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // LocalityName represents XSD element 'LocalityName'
        // minOccurs=0, maxOccurs=-1
        LocalityName []LocalityNameElementType `xml:"LocalityName,omitempty"`
        // Thoroughfare represents XSD element 'Thoroughfare'
        // minOccurs=0, maxOccurs=1
        Thoroughfare *ThoroughfareElement `xml:"Thoroughfare,omitempty"`
        // Premise represents XSD element 'Premise'
        // minOccurs=0, maxOccurs=1
        Premise *PremiseElement `xml:"Premise,omitempty"`
        // DependentLocality represents XSD element 'DependentLocality'
        // minOccurs=0, maxOccurs=1
        DependentLocality *DependentLocalityType `xml:"DependentLocality,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // PostBox represents XSD element 'PostBox'
        PostBox *PostBoxElement `xml:"PostBox,omitempty"`
        // LargeMailUser represents XSD element 'LargeMailUser'
        LargeMailUser *LargeMailUserType `xml:"LargeMailUser,omitempty"`
        // PostOffice represents XSD element 'PostOffice'
        PostOffice *PostOfficeElement `xml:"PostOffice,omitempty"`
        // PostalRoute represents XSD element 'PostalRoute'
        PostalRoute *PostalRouteType `xml:"PostalRoute,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UsageType represents XSD attribute 'UsageType'
        // use="optional"
        UsageType *string `xml:"UsageType,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *LocalityElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias LocalityElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *LocalityElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias LocalityElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *LocalityElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *LocalityElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *LocalityElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *LocalityElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *LocalityElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadLocalityFromBytes loads an element from bytes with namespace preservation
func LoadLocalityFromBytes(data []byte) (*LocalityElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element LocalityElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadLocalityFromFile loads an element from a file with namespace preservation
func LoadLocalityFromFile(path string) (*LocalityElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadLocalityFromBytes(data)</span>
}

// PremiseElement represents the XSD element 'Premise'
// XSD element declaration (W3C XSD 3.3)
type PremiseElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 Premise"`
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PremiseName represents XSD element 'PremiseName'
        // minOccurs=0, maxOccurs=-1
        PremiseName []PremiseNameElementType `xml:"PremiseName,omitempty"`
        // PremiseNumberPrefix represents XSD element 'PremiseNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        PremiseNumberPrefix []PremiseNumberPrefixElement `xml:"PremiseNumberPrefix,omitempty"`
        // PremiseNumberSuffix represents XSD element 'PremiseNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        PremiseNumberSuffix []PremiseNumberSuffixElement `xml:"PremiseNumberSuffix,omitempty"`
        // BuildingName represents XSD element 'BuildingName'
        // minOccurs=0, maxOccurs=-1
        BuildingName []BuildingNameType `xml:"BuildingName,omitempty"`
        // MailStop represents XSD element 'MailStop'
        // minOccurs=0, maxOccurs=1
        MailStop *MailStopType `xml:"MailStop,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Premise represents XSD element 'Premise'
        // minOccurs=0, maxOccurs=1
        Premise *PremiseElement `xml:"Premise,omitempty"`
        // PremiseLocation represents XSD element 'PremiseLocation'
        PremiseLocation *PremiseLocationElementType `xml:"PremiseLocation,omitempty"`
        // PremiseNumber represents XSD element 'PremiseNumber'
        // minOccurs=1, maxOccurs=-1
        PremiseNumber []PremiseNumberElement `xml:"PremiseNumber,omitempty"`
        // PremiseNumberRange represents XSD element 'PremiseNumberRange'
        PremiseNumberRange *PremiseNumberRangeElementType `xml:"PremiseNumberRange,omitempty"`
        // SubPremise represents XSD element 'SubPremise'
        // minOccurs=0, maxOccurs=-1
        SubPremise []*SubPremiseType `xml:"SubPremise,omitempty"`
        // Firm represents XSD element 'Firm'
        // minOccurs=0, maxOccurs=1
        Firm *FirmType `xml:"Firm,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // PremiseDependency represents XSD attribute 'PremiseDependency'
        // use="optional"
        PremiseDependency *string `xml:"PremiseDependency,attr,omitempty"`
        // PremiseDependencyType represents XSD attribute 'PremiseDependencyType'
        // use="optional"
        PremiseDependencyType *string `xml:"PremiseDependencyType,attr,omitempty"`
        // PremiseThoroughfareConnector represents XSD attribute 'PremiseThoroughfareConnector'
        // use="optional"
        PremiseThoroughfareConnector *string `xml:"PremiseThoroughfareConnector,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PremiseElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PremiseElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PremiseElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PremiseElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PremiseElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PremiseElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PremiseElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PremiseElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PremiseElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPremiseFromBytes loads an element from bytes with namespace preservation
func LoadPremiseFromBytes(data []byte) (*PremiseElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PremiseElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPremiseFromFile loads an element from a file with namespace preservation
func LoadPremiseFromFile(path string) (*PremiseElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPremiseFromBytes(data)</span>
}

// AdministrativeAreaElement represents the XSD element 'AdministrativeArea'
// XSD element declaration (W3C XSD 3.3)
type AdministrativeAreaElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 AdministrativeArea"`
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // AdministrativeAreaName represents XSD element 'AdministrativeAreaName'
        // minOccurs=0, maxOccurs=-1
        AdministrativeAreaName []AdministrativeAreaNameElementType `xml:"AdministrativeAreaName,omitempty"`
        // SubAdministrativeArea represents XSD element 'SubAdministrativeArea'
        // minOccurs=0, maxOccurs=1
        SubAdministrativeArea *SubAdministrativeAreaElementType `xml:"SubAdministrativeArea,omitempty"`
        // Locality represents XSD element 'Locality'
        Locality *LocalityElement `xml:"Locality,omitempty"`
        // PostOffice represents XSD element 'PostOffice'
        PostOffice *PostOfficeElement `xml:"PostOffice,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UsageType represents XSD attribute 'UsageType'
        // use="optional"
        UsageType *string `xml:"UsageType,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *AdministrativeAreaElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias AdministrativeAreaElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *AdministrativeAreaElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias AdministrativeAreaElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *AdministrativeAreaElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *AdministrativeAreaElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *AdministrativeAreaElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *AdministrativeAreaElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *AdministrativeAreaElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadAdministrativeAreaFromBytes loads an element from bytes with namespace preservation
func LoadAdministrativeAreaFromBytes(data []byte) (*AdministrativeAreaElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element AdministrativeAreaElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadAdministrativeAreaFromFile loads an element from a file with namespace preservation
func LoadAdministrativeAreaFromFile(path string) (*AdministrativeAreaElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadAdministrativeAreaFromBytes(data)</span>
}

// PostalCodeElement represents the XSD element 'PostalCode'
// XSD element declaration (W3C XSD 3.3)
type PostalCodeElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 PostalCode"`
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PostalCodeNumber represents XSD element 'PostalCodeNumber'
        // minOccurs=0, maxOccurs=-1
        PostalCodeNumber []PostalCodeNumberElementType `xml:"PostalCodeNumber,omitempty"`
        // PostalCodeNumberExtension represents XSD element 'PostalCodeNumberExtension'
        // minOccurs=0, maxOccurs=-1
        PostalCodeNumberExtension []PostalCodeNumberExtensionElementType `xml:"PostalCodeNumberExtension,omitempty"`
        // PostTown represents XSD element 'PostTown'
        // minOccurs=0, maxOccurs=1
        PostTown *PostTownElementType `xml:"PostTown,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PostalCodeElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PostalCodeElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PostalCodeElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PostalCodeElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PostalCodeElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PostalCodeElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PostalCodeElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PostalCodeElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PostalCodeElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPostalCodeFromBytes loads an element from bytes with namespace preservation
func LoadPostalCodeFromBytes(data []byte) (*PostalCodeElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PostalCodeElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPostalCodeFromFile loads an element from a file with namespace preservation
func LoadPostalCodeFromFile(path string) (*PostalCodeElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPostalCodeFromBytes(data)</span>
}

// ThoroughfareNumberElement represents the XSD element 'ThoroughfareNumber'
// XSD element declaration (W3C XSD 3.3)
type ThoroughfareNumberElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 ThoroughfareNumber"`
        Value   string   `xml:",chardata"` // XSD mixed content
        // NumberType represents XSD attribute 'NumberType'
        // use="optional"
        NumberType *string `xml:"NumberType,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // IndicatorOccurrence represents XSD attribute 'IndicatorOccurrence'
        // use="optional"
        IndicatorOccurrence *string `xml:"IndicatorOccurrence,attr,omitempty"`
        // NumberOccurrence represents XSD attribute 'NumberOccurrence'
        // use="optional"
        NumberOccurrence *string `xml:"NumberOccurrence,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ThoroughfareNumberElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ThoroughfareNumberElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ThoroughfareNumberElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ThoroughfareNumberElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ThoroughfareNumberElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ThoroughfareNumberElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ThoroughfareNumberElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ThoroughfareNumberElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ThoroughfareNumberElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadThoroughfareNumberFromBytes loads an element from bytes with namespace preservation
func LoadThoroughfareNumberFromBytes(data []byte) (*ThoroughfareNumberElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ThoroughfareNumberElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadThoroughfareNumberFromFile loads an element from a file with namespace preservation
func LoadThoroughfareNumberFromFile(path string) (*ThoroughfareNumberElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadThoroughfareNumberFromBytes(data)</span>
}

// ThoroughfareElement represents the XSD element 'Thoroughfare'
// XSD element declaration (W3C XSD 3.3)
type ThoroughfareElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 Thoroughfare"`
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // ThoroughfareNumberPrefix represents XSD element 'ThoroughfareNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareNumberPrefix []ThoroughfareNumberPrefixElement `xml:"ThoroughfareNumberPrefix,omitempty"`
        // ThoroughfareNumberSuffix represents XSD element 'ThoroughfareNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareNumberSuffix []ThoroughfareNumberSuffixElement `xml:"ThoroughfareNumberSuffix,omitempty"`
        // ThoroughfarePreDirection represents XSD element 'ThoroughfarePreDirection'
        // minOccurs=0, maxOccurs=1
        ThoroughfarePreDirection *ThoroughfarePreDirectionType `xml:"ThoroughfarePreDirection,omitempty"`
        // ThoroughfareLeadingType represents XSD element 'ThoroughfareLeadingType'
        // minOccurs=0, maxOccurs=1
        ThoroughfareLeadingType *ThoroughfareLeadingTypeType `xml:"ThoroughfareLeadingType,omitempty"`
        // ThoroughfareName represents XSD element 'ThoroughfareName'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareName []ThoroughfareNameType `xml:"ThoroughfareName,omitempty"`
        // ThoroughfareTrailingType represents XSD element 'ThoroughfareTrailingType'
        // minOccurs=0, maxOccurs=1
        ThoroughfareTrailingType *ThoroughfareTrailingTypeType `xml:"ThoroughfareTrailingType,omitempty"`
        // ThoroughfarePostDirection represents XSD element 'ThoroughfarePostDirection'
        // minOccurs=0, maxOccurs=1
        ThoroughfarePostDirection *ThoroughfarePostDirectionType `xml:"ThoroughfarePostDirection,omitempty"`
        // DependentThoroughfare represents XSD element 'DependentThoroughfare'
        // minOccurs=0, maxOccurs=1
        DependentThoroughfare *DependentThoroughfareElementType `xml:"DependentThoroughfare,omitempty"`
        // ThoroughfareNumber represents XSD element 'ThoroughfareNumber'
        ThoroughfareNumber []ThoroughfareNumberElement `xml:"ThoroughfareNumber,omitempty"`
        // ThoroughfareNumberRange represents XSD element 'ThoroughfareNumberRange'
        ThoroughfareNumberRange []ThoroughfareNumberRangeElementType `xml:"ThoroughfareNumberRange,omitempty"`
        // DependentLocality represents XSD element 'DependentLocality'
        DependentLocality *DependentLocalityType `xml:"DependentLocality,omitempty"`
        // Premise represents XSD element 'Premise'
        Premise *PremiseElement `xml:"Premise,omitempty"`
        // Firm represents XSD element 'Firm'
        Firm *FirmType `xml:"Firm,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // DependentThoroughfares represents XSD attribute 'DependentThoroughfares'
        // use="optional"
        DependentThoroughfares *string `xml:"DependentThoroughfares,attr,omitempty"`
        // DependentThoroughfaresIndicator represents XSD attribute 'DependentThoroughfaresIndicator'
        // use="optional"
        DependentThoroughfaresIndicator *string `xml:"DependentThoroughfaresIndicator,attr,omitempty"`
        // DependentThoroughfaresConnector represents XSD attribute 'DependentThoroughfaresConnector'
        // use="optional"
        DependentThoroughfaresConnector *string `xml:"DependentThoroughfaresConnector,attr,omitempty"`
        // DependentThoroughfaresType represents XSD attribute 'DependentThoroughfaresType'
        // use="optional"
        DependentThoroughfaresType *string `xml:"DependentThoroughfaresType,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ThoroughfareElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ThoroughfareElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ThoroughfareElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ThoroughfareElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ThoroughfareElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ThoroughfareElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ThoroughfareElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ThoroughfareElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ThoroughfareElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadThoroughfareFromBytes loads an element from bytes with namespace preservation
func LoadThoroughfareFromBytes(data []byte) (*ThoroughfareElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ThoroughfareElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadThoroughfareFromFile loads an element from a file with namespace preservation
func LoadThoroughfareFromFile(path string) (*ThoroughfareElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadThoroughfareFromBytes(data)</span>
}

// PostOfficeElement represents the XSD element 'PostOffice'
// XSD element declaration (W3C XSD 3.3)
type PostOfficeElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 PostOffice"`
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PostalRoute represents XSD element 'PostalRoute'
        // minOccurs=0, maxOccurs=1
        PostalRoute *PostalRouteType `xml:"PostalRoute,omitempty"`
        // PostBox represents XSD element 'PostBox'
        // minOccurs=0, maxOccurs=1
        PostBox *PostBoxElement `xml:"PostBox,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // PostOfficeName represents XSD element 'PostOfficeName'
        // minOccurs=0, maxOccurs=-1
        PostOfficeName []PostOfficeNameElementType `xml:"PostOfficeName,omitempty"`
        // PostOfficeNumber represents XSD element 'PostOfficeNumber'
        // minOccurs=0, maxOccurs=1
        PostOfficeNumber *PostOfficeNumberElementType `xml:"PostOfficeNumber,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PostOfficeElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PostOfficeElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PostOfficeElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PostOfficeElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PostOfficeElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PostOfficeElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PostOfficeElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PostOfficeElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PostOfficeElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPostOfficeFromBytes loads an element from bytes with namespace preservation
func LoadPostOfficeFromBytes(data []byte) (*PostOfficeElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PostOfficeElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPostOfficeFromFile loads an element from a file with namespace preservation
func LoadPostOfficeFromFile(path string) (*PostOfficeElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPostOfficeFromBytes(data)</span>
}

// DepartmentElement represents the XSD element 'Department'
// XSD element declaration (W3C XSD 3.3)
type DepartmentElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 Department"`
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // DepartmentName represents XSD element 'DepartmentName'
        // minOccurs=0, maxOccurs=-1
        DepartmentName []DepartmentNameElementType `xml:"DepartmentName,omitempty"`
        // MailStop represents XSD element 'MailStop'
        // minOccurs=0, maxOccurs=1
        MailStop *MailStopType `xml:"MailStop,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *DepartmentElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias DepartmentElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *DepartmentElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias DepartmentElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *DepartmentElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *DepartmentElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *DepartmentElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *DepartmentElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *DepartmentElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadDepartmentFromBytes loads an element from bytes with namespace preservation
func LoadDepartmentFromBytes(data []byte) (*DepartmentElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element DepartmentElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadDepartmentFromFile loads an element from a file with namespace preservation
func LoadDepartmentFromFile(path string) (*DepartmentElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadDepartmentFromBytes(data)</span>
}

// ThoroughfareNumberSuffixElement represents the XSD element 'ThoroughfareNumberSuffix'
// XSD element declaration (W3C XSD 3.3)
type ThoroughfareNumberSuffixElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0 ThoroughfareNumberSuffix"`
        Value   string   `xml:",chardata"` // XSD mixed content
        // NumberSuffixSeparator represents XSD attribute 'NumberSuffixSeparator'
        // use="optional"
        NumberSuffixSeparator *string `xml:"NumberSuffixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ThoroughfareNumberSuffixElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ThoroughfareNumberSuffixElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ThoroughfareNumberSuffixElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ThoroughfareNumberSuffixElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ThoroughfareNumberSuffixElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ThoroughfareNumberSuffixElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ThoroughfareNumberSuffixElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ThoroughfareNumberSuffixElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ThoroughfareNumberSuffixElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadThoroughfareNumberSuffixFromBytes loads an element from bytes with namespace preservation
func LoadThoroughfareNumberSuffixFromBytes(data []byte) (*ThoroughfareNumberSuffixElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ThoroughfareNumberSuffixElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadThoroughfareNumberSuffixFromFile loads an element from a file with namespace preservation
func LoadThoroughfareNumberSuffixFromFile(path string) (*ThoroughfareNumberSuffixElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadThoroughfareNumberSuffixFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package pkg_2_01 generated from XSD schema
// Source namespace: urn:oasis:names:tc:ciq:xsdschema:xAL:2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/xAL.xsd
// Generated by forgexml - Do not edit manually

package pkg_2_01

import (
        "encoding/xml"
        "regexp"
        "strings"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// SubPremiseNumberElementType represents the XSD type 'SubPremiseNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SubPremiseNumberElementType struct {
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // IndicatorOccurrence represents XSD attribute 'IndicatorOccurrence'
        // use="optional"
        IndicatorOccurrence *string `xml:"IndicatorOccurrence,attr,omitempty"`
        // NumberTypeOccurrence represents XSD attribute 'NumberTypeOccurrence'
        // use="optional"
        NumberTypeOccurrence *string `xml:"NumberTypeOccurrence,attr,omitempty"`
        // PremiseNumberSeparator represents XSD attribute 'PremiseNumberSeparator'
        // use="optional"
        PremiseNumberSeparator *string `xml:"PremiseNumberSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FirmType represents the XSD type 'FirmType'
// XSD complex type (W3C XSD 3.4)
type FirmType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // FirmName represents XSD element 'FirmName'
        // minOccurs=0, maxOccurs=-1
        FirmName []FirmNameElementType `xml:"FirmName,omitempty"`
        // Department represents XSD element 'Department'
        // minOccurs=0, maxOccurs=-1
        Department []DepartmentElement `xml:"Department,omitempty"`
        // MailStop represents XSD element 'MailStop'
        // minOccurs=0, maxOccurs=1
        MailStop *MailStopType `xml:"MailStop,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostalRouteType represents the XSD type 'PostalRouteType'
// XSD complex type (W3C XSD 3.4)
type PostalRouteType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PostBox represents XSD element 'PostBox'
        // minOccurs=0, maxOccurs=1
        PostBox *PostBoxElement `xml:"PostBox,omitempty"`
        // PostalRouteName represents XSD element 'PostalRouteName'
        // minOccurs=1, maxOccurs=-1
        PostalRouteName []PostalRouteNameElementType `xml:"PostalRouteName,omitempty"`
        // PostalRouteNumber represents XSD element 'PostalRouteNumber'
        PostalRouteNumber *PostalRouteNumberElementType `xml:"PostalRouteNumber,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SubPremiseType represents the XSD type 'SubPremiseType'
// XSD complex type (W3C XSD 3.4)
type SubPremiseType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // SubPremiseName represents XSD element 'SubPremiseName'
        // minOccurs=0, maxOccurs=-1
        SubPremiseName []SubPremiseNameElementType `xml:"SubPremiseName,omitempty"`
        // SubPremiseNumberPrefix represents XSD element 'SubPremiseNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        SubPremiseNumberPrefix []SubPremiseNumberPrefixElementType `xml:"SubPremiseNumberPrefix,omitempty"`
        // SubPremiseNumberSuffix represents XSD element 'SubPremiseNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        SubPremiseNumberSuffix []SubPremiseNumberSuffixElementType `xml:"SubPremiseNumberSuffix,omitempty"`
        // BuildingName represents XSD element 'BuildingName'
        // minOccurs=0, maxOccurs=-1
        BuildingName []BuildingNameType `xml:"BuildingName,omitempty"`
        // Firm represents XSD element 'Firm'
        // minOccurs=0, maxOccurs=1
        Firm *FirmType `xml:"Firm,omitempty"`
        // MailStop represents XSD element 'MailStop'
        // minOccurs=0, maxOccurs=1
        MailStop *MailStopType `xml:"MailStop,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // SubPremise represents XSD element 'SubPremise'
        // minOccurs=0, maxOccurs=1
        SubPremise *SubPremiseType `xml:"SubPremise,omitempty"`
        // SubPremiseLocation represents XSD element 'SubPremiseLocation'
        SubPremiseLocation *SubPremiseLocationElementType `xml:"SubPremiseLocation,omitempty"`
        // SubPremiseNumber represents XSD element 'SubPremiseNumber'
        // minOccurs=0, maxOccurs=-1
        SubPremiseNumber []SubPremiseNumberElementType `xml:"SubPremiseNumber,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareNumberPrefixElementType represents the XSD type 'ThoroughfareNumberPrefixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfareNumberPrefixElementType struct {
        // NumberPrefixSeparator represents XSD attribute 'NumberPrefixSeparator'
        // use="optional"
        NumberPrefixSeparator *string `xml:"NumberPrefixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostalCodeElementType represents the XSD type 'PostalCodeElementType'
// XSD complex type (W3C XSD 3.4)
type PostalCodeElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PostalCodeNumber represents XSD element 'PostalCodeNumber'
        // minOccurs=0, maxOccurs=-1
        PostalCodeNumber []PostalCodeNumberElementType `xml:"PostalCodeNumber,omitempty"`
        // PostalCodeNumberExtension represents XSD element 'PostalCodeNumberExtension'
        // minOccurs=0, maxOccurs=-1
        PostalCodeNumberExtension []PostalCodeNumberExtensionElementType `xml:"PostalCodeNumberExtension,omitempty"`
        // PostTown represents XSD element 'PostTown'
        // minOccurs=0, maxOccurs=1
        PostTown *PostTownElementType `xml:"PostTown,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SortingCodeElementType represents the XSD type 'SortingCodeElementType'
// XSD complex type (W3C XSD 3.4)
type SortingCodeElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// BuildingNameType represents the XSD type 'BuildingNameType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type BuildingNameType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // TypeOccurrence represents XSD attribute 'TypeOccurrence'
        // use="optional"
        TypeOccurrence *string `xml:"TypeOccurrence,attr,omitempty"`
        InnerXML       string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfarePreDirectionType represents the XSD type 'ThoroughfarePreDirectionType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfarePreDirectionType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareTrailingTypeType represents the XSD type 'ThoroughfareTrailingTypeType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfareTrailingTypeType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DepartmentNameElementType represents the XSD type 'DepartmentNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type DepartmentNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostBoxNumberElementType represents the XSD type 'PostBoxNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostBoxNumberElementType struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostBoxNumberPrefixElementType represents the XSD type 'PostBoxNumberPrefixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostBoxNumberPrefixElementType struct {
        // NumberPrefixSeparator represents XSD attribute 'NumberPrefixSeparator'
        // use="optional"
        NumberPrefixSeparator *string `xml:"NumberPrefixSeparator,attr,omitempty"`
        InnerXML              string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostalCodeNumberElementType represents the XSD type 'PostalCodeNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostalCodeNumberElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareNumberElementType represents the XSD type 'ThoroughfareNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfareNumberElementType struct {
        // NumberType represents XSD attribute 'NumberType'
        // use="optional"
        NumberType *string `xml:"NumberType,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // IndicatorOccurrence represents XSD attribute 'IndicatorOccurrence'
        // use="optional"
        IndicatorOccurrence *string `xml:"IndicatorOccurrence,attr,omitempty"`
        // NumberOccurrence represents XSD attribute 'NumberOccurrence'
        // use="optional"
        NumberOccurrence *string `xml:"NumberOccurrence,attr,omitempty"`
        InnerXML         string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostalCodeNumberExtensionElementType represents the XSD type 'PostalCodeNumberExtensionElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostalCodeNumberExtensionElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NumberExtensionSeparator represents XSD attribute 'NumberExtensionSeparator'
        // use="optional"
        NumberExtensionSeparator *string `xml:"NumberExtensionSeparator,attr,omitempty"`
        InnerXML                 string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostOfficeNameElementType represents the XSD type 'PostOfficeNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostOfficeNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MailStopNameElementType represents the XSD type 'MailStopNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type MailStopNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SubPremiseNumberSuffixElementType represents the XSD type 'SubPremiseNumberSuffixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SubPremiseNumberSuffixElementType struct {
        // NumberSuffixSeparator represents XSD attribute 'NumberSuffixSeparator'
        // use="optional"
        NumberSuffixSeparator *string `xml:"NumberSuffixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// KeyLineCodeElementType represents the XSD type 'KeyLineCodeElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type KeyLineCodeElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostBoxElementType represents the XSD type 'PostBoxElementType'
// XSD complex type (W3C XSD 3.4)
type PostBoxElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PostBoxNumber represents XSD element 'PostBoxNumber'
        PostBoxNumber PostBoxNumberElementType `xml:"PostBoxNumber"`
        // PostBoxNumberPrefix represents XSD element 'PostBoxNumberPrefix'
        // minOccurs=0, maxOccurs=1
        PostBoxNumberPrefix *PostBoxNumberPrefixElementType `xml:"PostBoxNumberPrefix,omitempty"`
        // PostBoxNumberSuffix represents XSD element 'PostBoxNumberSuffix'
        // minOccurs=0, maxOccurs=1
        PostBoxNumberSuffix *PostBoxNumberSuffixElementType `xml:"PostBoxNumberSuffix,omitempty"`
        // PostBoxNumberExtension represents XSD element 'PostBoxNumberExtension'
        // minOccurs=0, maxOccurs=1
        PostBoxNumberExtension *PostBoxNumberExtensionElementType `xml:"PostBoxNumberExtension,omitempty"`
        // Firm represents XSD element 'Firm'
        // minOccurs=0, maxOccurs=1
        Firm *FirmType `xml:"Firm,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostBoxNumberExtensionElementType represents the XSD type 'PostBoxNumberExtensionElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostBoxNumberExtensionElementType struct {
        // NumberExtensionSeparator represents XSD attribute 'NumberExtensionSeparator'
        // use="optional"
        NumberExtensionSeparator *string `xml:"NumberExtensionSeparator,attr,omitempty"`
        InnerXML                 string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseElementType represents the XSD type 'PremiseElementType'
// XSD complex type (W3C XSD 3.4)
type PremiseElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PremiseName represents XSD element 'PremiseName'
        // minOccurs=0, maxOccurs=-1
        PremiseName []PremiseNameElementType `xml:"PremiseName,omitempty"`
        // PremiseNumberPrefix represents XSD element 'PremiseNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        PremiseNumberPrefix []PremiseNumberPrefixElement `xml:"PremiseNumberPrefix,omitempty"`
        // PremiseNumberSuffix represents XSD element 'PremiseNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        PremiseNumberSuffix []PremiseNumberSuffixElement `xml:"PremiseNumberSuffix,omitempty"`
        // BuildingName represents XSD element 'BuildingName'
        // minOccurs=0, maxOccurs=-1
        BuildingName []BuildingNameType `xml:"BuildingName,omitempty"`
        // MailStop represents XSD element 'MailStop'
        // minOccurs=0, maxOccurs=1
        MailStop *MailStopType `xml:"MailStop,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Premise represents XSD element 'Premise'
        // minOccurs=0, maxOccurs=1
        Premise *PremiseElement `xml:"Premise,omitempty"`
        // PremiseLocation represents XSD element 'PremiseLocation'
        PremiseLocation *PremiseLocationElementType `xml:"PremiseLocation,omitempty"`
        // PremiseNumber represents XSD element 'PremiseNumber'
        // minOccurs=1, maxOccurs=-1
        PremiseNumber []PremiseNumberElement `xml:"PremiseNumber,omitempty"`
        // PremiseNumberRange represents XSD element 'PremiseNumberRange'
        PremiseNumberRange *PremiseNumberRangeElementType `xml:"PremiseNumberRange,omitempty"`
        // SubPremise represents XSD element 'SubPremise'
        // minOccurs=0, maxOccurs=-1
        SubPremise []*SubPremiseType `xml:"SubPremise,omitempty"`
        // Firm represents XSD element 'Firm'
        // minOccurs=0, maxOccurs=1
        Firm *FirmType `xml:"Firm,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // PremiseDependency represents XSD attribute 'PremiseDependency'
        // use="optional"
        PremiseDependency *string `xml:"PremiseDependency,attr,omitempty"`
        // PremiseDependencyType represents XSD attribute 'PremiseDependencyType'
        // use="optional"
        PremiseDependencyType *string `xml:"PremiseDependencyType,attr,omitempty"`
        // PremiseThoroughfareConnector represents XSD attribute 'PremiseThoroughfareConnector'
        // use="optional"
        PremiseThoroughfareConnector *string `xml:"PremiseThoroughfareConnector,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostTownSuffixElementType represents the XSD type 'PostTownSuffixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostTownSuffixElementType struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostalRouteNumberElementType represents the XSD type 'PostalRouteNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostalRouteNumberElementType struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostOfficeNumberElementType represents the XSD type 'PostOfficeNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostOfficeNumberElementType struct {
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // IndicatorOccurrence represents XSD attribute 'IndicatorOccurrence'
        // use="optional"
        IndicatorOccurrence *string `xml:"IndicatorOccurrence,attr,omitempty"`
        InnerXML            string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostalRouteNameElementType represents the XSD type 'PostalRouteNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostalRouteNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressLatitudeDirectionElementType represents the XSD type 'AddressLatitudeDirectionElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AddressLatitudeDirectionElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseNumberRangeElementType represents the XSD type 'PremiseNumberRangeElementType'
// XSD complex type (W3C XSD 3.4)
type PremiseNumberRangeElementType struct {
        // PremiseNumberRangeFrom represents XSD element 'PremiseNumberRangeFrom'
        PremiseNumberRangeFrom PremiseNumberRangeFromElementType `xml:"PremiseNumberRangeFrom"`
        // PremiseNumberRangeTo represents XSD element 'PremiseNumberRangeTo'
        PremiseNumberRangeTo PremiseNumberRangeToElementType `xml:"PremiseNumberRangeTo"`
        // RangeType represents XSD attribute 'RangeType'
        // use="optional"
        RangeType *string `xml:"RangeType,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // Separator represents XSD attribute 'Separator'
        // use="optional"
        Separator *string `xml:"Separator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // IndicatorOccurence represents XSD attribute 'IndicatorOccurence'
        // use="optional"
        IndicatorOccurence *string `xml:"IndicatorOccurence,attr,omitempty"`
        // NumberRangeOccurence represents XSD attribute 'NumberRangeOccurence'
        // use="optional"
        NumberRangeOccurence *string `xml:"NumberRangeOccurence,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AdministrativeAreaElementType represents the XSD type 'AdministrativeAreaElementType'
// XSD complex type (W3C XSD 3.4)
type AdministrativeAreaElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // AdministrativeAreaName represents XSD element 'AdministrativeAreaName'
        // minOccurs=0, maxOccurs=-1
        AdministrativeAreaName []AdministrativeAreaNameElementType `xml:"AdministrativeAreaName,omitempty"`
        // SubAdministrativeArea represents XSD element 'SubAdministrativeArea'
        // minOccurs=0, maxOccurs=1
        SubAdministrativeArea *SubAdministrativeAreaElementType `xml:"SubAdministrativeArea,omitempty"`
        // Locality represents XSD element 'Locality'
        Locality *LocalityElement `xml:"Locality,omitempty"`
        // PostOffice represents XSD element 'PostOffice'
        PostOffice *PostOfficeElement `xml:"PostOffice,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UsageType represents XSD attribute 'UsageType'
        // use="optional"
        UsageType *string `xml:"UsageType,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SupplementaryPostalServiceDataElementType represents the XSD type 'SupplementaryPostalServiceDataElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SupplementaryPostalServiceDataElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareNameType represents the XSD type 'ThoroughfareNameType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfareNameType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SubAdministrativeAreaNameElementType represents the XSD type 'SubAdministrativeAreaNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SubAdministrativeAreaNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostTownElementType represents the XSD type 'PostTownElementType'
// XSD complex type (W3C XSD 3.4)
type PostTownElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PostTownName represents XSD element 'PostTownName'
        // minOccurs=0, maxOccurs=-1
        PostTownName []PostTownNameElementType `xml:"PostTownName,omitempty"`
        // PostTownSuffix represents XSD element 'PostTownSuffix'
        // minOccurs=0, maxOccurs=1
        PostTownSuffix *PostTownSuffixElementType `xml:"PostTownSuffix,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareNumberToElementType represents the XSD type 'ThoroughfareNumberToElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfareNumberToElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // ThoroughfareNumberPrefix represents XSD element 'ThoroughfareNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareNumberPrefix []ThoroughfareNumberPrefixElement `xml:"ThoroughfareNumberPrefix,omitempty"`
        // ThoroughfareNumber represents XSD element 'ThoroughfareNumber'
        // minOccurs=1, maxOccurs=-1
        ThoroughfareNumber []ThoroughfareNumberElement `xml:"ThoroughfareNumber"`
        // ThoroughfareNumberSuffix represents XSD element 'ThoroughfareNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareNumberSuffix []ThoroughfareNumberSuffixElement `xml:"ThoroughfareNumberSuffix,omitempty"`
        Value                    string                            `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressLinesType represents the XSD type 'AddressLinesType'
// XSD complex type (W3C XSD 3.4)
type AddressLinesType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=1, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MailStopNumberElementType represents the XSD type 'MailStopNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type MailStopNumberElementType struct {
        // NameNumberSeparator represents XSD attribute 'NameNumberSeparator'
        // use="optional"
        NameNumberSeparator *string `xml:"NameNumberSeparator,attr,omitempty"`
        InnerXML            string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// BarcodeElementType represents the XSD type 'BarcodeElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type BarcodeElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CountryElementType represents the XSD type 'CountryElementType'
// XSD complex type (W3C XSD 3.4)
type CountryElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // CountryNameCode represents XSD element 'CountryNameCode'
        // minOccurs=0, maxOccurs=-1
        CountryNameCode []CountryNameCodeElementType `xml:"CountryNameCode,omitempty"`
        // CountryName represents XSD element 'CountryName'
        // minOccurs=0, maxOccurs=-1
        CountryName []CountryNameElement `xml:"CountryName,omitempty"`
        // AdministrativeArea represents XSD element 'AdministrativeArea'
        AdministrativeArea *AdministrativeAreaElement `xml:"AdministrativeArea,omitempty"`
        // Locality represents XSD element 'Locality'
        Locality *LocalityElement `xml:"Locality,omitempty"`
        // Thoroughfare represents XSD element 'Thoroughfare'
        Thoroughfare *ThoroughfareElement `xml:"Thoroughfare,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareNumberSuffixElementType represents the XSD type 'ThoroughfareNumberSuffixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfareNumberSuffixElementType struct {
        // NumberSuffixSeparator represents XSD attribute 'NumberSuffixSeparator'
        // use="optional"
        NumberSuffixSeparator *string `xml:"NumberSuffixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostTownNameElementType represents the XSD type 'PostTownNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostTownNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareNumberRangeElementType represents the XSD type 'ThoroughfareNumberRangeElementType'
// XSD complex type (W3C XSD 3.4)
type ThoroughfareNumberRangeElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // ThoroughfareNumberFrom represents XSD element 'ThoroughfareNumberFrom'
        ThoroughfareNumberFrom ThoroughfareNumberFromElementType `xml:"ThoroughfareNumberFrom"`
        // ThoroughfareNumberTo represents XSD element 'ThoroughfareNumberTo'
        ThoroughfareNumberTo ThoroughfareNumberToElementType `xml:"ThoroughfareNumberTo"`
        // RangeType represents XSD attribute 'RangeType'
        // use="optional"
        RangeType *string `xml:"RangeType,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // Separator represents XSD attribute 'Separator'
        // use="optional"
        Separator *string `xml:"Separator,attr,omitempty"`
        // IndicatorOccurrence represents XSD attribute 'IndicatorOccurrence'
        // use="optional"
        IndicatorOccurrence *string `xml:"IndicatorOccurrence,attr,omitempty"`
        // NumberRangeOccurrence represents XSD attribute 'NumberRangeOccurrence'
        // use="optional"
        NumberRangeOccurrence *string `xml:"NumberRangeOccurrence,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SubPremiseNameElementType represents the XSD type 'SubPremiseNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SubPremiseNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // TypeOccurrence represents XSD attribute 'TypeOccurrence'
        // use="optional"
        TypeOccurrence *string `xml:"TypeOccurrence,attr,omitempty"`
        InnerXML       string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DependentLocalityNameElementType represents the XSD type 'DependentLocalityNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type DependentLocalityNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseNumberElementType represents the XSD type 'PremiseNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PremiseNumberElementType struct {
        // NumberType represents XSD attribute 'NumberType'
        // use="optional"
        NumberType *string `xml:"NumberType,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // IndicatorOccurrence represents XSD attribute 'IndicatorOccurrence'
        // use="optional"
        IndicatorOccurrence *string `xml:"IndicatorOccurrence,attr,omitempty"`
        // NumberTypeOccurrence represents XSD attribute 'NumberTypeOccurrence'
        // use="optional"
        NumberTypeOccurrence *string `xml:"NumberTypeOccurrence,attr,omitempty"`
        InnerXML             string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CountryNameElementType represents the XSD type 'CountryNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type CountryNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseNumberRangeToElementType represents the XSD type 'PremiseNumberRangeToElementType'
// XSD complex type (W3C XSD 3.4)
type PremiseNumberRangeToElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PremiseNumberPrefix represents XSD element 'PremiseNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        PremiseNumberPrefix []PremiseNumberPrefixElement `xml:"PremiseNumberPrefix,omitempty"`
        // PremiseNumber represents XSD element 'PremiseNumber'
        // minOccurs=1, maxOccurs=-1
        PremiseNumber []PremiseNumberElement `xml:"PremiseNumber"`
        // PremiseNumberSuffix represents XSD element 'PremiseNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        PremiseNumberSuffix []PremiseNumberSuffixElement `xml:"PremiseNumberSuffix,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AdministrativeAreaNameElementType represents the XSD type 'AdministrativeAreaNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AdministrativeAreaNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareNumberFromElementType represents the XSD type 'ThoroughfareNumberFromElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfareNumberFromElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // ThoroughfareNumberPrefix represents XSD element 'ThoroughfareNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareNumberPrefix []ThoroughfareNumberPrefixElement `xml:"ThoroughfareNumberPrefix,omitempty"`
        // ThoroughfareNumber represents XSD element 'ThoroughfareNumber'
        // minOccurs=1, maxOccurs=-1
        ThoroughfareNumber []ThoroughfareNumberElement `xml:"ThoroughfareNumber"`
        // ThoroughfareNumberSuffix represents XSD element 'ThoroughfareNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareNumberSuffix []ThoroughfareNumberSuffixElement `xml:"ThoroughfareNumberSuffix,omitempty"`
        Value                    string                            `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SubPremiseLocationElementType represents the XSD type 'SubPremiseLocationElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SubPremiseLocationElementType struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressElementType represents the XSD type 'AddressElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AddressElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DependentThoroughfareElementType represents the XSD type 'DependentThoroughfareElementType'
// XSD complex type (W3C XSD 3.4)
type DependentThoroughfareElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // ThoroughfarePreDirection represents XSD element 'ThoroughfarePreDirection'
        // minOccurs=0, maxOccurs=1
        ThoroughfarePreDirection *ThoroughfarePreDirectionType `xml:"ThoroughfarePreDirection,omitempty"`
        // ThoroughfareLeadingType represents XSD element 'ThoroughfareLeadingType'
        // minOccurs=0, maxOccurs=1
        ThoroughfareLeadingType *ThoroughfareLeadingTypeType `xml:"ThoroughfareLeadingType,omitempty"`
        // ThoroughfareName represents XSD element 'ThoroughfareName'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareName []ThoroughfareNameType `xml:"ThoroughfareName,omitempty"`
        // ThoroughfareTrailingType represents XSD element 'ThoroughfareTrailingType'
        // minOccurs=0, maxOccurs=1
        ThoroughfareTrailingType *ThoroughfareTrailingTypeType `xml:"ThoroughfareTrailingType,omitempty"`
        // ThoroughfarePostDirection represents XSD element 'ThoroughfarePostDirection'
        // minOccurs=0, maxOccurs=1
        ThoroughfarePostDirection *ThoroughfarePostDirectionType `xml:"ThoroughfarePostDirection,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DependentLocalityType represents the XSD type 'DependentLocalityType'
// XSD complex type (W3C XSD 3.4)
type DependentLocalityType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // DependentLocalityName represents XSD element 'DependentLocalityName'
        // minOccurs=0, maxOccurs=-1
        DependentLocalityName []DependentLocalityNameElementType `xml:"DependentLocalityName,omitempty"`
        // DependentLocalityNumber represents XSD element 'DependentLocalityNumber'
        // minOccurs=0, maxOccurs=1
        DependentLocalityNumber *DependentLocalityNumberElementType `xml:"DependentLocalityNumber,omitempty"`
        // Thoroughfare represents XSD element 'Thoroughfare'
        // minOccurs=0, maxOccurs=1
        Thoroughfare *ThoroughfareElement `xml:"Thoroughfare,omitempty"`
        // Premise represents XSD element 'Premise'
        // minOccurs=0, maxOccurs=1
        Premise *PremiseElement `xml:"Premise,omitempty"`
        // DependentLocality represents XSD element 'DependentLocality'
        // minOccurs=0, maxOccurs=1
        DependentLocality *DependentLocalityType `xml:"DependentLocality,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // PostBox represents XSD element 'PostBox'
        PostBox *PostBoxElement `xml:"PostBox,omitempty"`
        // LargeMailUser represents XSD element 'LargeMailUser'
        LargeMailUser *LargeMailUserType `xml:"LargeMailUser,omitempty"`
        // PostOffice represents XSD element 'PostOffice'
        PostOffice *PostOfficeElement `xml:"PostOffice,omitempty"`
        // PostalRoute represents XSD element 'PostalRoute'
        PostalRoute *PostalRouteType `xml:"PostalRoute,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UsageType represents XSD attribute 'UsageType'
        // use="optional"
        UsageType *string `xml:"UsageType,attr,omitempty"`
        // Connector represents XSD attribute 'Connector'
        // use="optional"
        Connector *string `xml:"Connector,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfarePostDirectionType represents the XSD type 'ThoroughfarePostDirectionType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfarePostDirectionType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseLocationElementType represents the XSD type 'PremiseLocationElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PremiseLocationElementType struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DependentLocalityNumberElementType represents the XSD type 'DependentLocalityNumberElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type DependentLocalityNumberElementType struct {
        // NameNumberOccurrence represents XSD attribute 'NameNumberOccurrence'
        // use="optional"
        NameNumberOccurrence *string `xml:"NameNumberOccurrence,attr,omitempty"`
        InnerXML             string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LargeMailUserNameElementType represents the XSD type 'LargeMailUserNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type LargeMailUserNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EndorsementLineCodeElementType represents the XSD type 'EndorsementLineCodeElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type EndorsementLineCodeElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressLongitudeDirectionElementType represents the XSD type 'AddressLongitudeDirectionElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AddressLongitudeDirectionElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DepartmentElementType represents the XSD type 'DepartmentElementType'
// XSD complex type (W3C XSD 3.4)
type DepartmentElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // DepartmentName represents XSD element 'DepartmentName'
        // minOccurs=0, maxOccurs=-1
        DepartmentName []DepartmentNameElementType `xml:"DepartmentName,omitempty"`
        // MailStop represents XSD element 'MailStop'
        // minOccurs=0, maxOccurs=1
        MailStop *MailStopType `xml:"MailStop,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseNumberSuffixElementType represents the XSD type 'PremiseNumberSuffixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PremiseNumberSuffixElementType struct {
        // NumberSuffixSeparator represents XSD attribute 'NumberSuffixSeparator'
        // use="optional"
        NumberSuffixSeparator *string `xml:"NumberSuffixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseNumberRangeFromElementType represents the XSD type 'PremiseNumberRangeFromElementType'
// XSD complex type (W3C XSD 3.4)
type PremiseNumberRangeFromElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PremiseNumberPrefix represents XSD element 'PremiseNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        PremiseNumberPrefix []PremiseNumberPrefixElement `xml:"PremiseNumberPrefix,omitempty"`
        // PremiseNumber represents XSD element 'PremiseNumber'
        // minOccurs=1, maxOccurs=-1
        PremiseNumber []PremiseNumberElement `xml:"PremiseNumber"`
        // PremiseNumberSuffix represents XSD element 'PremiseNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        PremiseNumberSuffix []PremiseNumberSuffixElement `xml:"PremiseNumberSuffix,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareElementType represents the XSD type 'ThoroughfareElementType'
// XSD complex type (W3C XSD 3.4)
type ThoroughfareElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // ThoroughfareNumberPrefix represents XSD element 'ThoroughfareNumberPrefix'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareNumberPrefix []ThoroughfareNumberPrefixElement `xml:"ThoroughfareNumberPrefix,omitempty"`
        // ThoroughfareNumberSuffix represents XSD element 'ThoroughfareNumberSuffix'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareNumberSuffix []ThoroughfareNumberSuffixElement `xml:"ThoroughfareNumberSuffix,omitempty"`
        // ThoroughfarePreDirection represents XSD element 'ThoroughfarePreDirection'
        // minOccurs=0, maxOccurs=1
        ThoroughfarePreDirection *ThoroughfarePreDirectionType `xml:"ThoroughfarePreDirection,omitempty"`
        // ThoroughfareLeadingType represents XSD element 'ThoroughfareLeadingType'
        // minOccurs=0, maxOccurs=1
        ThoroughfareLeadingType *ThoroughfareLeadingTypeType `xml:"ThoroughfareLeadingType,omitempty"`
        // ThoroughfareName represents XSD element 'ThoroughfareName'
        // minOccurs=0, maxOccurs=-1
        ThoroughfareName []ThoroughfareNameType `xml:"ThoroughfareName,omitempty"`
        // ThoroughfareTrailingType represents XSD element 'ThoroughfareTrailingType'
        // minOccurs=0, maxOccurs=1
        ThoroughfareTrailingType *ThoroughfareTrailingTypeType `xml:"ThoroughfareTrailingType,omitempty"`
        // ThoroughfarePostDirection represents XSD element 'ThoroughfarePostDirection'
        // minOccurs=0, maxOccurs=1
        ThoroughfarePostDirection *ThoroughfarePostDirectionType `xml:"ThoroughfarePostDirection,omitempty"`
        // DependentThoroughfare represents XSD element 'DependentThoroughfare'
        // minOccurs=0, maxOccurs=1
        DependentThoroughfare *DependentThoroughfareElementType `xml:"DependentThoroughfare,omitempty"`
        // ThoroughfareNumber represents XSD element 'ThoroughfareNumber'
        ThoroughfareNumber []ThoroughfareNumberElement `xml:"ThoroughfareNumber,omitempty"`
        // ThoroughfareNumberRange represents XSD element 'ThoroughfareNumberRange'
        ThoroughfareNumberRange []ThoroughfareNumberRangeElementType `xml:"ThoroughfareNumberRange,omitempty"`
        // DependentLocality represents XSD element 'DependentLocality'
        DependentLocality *DependentLocalityType `xml:"DependentLocality,omitempty"`
        // Premise represents XSD element 'Premise'
        Premise *PremiseElement `xml:"Premise,omitempty"`
        // Firm represents XSD element 'Firm'
        Firm *FirmType `xml:"Firm,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // DependentThoroughfares represents XSD attribute 'DependentThoroughfares'
        // use="optional"
        DependentThoroughfares *string `xml:"DependentThoroughfares,attr,omitempty"`
        // DependentThoroughfaresIndicator represents XSD attribute 'DependentThoroughfaresIndicator'
        // use="optional"
        DependentThoroughfaresIndicator *string `xml:"DependentThoroughfaresIndicator,attr,omitempty"`
        // DependentThoroughfaresConnector represents XSD attribute 'DependentThoroughfaresConnector'
        // use="optional"
        DependentThoroughfaresConnector *string `xml:"DependentThoroughfaresConnector,attr,omitempty"`
        // DependentThoroughfaresType represents XSD attribute 'DependentThoroughfaresType'
        // use="optional"
        DependentThoroughfaresType *string `xml:"DependentThoroughfaresType,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LargeMailUserIdentifierElementType represents the XSD type 'LargeMailUserIdentifierElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type LargeMailUserIdentifierElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        InnerXML  string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressIdentifierElementType represents the XSD type 'AddressIdentifierElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AddressIdentifierElementType struct {
        // IdentifierType represents XSD attribute 'IdentifierType'
        // use="optional"
        IdentifierType *string `xml:"IdentifierType,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressLatitudeElementType represents the XSD type 'AddressLatitudeElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AddressLatitudeElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressLongitudeElementType represents the XSD type 'AddressLongitudeElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AddressLongitudeElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LargeMailUserType represents the XSD type 'LargeMailUserType'
// XSD complex type (W3C XSD 3.4)
type LargeMailUserType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // LargeMailUserName represents XSD element 'LargeMailUserName'
        // minOccurs=0, maxOccurs=-1
        LargeMailUserName []LargeMailUserNameElementType `xml:"LargeMailUserName,omitempty"`
        // LargeMailUserIdentifier represents XSD element 'LargeMailUserIdentifier'
        // minOccurs=0, maxOccurs=1
        LargeMailUserIdentifier *LargeMailUserIdentifierElementType `xml:"LargeMailUserIdentifier,omitempty"`
        // BuildingName represents XSD element 'BuildingName'
        // minOccurs=0, maxOccurs=-1
        BuildingName []BuildingNameType `xml:"BuildingName,omitempty"`
        // Department represents XSD element 'Department'
        // minOccurs=0, maxOccurs=1
        Department *DepartmentElement `xml:"Department,omitempty"`
        // PostBox represents XSD element 'PostBox'
        // minOccurs=0, maxOccurs=1
        PostBox *PostBoxElement `xml:"PostBox,omitempty"`
        // Thoroughfare represents XSD element 'Thoroughfare'
        // minOccurs=0, maxOccurs=1
        Thoroughfare *ThoroughfareElement `xml:"Thoroughfare,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseNumberPrefixElementType represents the XSD type 'PremiseNumberPrefixElementType'
// XSD complex type (W3C XSD 3.4)
type PremiseNumberPrefixElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // NumberPrefixSeparator represents XSD attribute 'NumberPrefixSeparator'
        // use="optional"
        NumberPrefixSeparator *string `xml:"NumberPrefixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseNumberPrefixElementType is an alias for PremiseNumberPrefixElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type PremiseNumberPrefixElementType = PremiseNumberPrefixElementTypeWithAttrs

// SubAdministrativeAreaElementType represents the XSD type 'SubAdministrativeAreaElementType'
// XSD complex type (W3C XSD 3.4)
type SubAdministrativeAreaElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // SubAdministrativeAreaName represents XSD element 'SubAdministrativeAreaName'
        // minOccurs=0, maxOccurs=-1
        SubAdministrativeAreaName []SubAdministrativeAreaNameElementType `xml:"SubAdministrativeAreaName,omitempty"`
        // Locality represents XSD element 'Locality'
        Locality *LocalityElement `xml:"Locality,omitempty"`
        // PostOffice represents XSD element 'PostOffice'
        PostOffice *PostOfficeElement `xml:"PostOffice,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UsageType represents XSD attribute 'UsageType'
        // use="optional"
        UsageType *string `xml:"UsageType,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FirmNameElementType represents the XSD type 'FirmNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type FirmNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CountryNameCodeElementType represents the XSD type 'CountryNameCodeElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type CountryNameCodeElementType struct {
        // Scheme represents XSD attribute 'Scheme'
        // use="optional"
        Scheme   *string `xml:"Scheme,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressDetails represents the XSD type 'AddressDetails'
// XSD complex type (W3C XSD 3.4)
type AddressDetails struct {
        // PostalServiceElements represents XSD element 'PostalServiceElements'
        // minOccurs=0, maxOccurs=1
        PostalServiceElements *PostalServiceElementsElementType `xml:"PostalServiceElements,omitempty"`
        // Address represents XSD element 'Address'
        Address *AddressElementType `xml:"Address,omitempty"`
        // AddressLines represents XSD element 'AddressLines'
        AddressLines *AddressLinesType `xml:"AddressLines,omitempty"`
        // Country represents XSD element 'Country'
        Country *CountryElementType `xml:"Country,omitempty"`
        // AdministrativeArea represents XSD element 'AdministrativeArea'
        AdministrativeArea *AdministrativeAreaElement `xml:"AdministrativeArea,omitempty"`
        // Locality represents XSD element 'Locality'
        Locality *LocalityElement `xml:"Locality,omitempty"`
        // Thoroughfare represents XSD element 'Thoroughfare'
        Thoroughfare *ThoroughfareElement `xml:"Thoroughfare,omitempty"`
        // AddressType represents XSD attribute 'AddressType'
        // use="optional"
        AddressType *string `xml:"AddressType,attr,omitempty"`
        // CurrentStatus represents XSD attribute 'CurrentStatus'
        // use="optional"
        CurrentStatus *string `xml:"CurrentStatus,attr,omitempty"`
        // ValidFromDate represents XSD attribute 'ValidFromDate'
        // use="optional"
        ValidFromDate *string `xml:"ValidFromDate,attr,omitempty"`
        // ValidToDate represents XSD attribute 'ValidToDate'
        // use="optional"
        ValidToDate *string `xml:"ValidToDate,attr,omitempty"`
        // Usage represents XSD attribute 'Usage'
        // use="optional"
        Usage *string `xml:"Usage,attr,omitempty"`
        // AddressDetailsKey represents XSD attribute 'AddressDetailsKey'
        // use="optional"
        AddressDetailsKey *string `xml:"AddressDetailsKey,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ThoroughfareLeadingTypeType represents the XSD type 'ThoroughfareLeadingTypeType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ThoroughfareLeadingTypeType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddressLineElementType represents the XSD type 'AddressLineElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AddressLineElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LocalityElementType represents the XSD type 'LocalityElementType'
// XSD complex type (W3C XSD 3.4)
type LocalityElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // LocalityName represents XSD element 'LocalityName'
        // minOccurs=0, maxOccurs=-1
        LocalityName []LocalityNameElementType `xml:"LocalityName,omitempty"`
        // Thoroughfare represents XSD element 'Thoroughfare'
        // minOccurs=0, maxOccurs=1
        Thoroughfare *ThoroughfareElement `xml:"Thoroughfare,omitempty"`
        // Premise represents XSD element 'Premise'
        // minOccurs=0, maxOccurs=1
        Premise *PremiseElement `xml:"Premise,omitempty"`
        // DependentLocality represents XSD element 'DependentLocality'
        // minOccurs=0, maxOccurs=1
        DependentLocality *DependentLocalityType `xml:"DependentLocality,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // PostBox represents XSD element 'PostBox'
        PostBox *PostBoxElement `xml:"PostBox,omitempty"`
        // LargeMailUser represents XSD element 'LargeMailUser'
        LargeMailUser *LargeMailUserType `xml:"LargeMailUser,omitempty"`
        // PostOffice represents XSD element 'PostOffice'
        PostOffice *PostOfficeElement `xml:"PostOffice,omitempty"`
        // PostalRoute represents XSD element 'PostalRoute'
        PostalRoute *PostalRouteType `xml:"PostalRoute,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UsageType represents XSD attribute 'UsageType'
        // use="optional"
        UsageType *string `xml:"UsageType,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// XALElementType represents the XSD type 'XALElementType'
// XSD complex type (W3C XSD 3.4)
type XALElementType struct {
        // AddressDetails represents XSD element 'AddressDetails'
        // minOccurs=1, maxOccurs=-1
        AddressDetails []AddressDetails `xml:"AddressDetails"`
        // Version represents XSD attribute 'Version'
        // use="optional"
        Version *string `xml:"Version,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostBoxNumberSuffixElementType represents the XSD type 'PostBoxNumberSuffixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PostBoxNumberSuffixElementType struct {
        // NumberSuffixSeparator represents XSD attribute 'NumberSuffixSeparator'
        // use="optional"
        NumberSuffixSeparator *string `xml:"NumberSuffixSeparator,attr,omitempty"`
        InnerXML              string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PremiseNameElementType represents the XSD type 'PremiseNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PremiseNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // TypeOccurrence represents XSD attribute 'TypeOccurrence'
        // use="optional"
        TypeOccurrence *string `xml:"TypeOccurrence,attr,omitempty"`
        InnerXML       string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostalServiceElementsElementType represents the XSD type 'PostalServiceElementsElementType'
// XSD complex type (W3C XSD 3.4)
type PostalServiceElementsElementType struct {
        // AddressIdentifier represents XSD element 'AddressIdentifier'
        // minOccurs=0, maxOccurs=-1
        AddressIdentifier []AddressIdentifierElementType `xml:"AddressIdentifier,omitempty"`
        // EndorsementLineCode represents XSD element 'EndorsementLineCode'
        // minOccurs=0, maxOccurs=1
        EndorsementLineCode *EndorsementLineCodeElementType `xml:"EndorsementLineCode,omitempty"`
        // KeyLineCode represents XSD element 'KeyLineCode'
        // minOccurs=0, maxOccurs=1
        KeyLineCode *KeyLineCodeElementType `xml:"KeyLineCode,omitempty"`
        // Barcode represents XSD element 'Barcode'
        // minOccurs=0, maxOccurs=1
        Barcode *BarcodeElementType `xml:"Barcode,omitempty"`
        // SortingCode represents XSD element 'SortingCode'
        // minOccurs=0, maxOccurs=1
        SortingCode *SortingCodeElementType `xml:"SortingCode,omitempty"`
        // AddressLatitude represents XSD element 'AddressLatitude'
        // minOccurs=0, maxOccurs=1
        AddressLatitude *AddressLatitudeElementType `xml:"AddressLatitude,omitempty"`
        // AddressLatitudeDirection represents XSD element 'AddressLatitudeDirection'
        // minOccurs=0, maxOccurs=1
        AddressLatitudeDirection *AddressLatitudeDirectionElementType `xml:"AddressLatitudeDirection,omitempty"`
        // AddressLongitude represents XSD element 'AddressLongitude'
        // minOccurs=0, maxOccurs=1
        AddressLongitude *AddressLongitudeElementType `xml:"AddressLongitude,omitempty"`
        // AddressLongitudeDirection represents XSD element 'AddressLongitudeDirection'
        // minOccurs=0, maxOccurs=1
        AddressLongitudeDirection *AddressLongitudeDirectionElementType `xml:"AddressLongitudeDirection,omitempty"`
        // SupplementaryPostalServiceData represents XSD element 'SupplementaryPostalServiceData'
        // minOccurs=0, maxOccurs=-1
        SupplementaryPostalServiceData []SupplementaryPostalServiceDataElementType `xml:"SupplementaryPostalServiceData,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MailStopType represents the XSD type 'MailStopType'
// XSD complex type (W3C XSD 3.4)
type MailStopType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // MailStopName represents XSD element 'MailStopName'
        // minOccurs=0, maxOccurs=1
        MailStopName *MailStopNameElementType `xml:"MailStopName,omitempty"`
        // MailStopNumber represents XSD element 'MailStopNumber'
        // minOccurs=0, maxOccurs=1
        MailStopNumber *MailStopNumberElementType `xml:"MailStopNumber,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LocalityNameElementType represents the XSD type 'LocalityNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type LocalityNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PostOfficeElementType represents the XSD type 'PostOfficeElementType'
// XSD complex type (W3C XSD 3.4)
type PostOfficeElementType struct {
        // AddressLine represents XSD element 'AddressLine'
        // minOccurs=0, maxOccurs=-1
        AddressLine []AddressLineElement `xml:"AddressLine,omitempty"`
        // PostalRoute represents XSD element 'PostalRoute'
        // minOccurs=0, maxOccurs=1
        PostalRoute *PostalRouteType `xml:"PostalRoute,omitempty"`
        // PostBox represents XSD element 'PostBox'
        // minOccurs=0, maxOccurs=1
        PostBox *PostBoxElement `xml:"PostBox,omitempty"`
        // PostalCode represents XSD element 'PostalCode'
        // minOccurs=0, maxOccurs=1
        PostalCode *PostalCodeElement `xml:"PostalCode,omitempty"`
        // PostOfficeName represents XSD element 'PostOfficeName'
        // minOccurs=0, maxOccurs=-1
        PostOfficeName []PostOfficeNameElementType `xml:"PostOfficeName,omitempty"`
        // PostOfficeNumber represents XSD element 'PostOfficeNumber'
        // minOccurs=0, maxOccurs=1
        PostOfficeNumber *PostOfficeNumberElementType `xml:"PostOfficeNumber,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Indicator represents XSD attribute 'Indicator'
        // use="optional"
        Indicator *string `xml:"Indicator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SubPremiseNumberPrefixElementType represents the XSD type 'SubPremiseNumberPrefixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SubPremiseNumberPrefixElementType struct {
        // NumberPrefixSeparator represents XSD attribute 'NumberPrefixSeparator'
        // use="optional"
        NumberPrefixSeparator *string `xml:"NumberPrefixSeparator,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type     *string `xml:"Type,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package pkg_2_0 generated from XSD schema
// Source namespace: urn:oasis:names:tc:ciq:xsdschema:xNL:2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/xNL.xsd
// Generated by forgexml - Do not edit manually

package pkg_2_0

import (
        "encoding/xml"
        "os"
        "strings"
)

// PersonNameElement represents the XSD element 'PersonName'
// XSD element declaration (W3C XSD 3.3)
type PersonNameElement struct {
        XMLName    xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xNL:2.0 PersonName"`
        PersonName          // XSD extension base
        // FormerName represents XSD element 'FormerName'
        // minOccurs=0, maxOccurs=-1
        FormerName []FormerNameElementType `xml:"FormerName,omitempty"`
        // KnownAs represents XSD element 'KnownAs'
        // minOccurs=0, maxOccurs=-1
        KnownAs []KnownAsElementType `xml:"KnownAs,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PersonNameElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PersonNameElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PersonNameElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PersonNameElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PersonNameElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PersonNameElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PersonNameElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PersonNameElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PersonNameElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPersonNameFromBytes loads an element from bytes with namespace preservation
func LoadPersonNameFromBytes(data []byte) (*PersonNameElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PersonNameElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPersonNameFromFile loads an element from a file with namespace preservation
func LoadPersonNameFromFile(path string) (*PersonNameElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPersonNameFromBytes(data)</span>
}

// JointPersonNameElement represents the XSD element 'JointPersonName'
// XSD element declaration (W3C XSD 3.3)
type JointPersonNameElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xNL:2.0 JointPersonName"`
        // NameLine represents XSD element 'NameLine'
        // minOccurs=1, maxOccurs=-1
        NameLine []NameLineType `xml:"NameLine,omitempty"`
        // PersonName represents XSD element 'PersonName'
        // minOccurs=1, maxOccurs=-1
        PersonName []PersonNameElement `xml:"PersonName,omitempty"`
        // JointNameConnector represents XSD attribute 'JointNameConnector'
        // use="optional"
        JointNameConnector *string `xml:"JointNameConnector,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code *string `xml:"Code,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *JointPersonNameElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias JointPersonNameElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *JointPersonNameElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias JointPersonNameElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *JointPersonNameElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *JointPersonNameElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *JointPersonNameElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *JointPersonNameElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *JointPersonNameElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadJointPersonNameFromBytes loads an element from bytes with namespace preservation
func LoadJointPersonNameFromBytes(data []byte) (*JointPersonNameElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element JointPersonNameElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadJointPersonNameFromFile loads an element from a file with namespace preservation
func LoadJointPersonNameFromFile(path string) (*JointPersonNameElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadJointPersonNameFromBytes(data)</span>
}

// OrganisationNameDetailsElement represents the XSD element 'OrganisationNameDetails'
// XSD element declaration (W3C XSD 3.3)
type OrganisationNameDetailsElement struct {
        XMLName                 xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xNL:2.0 OrganisationNameDetails"`
        OrganisationNameDetails          // XSD extension base
        // OrganisationFormerName represents XSD element 'OrganisationFormerName'
        // minOccurs=0, maxOccurs=-1
        OrganisationFormerName []OrganisationFormerNameElementType `xml:"OrganisationFormerName,omitempty"`
        // OrganisationKnownAs represents XSD element 'OrganisationKnownAs'
        // minOccurs=0, maxOccurs=-1
        OrganisationKnownAs []OrganisationKnownAsElementType `xml:"OrganisationKnownAs,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *OrganisationNameDetailsElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias OrganisationNameDetailsElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *OrganisationNameDetailsElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias OrganisationNameDetailsElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *OrganisationNameDetailsElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *OrganisationNameDetailsElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *OrganisationNameDetailsElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *OrganisationNameDetailsElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *OrganisationNameDetailsElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadOrganisationNameDetailsFromBytes loads an element from bytes with namespace preservation
func LoadOrganisationNameDetailsFromBytes(data []byte) (*OrganisationNameDetailsElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element OrganisationNameDetailsElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadOrganisationNameDetailsFromFile loads an element from a file with namespace preservation
func LoadOrganisationNameDetailsFromFile(path string) (*OrganisationNameDetailsElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadOrganisationNameDetailsFromBytes(data)</span>
}

// FunctionElement represents the XSD element 'Function'
// XSD element declaration (W3C XSD 3.3)
type FunctionElement struct {
        XMLName  xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xNL:2.0 Function"`
        Function          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *FunctionElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias FunctionElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *FunctionElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias FunctionElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *FunctionElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *FunctionElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *FunctionElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *FunctionElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *FunctionElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadFunctionFromBytes loads an element from bytes with namespace preservation
func LoadFunctionFromBytes(data []byte) (*FunctionElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element FunctionElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadFunctionFromFile loads an element from a file with namespace preservation
func LoadFunctionFromFile(path string) (*FunctionElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadFunctionFromBytes(data)</span>
}

// XNLElement represents the XSD element 'xNL'
// XSD element declaration (W3C XSD 3.3)
type XNLElement struct {
        XMLName xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xNL:2.0 xNL"`
        // NameDetails represents XSD element 'NameDetails'
        // minOccurs=1, maxOccurs=-1
        NameDetails []NameDetailsElement `xml:"NameDetails"`
        // Version represents XSD attribute 'Version'
        // use="optional"
        Version *string `xml:"Version,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *XNLElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias XNLElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *XNLElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias XNLElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *XNLElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *XNLElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *XNLElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *XNLElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *XNLElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadXNLFromBytes loads an element from bytes with namespace preservation
func LoadXNLFromBytes(data []byte) (*XNLElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element XNLElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadXNLFromFile loads an element from a file with namespace preservation
func LoadXNLFromFile(path string) (*XNLElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadXNLFromBytes(data)</span>
}

// NameDetailsElement represents the XSD element 'NameDetails'
// XSD element declaration (W3C XSD 3.3)
type NameDetailsElement struct {
        XMLName     xml.Name `xml:"urn:oasis:names:tc:ciq:xsdschema:xNL:2.0 NameDetails"`
        NameDetails          // XSD extension base
        // AddresseeIndicator represents XSD element 'AddresseeIndicator'
        // minOccurs=0, maxOccurs=1
        AddresseeIndicator *AddresseeIndicatorElementType `xml:"AddresseeIndicator,omitempty"`
        // Function represents XSD element 'Function'
        // minOccurs=0, maxOccurs=1
        Function *Function `xml:"Function,omitempty"`
        // DependencyName represents XSD element 'DependencyName'
        // minOccurs=0, maxOccurs=1
        DependencyName *DependencyNameElementType `xml:"DependencyName,omitempty"`
        // NameDetailsKey represents XSD attribute 'NameDetailsKey'
        // use="optional"
        NameDetailsKey *string `xml:"NameDetailsKey,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *NameDetailsElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias NameDetailsElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *NameDetailsElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias NameDetailsElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *NameDetailsElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *NameDetailsElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *NameDetailsElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *NameDetailsElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *NameDetailsElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadNameDetailsFromBytes loads an element from bytes with namespace preservation
func LoadNameDetailsFromBytes(data []byte) (*NameDetailsElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element NameDetailsElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadNameDetailsFromFile loads an element from a file with namespace preservation
func LoadNameDetailsFromFile(path string) (*NameDetailsElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadNameDetailsFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package pkg_2_0 generated from XSD schema
// Source namespace: urn:oasis:names:tc:ciq:xsdschema:xNL:2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/xNL.xsd
// Generated by forgexml - Do not edit manually

package pkg_2_0

import (
        "encoding/xml"
        "regexp"
        "strings"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// NameDetailsElementType represents the XSD type 'NameDetailsElementType'
// XSD complex type (W3C XSD 3.4)
type NameDetailsElementType struct {
        NameDetails // XSD extension base
        // AddresseeIndicator represents XSD element 'AddresseeIndicator'
        // minOccurs=0, maxOccurs=1
        AddresseeIndicator *AddresseeIndicatorElementType `xml:"AddresseeIndicator,omitempty"`
        // Function represents XSD element 'Function'
        // minOccurs=0, maxOccurs=1
        Function *Function `xml:"Function,omitempty"`
        // DependencyName represents XSD element 'DependencyName'
        // minOccurs=0, maxOccurs=1
        DependencyName *DependencyNameElementType `xml:"DependencyName,omitempty"`
        // NameDetailsKey represents XSD attribute 'NameDetailsKey'
        // use="optional"
        NameDetailsKey *string `xml:"NameDetailsKey,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PersonNameElementType represents the XSD type 'PersonNameElementType'
// XSD complex type (W3C XSD 3.4)
type PersonNameElementType struct {
        PersonName // XSD extension base
        // FormerName represents XSD element 'FormerName'
        // minOccurs=0, maxOccurs=-1
        FormerName []FormerNameElementType `xml:"FormerName,omitempty"`
        // KnownAs represents XSD element 'KnownAs'
        // minOccurs=0, maxOccurs=-1
        KnownAs []KnownAsElementType `xml:"KnownAs,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// KnownAsElementType represents the XSD type 'KnownAsElementType'
// XSD complex type (W3C XSD 3.4)
type KnownAsElementType struct {
        PersonName // XSD extension base
        // ValidFrom represents XSD attribute 'ValidFrom'
        // use="optional"
        ValidFrom *string `xml:"ValidFrom,attr,omitempty"`
        // ValidTo represents XSD attribute 'ValidTo'
        // use="optional"
        ValidTo *string `xml:"ValidTo,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// OrganisationTypeElementType represents the XSD type 'OrganisationTypeElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type OrganisationTypeElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LastNameElementType represents the XSD type 'LastNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type LastNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// XNLElementType represents the XSD type 'XNLElementType'
// XSD complex type (W3C XSD 3.4)
type XNLElementType struct {
        // NameDetails represents XSD element 'NameDetails'
        // minOccurs=1, maxOccurs=-1
        NameDetails []NameDetailsElement `xml:"NameDetails"`
        // Version represents XSD attribute 'Version'
        // use="optional"
        Version *string `xml:"Version,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FirstNameElementType represents the XSD type 'FirstNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type FirstNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// NamePrefixElementType represents the XSD type 'NamePrefixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type NamePrefixElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// GeneralSuffixElementType represents the XSD type 'GeneralSuffixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type GeneralSuffixElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// OrganisationFormerNameElementType represents the XSD type 'OrganisationFormerNameElementType'
// XSD complex type (W3C XSD 3.4)
type OrganisationFormerNameElementType struct {
        OrganisationNameDetails // XSD extension base
        // ValidFrom represents XSD attribute 'ValidFrom'
        // use="optional"
        ValidFrom *string `xml:"ValidFrom,attr,omitempty"`
        // ValidTo represents XSD attribute 'ValidTo'
        // use="optional"
        ValidTo *string `xml:"ValidTo,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// GenerationIdentifierElementType represents the XSD type 'GenerationIdentifierElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type GenerationIdentifierElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SuffixElementType represents the XSD type 'SuffixElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SuffixElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// Function represents the XSD type 'Function'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type Function struct {
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// NameLineType represents the XSD type 'NameLineType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type NameLineType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// OrganisationNameDetailsElementType represents the XSD type 'OrganisationNameDetailsElementType'
// XSD complex type (W3C XSD 3.4)
type OrganisationNameDetailsElementType struct {
        OrganisationNameDetails // XSD extension base
        // OrganisationFormerName represents XSD element 'OrganisationFormerName'
        // minOccurs=0, maxOccurs=-1
        OrganisationFormerName []OrganisationFormerNameElementType `xml:"OrganisationFormerName,omitempty"`
        // OrganisationKnownAs represents XSD element 'OrganisationKnownAs'
        // minOccurs=0, maxOccurs=-1
        OrganisationKnownAs []OrganisationKnownAsElementType `xml:"OrganisationKnownAs,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TitleElementType represents the XSD type 'TitleElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type TitleElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MiddleNameElementType represents the XSD type 'MiddleNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type MiddleNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// OrganisationNameDetails represents the XSD type 'OrganisationNameDetails'
// XSD complex type (W3C XSD 3.4)
type OrganisationNameDetails struct {
        // NameLine represents XSD element 'NameLine'
        // minOccurs=0, maxOccurs=-1
        NameLine []NameLineType `xml:"NameLine,omitempty"`
        // OrganisationName represents XSD element 'OrganisationName'
        // minOccurs=0, maxOccurs=-1
        OrganisationName []OrganisationNameElementType `xml:"OrganisationName,omitempty"`
        // OrganisationType represents XSD element 'OrganisationType'
        // minOccurs=0, maxOccurs=-1
        OrganisationType []OrganisationTypeElementType `xml:"OrganisationType,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DependencyNameElementType represents the XSD type 'DependencyNameElementType'
// XSD complex type (W3C XSD 3.4)
type DependencyNameElementType struct {
        NameDetails // XSD extension base
        // DependencyType represents XSD attribute 'DependencyType'
        // use="optional"
        DependencyType *string `xml:"DependencyType,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// NameDetails represents the XSD type 'NameDetails'
// XSD complex type (W3C XSD 3.4)
type NameDetails struct {
        // NameLine represents XSD element 'NameLine'
        // minOccurs=1, maxOccurs=-1
        NameLine []NameLineType `xml:"NameLine,omitempty"`
        // PersonName represents XSD element 'PersonName'
        PersonName *PersonNameElement `xml:"PersonName,omitempty"`
        // JointPersonName represents XSD element 'JointPersonName'
        JointPersonName *JointPersonNameElement `xml:"JointPersonName,omitempty"`
        // OrganisationNameDetails represents XSD element 'OrganisationNameDetails'
        OrganisationNameDetails *OrganisationNameDetailsElement `xml:"OrganisationNameDetails,omitempty"`
        // PartyType represents XSD attribute 'PartyType'
        // use="optional"
        PartyType *string `xml:"PartyType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code *string `xml:"Code,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PersonName represents the XSD type 'PersonName'
// XSD complex type (W3C XSD 3.4)
type PersonName struct {
        // NameLine represents XSD element 'NameLine'
        // minOccurs=0, maxOccurs=-1
        NameLine []NameLineType `xml:"NameLine,omitempty"`
        // PrecedingTitle represents XSD element 'PrecedingTitle'
        // minOccurs=0, maxOccurs=-1
        PrecedingTitle []PrecedingTitleElementType `xml:"PrecedingTitle,omitempty"`
        // Title represents XSD element 'Title'
        // minOccurs=0, maxOccurs=-1
        Title []TitleElementType `xml:"Title,omitempty"`
        // FirstName represents XSD element 'FirstName'
        // minOccurs=0, maxOccurs=-1
        FirstName []FirstNameElementType `xml:"FirstName,omitempty"`
        // MiddleName represents XSD element 'MiddleName'
        // minOccurs=0, maxOccurs=-1
        MiddleName []MiddleNameElementType `xml:"MiddleName,omitempty"`
        // NamePrefix represents XSD element 'NamePrefix'
        // minOccurs=0, maxOccurs=1
        NamePrefix *NamePrefixElementType `xml:"NamePrefix,omitempty"`
        // LastName represents XSD element 'LastName'
        // minOccurs=0, maxOccurs=-1
        LastName []LastNameElementType `xml:"LastName,omitempty"`
        // OtherName represents XSD element 'OtherName'
        // minOccurs=0, maxOccurs=-1
        OtherName []OtherNameElementType `xml:"OtherName,omitempty"`
        // Alias represents XSD element 'Alias'
        // minOccurs=0, maxOccurs=-1
        Alias []AliasElementType `xml:"Alias,omitempty"`
        // GenerationIdentifier represents XSD element 'GenerationIdentifier'
        // minOccurs=0, maxOccurs=-1
        GenerationIdentifier []GenerationIdentifierElementType `xml:"GenerationIdentifier,omitempty"`
        // Suffix represents XSD element 'Suffix'
        // minOccurs=0, maxOccurs=-1
        Suffix []SuffixElementType `xml:"Suffix,omitempty"`
        // GeneralSuffix represents XSD element 'GeneralSuffix'
        // minOccurs=0, maxOccurs=1
        GeneralSuffix *GeneralSuffixElementType `xml:"GeneralSuffix,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code *string `xml:"Code,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// OrganisationKnownAsElementType represents the XSD type 'OrganisationKnownAsElementType'
// XSD complex type (W3C XSD 3.4)
type OrganisationKnownAsElementType struct {
        OrganisationNameDetails // XSD extension base
        // ValidFrom represents XSD attribute 'ValidFrom'
        // use="optional"
        ValidFrom *string `xml:"ValidFrom,attr,omitempty"`
        // ValidTo represents XSD attribute 'ValidTo'
        // use="optional"
        ValidTo *string `xml:"ValidTo,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AliasElementType represents the XSD type 'AliasElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AliasElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FormerNameElementType represents the XSD type 'FormerNameElementType'
// XSD complex type (W3C XSD 3.4)
type FormerNameElementType struct {
        PersonName // XSD extension base
        // ValidFrom represents XSD attribute 'ValidFrom'
        // use="optional"
        ValidFrom *string `xml:"ValidFrom,attr,omitempty"`
        // ValidTo represents XSD attribute 'ValidTo'
        // use="optional"
        ValidTo *string `xml:"ValidTo,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// OrganisationNameElementType represents the XSD type 'OrganisationNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type OrganisationNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AddresseeIndicatorElementType represents the XSD type 'AddresseeIndicatorElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type AddresseeIndicatorElementType struct {
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// JointPersonNameElementType represents the XSD type 'JointPersonNameElementType'
// XSD complex type (W3C XSD 3.4)
type JointPersonNameElementType struct {
        // NameLine represents XSD element 'NameLine'
        // minOccurs=1, maxOccurs=-1
        NameLine []NameLineType `xml:"NameLine,omitempty"`
        // PersonName represents XSD element 'PersonName'
        // minOccurs=1, maxOccurs=-1
        PersonName []PersonNameElement `xml:"PersonName,omitempty"`
        // JointNameConnector represents XSD attribute 'JointNameConnector'
        // use="optional"
        JointNameConnector *string `xml:"JointNameConnector,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code *string `xml:"Code,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PrecedingTitleElementType represents the XSD type 'PrecedingTitleElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type PrecedingTitleElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// OtherNameElementType represents the XSD type 'OtherNameElementType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type OtherNameElementType struct {
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // NameType represents XSD attribute 'NameType'
        // use="optional"
        NameType *string `xml:"NameType,attr,omitempty"`
        // Code represents XSD attribute 'Code'
        // use="optional"
        Code     *string `xml:"Code,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package dictionary2_0 generated from XSD schema
// Source namespace: http://cpe.mitre.org/dictionary/2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/cpe-dictionary/cpe-dictionary_2.1.xsd
// Generated by forgexml - Do not edit manually

package dictionary2_0

import (
        "encoding/xml"
        "os"
        "strings"
)

// CpeListElement represents the XSD element 'cpe-list'
// XSD element declaration (W3C XSD 3.3)
type CpeListElement struct {
        XMLName  xml.Name `xml:"http://cpe.mitre.org/dictionary/2.0 cpe-list"`
        ListType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *CpeListElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias CpeListElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *CpeListElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias CpeListElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *CpeListElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *CpeListElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *CpeListElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *CpeListElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *CpeListElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadCpeListFromBytes loads an element from bytes with namespace preservation
func LoadCpeListFromBytes(data []byte) (*CpeListElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element CpeListElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadCpeListFromFile loads an element from a file with namespace preservation
func LoadCpeListFromFile(path string) (*CpeListElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadCpeListFromBytes(data)</span>
}

// CpeItemElement represents the XSD element 'cpe-item'
// XSD element declaration (W3C XSD 3.3)
type CpeItemElement struct {
        XMLName  xml.Name `xml:"http://cpe.mitre.org/dictionary/2.0 cpe-item"`
        ItemType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *CpeItemElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias CpeItemElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *CpeItemElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias CpeItemElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *CpeItemElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *CpeItemElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *CpeItemElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *CpeItemElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *CpeItemElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadCpeItemFromBytes loads an element from bytes with namespace preservation
func LoadCpeItemFromBytes(data []byte) (*CpeItemElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element CpeItemElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadCpeItemFromFile loads an element from a file with namespace preservation
func LoadCpeItemFromFile(path string) (*CpeItemElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadCpeItemFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package dictionary2_0 generated from XSD schema
// Source namespace: http://cpe.mitre.org/dictionary/2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/cpe-dictionary/cpe-dictionary_2.1.xsd
// Generated by forgexml - Do not edit manually

package dictionary2_0

import (
        "encoding/xml"
        "regexp"
        "strings"

        types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// NamePattern represents the XSD type 'namePattern'
// XSD simple type (W3C XSD 4.1)
// pattern="[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\._\-~%]*){0,6}"
type NamePattern string

// GeneratorType represents the XSD type 'GeneratorType'
// XSD complex type (W3C XSD 3.4)
type GeneratorType struct {
        // Product_name represents XSD element 'product_name'
        // minOccurs=0, maxOccurs=1
        Product_name *string `xml:"product_name,omitempty"`
        // Product_version represents XSD element 'product_version'
        // minOccurs=0, maxOccurs=1
        Product_version *string `xml:"product_version,omitempty"`
        // Schema_version represents XSD element 'schema_version'
        Schema_version string `xml:"schema_version"`
        // Timestamp represents XSD element 'timestamp'
        Timestamp types.DateTime `xml:"timestamp"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TextType represents the XSD type 'TextType'
// XSD complex type (W3C XSD 3.4)
type TextTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TextType is an alias for TextTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type TextType = TextTypeWithAttrs

// ReferencesType represents the XSD type 'ReferencesType'
// XSD complex type (W3C XSD 3.4)
type ReferencesType struct {
        // Reference represents XSD element 'reference'
        // minOccurs=1, maxOccurs=-1
        Reference []ReferenceElementType `xml:"reference"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ItemType represents the XSD type 'ItemType'
// XSD complex type (W3C XSD 3.4)
type ItemType struct {
        // Title represents XSD element 'title'
        // minOccurs=1, maxOccurs=-1
        Title []TextTypeWithAttrs `xml:"title"`
        // Notes represents XSD element 'notes'
        // minOccurs=0, maxOccurs=-1
        Notes []NotesType `xml:"notes,omitempty"`
        // References represents XSD element 'references'
        // minOccurs=0, maxOccurs=1
        References *ReferencesType `xml:"references,omitempty"`
        // Check represents XSD element 'check'
        // minOccurs=0, maxOccurs=-1
        Check []CheckTypeWithAttrs `xml:"check,omitempty"`
        // Name represents XSD attribute 'name'
        // use="required"
        Name NamePattern `xml:"name,attr"`
        // Deprecated represents XSD attribute 'deprecated'
        // use="optional"
        Deprecated *bool `xml:"deprecated,attr,omitempty"`
        // Deprecated_by represents XSD attribute 'deprecated_by'
        // use="optional"
        Deprecated_by *NamePattern `xml:"deprecated_by,attr,omitempty"`
        // Deprecation_date represents XSD attribute 'deprecation_date'
        // use="optional"
        Deprecation_date *types.DateTime `xml:"deprecation_date,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ListType represents the XSD type 'ListType'
// XSD complex type (W3C XSD 3.4)
type ListType struct {
        // Generator represents XSD element 'generator'
        // minOccurs=0, maxOccurs=1
        Generator *GeneratorType `xml:"generator,omitempty"`
        // CpeItem represents XSD element 'cpe-item'
        // minOccurs=1, maxOccurs=-1
        CpeItem []ItemType `xml:"cpe-item"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// NotesType represents the XSD type 'NotesType'
// XSD complex type (W3C XSD 3.4)
type NotesType struct {
        // Note represents XSD element 'note'
        // minOccurs=1, maxOccurs=-1
        Note []string `xml:"note"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CheckType represents the XSD type 'CheckType'
// XSD complex type (W3C XSD 3.4)
type CheckTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // System represents XSD attribute 'system'
        // use="required"
        System string `xml:"system,attr"`
        // Href represents XSD attribute 'href'
        // use="optional"
        Href *string `xml:"href,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CheckType is an alias for CheckTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type CheckType = CheckTypeWithAttrs

// ReferenceElementType represents the XSD type 'ReferenceElementType'
// XSD complex type (W3C XSD 3.4)
type ReferenceElementTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Href represents XSD attribute 'href'
        // use="optional"
        Href *string `xml:"href,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReferenceElementType is an alias for ReferenceElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type ReferenceElementType = ReferenceElementTypeWithAttrs
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package language2_0 generated from XSD schema
// Source namespace: http://cpe.mitre.org/language/2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/xccdf/common/cpe-language_2.0.xsd
// Generated by forgexml - Do not edit manually

package language2_0

import (
        "encoding/xml"
        "os"
        "strings"
)

// PlatformSpecificationElement represents the XSD element 'platform-specification'
// XSD element declaration (W3C XSD 3.3)
type PlatformSpecificationElement struct {
        XMLName xml.Name `xml:"http://cpe.mitre.org/language/2.0 platform-specification"`
        // Platform represents XSD element 'platform'
        // minOccurs=1, maxOccurs=-1
        Platform []*PlatformType `xml:"platform"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PlatformSpecificationElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PlatformSpecificationElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PlatformSpecificationElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PlatformSpecificationElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PlatformSpecificationElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PlatformSpecificationElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PlatformSpecificationElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PlatformSpecificationElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PlatformSpecificationElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPlatformSpecificationFromBytes loads an element from bytes with namespace preservation
func LoadPlatformSpecificationFromBytes(data []byte) (*PlatformSpecificationElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PlatformSpecificationElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPlatformSpecificationFromFile loads an element from a file with namespace preservation
func LoadPlatformSpecificationFromFile(path string) (*PlatformSpecificationElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPlatformSpecificationFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package language2_0 generated from XSD schema
// Source namespace: http://cpe.mitre.org/language/2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/xccdf/common/cpe-language_2.0.xsd
// Generated by forgexml - Do not edit manually

package language2_0

import (
        "encoding/xml"
        "regexp"
        "strings"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// OperatorEnumeration represents the XSD type 'OperatorEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="AND"
// enumeration="OR"
type OperatorEnumeration string

// NamePattern represents the XSD type 'namePattern'
// XSD simple type (W3C XSD 4.1)
// pattern="cpe:/([aho](:[A-Za-z0-9\._\-~]*(:[A-Za-z0-9\._\-~]*(:[A-Za-z0-9\._\.\-~]*(:[A-Za-z0-9\._\-~]*)?)?)?)?)?"
type NamePattern string

// PlatformType represents the XSD type 'PlatformType'
// XSD complex type (W3C XSD 3.4)
type PlatformType struct {
        // Title represents XSD element 'title'
        // minOccurs=0, maxOccurs=-1
        Title []TextTypeWithAttrs `xml:"title,omitempty"`
        // Remark represents XSD element 'remark'
        // minOccurs=0, maxOccurs=-1
        Remark []TextTypeWithAttrs `xml:"remark,omitempty"`
        // LogicalTest represents XSD element 'logical-test'
        LogicalTest *LogicalTestType `xml:"logical-test"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id string `xml:"id,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LogicalTestType represents the XSD type 'LogicalTestType'
// XSD complex type (W3C XSD 3.4)
type LogicalTestType struct {
        // LogicalTest represents XSD element 'logical-test'
        // minOccurs=0, maxOccurs=-1
        LogicalTest []*LogicalTestType `xml:"logical-test,omitempty"`
        // FactRef represents XSD element 'fact-ref'
        // minOccurs=0, maxOccurs=-1
        FactRef []FactRefType `xml:"fact-ref,omitempty"`
        // Operator represents XSD attribute 'operator'
        // use="required"
        Operator OperatorEnumeration `xml:"operator,attr"`
        // Negate represents XSD attribute 'negate'
        // use="required"
        Negate bool `xml:"negate,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FactRefType represents the XSD type 'FactRefType'
// XSD complex type (W3C XSD 3.4)
type FactRefType struct {
        // Name represents XSD attribute 'name'
        // use="required"
        Name NamePattern `xml:"name,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TextType represents the XSD type 'textType'
// XSD complex type (W3C XSD 3.4)
type TextTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TextType is an alias for TextTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type TextType = TextTypeWithAttrs

// PlatformSpecificationElementType represents the XSD type 'PlatformSpecificationElementType'
// XSD complex type (W3C XSD 3.4)
type PlatformSpecificationElementType struct {
        // Platform represents XSD element 'platform'
        // minOccurs=1, maxOccurs=-1
        Platform []*PlatformType `xml:"platform"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package xmlschemaoval_common_5 generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-common-5
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/oval-common-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_common_5

import (
        "encoding/xml"
        "os"
        "strings"
)

// Deprecated_infoElement represents the XSD element 'deprecated_info'
// XSD element declaration (W3C XSD 3.3)
type Deprecated_infoElement struct {
        XMLName            xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-common-5 deprecated_info"`
        DeprecatedInfoType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Deprecated_infoElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias Deprecated_infoElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Deprecated_infoElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias Deprecated_infoElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Deprecated_infoElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Deprecated_infoElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Deprecated_infoElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Deprecated_infoElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *Deprecated_infoElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadDeprecated_infoFromBytes loads an element from bytes with namespace preservation
func LoadDeprecated_infoFromBytes(data []byte) (*Deprecated_infoElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element Deprecated_infoElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadDeprecated_infoFromFile loads an element from a file with namespace preservation
func LoadDeprecated_infoFromFile(path string) (*Deprecated_infoElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadDeprecated_infoFromBytes(data)</span>
}

// Element_mappingElement represents the XSD element 'element_mapping'
// XSD element declaration (W3C XSD 3.3)
type Element_mappingElement struct {
        XMLName        xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-common-5 element_mapping"`
        ElementMapType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Element_mappingElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias Element_mappingElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Element_mappingElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias Element_mappingElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Element_mappingElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Element_mappingElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Element_mappingElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Element_mappingElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *Element_mappingElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadElement_mappingFromBytes loads an element from bytes with namespace preservation
func LoadElement_mappingFromBytes(data []byte) (*Element_mappingElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element Element_mappingElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadElement_mappingFromFile loads an element from a file with namespace preservation
func LoadElement_mappingFromFile(path string) (*Element_mappingElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadElement_mappingFromBytes(data)</span>
}

// NotesElement represents the XSD element 'notes'
// XSD element declaration (W3C XSD 3.3)
type NotesElement struct {
        XMLName   xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-common-5 notes"`
        NotesType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *NotesElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias NotesElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *NotesElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias NotesElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *NotesElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *NotesElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *NotesElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *NotesElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *NotesElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadNotesFromBytes loads an element from bytes with namespace preservation
func LoadNotesFromBytes(data []byte) (*NotesElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element NotesElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadNotesFromFile loads an element from a file with namespace preservation
func LoadNotesFromFile(path string) (*NotesElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadNotesFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package xmlschemaoval_common_5 generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-common-5
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/oval-common-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_common_5

import (
        "encoding/xml"
        "regexp"
        "strings"

        types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// NotesType represents the XSD type 'NotesType'
// XSD complex type (W3C XSD 3.4)
type NotesType struct {
        // Note represents XSD element 'note'
        // minOccurs=0, maxOccurs=-1
        Note []string `xml:"note,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ClassEnumeration represents the XSD type 'ClassEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="compliance"
// enumeration="inventory"
// enumeration="miscellaneous"
// enumeration="patch"
// enumeration="vulnerability"
type ClassEnumeration string

// NonEmptyStringType represents the XSD type 'NonEmptyStringType'
// XSD simple type (W3C XSD 4.1)
// minLength="1"
type NonEmptyStringType string

// ElementMapItemType represents the XSD type 'ElementMapItemType'
// XSD complex type (W3C XSD 3.4)
type ElementMapItemTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Target_namespace represents XSD attribute 'target_namespace'
        // use="optional"
        Target_namespace *string `xml:"target_namespace,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ElementMapItemType is an alias for ElementMapItemTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type ElementMapItemType = ElementMapItemTypeWithAttrs

// GeneratorType represents the XSD type 'GeneratorType'
// XSD complex type (W3C XSD 3.4)
type GeneratorType struct {
        // Product_name represents XSD element 'product_name'
        // minOccurs=0, maxOccurs=1
        Product_name *string `xml:"product_name,omitempty"`
        // Product_version represents XSD element 'product_version'
        // minOccurs=0, maxOccurs=1
        Product_version *string `xml:"product_version,omitempty"`
        // Schema_version represents XSD element 'schema_version'
        // minOccurs=1, maxOccurs=-1
        Schema_version []SchemaVersionType `xml:"schema_version"`
        // Timestamp represents XSD element 'timestamp'
        Timestamp types.DateTime `xml:"timestamp"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SchemaVersionType represents the XSD type 'SchemaVersionType'
// XSD complex type (W3C XSD 3.4)
type SchemaVersionTypeWithAttrs struct {
        Value SchemaVersionPattern `xml:",chardata"` // XSD simple content
        // Platform represents XSD attribute 'platform'
        // use="optional"
        Platform *string `xml:"platform,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SchemaVersionType is an alias for SchemaVersionTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type SchemaVersionType = SchemaVersionTypeWithAttrs

// VersionElementType represents the XSD type 'VersionElementType'
// XSD simple type (W3C XSD 4.1)
type VersionElementType SchemaVersionPattern

// CheckEnumeration represents the XSD type 'CheckEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="all"
// enumeration="at least one"
// enumeration="none exist"
// enumeration="none satisfy"
// enumeration="only one"
type CheckEnumeration string

// SimpleDatatypeEnumeration represents the XSD type 'SimpleDatatypeEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="binary"
// enumeration="boolean"
// enumeration="evr_string"
// enumeration="debian_evr_string"
// enumeration="fileset_revision"
// enumeration="float"
// enumeration="ios_version"
// enumeration="int"
// enumeration="ipv4_address"
// enumeration="ipv6_address"
// enumeration="string"
// enumeration="version"
type SimpleDatatypeEnumeration string

// DatatypeEnumeration represents the XSD type 'DatatypeEnumeration'
// XSD union type (W3C XSD 4.2.3.3)
type DatatypeEnumeration struct {
        Value interface{} // Union type - can hold any member type
}

// OperatorEnumeration represents the XSD type 'OperatorEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="AND"
// enumeration="ONE"
// enumeration="OR"
// enumeration="XOR"
type OperatorEnumeration string

// ObjectIDPattern represents the XSD type 'ObjectIDPattern'
// XSD simple type (W3C XSD 4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:obj:[1-9][0-9]*"
type ObjectIDPattern string

// VariableIDPattern represents the XSD type 'VariableIDPattern'
// XSD simple type (W3C XSD 4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:var:[1-9][0-9]*"
type VariableIDPattern string

// SchemaVersionPattern represents the XSD type 'SchemaVersionPattern'
// XSD simple type (W3C XSD 4.1)
// pattern="[0-9]+\.[0-9]+(\.[0-9]+)?(:[0-9]+\.[0-9]+(\.[0-9]+)?)?"
type SchemaVersionPattern string

// ElementMapType represents the XSD type 'ElementMapType'
// XSD complex type (W3C XSD 3.4)
type ElementMapType struct {
        // Test represents XSD element 'test'
        Test ElementMapItemTypeWithAttrs `xml:"test"`
        // Object represents XSD element 'object'
        // minOccurs=0, maxOccurs=1
        Object *ElementMapItemTypeWithAttrs `xml:"object,omitempty"`
        // State represents XSD element 'state'
        // minOccurs=0, maxOccurs=1
        State *ElementMapItemTypeWithAttrs `xml:"state,omitempty"`
        // Item represents XSD element 'item'
        // minOccurs=0, maxOccurs=1
        Item *ElementMapItemTypeWithAttrs `xml:"item,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ComplexDatatypeEnumeration represents the XSD type 'ComplexDatatypeEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="record"
type ComplexDatatypeEnumeration string

// FamilyEnumeration represents the XSD type 'FamilyEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="android"
// enumeration="asa"
// enumeration="apple_ios"
// enumeration="catos"
// enumeration="ios"
// enumeration="iosxe"
// enumeration="junos"
// enumeration="macos"
// enumeration="pixos"
// enumeration="undefined"
// enumeration="unix"
// enumeration="vmware_infrastructure"
// enumeration="windows"
type FamilyEnumeration string

// MessageLevelEnumeration represents the XSD type 'MessageLevelEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="debug"
// enumeration="error"
// enumeration="fatal"
// enumeration="info"
// enumeration="warning"
type MessageLevelEnumeration string

// OperationEnumeration represents the XSD type 'OperationEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="equals"
// enumeration="not equal"
// enumeration="case insensitive equals"
// enumeration="case insensitive not equal"
// enumeration="greater than"
// enumeration="less than"
// enumeration="greater than or equal"
// enumeration="less than or equal"
// enumeration="bitwise and"
// enumeration="bitwise or"
// enumeration="pattern match"
// enumeration="subset of"
// enumeration="superset of"
type OperationEnumeration string

// StateIDPattern represents the XSD type 'StateIDPattern'
// XSD simple type (W3C XSD 4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:ste:[1-9][0-9]*"
type StateIDPattern string

// TestIDPattern represents the XSD type 'TestIDPattern'
// XSD simple type (W3C XSD 4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:tst:[1-9][0-9]*"
type TestIDPattern string

// EmptyStringType represents the XSD type 'EmptyStringType'
// XSD simple type (W3C XSD 4.1)
// maxLength="0"
type EmptyStringType string

// DeprecatedInfoType represents the XSD type 'DeprecatedInfoType'
// XSD complex type (W3C XSD 3.4)
type DeprecatedInfoType struct {
        // Version represents XSD element 'version'
        Version VersionElementType `xml:"version"`
        // Reason represents XSD element 'reason'
        Reason string `xml:"reason"`
        // Comment represents XSD element 'comment'
        // minOccurs=0, maxOccurs=1
        Comment *string `xml:"comment,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ExistenceEnumeration represents the XSD type 'ExistenceEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="all_exist"
// enumeration="any_exist"
// enumeration="at_least_one_exists"
// enumeration="none_exist"
// enumeration="only_one_exists"
type ExistenceEnumeration string

// DefinitionIDPattern represents the XSD type 'DefinitionIDPattern'
// XSD simple type (W3C XSD 4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:def:[1-9][0-9]*"
type DefinitionIDPattern string

// ItemIDPattern represents the XSD type 'ItemIDPattern'
// XSD simple type (W3C XSD 4.1)
type ItemIDPattern int64

// MessageType represents the XSD type 'MessageType'
// XSD complex type (W3C XSD 3.4)
type MessageTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Level represents XSD attribute 'level'
        // use="optional"
        Level *MessageLevelEnumeration `xml:"level,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MessageType is an alias for MessageTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type MessageType = MessageTypeWithAttrs
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package xmlschemaoval_definitions_5 generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-definitions-5
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/oval-definitions-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5

import (
        "encoding/xml"
        "os"
        "strings"

        xmlschemaoval_common_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-common-5"
        pkg_200009xmldsig "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig"
)

// NotesElement represents the XSD element 'notes'
// XSD element declaration (W3C XSD 3.3)
type NotesElement struct {
        XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 notes"`
        xmlschemaoval_common_5.NotesType          // XSD extension base
        // Note represents XSD element 'note'
        // minOccurs=0, maxOccurs=-1
        Note []string `xml:"note,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *NotesElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias NotesElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *NotesElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias NotesElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *NotesElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *NotesElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *NotesElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *NotesElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *NotesElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadNotesFromBytes loads an element from bytes with namespace preservation
func LoadNotesFromBytes(data []byte) (*NotesElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element NotesElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadNotesFromFile loads an element from a file with namespace preservation
func LoadNotesFromFile(path string) (*NotesElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadNotesFromBytes(data)</span>
}

// SetElement represents the XSD element 'set'
// XSD element declaration (W3C XSD 3.3)
type SetElement struct {
        XMLName xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 set"`
        // Set represents XSD element 'set'
        // minOccurs=1, maxOccurs=2
        Set []SetElement `xml:"set"`
        // Object_reference represents XSD element 'object_reference'
        // minOccurs=1, maxOccurs=2
        Object_reference []xmlschemaoval_common_5.ObjectIDPattern `xml:"object_reference"`
        // Filter represents XSD element 'filter'
        // minOccurs=0, maxOccurs=-1
        Filter []FilterElement `xml:"filter,omitempty"`
        // Set_operator represents XSD attribute 'set_operator'
        // use="optional"
        Set_operator *SetOperatorEnumeration `xml:"set_operator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SetElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SetElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SetElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SetElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SetElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SetElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SetElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SetElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SetElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSetFromBytes loads an element from bytes with namespace preservation
func LoadSetFromBytes(data []byte) (*SetElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SetElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSetFromFile loads an element from a file with namespace preservation
func LoadSetFromFile(path string) (*SetElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSetFromBytes(data)</span>
}

// StateElement represents the XSD element 'state'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type StateElement struct {
        XMLName   xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 state"`
        StateType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *StateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias StateElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *StateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias StateElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *StateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *StateElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *StateElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *StateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *StateElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadStateFromBytes loads an element from bytes with namespace preservation
func LoadStateFromBytes(data []byte) (*StateElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element StateElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadStateFromFile loads an element from a file with namespace preservation
func LoadStateFromFile(path string) (*StateElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadStateFromBytes(data)</span>
}

// VariableElement represents the XSD element 'variable'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type VariableElement struct {
        XMLName      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 variable"`
        VariableType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *VariableElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias VariableElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *VariableElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias VariableElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *VariableElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *VariableElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *VariableElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *VariableElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *VariableElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadVariableFromBytes loads an element from bytes with namespace preservation
func LoadVariableFromBytes(data []byte) (*VariableElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element VariableElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadVariableFromFile loads an element from a file with namespace preservation
func LoadVariableFromFile(path string) (*VariableElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadVariableFromBytes(data)</span>
}

// Constant_variableElement represents the XSD element 'constant_variable'
// XSD element declaration (W3C XSD 3.3)
type Constant_variableElement struct {
        XMLName      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 constant_variable"`
        VariableType          // XSD extension base
        // Value represents XSD element 'value'
        // minOccurs=1, maxOccurs=-1
        Value []ValueType `xml:"value"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Constant_variableElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias Constant_variableElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Constant_variableElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias Constant_variableElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Constant_variableElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Constant_variableElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Constant_variableElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Constant_variableElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *Constant_variableElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadConstant_variableFromBytes loads an element from bytes with namespace preservation
func LoadConstant_variableFromBytes(data []byte) (*Constant_variableElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element Constant_variableElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadConstant_variableFromFile loads an element from a file with namespace preservation
func LoadConstant_variableFromFile(path string) (*Constant_variableElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadConstant_variableFromBytes(data)</span>
}

// Local_variableElement represents the XSD element 'local_variable'
// XSD element declaration (W3C XSD 3.3)
type Local_variableElement struct {
        XMLName      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 local_variable"`
        VariableType          // XSD extension base
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Local_variableElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias Local_variableElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Local_variableElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias Local_variableElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Local_variableElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Local_variableElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Local_variableElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Local_variableElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *Local_variableElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadLocal_variableFromBytes loads an element from bytes with namespace preservation
func LoadLocal_variableFromBytes(data []byte) (*Local_variableElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element Local_variableElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadLocal_variableFromFile loads an element from a file with namespace preservation
func LoadLocal_variableFromFile(path string) (*Local_variableElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadLocal_variableFromBytes(data)</span>
}

// DefinitionElement represents the XSD element 'definition'
// XSD element declaration (W3C XSD 3.3)
type DefinitionElement struct {
        XMLName        xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 definition"`
        DefinitionType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *DefinitionElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias DefinitionElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *DefinitionElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias DefinitionElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *DefinitionElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *DefinitionElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *DefinitionElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *DefinitionElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *DefinitionElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadDefinitionFromBytes loads an element from bytes with namespace preservation
func LoadDefinitionFromBytes(data []byte) (*DefinitionElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element DefinitionElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadDefinitionFromFile loads an element from a file with namespace preservation
func LoadDefinitionFromFile(path string) (*DefinitionElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadDefinitionFromBytes(data)</span>
}

// TestElement represents the XSD element 'test'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type TestElement struct {
        XMLName  xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 test"`
        TestType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *TestElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias TestElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *TestElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias TestElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *TestElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *TestElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *TestElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *TestElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *TestElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadTestFromBytes loads an element from bytes with namespace preservation
func LoadTestFromBytes(data []byte) (*TestElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element TestElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadTestFromFile loads an element from a file with namespace preservation
func LoadTestFromFile(path string) (*TestElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadTestFromBytes(data)</span>
}

// ObjectElement represents the XSD element 'object'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type ObjectElement struct {
        XMLName    xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 object"`
        ObjectType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ObjectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias ObjectElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ObjectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias ObjectElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ObjectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ObjectElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ObjectElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ObjectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ObjectElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadObjectFromBytes loads an element from bytes with namespace preservation
func LoadObjectFromBytes(data []byte) (*ObjectElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ObjectElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadObjectFromFile loads an element from a file with namespace preservation
func LoadObjectFromFile(path string) (*ObjectElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadObjectFromBytes(data)</span>
}

// FilterElement represents the XSD element 'filter'
// XSD element declaration (W3C XSD 3.3)
type FilterElement struct {
        XMLName xml.Name                              `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 filter"`
        Value   xmlschemaoval_common_5.StateIDPattern `xml:",chardata"` // XSD simpleContent from StateIDPattern
        // Action represents XSD attribute 'action'
        // use="optional"
        Action *FilterActionEnumeration `xml:"action,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *FilterElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias FilterElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *FilterElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias FilterElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *FilterElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *FilterElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *FilterElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *FilterElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *FilterElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadFilterFromBytes loads an element from bytes with namespace preservation
func LoadFilterFromBytes(data []byte) (*FilterElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element FilterElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadFilterFromFile loads an element from a file with namespace preservation
func LoadFilterFromFile(path string) (*FilterElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadFilterFromBytes(data)</span>
}

// External_variableElement represents the XSD element 'external_variable'
// XSD element declaration (W3C XSD 3.3)
type External_variableElement struct {
        XMLName      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 external_variable"`
        VariableType          // XSD extension base
        // Possible_value represents XSD element 'possible_value'
        Possible_value []PossibleValueTypeWithAttrs `xml:"possible_value,omitempty"`
        // Possible_restriction represents XSD element 'possible_restriction'
        Possible_restriction []PossibleRestrictionType `xml:"possible_restriction,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *External_variableElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias External_variableElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *External_variableElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias External_variableElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *External_variableElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *External_variableElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *External_variableElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *External_variableElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *External_variableElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadExternal_variableFromBytes loads an element from bytes with namespace preservation
func LoadExternal_variableFromBytes(data []byte) (*External_variableElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element External_variableElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadExternal_variableFromFile loads an element from a file with namespace preservation
func LoadExternal_variableFromFile(path string) (*External_variableElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadExternal_variableFromBytes(data)</span>
}

// Oval_definitionsElement represents the XSD element 'oval_definitions'
// XSD element declaration (W3C XSD 3.3)
type Oval_definitionsElement struct {
        XMLName xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 oval_definitions"`
        // Generator represents XSD element 'generator'
        Generator xmlschemaoval_common_5.GeneratorType `xml:"generator"`
        // Definitions represents XSD element 'definitions'
        // minOccurs=0, maxOccurs=1
        Definitions *DefinitionsType `xml:"definitions,omitempty"`
        // Tests represents XSD element 'tests'
        // minOccurs=0, maxOccurs=1
        Tests *TestsType `xml:"tests,omitempty"`
        // Objects represents XSD element 'objects'
        // minOccurs=0, maxOccurs=1
        Objects *ObjectsType `xml:"objects,omitempty"`
        // States represents XSD element 'states'
        // minOccurs=0, maxOccurs=1
        States *StatesType `xml:"states,omitempty"`
        // Variables represents XSD element 'variables'
        // minOccurs=0, maxOccurs=1
        Variables *VariablesType `xml:"variables,omitempty"`
        // Signature represents XSD element 'Signature'
        // minOccurs=0, maxOccurs=1
        Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Oval_definitionsElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias Oval_definitionsElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Oval_definitionsElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias Oval_definitionsElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Oval_definitionsElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Oval_definitionsElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Oval_definitionsElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Oval_definitionsElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *Oval_definitionsElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadOval_definitionsFromBytes loads an element from bytes with namespace preservation
func LoadOval_definitionsFromBytes(data []byte) (*Oval_definitionsElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element Oval_definitionsElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadOval_definitionsFromFile loads an element from a file with namespace preservation
func LoadOval_definitionsFromFile(path string) (*Oval_definitionsElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadOval_definitionsFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package xmlschemaoval_definitions_5 generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-definitions-5
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/oval-definitions-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5

import (
        "encoding/xml"
        "regexp"
        "strings"

        dictionary2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/dictionary/2-0"
        language2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/language/2-0"
        xmlschemaoval_common_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-common-5"
        pkg_200009xmldsig "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// PossibleValueType represents the XSD type 'PossibleValueType'
// XSD complex type (W3C XSD 3.4)
type PossibleValueTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Hint represents XSD attribute 'hint'
        // use="required"
        Hint string `xml:"hint,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PossibleValueType is an alias for PossibleValueTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type PossibleValueType = PossibleValueTypeWithAttrs

// EntityObjectStringType represents the XSD type 'EntityObjectStringType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectStringType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="optional"
        Datatype *xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectAnySimpleType represents the XSD type 'EntityObjectAnySimpleType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectAnySimpleType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="optional"
        Datatype *xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FilterActionEnumeration represents the XSD type 'FilterActionEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="exclude"
// enumeration="include"
type FilterActionEnumeration string

// SetOperatorEnumeration represents the XSD type 'SetOperatorEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="COMPLEMENT"
// enumeration="INTERSECTION"
// enumeration="UNION"
type SetOperatorEnumeration string

// AffectedType represents the XSD type 'AffectedType'
// XSD complex type (W3C XSD 3.4)
type AffectedType struct {
        // Platform represents XSD element 'platform'
        // minOccurs=0, maxOccurs=-1
        Platform []string `xml:"platform,omitempty"`
        // Product represents XSD element 'product'
        // minOccurs=0, maxOccurs=-1
        Product []string `xml:"product,omitempty"`
        // Family represents XSD attribute 'family'
        // use="required"
        Family xmlschemaoval_common_5.FamilyEnumeration `xml:"family,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TestsType represents the XSD type 'TestsType'
// XSD complex type (W3C XSD 3.4)
type TestsType struct {
        // Test represents XSD element 'test'
        // minOccurs=1, maxOccurs=-1
        Test []TestType `xml:"test"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// StatesType represents the XSD type 'StatesType'
// XSD complex type (W3C XSD 3.4)
type StatesType struct {
        // State represents XSD element 'state'
        // minOccurs=1, maxOccurs=-1
        State []StateType `xml:"state"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// UniqueFunctionType represents the XSD type 'UniqueFunctionType'
// XSD complex type (W3C XSD 3.4)
type UniqueFunctionType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateEVRStringType represents the XSD type 'EntityStateEVRStringType'
// XSD complex type (W3C XSD 3.4)
type EntityStateEVRStringType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CriterionType represents the XSD type 'CriterionType'
// XSD complex type (W3C XSD 3.4)
type CriterionType struct {
        // Applicability_check represents XSD attribute 'applicability_check'
        // use="optional"
        Applicability_check *bool `xml:"applicability_check,attr,omitempty"`
        // Test_ref represents XSD attribute 'test_ref'
        // use="required"
        Test_ref xmlschemaoval_common_5.TestIDPattern `xml:"test_ref,attr"`
        // Negate represents XSD attribute 'negate'
        // use="optional"
        Negate *bool `xml:"negate,attr,omitempty"`
        // Comment represents XSD attribute 'comment'
        // use="optional"
        Comment *xmlschemaoval_common_5.NonEmptyStringType `xml:"comment,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// StateRefType represents the XSD type 'StateRefType'
// XSD complex type (W3C XSD 3.4)
type StateRefType struct {
        // State_ref represents XSD attribute 'state_ref'
        // use="required"
        State_ref xmlschemaoval_common_5.StateIDPattern `xml:"state_ref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ObjectsType represents the XSD type 'ObjectsType'
// XSD complex type (W3C XSD 3.4)
type ObjectsType struct {
        // Object represents XSD element 'object'
        // minOccurs=1, maxOccurs=-1
        Object []ObjectType `xml:"object"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// VariablesType represents the XSD type 'VariablesType'
// XSD complex type (W3C XSD 3.4)
type VariablesType struct {
        // Oval_definitionsLocal_variable represents substitution group member 'local_variable' (namespace: http://oval.mitre.org/XMLSchema/oval-definitions-5)
        // Substitutes for abstract element 'variable'
        Oval_definitionsLocal_variable []Local_variableElement `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 local_variable,omitempty"`
        // Oval_definitionsExternal_variable represents substitution group member 'external_variable' (namespace: http://oval.mitre.org/XMLSchema/oval-definitions-5)
        // Substitutes for abstract element 'variable'
        Oval_definitionsExternal_variable []External_variableElement `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 external_variable,omitempty"`
        // Oval_definitionsConstant_variable represents substitution group member 'constant_variable' (namespace: http://oval.mitre.org/XMLSchema/oval-definitions-5)
        // Substitutes for abstract element 'variable'
        Oval_definitionsConstant_variable []Constant_variableElement `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5 constant_variable,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// VariableType represents the XSD type 'VariableType'
// XSD complex type (W3C XSD 3.4)
type VariableType struct {
        // Signature represents XSD element 'Signature'
        // minOccurs=0, maxOccurs=1
        Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
        // Notes represents XSD element 'notes'
        // minOccurs=0, maxOccurs=1
        Notes *dictionary2_0.NotesType `xml:"notes,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id xmlschemaoval_common_5.VariableIDPattern `xml:"id,attr"`
        // Version represents XSD attribute 'version'
        // use="required"
        Version uint64 `xml:"version,attr"`
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // Comment represents XSD attribute 'comment'
        // use="required"
        Comment xmlschemaoval_common_5.NonEmptyStringType `xml:"comment,attr"`
        // Deprecated represents XSD attribute 'deprecated'
        // use="optional"
        Deprecated *bool `xml:"deprecated,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SubstringFunctionType represents the XSD type 'SubstringFunctionType'
// XSD complex type (W3C XSD 3.4)
type SubstringFunctionType struct {
        // Substring_start represents XSD attribute 'substring_start'
        // use="required"
        Substring_start int32 `xml:"substring_start,attr"`
        // Substring_length represents XSD attribute 'substring_length'
        // use="required"
        Substring_length int32 `xml:"substring_length,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateIntType represents the XSD type 'EntityStateIntType'
// XSD complex type (W3C XSD 3.4)
type EntityStateIntType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateRecordType represents the XSD type 'EntityStateRecordType'
// XSD complex type (W3C XSD 3.4)
type EntityStateRecordType struct {
        EntityStateComplexBaseType // XSD extension base
        // Field represents XSD element 'field'
        // minOccurs=0, maxOccurs=-1
        Field []EntityStateFieldTypeWithAttrs `xml:"field,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MetadataType represents the XSD type 'MetadataType'
// XSD complex type (W3C XSD 3.4)
type MetadataType struct {
        // Title represents XSD element 'title'
        Title string `xml:"title"`
        // Affected represents XSD element 'affected'
        // minOccurs=0, maxOccurs=-1
        Affected []AffectedType `xml:"affected,omitempty"`
        // Reference represents XSD element 'reference'
        // minOccurs=0, maxOccurs=-1
        Reference []ReferenceType `xml:"reference,omitempty"`
        // Description represents XSD element 'description'
        Description string `xml:"description"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RestrictionType represents the XSD type 'RestrictionType'
// XSD complex type (W3C XSD 3.4)
type RestrictionTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Operation represents XSD attribute 'operation'
        // use="required"
        Operation xmlschemaoval_common_5.OperationEnumeration `xml:"operation,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RestrictionType is an alias for RestrictionTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type RestrictionType = RestrictionTypeWithAttrs

// ValueType represents the XSD type 'ValueType'
// XSD complex type (W3C XSD 3.4)
type ValueType struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ObjectComponentType represents the XSD type 'ObjectComponentType'
// XSD complex type (W3C XSD 3.4)
type ObjectComponentType struct {
        // Object_ref represents XSD attribute 'object_ref'
        // use="required"
        Object_ref xmlschemaoval_common_5.ObjectIDPattern `xml:"object_ref,attr"`
        // Item_field represents XSD attribute 'item_field'
        // use="required"
        Item_field xmlschemaoval_common_5.NonEmptyStringType `xml:"item_field,attr"`
        // Record_field represents XSD attribute 'record_field'
        // use="optional"
        Record_field *xmlschemaoval_common_5.NonEmptyStringType `xml:"record_field,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EndFunctionType represents the XSD type 'EndFunctionType'
// XSD complex type (W3C XSD 3.4)
type EndFunctionType struct {
        // Character represents XSD attribute 'character'
        // use="required"
        Character string `xml:"character,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectIPAddressStringType represents the XSD type 'EntityObjectIPAddressStringType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectIPAddressStringType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="optional"
        Datatype *string `xml:"datatype,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectBinaryType represents the XSD type 'EntityObjectBinaryType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectBinaryType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateFileSetRevisionType represents the XSD type 'EntityStateFileSetRevisionType'
// XSD complex type (W3C XSD 3.4)
type EntityStateFileSetRevisionType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtendDefinitionType represents the XSD type 'ExtendDefinitionType'
// XSD complex type (W3C XSD 3.4)
type ExtendDefinitionType struct {
        // Applicability_check represents XSD attribute 'applicability_check'
        // use="optional"
        Applicability_check *bool `xml:"applicability_check,attr,omitempty"`
        // Definition_ref represents XSD attribute 'definition_ref'
        // use="required"
        Definition_ref xmlschemaoval_common_5.DefinitionIDPattern `xml:"definition_ref,attr"`
        // Negate represents XSD attribute 'negate'
        // use="optional"
        Negate *bool `xml:"negate,attr,omitempty"`
        // Comment represents XSD attribute 'comment'
        // use="optional"
        Comment *xmlschemaoval_common_5.NonEmptyStringType `xml:"comment,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ObjectRefType represents the XSD type 'ObjectRefType'
// XSD complex type (W3C XSD 3.4)
type ObjectRefType struct {
        // Object_ref represents XSD attribute 'object_ref'
        // use="required"
        Object_ref xmlschemaoval_common_5.ObjectIDPattern `xml:"object_ref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ObjectType represents the XSD type 'ObjectType'
// XSD complex type (W3C XSD 3.4)
type ObjectType struct {
        // Signature represents XSD element 'Signature'
        // minOccurs=0, maxOccurs=1
        Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
        // Notes represents XSD element 'notes'
        // minOccurs=0, maxOccurs=1
        Notes *NotesElement `xml:"notes,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id xmlschemaoval_common_5.ObjectIDPattern `xml:"id,attr"`
        // Version represents XSD attribute 'version'
        // use="required"
        Version uint64 `xml:"version,attr"`
        // Comment represents XSD attribute 'comment'
        // use="optional"
        Comment *xmlschemaoval_common_5.NonEmptyStringType `xml:"comment,attr,omitempty"`
        // Deprecated represents XSD attribute 'deprecated'
        // use="optional"
        Deprecated *bool `xml:"deprecated,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// VariableComponentType represents the XSD type 'VariableComponentType'
// XSD complex type (W3C XSD 3.4)
type VariableComponentType struct {
        // Var_ref represents XSD attribute 'var_ref'
        // use="required"
        Var_ref xmlschemaoval_common_5.VariableIDPattern `xml:"var_ref,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectIPAddressType represents the XSD type 'EntityObjectIPAddressType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectIPAddressType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype string `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectFloatType represents the XSD type 'EntityObjectFloatType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectFloatType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateFloatType represents the XSD type 'EntityStateFloatType'
// XSD complex type (W3C XSD 3.4)
type EntityStateFloatType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateDebianEVRStringType represents the XSD type 'EntityStateDebianEVRStringType'
// XSD complex type (W3C XSD 3.4)
type EntityStateDebianEVRStringType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SplitFunctionType represents the XSD type 'SplitFunctionType'
// XSD complex type (W3C XSD 3.4)
type SplitFunctionType struct {
        // Delimiter represents XSD attribute 'delimiter'
        // use="required"
        Delimiter string `xml:"delimiter,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CountFunctionType represents the XSD type 'CountFunctionType'
// XSD complex type (W3C XSD 3.4)
type CountFunctionType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateIPAddressStringType represents the XSD type 'EntityStateIPAddressStringType'
// XSD complex type (W3C XSD 3.4)
type EntityStateIPAddressStringType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="optional"
        Datatype *string `xml:"datatype,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateAnySimpleType represents the XSD type 'EntityStateAnySimpleType'
// XSD complex type (W3C XSD 3.4)
type EntityStateAnySimpleType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="optional"
        Datatype *xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ArithmeticEnumeration represents the XSD type 'ArithmeticEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="add"
// enumeration="multiply"
type ArithmeticEnumeration string

// CriteriaType represents the XSD type 'CriteriaType'
// XSD complex type (W3C XSD 3.4)
type CriteriaType struct {
        // Criteria represents XSD element 'criteria'
        Criteria []*CriteriaType `xml:"criteria,omitempty"`
        // Criterion represents XSD element 'criterion'
        Criterion []CriterionType `xml:"criterion,omitempty"`
        // Extend_definition represents XSD element 'extend_definition'
        Extend_definition []ExtendDefinitionType `xml:"extend_definition,omitempty"`
        // Applicability_check represents XSD attribute 'applicability_check'
        // use="optional"
        Applicability_check *bool `xml:"applicability_check,attr,omitempty"`
        // Operator represents XSD attribute 'operator'
        // use="optional"
        Operator *language2_0.OperatorEnumeration `xml:"operator,attr,omitempty"`
        // Negate represents XSD attribute 'negate'
        // use="optional"
        Negate *bool `xml:"negate,attr,omitempty"`
        // Comment represents XSD attribute 'comment'
        // use="optional"
        Comment *xmlschemaoval_common_5.NonEmptyStringType `xml:"comment,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RegexCaptureFunctionType represents the XSD type 'RegexCaptureFunctionType'
// XSD complex type (W3C XSD 3.4)
type RegexCaptureFunctionType struct {
        // Pattern represents XSD attribute 'pattern'
        // use="optional"
        Pattern *string `xml:"pattern,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectIntType represents the XSD type 'EntityObjectIntType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectIntType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectRecordType represents the XSD type 'EntityObjectRecordType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectRecordType struct {
        EntityComplexBaseType // XSD extension base
        // Field represents XSD element 'field'
        // minOccurs=0, maxOccurs=-1
        Field []EntityObjectFieldTypeWithAttrs `xml:"field,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateComplexBaseType represents the XSD type 'EntityStateComplexBaseType'
// XSD complex type (W3C XSD 3.4)
// abstract="true"
type EntityStateComplexBaseType struct {
        EntityComplexBaseType // XSD extension base
        // Entity_check represents XSD attribute 'entity_check'
        // use="optional"
        Entity_check *xmlschemaoval_common_5.CheckEnumeration `xml:"entity_check,attr,omitempty"`
        // Check_existence represents XSD attribute 'check_existence'
        // use="optional"
        Check_existence *xmlschemaoval_common_5.ExistenceEnumeration `xml:"check_existence,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateIPAddressType represents the XSD type 'EntityStateIPAddressType'
// XSD complex type (W3C XSD 3.4)
type EntityStateIPAddressType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype string `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateVersionType represents the XSD type 'EntityStateVersionType'
// XSD complex type (W3C XSD 3.4)
type EntityStateVersionType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DateTimeFormatEnumeration represents the XSD type 'DateTimeFormatEnumeration'
// XSD simple type (W3C XSD 4.1)
// enumeration="year_month_day"
// enumeration="month_day_year"
// enumeration="day_month_year"
// enumeration="win_filetime"
// enumeration="seconds_since_epoch"
// enumeration="cim_datetime"
type DateTimeFormatEnumeration string

// LiteralComponentType represents the XSD type 'LiteralComponentType'
// XSD complex type (W3C XSD 3.4)
type LiteralComponentTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Datatype represents XSD attribute 'datatype'
        // use="optional"
        Datatype *xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LiteralComponentType is an alias for LiteralComponentTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type LiteralComponentType = LiteralComponentTypeWithAttrs

// BeginFunctionType represents the XSD type 'BeginFunctionType'
// XSD complex type (W3C XSD 3.4)
type BeginFunctionType struct {
        // Character represents XSD attribute 'character'
        // use="required"
        Character string `xml:"character,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateBinaryType represents the XSD type 'EntityStateBinaryType'
// XSD complex type (W3C XSD 3.4)
type EntityStateBinaryType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// Constant_variableElementType represents the XSD type 'Constant_variableElementType'
// XSD complex type (W3C XSD 3.4)
type Constant_variableElementType struct {
        VariableType // XSD extension base
        // Value represents XSD element 'value'
        // minOccurs=1, maxOccurs=-1
        Value []ValueType `xml:"value"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FilterElementType represents the XSD type 'FilterElementType'
// XSD complex type (W3C XSD 3.4)
type FilterElementTypeWithAttrs struct {
        Value xmlschemaoval_common_5.StateIDPattern `xml:",chardata"` // XSD simple content
        // Action represents XSD attribute 'action'
        // use="optional"
        Action *FilterActionEnumeration `xml:"action,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// FilterElementType is an alias for FilterElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type FilterElementType = FilterElementTypeWithAttrs

// NotesElementType represents the XSD type 'NotesElementType'
// XSD complex type (W3C XSD 3.4)
type NotesElementType struct {
        xmlschemaoval_common_5.NotesType // XSD extension base
        // Note represents XSD element 'note'
        // minOccurs=0, maxOccurs=-1
        Note []string `xml:"note,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SetElementType represents the XSD type 'SetElementType'
// XSD complex type (W3C XSD 3.4)
type SetElementType struct {
        // Set represents XSD element 'set'
        // minOccurs=1, maxOccurs=2
        Set []SetElement `xml:"set"`
        // Object_reference represents XSD element 'object_reference'
        // minOccurs=1, maxOccurs=2
        Object_reference []xmlschemaoval_common_5.ObjectIDPattern `xml:"object_reference"`
        // Filter represents XSD element 'filter'
        // minOccurs=0, maxOccurs=-1
        Filter []FilterElement `xml:"filter,omitempty"`
        // Set_operator represents XSD attribute 'set_operator'
        // use="optional"
        Set_operator *SetOperatorEnumeration `xml:"set_operator,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DefinitionType represents the XSD type 'DefinitionType'
// XSD complex type (W3C XSD 3.4)
type DefinitionType struct {
        // Signature represents XSD element 'Signature'
        // minOccurs=0, maxOccurs=1
        Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
        // Metadata represents XSD element 'metadata'
        Metadata MetadataType `xml:"metadata"`
        // Notes represents XSD element 'notes'
        // minOccurs=0, maxOccurs=1
        Notes *xmlschemaoval_common_5.NotesType `xml:"notes,omitempty"`
        // Criteria represents XSD element 'criteria'
        // minOccurs=0, maxOccurs=1
        Criteria *CriteriaType `xml:"criteria,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id xmlschemaoval_common_5.DefinitionIDPattern `xml:"id,attr"`
        // Version represents XSD attribute 'version'
        // use="required"
        Version uint64 `xml:"version,attr"`
        // Class represents XSD attribute 'class'
        // use="required"
        Class xmlschemaoval_common_5.ClassEnumeration `xml:"class,attr"`
        // Deprecated represents XSD attribute 'deprecated'
        // use="optional"
        Deprecated *bool `xml:"deprecated,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateFieldType represents the XSD type 'EntityStateFieldType'
// XSD complex type (W3C XSD 3.4)
type EntityStateFieldTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Name represents XSD attribute 'name'
        // use="required"
        Name string `xml:"name,attr"`
        // Entity_check represents XSD attribute 'entity_check'
        // use="optional"
        Entity_check *xmlschemaoval_common_5.CheckEnumeration `xml:"entity_check,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateFieldType is an alias for EntityStateFieldTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type EntityStateFieldType = EntityStateFieldTypeWithAttrs

// EntitySimpleBaseType represents the XSD type 'EntitySimpleBaseType'
// XSD complex type (W3C XSD 3.4)
// abstract="true"
type EntitySimpleBaseType struct {
        Value string `xml:",chardata"` // XSD simple content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityComplexBaseType represents the XSD type 'EntityComplexBaseType'
// XSD complex type (W3C XSD 3.4)
// abstract="true"
type EntityComplexBaseType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateBoolType represents the XSD type 'EntityStateBoolType'
// XSD complex type (W3C XSD 3.4)
type EntityStateBoolType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// External_variableElementType represents the XSD type 'External_variableElementType'
// XSD complex type (W3C XSD 3.4)
type External_variableElementType struct {
        VariableType // XSD extension base
        // Possible_value represents XSD element 'possible_value'
        Possible_value []PossibleValueTypeWithAttrs `xml:"possible_value,omitempty"`
        // Possible_restriction represents XSD element 'possible_restriction'
        Possible_restriction []PossibleRestrictionType `xml:"possible_restriction,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// Local_variableElementType represents the XSD type 'Local_variableElementType'
// XSD complex type (W3C XSD 3.4)
type Local_variableElementType struct {
        VariableType // XSD extension base
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// StateType represents the XSD type 'StateType'
// XSD complex type (W3C XSD 3.4)
type StateType struct {
        // Signature represents XSD element 'Signature'
        // minOccurs=0, maxOccurs=1
        Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
        // Notes represents XSD element 'notes'
        // minOccurs=0, maxOccurs=1
        Notes *xmlschemaoval_common_5.NotesType `xml:"notes,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id xmlschemaoval_common_5.StateIDPattern `xml:"id,attr"`
        // Version represents XSD attribute 'version'
        // use="required"
        Version uint64 `xml:"version,attr"`
        // Operator represents XSD attribute 'operator'
        // use="optional"
        Operator *language2_0.OperatorEnumeration `xml:"operator,attr,omitempty"`
        // Comment represents XSD attribute 'comment'
        // use="optional"
        Comment *xmlschemaoval_common_5.NonEmptyStringType `xml:"comment,attr,omitempty"`
        // Deprecated represents XSD attribute 'deprecated'
        // use="optional"
        Deprecated *bool `xml:"deprecated,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ConcatFunctionType represents the XSD type 'ConcatFunctionType'
// XSD complex type (W3C XSD 3.4)
type ConcatFunctionType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TimeDifferenceFunctionType represents the XSD type 'TimeDifferenceFunctionType'
// XSD complex type (W3C XSD 3.4)
type TimeDifferenceFunctionType struct {
        // Format_1 represents XSD attribute 'format_1'
        // use="optional"
        Format_1 *DateTimeFormatEnumeration `xml:"format_1,attr,omitempty"`
        // Format_2 represents XSD attribute 'format_2'
        // use="optional"
        Format_2 *DateTimeFormatEnumeration `xml:"format_2,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectBoolType represents the XSD type 'EntityObjectBoolType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectBoolType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DefinitionsType represents the XSD type 'DefinitionsType'
// XSD complex type (W3C XSD 3.4)
type DefinitionsType struct {
        // Definition represents XSD element 'definition'
        // minOccurs=1, maxOccurs=-1
        Definition []*DefinitionType `xml:"definition"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EscapeRegexFunctionType represents the XSD type 'EscapeRegexFunctionType'
// XSD complex type (W3C XSD 3.4)
type EscapeRegexFunctionType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectVersionType represents the XSD type 'EntityObjectVersionType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectVersionType struct {
        EntitySimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="required"
        Datatype xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReferenceType represents the XSD type 'ReferenceType'
// XSD complex type (W3C XSD 3.4)
type ReferenceType struct {
        // Source represents XSD attribute 'source'
        // use="required"
        Source string `xml:"source,attr"`
        // Ref_id represents XSD attribute 'ref_id'
        // use="required"
        Ref_id string `xml:"ref_id,attr"`
        // Ref_url represents XSD attribute 'ref_url'
        // use="optional"
        Ref_url *string `xml:"ref_url,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PossibleRestrictionType represents the XSD type 'PossibleRestrictionType'
// XSD complex type (W3C XSD 3.4)
type PossibleRestrictionType struct {
        // Restriction represents XSD element 'restriction'
        // minOccurs=1, maxOccurs=-1
        Restriction []RestrictionTypeWithAttrs `xml:"restriction,omitempty"`
        // Operator represents XSD attribute 'operator'
        // use="optional"
        Operator *language2_0.OperatorEnumeration `xml:"operator,attr,omitempty"`
        // Hint represents XSD attribute 'hint'
        // use="required"
        Hint string `xml:"hint,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateSimpleBaseType represents the XSD type 'EntityStateSimpleBaseType'
// XSD complex type (W3C XSD 3.4)
// abstract="true"
type EntityStateSimpleBaseType struct {
        EntitySimpleBaseType // XSD extension base
        // Entity_check represents XSD attribute 'entity_check'
        // use="optional"
        Entity_check *xmlschemaoval_common_5.CheckEnumeration `xml:"entity_check,attr,omitempty"`
        // Check_existence represents XSD attribute 'check_existence'
        // use="optional"
        Check_existence *xmlschemaoval_common_5.ExistenceEnumeration `xml:"check_existence,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateIOSVersionType represents the XSD type 'EntityStateIOSVersionType'
// XSD complex type (W3C XSD 3.4)
type EntityStateIOSVersionType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="optional"
        Datatype *string `xml:"datatype,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityStateStringType represents the XSD type 'EntityStateStringType'
// XSD complex type (W3C XSD 3.4)
type EntityStateStringType struct {
        EntityStateSimpleBaseType // XSD extension base
        // Datatype represents XSD attribute 'datatype'
        // use="optional"
        Datatype *xmlschemaoval_common_5.SimpleDatatypeEnumeration `xml:"datatype,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// GlobToRegexFunctionType represents the XSD type 'GlobToRegexFunctionType'
// XSD complex type (W3C XSD 3.4)
type GlobToRegexFunctionType struct {
        // Glob_noescape represents XSD attribute 'glob_noescape'
        // use="optional"
        Glob_noescape *bool `xml:"glob_noescape,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectFieldType represents the XSD type 'EntityObjectFieldType'
// XSD complex type (W3C XSD 3.4)
type EntityObjectFieldTypeWithAttrs struct {
        Value string `xml:",chardata"` // XSD simple content
        // Name represents XSD attribute 'name'
        // use="required"
        Name string `xml:"name,attr"`
        // Entity_check represents XSD attribute 'entity_check'
        // use="optional"
        Entity_check *xmlschemaoval_common_5.CheckEnumeration `xml:"entity_check,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// EntityObjectFieldType is an alias for EntityObjectFieldTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type EntityObjectFieldType = EntityObjectFieldTypeWithAttrs

// TestType represents the XSD type 'TestType'
// XSD complex type (W3C XSD 3.4)
type TestType struct {
        // Signature represents XSD element 'Signature'
        // minOccurs=0, maxOccurs=1
        Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
        // Notes represents XSD element 'notes'
        // minOccurs=0, maxOccurs=1
        Notes *NotesElement `xml:"notes,omitempty"`
        // Id represents XSD attribute 'id'
        // use="required"
        Id xmlschemaoval_common_5.TestIDPattern `xml:"id,attr"`
        // Version represents XSD attribute 'version'
        // use="required"
        Version uint64 `xml:"version,attr"`
        // Check_existence represents XSD attribute 'check_existence'
        // use="optional"
        Check_existence *xmlschemaoval_common_5.ExistenceEnumeration `xml:"check_existence,attr,omitempty"`
        // Check represents XSD attribute 'check'
        // use="required"
        Check xmlschemaoval_common_5.CheckEnumeration `xml:"check,attr"`
        // State_operator represents XSD attribute 'state_operator'
        // use="optional"
        State_operator *language2_0.OperatorEnumeration `xml:"state_operator,attr,omitempty"`
        // Comment represents XSD attribute 'comment'
        // use="required"
        Comment xmlschemaoval_common_5.NonEmptyStringType `xml:"comment,attr"`
        // Deprecated represents XSD attribute 'deprecated'
        // use="optional"
        Deprecated *bool `xml:"deprecated,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ArithmeticFunctionType represents the XSD type 'ArithmeticFunctionType'
// XSD complex type (W3C XSD 3.4)
type ArithmeticFunctionType struct {
        // Arithmetic_operation represents XSD attribute 'arithmetic_operation'
        // use="required"
        Arithmetic_operation ArithmeticEnumeration `xml:"arithmetic_operation,attr"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// Oval_definitionsElementType represents the XSD type 'Oval_definitionsElementType'
// XSD complex type (W3C XSD 3.4)
type Oval_definitionsElementType struct {
        // Generator represents XSD element 'generator'
        Generator xmlschemaoval_common_5.GeneratorType `xml:"generator"`
        // Definitions represents XSD element 'definitions'
        // minOccurs=0, maxOccurs=1
        Definitions *DefinitionsType `xml:"definitions,omitempty"`
        // Tests represents XSD element 'tests'
        // minOccurs=0, maxOccurs=1
        Tests *TestsType `xml:"tests,omitempty"`
        // Objects represents XSD element 'objects'
        // minOccurs=0, maxOccurs=1
        Objects *ObjectsType `xml:"objects,omitempty"`
        // States represents XSD element 'states'
        // minOccurs=0, maxOccurs=1
        States *StatesType `xml:"states,omitempty"`
        // Variables represents XSD element 'variables'
        // minOccurs=0, maxOccurs=1
        Variables *VariablesType `xml:"variables,omitempty"`
        // Signature represents XSD element 'Signature'
        // minOccurs=0, maxOccurs=1
        Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package pkg_1999xlink generated from XSD schema
// Source namespace: http://www.w3.org/1999/xlink
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/xlink.xsd
// Generated by forgexml - Do not edit manually

package pkg_1999xlink

import (
        "encoding/xml"
        "os"
        "strings"
)

// TitleElement represents the XSD element 'title'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type TitleElement struct {
        XMLName      xml.Name `xml:"http://www.w3.org/1999/xlink title"`
        TitleEltType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *TitleElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias TitleElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *TitleElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias TitleElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *TitleElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *TitleElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *TitleElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *TitleElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *TitleElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadTitleFromBytes loads an element from bytes with namespace preservation
func LoadTitleFromBytes(data []byte) (*TitleElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element TitleElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadTitleFromFile loads an element from a file with namespace preservation
func LoadTitleFromFile(path string) (*TitleElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadTitleFromBytes(data)</span>
}

// ResourceElement represents the XSD element 'resource'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type ResourceElement struct {
        XMLName      xml.Name `xml:"http://www.w3.org/1999/xlink resource"`
        ResourceType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ResourceElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias ResourceElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ResourceElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias ResourceElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ResourceElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ResourceElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ResourceElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ResourceElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ResourceElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadResourceFromBytes loads an element from bytes with namespace preservation
func LoadResourceFromBytes(data []byte) (*ResourceElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ResourceElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadResourceFromFile loads an element from a file with namespace preservation
func LoadResourceFromFile(path string) (*ResourceElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadResourceFromBytes(data)</span>
}

// LocatorElement represents the XSD element 'locator'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type LocatorElement struct {
        XMLName     xml.Name `xml:"http://www.w3.org/1999/xlink locator"`
        LocatorType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *LocatorElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias LocatorElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *LocatorElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias LocatorElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *LocatorElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *LocatorElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *LocatorElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *LocatorElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *LocatorElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadLocatorFromBytes loads an element from bytes with namespace preservation
func LoadLocatorFromBytes(data []byte) (*LocatorElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element LocatorElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadLocatorFromFile loads an element from a file with namespace preservation
func LoadLocatorFromFile(path string) (*LocatorElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadLocatorFromBytes(data)</span>
}

// ArcElement represents the XSD element 'arc'
// XSD element declaration (W3C XSD 3.3)
// abstract="true"
type ArcElement struct {
        XMLName xml.Name `xml:"http://www.w3.org/1999/xlink arc"`
        ArcType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ArcElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Create alias type to prevent recursion
        type alias ArcElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov0" title="0">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov0" title="0"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov0" title="0">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov0" title="0">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ArcElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov0" title="0">if e.nsDefaultNamespace != "" </span><span class="cov0" title="0">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov0" title="0">type alias ArcElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ArcElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ArcElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ArcElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ArcElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ArcElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadArcFromBytes loads an element from bytes with namespace preservation
func LoadArcFromBytes(data []byte) (*ArcElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ArcElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadArcFromFile loads an element from a file with namespace preservation
func LoadArcFromFile(path string) (*ArcElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadArcFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package pkg_1999xlink generated from XSD schema
// Source namespace: http://www.w3.org/1999/xlink
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/xlink.xsd
// Generated by forgexml - Do not edit manually

package pkg_1999xlink

import (
        "encoding/xml"
        "regexp"
        "strings"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// TypeType represents the XSD type 'typeType'
// XSD simple type (W3C XSD 4.1)
// enumeration="simple"
// enumeration="extended"
// enumeration="title"
// enumeration="resource"
// enumeration="locator"
// enumeration="arc"
type TypeType string

// HrefType represents the XSD type 'hrefType'
// XSD simple type (W3C XSD 4.1)
type HrefType string

// ActuateType represents the XSD type 'actuateType'
// XSD simple type (W3C XSD 4.1)
// enumeration="onLoad"
// enumeration="onRequest"
// enumeration="other"
// enumeration="none"
type ActuateType string

// ToType represents the XSD type 'toType'
// XSD simple type (W3C XSD 4.1)
type ToType string

// ResourceType represents the XSD type 'resourceType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ResourceType struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RoleType represents the XSD type 'roleType'
// XSD simple type (W3C XSD 4.1)
// minLength="1"
type RoleType string

// TitleAttrType represents the XSD type 'titleAttrType'
// XSD simple type (W3C XSD 4.1)
type TitleAttrType string

// LabelType represents the XSD type 'labelType'
// XSD simple type (W3C XSD 4.1)
type LabelType string

// FromType represents the XSD type 'fromType'
// XSD simple type (W3C XSD 4.1)
type FromType string

// Simple represents the XSD type 'simple'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type Simple struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ArcType represents the XSD type 'arcType'
// XSD complex type (W3C XSD 3.4)
type ArcType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ShowType represents the XSD type 'showType'
// XSD simple type (W3C XSD 4.1)
// enumeration="new"
// enumeration="replace"
// enumeration="embed"
// enumeration="other"
// enumeration="none"
type ShowType string

// Extended represents the XSD type 'extended'
// XSD complex type (W3C XSD 3.4)
type Extended struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TitleEltType represents the XSD type 'titleEltType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type TitleEltType struct {
        InnerXML string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// LocatorType represents the XSD type 'locatorType'
// XSD complex type (W3C XSD 3.4)
type LocatorType struct {
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ArcroleType represents the XSD type 'arcroleType'
// XSD simple type (W3C XSD 4.1)
// minLength="1"
type ArcroleType string
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package pkg_200009xmldsig generated from XSD schema
// Source namespace: http://www.w3.org/2000/09/xmldsig#
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/xmldsig-core-schema.xsd
// Generated by forgexml - Do not edit manually

package pkg_200009xmldsig

import (
        "encoding/xml"
        "os"
        "strings"
)

// KeyValueElement represents the XSD element 'KeyValue'
// XSD element declaration (W3C XSD 3.3)
type KeyValueElement struct {
        XMLName      xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# KeyValue"`
        KeyValueType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *KeyValueElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias KeyValueElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *KeyValueElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias KeyValueElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *KeyValueElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *KeyValueElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *KeyValueElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *KeyValueElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *KeyValueElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadKeyValueFromBytes loads an element from bytes with namespace preservation
func LoadKeyValueFromBytes(data []byte) (*KeyValueElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element KeyValueElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadKeyValueFromFile loads an element from a file with namespace preservation
func LoadKeyValueFromFile(path string) (*KeyValueElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadKeyValueFromBytes(data)</span>
}

// DigestValueElement represents the XSD element 'DigestValue'
// XSD element declaration (W3C XSD 3.3)
type DigestValueElement struct {
        XMLName xml.Name        `xml:"http://www.w3.org/2000/09/xmldsig# DigestValue"`
        Value   DigestValueType `xml:",chardata"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *DigestValueElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias DigestValueElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *DigestValueElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias DigestValueElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *DigestValueElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *DigestValueElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *DigestValueElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *DigestValueElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *DigestValueElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadDigestValueFromBytes loads an element from bytes with namespace preservation
func LoadDigestValueFromBytes(data []byte) (*DigestValueElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element DigestValueElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadDigestValueFromFile loads an element from a file with namespace preservation
func LoadDigestValueFromFile(path string) (*DigestValueElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadDigestValueFromBytes(data)</span>
}

// ManifestElement represents the XSD element 'Manifest'
// XSD element declaration (W3C XSD 3.3)
type ManifestElement struct {
        XMLName      xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# Manifest"`
        ManifestType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ManifestElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ManifestElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ManifestElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ManifestElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ManifestElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ManifestElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ManifestElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ManifestElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ManifestElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadManifestFromBytes loads an element from bytes with namespace preservation
func LoadManifestFromBytes(data []byte) (*ManifestElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ManifestElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadManifestFromFile loads an element from a file with namespace preservation
func LoadManifestFromFile(path string) (*ManifestElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadManifestFromBytes(data)</span>
}

// SignaturePropertyElement represents the XSD element 'SignatureProperty'
// XSD element declaration (W3C XSD 3.3)
type SignaturePropertyElement struct {
        XMLName               xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# SignatureProperty"`
        SignaturePropertyType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SignaturePropertyElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SignaturePropertyElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SignaturePropertyElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SignaturePropertyElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SignaturePropertyElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SignaturePropertyElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SignaturePropertyElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SignaturePropertyElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SignaturePropertyElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSignaturePropertyFromBytes loads an element from bytes with namespace preservation
func LoadSignaturePropertyFromBytes(data []byte) (*SignaturePropertyElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SignaturePropertyElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSignaturePropertyFromFile loads an element from a file with namespace preservation
func LoadSignaturePropertyFromFile(path string) (*SignaturePropertyElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSignaturePropertyFromBytes(data)</span>
}

// DSAKeyValueElement represents the XSD element 'DSAKeyValue'
// XSD element declaration (W3C XSD 3.3)
type DSAKeyValueElement struct {
        XMLName         xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# DSAKeyValue"`
        DSAKeyValueType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *DSAKeyValueElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias DSAKeyValueElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *DSAKeyValueElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias DSAKeyValueElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *DSAKeyValueElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *DSAKeyValueElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *DSAKeyValueElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *DSAKeyValueElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *DSAKeyValueElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadDSAKeyValueFromBytes loads an element from bytes with namespace preservation
func LoadDSAKeyValueFromBytes(data []byte) (*DSAKeyValueElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element DSAKeyValueElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadDSAKeyValueFromFile loads an element from a file with namespace preservation
func LoadDSAKeyValueFromFile(path string) (*DSAKeyValueElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadDSAKeyValueFromBytes(data)</span>
}

// RetrievalMethodElement represents the XSD element 'RetrievalMethod'
// XSD element declaration (W3C XSD 3.3)
type RetrievalMethodElement struct {
        XMLName             xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# RetrievalMethod"`
        RetrievalMethodType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *RetrievalMethodElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias RetrievalMethodElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *RetrievalMethodElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias RetrievalMethodElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *RetrievalMethodElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *RetrievalMethodElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *RetrievalMethodElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *RetrievalMethodElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *RetrievalMethodElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadRetrievalMethodFromBytes loads an element from bytes with namespace preservation
func LoadRetrievalMethodFromBytes(data []byte) (*RetrievalMethodElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element RetrievalMethodElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadRetrievalMethodFromFile loads an element from a file with namespace preservation
func LoadRetrievalMethodFromFile(path string) (*RetrievalMethodElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadRetrievalMethodFromBytes(data)</span>
}

// SignaturePropertiesElement represents the XSD element 'SignatureProperties'
// XSD element declaration (W3C XSD 3.3)
type SignaturePropertiesElement struct {
        XMLName                 xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# SignatureProperties"`
        SignaturePropertiesType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SignaturePropertiesElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SignaturePropertiesElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SignaturePropertiesElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SignaturePropertiesElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SignaturePropertiesElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SignaturePropertiesElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SignaturePropertiesElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SignaturePropertiesElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SignaturePropertiesElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSignaturePropertiesFromBytes loads an element from bytes with namespace preservation
func LoadSignaturePropertiesFromBytes(data []byte) (*SignaturePropertiesElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SignaturePropertiesElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSignaturePropertiesFromFile loads an element from a file with namespace preservation
func LoadSignaturePropertiesFromFile(path string) (*SignaturePropertiesElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSignaturePropertiesFromBytes(data)</span>
}

// RSAKeyValueElement represents the XSD element 'RSAKeyValue'
// XSD element declaration (W3C XSD 3.3)
type RSAKeyValueElement struct {
        XMLName         xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# RSAKeyValue"`
        RSAKeyValueType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *RSAKeyValueElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias RSAKeyValueElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *RSAKeyValueElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias RSAKeyValueElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *RSAKeyValueElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *RSAKeyValueElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *RSAKeyValueElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *RSAKeyValueElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *RSAKeyValueElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadRSAKeyValueFromBytes loads an element from bytes with namespace preservation
func LoadRSAKeyValueFromBytes(data []byte) (*RSAKeyValueElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element RSAKeyValueElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadRSAKeyValueFromFile loads an element from a file with namespace preservation
func LoadRSAKeyValueFromFile(path string) (*RSAKeyValueElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadRSAKeyValueFromBytes(data)</span>
}

// SignatureElement represents the XSD element 'Signature'
// XSD element declaration (W3C XSD 3.3)
type SignatureElement struct {
        XMLName       xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# Signature"`
        SignatureType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SignatureElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SignatureElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SignatureElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SignatureElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SignatureElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SignatureElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SignatureElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SignatureElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SignatureElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSignatureFromBytes loads an element from bytes with namespace preservation
func LoadSignatureFromBytes(data []byte) (*SignatureElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SignatureElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSignatureFromFile loads an element from a file with namespace preservation
func LoadSignatureFromFile(path string) (*SignatureElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSignatureFromBytes(data)</span>
}

// SignedInfoElement represents the XSD element 'SignedInfo'
// XSD element declaration (W3C XSD 3.3)
type SignedInfoElement struct {
        XMLName        xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# SignedInfo"`
        SignedInfoType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SignedInfoElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SignedInfoElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SignedInfoElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SignedInfoElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SignedInfoElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SignedInfoElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SignedInfoElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SignedInfoElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SignedInfoElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSignedInfoFromBytes loads an element from bytes with namespace preservation
func LoadSignedInfoFromBytes(data []byte) (*SignedInfoElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SignedInfoElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSignedInfoFromFile loads an element from a file with namespace preservation
func LoadSignedInfoFromFile(path string) (*SignedInfoElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSignedInfoFromBytes(data)</span>
}

// ReferenceElement represents the XSD element 'Reference'
// XSD element declaration (W3C XSD 3.3)
type ReferenceElement struct {
        XMLName       xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# Reference"`
        ReferenceType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ReferenceElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ReferenceElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ReferenceElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ReferenceElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ReferenceElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ReferenceElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ReferenceElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ReferenceElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ReferenceElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadReferenceFromBytes loads an element from bytes with namespace preservation
func LoadReferenceFromBytes(data []byte) (*ReferenceElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ReferenceElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadReferenceFromFile loads an element from a file with namespace preservation
func LoadReferenceFromFile(path string) (*ReferenceElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadReferenceFromBytes(data)</span>
}

// TransformsElement represents the XSD element 'Transforms'
// XSD element declaration (W3C XSD 3.3)
type TransformsElement struct {
        XMLName        xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# Transforms"`
        TransformsType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *TransformsElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias TransformsElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *TransformsElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias TransformsElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *TransformsElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *TransformsElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *TransformsElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *TransformsElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *TransformsElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadTransformsFromBytes loads an element from bytes with namespace preservation
func LoadTransformsFromBytes(data []byte) (*TransformsElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element TransformsElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadTransformsFromFile loads an element from a file with namespace preservation
func LoadTransformsFromFile(path string) (*TransformsElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadTransformsFromBytes(data)</span>
}

// DigestMethodElement represents the XSD element 'DigestMethod'
// XSD element declaration (W3C XSD 3.3)
type DigestMethodElement struct {
        XMLName          xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# DigestMethod"`
        DigestMethodType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *DigestMethodElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias DigestMethodElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *DigestMethodElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias DigestMethodElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *DigestMethodElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *DigestMethodElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *DigestMethodElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *DigestMethodElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *DigestMethodElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadDigestMethodFromBytes loads an element from bytes with namespace preservation
func LoadDigestMethodFromBytes(data []byte) (*DigestMethodElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element DigestMethodElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadDigestMethodFromFile loads an element from a file with namespace preservation
func LoadDigestMethodFromFile(path string) (*DigestMethodElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadDigestMethodFromBytes(data)</span>
}

// KeyInfoElement represents the XSD element 'KeyInfo'
// XSD element declaration (W3C XSD 3.3)
type KeyInfoElement struct {
        XMLName     xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# KeyInfo"`
        KeyInfoType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *KeyInfoElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias KeyInfoElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *KeyInfoElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias KeyInfoElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *KeyInfoElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *KeyInfoElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *KeyInfoElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *KeyInfoElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *KeyInfoElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadKeyInfoFromBytes loads an element from bytes with namespace preservation
func LoadKeyInfoFromBytes(data []byte) (*KeyInfoElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element KeyInfoElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadKeyInfoFromFile loads an element from a file with namespace preservation
func LoadKeyInfoFromFile(path string) (*KeyInfoElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadKeyInfoFromBytes(data)</span>
}

// KeyNameElement represents the XSD element 'KeyName'
// XSD element declaration (W3C XSD 3.3)
type KeyNameElement struct {
        XMLName xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# KeyName"`
        Value   string   `xml:",chardata"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *KeyNameElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias KeyNameElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *KeyNameElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias KeyNameElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *KeyNameElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *KeyNameElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *KeyNameElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *KeyNameElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *KeyNameElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadKeyNameFromBytes loads an element from bytes with namespace preservation
func LoadKeyNameFromBytes(data []byte) (*KeyNameElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element KeyNameElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadKeyNameFromFile loads an element from a file with namespace preservation
func LoadKeyNameFromFile(path string) (*KeyNameElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadKeyNameFromBytes(data)</span>
}

// X509DataElement represents the XSD element 'X509Data'
// XSD element declaration (W3C XSD 3.3)
type X509DataElement struct {
        XMLName      xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# X509Data"`
        X509DataType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *X509DataElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias X509DataElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *X509DataElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias X509DataElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *X509DataElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *X509DataElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *X509DataElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *X509DataElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *X509DataElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadX509DataFromBytes loads an element from bytes with namespace preservation
func LoadX509DataFromBytes(data []byte) (*X509DataElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element X509DataElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadX509DataFromFile loads an element from a file with namespace preservation
func LoadX509DataFromFile(path string) (*X509DataElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadX509DataFromBytes(data)</span>
}

// SignatureValueElement represents the XSD element 'SignatureValue'
// XSD element declaration (W3C XSD 3.3)
type SignatureValueElement struct {
        XMLName                     xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# SignatureValue"`
        SignatureValueTypeWithAttrs          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SignatureValueElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SignatureValueElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SignatureValueElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SignatureValueElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SignatureValueElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SignatureValueElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SignatureValueElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SignatureValueElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SignatureValueElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSignatureValueFromBytes loads an element from bytes with namespace preservation
func LoadSignatureValueFromBytes(data []byte) (*SignatureValueElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SignatureValueElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSignatureValueFromFile loads an element from a file with namespace preservation
func LoadSignatureValueFromFile(path string) (*SignatureValueElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSignatureValueFromBytes(data)</span>
}

// CanonicalizationMethodElement represents the XSD element 'CanonicalizationMethod'
// XSD element declaration (W3C XSD 3.3)
type CanonicalizationMethodElement struct {
        XMLName                    xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# CanonicalizationMethod"`
        CanonicalizationMethodType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *CanonicalizationMethodElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias CanonicalizationMethodElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *CanonicalizationMethodElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias CanonicalizationMethodElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *CanonicalizationMethodElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *CanonicalizationMethodElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *CanonicalizationMethodElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *CanonicalizationMethodElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *CanonicalizationMethodElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadCanonicalizationMethodFromBytes loads an element from bytes with namespace preservation
func LoadCanonicalizationMethodFromBytes(data []byte) (*CanonicalizationMethodElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element CanonicalizationMethodElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadCanonicalizationMethodFromFile loads an element from a file with namespace preservation
func LoadCanonicalizationMethodFromFile(path string) (*CanonicalizationMethodElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadCanonicalizationMethodFromBytes(data)</span>
}

// SignatureMethodElement represents the XSD element 'SignatureMethod'
// XSD element declaration (W3C XSD 3.3)
type SignatureMethodElement struct {
        XMLName             xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# SignatureMethod"`
        SignatureMethodType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SignatureMethodElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SignatureMethodElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SignatureMethodElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SignatureMethodElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SignatureMethodElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SignatureMethodElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SignatureMethodElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SignatureMethodElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SignatureMethodElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSignatureMethodFromBytes loads an element from bytes with namespace preservation
func LoadSignatureMethodFromBytes(data []byte) (*SignatureMethodElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SignatureMethodElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSignatureMethodFromFile loads an element from a file with namespace preservation
func LoadSignatureMethodFromFile(path string) (*SignatureMethodElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSignatureMethodFromBytes(data)</span>
}

// TransformElement represents the XSD element 'Transform'
// XSD element declaration (W3C XSD 3.3)
type TransformElement struct {
        XMLName       xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# Transform"`
        TransformType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *TransformElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias TransformElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov8" title="1"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *TransformElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias TransformElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *TransformElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *TransformElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *TransformElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *TransformElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *TransformElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadTransformFromBytes loads an element from bytes with namespace preservation
func LoadTransformFromBytes(data []byte) (*TransformElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element TransformElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadTransformFromFile loads an element from a file with namespace preservation
func LoadTransformFromFile(path string) (*TransformElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadTransformFromBytes(data)</span>
}

// MgmtDataElement represents the XSD element 'MgmtData'
// XSD element declaration (W3C XSD 3.3)
type MgmtDataElement struct {
        XMLName xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# MgmtData"`
        Value   string   `xml:",chardata"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *MgmtDataElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias MgmtDataElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *MgmtDataElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias MgmtDataElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *MgmtDataElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *MgmtDataElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *MgmtDataElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *MgmtDataElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *MgmtDataElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadMgmtDataFromBytes loads an element from bytes with namespace preservation
func LoadMgmtDataFromBytes(data []byte) (*MgmtDataElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element MgmtDataElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadMgmtDataFromFile loads an element from a file with namespace preservation
func LoadMgmtDataFromFile(path string) (*MgmtDataElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadMgmtDataFromBytes(data)</span>
}

// PGPDataElement represents the XSD element 'PGPData'
// XSD element declaration (W3C XSD 3.3)
type PGPDataElement struct {
        XMLName     xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# PGPData"`
        PGPDataType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *PGPDataElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias PGPDataElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *PGPDataElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias PGPDataElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *PGPDataElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *PGPDataElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *PGPDataElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *PGPDataElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *PGPDataElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadPGPDataFromBytes loads an element from bytes with namespace preservation
func LoadPGPDataFromBytes(data []byte) (*PGPDataElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element PGPDataElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadPGPDataFromFile loads an element from a file with namespace preservation
func LoadPGPDataFromFile(path string) (*PGPDataElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadPGPDataFromBytes(data)</span>
}

// SPKIDataElement represents the XSD element 'SPKIData'
// XSD element declaration (W3C XSD 3.3)
type SPKIDataElement struct {
        XMLName      xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# SPKIData"`
        SPKIDataType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *SPKIDataElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias SPKIDataElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *SPKIDataElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias SPKIDataElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *SPKIDataElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *SPKIDataElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *SPKIDataElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *SPKIDataElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *SPKIDataElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadSPKIDataFromBytes loads an element from bytes with namespace preservation
func LoadSPKIDataFromBytes(data []byte) (*SPKIDataElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element SPKIDataElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadSPKIDataFromFile loads an element from a file with namespace preservation
func LoadSPKIDataFromFile(path string) (*SPKIDataElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadSPKIDataFromBytes(data)</span>
}

// ObjectElement represents the XSD element 'Object'
// XSD element declaration (W3C XSD 3.3)
type ObjectElement struct {
        XMLName    xml.Name `xml:"http://www.w3.org/2000/09/xmldsig# Object"`
        ObjectType          // Embedded complex type
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
        // nsDeclarations stores namespace prefix-&gt;URI mappings for perfect round-trip
        nsDeclarations map[string]string `xml:"-"`
        // nsDefaultNamespace stores the default namespace for perfect round-trip
        nsDefaultNamespace string `xml:"-"`
        // elementPrefixes stores element name-&gt;prefix mappings for perfect round-trip
        elementPrefixes map[string]string `xml:"-"`
        // elementsWithXmlns tracks which element names had xmlns in original (element_name -&gt; namespace_uri)
        // Used to replicate xmlns placement exactly during marshal for zero xmlns delta
        elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ObjectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Create alias type to prevent recursion
        type alias ObjectElement
        aux := (*alias)(e)

        // Extract namespace declarations from start element
        e.nsDeclarations = make(map[string]string)
        e.elementPrefixes = make(map[string]string)
        var nonXmlnsAttrs []xml.Attr
        for _, attr := range start.Attr </span><span class="cov8" title="1">{
                if attr.Name.Space == "xmlns" </span><span class="cov0" title="0">{
                        // xmlns:prefix="uri"
                        e.nsDeclarations[attr.Name.Local] = attr.Value
                        // Build reverse map for element prefix restoration
                        e.elementPrefixes[attr.Value] = attr.Name.Local
                }</span> else<span class="cov8" title="1"> if attr.Name.Local == "xmlns" &amp;&amp; attr.Name.Space == "" </span><span class="cov8" title="1">{
                        // xmlns="uri"
                        e.nsDefaultNamespace = attr.Value
                }</span> else<span class="cov0" title="0"> {
                        // Keep non-xmlns attributes for DecodeElement
                        nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
                }</span>
        }

        // Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
        <span class="cov8" title="1">start.Attr = nonXmlnsAttrs

        // Perform standard unmarshal
        return d.DecodeElement(aux, &amp;start)</span>
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ObjectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use the struct's XMLName to ensure correct element name
        start.Name = e.XMLName

        // Restore namespace declarations
        if len(e.nsDeclarations) &gt; 0 </span><span class="cov0" title="0">{
                // Add namespace declarations to start element
                for prefix, uri := range e.nsDeclarations </span><span class="cov0" title="0">{
                        start.Attr = append(start.Attr, xml.Attr{
                                Name:  xml.Name{Space: "xmlns", Local: prefix},
                                Value: uri,
                        })
                }</span>
        }
        // Restore default namespace declaration if it was present in input
        // This is necessary for perfect fidelity when elements have redundant xmlns
        <span class="cov8" title="1">if e.nsDefaultNamespace != "" </span><span class="cov8" title="1">{
                start.Attr = append(start.Attr, xml.Attr{
                        Name:  xml.Name{Local: "xmlns"},
                        Value: e.nsDefaultNamespace,
                })
        }</span>

        // Create alias type to prevent recursion
        <span class="cov8" title="1">type alias ObjectElement
        aux := (*alias)(e)

        // Encode using standard marshaler
        return encoder.EncodeElement(aux, start)</span>
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ObjectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) <span class="cov0" title="0">{
        data, err := xml.MarshalIndent(e, prefix, indent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fix Go's namespace corruption:
        // Go's xml.Encoder corrupts xmlns declarations by:
        // 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -&gt; '_xmlns:rc'
        // 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
        <span class="cov0" title="0">output := string(data)

        // Step 1: Fix Go's namespace corruption
        // First, remove the bogus xmlns:_xmlns="xmlns" attribute
        output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

        // Then fix all _xmlns: prefixes to xmlns:
        output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

        // Also remove any remaining xmlns:xmlns="xmlns" that may appear
        output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

        // Fix corrupted XMLSchema-instance namespace
        // Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
        output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
        output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

        // Step 2: Restore element namespace prefixes using the captured prefix map
        if len(e.elementPrefixes) &gt; 0 </span><span class="cov0" title="0">{
                output = restoreElementPrefixes(output, e.elementPrefixes)
        }</span>

        // Step 3: Replicate xmlns placement from original XML for zero xmlns delta
        // This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
        <span class="cov0" title="0">if len(e.elementsWithXmlns) &gt; 0 </span><span class="cov0" title="0">{
                output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
        }</span>

        <span class="cov0" title="0">return []byte(output), nil</span>
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ObjectElement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        return e.MarshalIndentClean("", "  ")
}</span>

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ObjectElement) SetElementPrefixes(prefixes map[string]string) <span class="cov0" title="0">{
        e.elementPrefixes = prefixes
}</span>

// SetElementsWithXmlns allows injecting element-&gt;xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ObjectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) <span class="cov0" title="0">{
        e.elementsWithXmlns = elementsWithXmlns
}</span>

// SaveToFile saves the element to a file with namespace preservation
func (e *ObjectElement) SaveToFile(path string) error <span class="cov0" title="0">{
        data, err := e.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// LoadObjectFromBytes loads an element from bytes with namespace preservation
func LoadObjectFromBytes(data []byte) (*ObjectElement, error) <span class="cov0" title="0">{
        // Extract element prefixes from raw XML before unmarshaling
        elementPrefixes := ExtractElementPrefixes(data)
        // Extract which elements had xmlns for exact xmlns replication
        elementsWithXmlns := ExtractElementsWithXmlns(data)

        var element ObjectElement
        if err := xml.Unmarshal(data, &amp;element); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store extracted element name -&gt; prefix mappings for restoration during marshal
        <span class="cov0" title="0">element.elementPrefixes = elementPrefixes
        // Store element -&gt; xmlns mappings for zero xmlns delta
        element.elementsWithXmlns = elementsWithXmlns

        return &amp;element, nil</span>
}

// LoadObjectFromFile loads an element from a file with namespace preservation
func LoadObjectFromFile(path string) (*ObjectElement, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return LoadObjectFromBytes(data)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package pkg_200009xmldsig generated from XSD schema
// Source namespace: http://www.w3.org/2000/09/xmldsig#
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/xmldsig-core-schema.xsd
// Generated by forgexml - Do not edit manually

package pkg_200009xmldsig

import (
        "encoding/xml"
        "regexp"
        "strings"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
        XMLName xml.Name   `xml:""`
        Content string     `xml:",innerxml"`
        Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -&gt; xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementsWithXmlns := make(map[string]string)
        xmlStr := string(xmlData)

        // Pattern to find elements with xmlns: &lt;element_name ...xmlns="uri"...
        // Captures both prefixed and unprefixed element names
        pattern := regexp.MustCompile(`&lt;(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^&gt;]*?xmlns="([^"]+)"`)
        matches := pattern.FindAllStringSubmatch(xmlStr, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 4 </span><span class="cov0" title="0">{
                        // match[1] = prefix (may be empty)
                        // match[2] = element name
                        // match[3] = xmlns URI
                        elementName := match[2]
                        xmlnsURI := match[3]
                        elementsWithXmlns[elementName] = xmlnsURI
                }</span>
        }

        <span class="cov0" title="0">return elementsWithXmlns</span>
}

// ExtractElementPrefixes parses raw XML to build element name -&gt; prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string <span class="cov0" title="0">{
        elementPrefixes := make(map[string]string)

        // Use regex to find all opening tags with prefixes: &lt;prefix:element
        pattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s&gt;]`)
        matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt;= 3 </span><span class="cov0" title="0">{
                        prefix := match[1]
                        elementName := match[2]
                        elementPrefixes[elementName] = prefix
                }</span>
        }

        <span class="cov0" title="0">return elementPrefixes</span>
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string <span class="cov0" title="0">{
        // For each element name -&gt; prefix mapping
        for elementName, prefix := range elementPrefixes </span><span class="cov0" title="0">{
                // Replace opening tags: &lt;elementName with &lt;prefix:elementName
                // and remove default xmlns="..." since the prefix declares the namespace
                pattern := regexp.MustCompile(`&lt;` + elementName + `(\s[^&gt;]*)?&gt;`)
                xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                        // Add prefix to element name
                        result := "&lt;" + prefix + ":" + elementName
                        // Extract attributes (everything between element name and &gt;)
                        if len(match) &gt; len("&lt;"+elementName+"&gt;") </span><span class="cov0" title="0">{
                                attrs := match[len("&lt;"+elementName) : len(match)-1]
                                // Remove default xmlns="..." attribute
                                xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                                result += attrs
                        }</span>
                        <span class="cov0" title="0">result += "&gt;"
                        return result</span>
                })

                // Replace closing tags: &lt;/elementName&gt; with &lt;/prefix:elementName&gt;
                <span class="cov0" title="0">xmlOutput = strings.ReplaceAll(xmlOutput, "&lt;/"+elementName+"&gt;", "&lt;/"+prefix+":"+elementName+"&gt;")</span>
        }

        <span class="cov0" title="0">return xmlOutput</span>
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string <span class="cov0" title="0">{
        if len(elementsWithXmlns) == 0 </span><span class="cov0" title="0">{
                // No xmlns tracking - remove all nested xmlns to avoid inflation
                // Keep only root element xmlns
                firstGT := strings.Index(xmlOutput, "&gt;")
                if firstGT == -1 </span><span class="cov0" title="0">{
                        return xmlOutput
                }</span>
                <span class="cov0" title="0">rootTag := xmlOutput[:firstGT+1]
                rest := xmlOutput[firstGT+1:]
                // Remove all xmlns from nested elements
                xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                rest = xmlnsPattern.ReplaceAllString(rest, "")
                return rootTag + rest</span>
        }

        // Strategy: Find all opening tags and remove xmlns if element type not in map
        // Pattern matches: &lt;element_name attr="val" xmlns="uri" ...&gt;
        <span class="cov0" title="0">tagPattern := regexp.MustCompile(`&lt;([a-zA-Z0-9_-]+)(\s[^&gt;]*?)&gt;`)
        result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string </span><span class="cov0" title="0">{
                // Extract element name
                tagMatch := tagPattern.FindStringSubmatch(match)
                if len(tagMatch) &lt; 2 </span><span class="cov0" title="0">{
                        return match
                }</span>
                <span class="cov0" title="0">elementName := tagMatch[1]
                attrs := ""
                if len(tagMatch) &gt;= 3 </span><span class="cov0" title="0">{
                        attrs = tagMatch[2]
                }</span>

                // CRITICAL FIX: Deduplicate xmlns attributes first
                // Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
                // This happens with nested structs having XMLName with different namespaces
                // Remove all duplicate xmlns declarations, keeping only the first one
                <span class="cov0" title="0">dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
                matches := dedupPattern.FindAllString(attrs, -1)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        // Found duplicates - keep only first xmlns, remove rest
                        firstXmlns := matches[0]
                        attrs = dedupPattern.ReplaceAllString(attrs, "")
                        attrs = " " + firstXmlns + attrs
                }</span>

                // Check if this element type should have xmlns
                <span class="cov0" title="0">expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
                if shouldHaveXmlns </span><span class="cov0" title="0">{
                        // This element should have xmlns - ensure it's present and correct
                        if !strings.Contains(attrs, "xmlns=") </span><span class="cov0" title="0">{
                                // Missing xmlns - add it
                                return "&lt;" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + "&gt;"
                        }</span>
                        // Has xmlns - verify it's correct
                        <span class="cov0" title="0">if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) </span><span class="cov0" title="0">{
                                // Wrong xmlns - replace it
                                xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
                                attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
                        }</span>
                        <span class="cov0" title="0">return "&lt;" + elementName + attrs + "&gt;"</span>
                }

                // This element should NOT have xmlns - remove any xmlns attributes
                <span class="cov0" title="0">xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
                attrs = xmlnsPattern.ReplaceAllString(attrs, "")
                return "&lt;" + elementName + attrs + "&gt;"</span>
        })

        <span class="cov0" title="0">return result</span>
}

// ManifestType represents the XSD type 'ManifestType'
// XSD complex type (W3C XSD 3.4)
type ManifestType struct {
        // Reference represents XSD element 'Reference'
        // minOccurs=1, maxOccurs=-1
        Reference []ReferenceType `xml:"Reference"`
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignaturePropertiesType represents the XSD type 'SignaturePropertiesType'
// XSD complex type (W3C XSD 3.4)
type SignaturePropertiesType struct {
        // SignatureProperty represents XSD element 'SignatureProperty'
        // minOccurs=1, maxOccurs=-1
        SignatureProperty []SignaturePropertyType `xml:"SignatureProperty"`
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignatureType represents the XSD type 'SignatureType'
// XSD complex type (W3C XSD 3.4)
type SignatureType struct {
        // SignedInfo represents XSD element 'SignedInfo'
        SignedInfo SignedInfoType `xml:"SignedInfo"`
        // SignatureValue represents XSD element 'SignatureValue'
        SignatureValue SignatureValueTypeWithAttrs `xml:"SignatureValue"`
        // KeyInfo represents XSD element 'KeyInfo'
        // minOccurs=0, maxOccurs=1
        KeyInfo *KeyInfoType `xml:"KeyInfo,omitempty"`
        // Object represents XSD element 'Object'
        // minOccurs=0, maxOccurs=-1
        Object []ObjectType `xml:"Object,omitempty"`
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignatureValueType represents the XSD type 'SignatureValueType'
// XSD complex type (W3C XSD 3.4)
type SignatureValueTypeWithAttrs struct {
        Value []byte `xml:",chardata"` // XSD simple content
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignatureValueType is an alias for SignatureValueTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type SignatureValueType = SignatureValueTypeWithAttrs

// SignedInfoType represents the XSD type 'SignedInfoType'
// XSD complex type (W3C XSD 3.4)
type SignedInfoType struct {
        // CanonicalizationMethod represents XSD element 'CanonicalizationMethod'
        CanonicalizationMethod CanonicalizationMethodType `xml:"CanonicalizationMethod"`
        // SignatureMethod represents XSD element 'SignatureMethod'
        SignatureMethod SignatureMethodType `xml:"SignatureMethod"`
        // Reference represents XSD element 'Reference'
        // minOccurs=1, maxOccurs=-1
        Reference []ReferenceType `xml:"Reference"`
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id *string `xml:"Id,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReferenceType represents the XSD type 'ReferenceType'
// XSD complex type (W3C XSD 3.4)
type ReferenceType struct {
        // Transforms represents XSD element 'Transforms'
        // minOccurs=0, maxOccurs=1
        Transforms *TransformsType `xml:"Transforms,omitempty"`
        // DigestMethod represents XSD element 'DigestMethod'
        DigestMethod DigestMethodType `xml:"DigestMethod"`
        // DigestValue represents XSD element 'DigestValue'
        DigestValue DigestValueType `xml:"DigestValue"`
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id *string `xml:"Id,attr,omitempty"`
        // URI represents XSD attribute 'URI'
        // use="optional"
        URI *string `xml:"URI,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TransformsType represents the XSD type 'TransformsType'
// XSD complex type (W3C XSD 3.4)
type TransformsType struct {
        // Transform represents XSD element 'Transform'
        // minOccurs=1, maxOccurs=-1
        Transform []TransformType `xml:"Transform"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DigestMethodType represents the XSD type 'DigestMethodType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type DigestMethodType struct {
        // Algorithm represents XSD attribute 'Algorithm'
        // use="required"
        Algorithm string `xml:"Algorithm,attr"`
        InnerXML  string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CryptoBinary represents the XSD type 'CryptoBinary'
// XSD simple type (W3C XSD 4.1)
type CryptoBinary []byte

// DigestValueType represents the XSD type 'DigestValueType'
// XSD simple type (W3C XSD 4.1)
type DigestValueType []byte

// HMACOutputLengthType represents the XSD type 'HMACOutputLengthType'
// XSD simple type (W3C XSD 4.1)
type HMACOutputLengthType int64

// KeyInfoType represents the XSD type 'KeyInfoType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type KeyInfoType struct {
        // KeyName represents XSD element 'KeyName'
        KeyName []string `xml:"KeyName,omitempty"`
        // KeyValue represents XSD element 'KeyValue'
        KeyValue []KeyValueType `xml:"KeyValue,omitempty"`
        // RetrievalMethod represents XSD element 'RetrievalMethod'
        RetrievalMethod []RetrievalMethodType `xml:"RetrievalMethod,omitempty"`
        // X509Data represents XSD element 'X509Data'
        X509Data []X509DataType `xml:"X509Data,omitempty"`
        // PGPData represents XSD element 'PGPData'
        PGPData []PGPDataType `xml:"PGPData,omitempty"`
        // SPKIData represents XSD element 'SPKIData'
        SPKIData []SPKIDataType `xml:"SPKIData,omitempty"`
        // MgmtData represents XSD element 'MgmtData'
        MgmtData []string `xml:"MgmtData,omitempty"`
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id    *string `xml:"Id,attr,omitempty"`
        Value string  `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// X509DataType represents the XSD type 'X509DataType'
// XSD complex type (W3C XSD 3.4)
type X509DataType struct {
        // X509IssuerSerial represents XSD element 'X509IssuerSerial'
        X509IssuerSerial *X509IssuerSerialType `xml:"X509IssuerSerial,omitempty"`
        // X509SKI represents XSD element 'X509SKI'
        X509SKI []byte `xml:"X509SKI,omitempty"`
        // X509SubjectName represents XSD element 'X509SubjectName'
        X509SubjectName *string `xml:"X509SubjectName,omitempty"`
        // X509Certificate represents XSD element 'X509Certificate'
        X509Certificate []byte `xml:"X509Certificate,omitempty"`
        // X509CRL represents XSD element 'X509CRL'
        X509CRL []byte `xml:"X509CRL,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignatureMethodType represents the XSD type 'SignatureMethodType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SignatureMethodType struct {
        // HMACOutputLength represents XSD element 'HMACOutputLength'
        // minOccurs=0, maxOccurs=1
        HMACOutputLength *HMACOutputLengthType `xml:"HMACOutputLength,omitempty"`
        // Algorithm represents XSD attribute 'Algorithm'
        // use="required"
        Algorithm string `xml:"Algorithm,attr"`
        Value     string `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RetrievalMethodType represents the XSD type 'RetrievalMethodType'
// XSD complex type (W3C XSD 3.4)
type RetrievalMethodType struct {
        // Transforms represents XSD element 'Transforms'
        // minOccurs=0, maxOccurs=1
        Transforms *TransformsType `xml:"Transforms,omitempty"`
        // URI represents XSD attribute 'URI'
        // use="optional"
        URI *string `xml:"URI,attr,omitempty"`
        // Type represents XSD attribute 'Type'
        // use="optional"
        Type *string `xml:"Type,attr,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// X509IssuerSerialType represents the XSD type 'X509IssuerSerialType'
// XSD complex type (W3C XSD 3.4)
type X509IssuerSerialType struct {
        // X509IssuerName represents XSD element 'X509IssuerName'
        X509IssuerName string `xml:"X509IssuerName"`
        // X509SerialNumber represents XSD element 'X509SerialNumber'
        X509SerialNumber int64 `xml:"X509SerialNumber"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignaturePropertyType represents the XSD type 'SignaturePropertyType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type SignaturePropertyType struct {
        // Target represents XSD attribute 'Target'
        // use="required"
        Target string `xml:"Target,attr"`
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id       *string `xml:"Id,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DSAKeyValueType represents the XSD type 'DSAKeyValueType'
// XSD complex type (W3C XSD 3.4)
type DSAKeyValueType struct {
        // G represents XSD element 'G'
        // minOccurs=0, maxOccurs=1
        G *CryptoBinary `xml:"G,omitempty"`
        // Y represents XSD element 'Y'
        Y CryptoBinary `xml:"Y"`
        // J represents XSD element 'J'
        // minOccurs=0, maxOccurs=1
        J *CryptoBinary `xml:"J,omitempty"`
        // P represents XSD element 'P'
        P CryptoBinary `xml:"P"`
        // Q represents XSD element 'Q'
        Q CryptoBinary `xml:"Q"`
        // Seed represents XSD element 'Seed'
        Seed CryptoBinary `xml:"Seed"`
        // PgenCounter represents XSD element 'PgenCounter'
        PgenCounter CryptoBinary `xml:"PgenCounter"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RSAKeyValueType represents the XSD type 'RSAKeyValueType'
// XSD complex type (W3C XSD 3.4)
type RSAKeyValueType struct {
        // Modulus represents XSD element 'Modulus'
        Modulus CryptoBinary `xml:"Modulus"`
        // Exponent represents XSD element 'Exponent'
        Exponent CryptoBinary `xml:"Exponent"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CanonicalizationMethodType represents the XSD type 'CanonicalizationMethodType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type CanonicalizationMethodType struct {
        // Algorithm represents XSD attribute 'Algorithm'
        // use="required"
        Algorithm string `xml:"Algorithm,attr"`
        InnerXML  string `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TransformType represents the XSD type 'TransformType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type TransformType struct {
        // XPath represents XSD element 'XPath'
        XPath []string `xml:"XPath,omitempty"`
        // Algorithm represents XSD attribute 'Algorithm'
        // use="required"
        Algorithm string `xml:"Algorithm,attr"`
        Value     string `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// KeyValueType represents the XSD type 'KeyValueType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type KeyValueType struct {
        // DSAKeyValue represents XSD element 'DSAKeyValue'
        DSAKeyValue *DSAKeyValueType `xml:"DSAKeyValue,omitempty"`
        // RSAKeyValue represents XSD element 'RSAKeyValue'
        RSAKeyValue *RSAKeyValueType `xml:"RSAKeyValue,omitempty"`
        Value       string           `xml:",chardata"` // XSD mixed content
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PGPDataType represents the XSD type 'PGPDataType'
// XSD complex type (W3C XSD 3.4)
type PGPDataType struct {
        // PGPKeyID represents XSD element 'PGPKeyID'
        PGPKeyID []byte `xml:"PGPKeyID"`
        // PGPKeyPacket represents XSD element 'PGPKeyPacket'
        // minOccurs=0, maxOccurs=1
        PGPKeyPacket []byte `xml:"PGPKeyPacket,omitempty"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SPKIDataType represents the XSD type 'SPKIDataType'
// XSD complex type (W3C XSD 3.4)
type SPKIDataType struct {
        // SPKISexp represents XSD element 'SPKISexp'
        SPKISexp [][]byte `xml:"SPKISexp"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ObjectType represents the XSD type 'ObjectType'
// XSD complex type (W3C XSD 3.4)
// mixed="true"
type ObjectType struct {
        // Id represents XSD attribute 'Id'
        // use="optional"
        Id *string `xml:"Id,attr,omitempty"`
        // MimeType represents XSD attribute 'MimeType'
        // use="optional"
        MimeType *string `xml:"MimeType,attr,omitempty"`
        // Encoding represents XSD attribute 'Encoding'
        // use="optional"
        Encoding *string `xml:"Encoding,attr,omitempty"`
        InnerXML string  `xml:",innerxml"`
        // UnknownElements captures any elements not defined in XSD
        UnknownElements []GenericElement `xml:",any,omitempty"`
        // UnknownAttrs captures any attributes not defined in XSD
        UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Package types provides custom types for XSD built-in types with 100% fidelity
package types

import (
        "encoding/xml"
        "time"
)

// DateTime represents an XSD dateTime value with support for multiple formats
// and preserves the original string representation for exact round-trip fidelity.
// Supports:
// - RFC3339 with timezone: "2006-01-02T15:04:05Z" or "2006-01-02T15:04:05-07:00"
// - ISO 8601 without timezone: "2006-01-02T15:04:05"
// - Date only: "2006-01-02"
type DateTime struct {
        Value    time.Time // Parsed time value
        Original string    // Original string representation for fidelity
}

// Common datetime formats in order of specificity
var dateTimeFormats = []string{
        time.RFC3339Nano,                // "2006-01-02T15:04:05.999999999Z07:00"
        time.RFC3339,                    // "2006-01-02T15:04:05Z07:00"
        "2006-01-02T15:04:05.999999999", // Nanoseconds without timezone
        "2006-01-02T15:04:05.999999",    // Microseconds without timezone
        "2006-01-02T15:04:05.999",       // Milliseconds without timezone
        "2006-01-02T15:04:05",           // Seconds without timezone (OVAL format)
        "2006-01-02",                    // Date only
}

// UnmarshalXML implements xml.Unmarshaler for flexible datetime parsing
func (dt *DateTime) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        var content string
        if err := d.DecodeElement(&amp;content, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Preserve original for exact round-trip
        <span class="cov8" title="1">dt.Original = content

        // Try parsing with each format
        var lastErr error
        for _, format := range dateTimeFormats </span><span class="cov8" title="1">{
                t, err := time.Parse(format, content)
                if err == nil </span><span class="cov8" title="1">{
                        dt.Value = t
                        return nil
                }</span>
                <span class="cov8" title="1">lastErr = err</span>
        }

        // If all formats failed, return the last error
        <span class="cov8" title="1">return lastErr</span>
}

// MarshalXML implements xml.Marshaler to preserve original format
func (dt DateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        // Use original string if available for exact fidelity
        if dt.Original != "" </span><span class="cov8" title="1">{
                return e.EncodeElement(dt.Original, start)
        }</span>

        // Fallback to RFC3339 if no original (shouldn't happen in round-trip)
        <span class="cov8" title="1">return e.EncodeElement(dt.Value.Format(time.RFC3339), start)</span>
}

// UnmarshalText implements encoding.TextUnmarshaler for attribute parsing
// This is required for DateTime fields used as XML attributes
func (dt *DateTime) UnmarshalText(text []byte) error <span class="cov8" title="1">{
        content := string(text)
        dt.Original = content

        // Try parsing with each format
        var lastErr error
        for _, format := range dateTimeFormats </span><span class="cov8" title="1">{
                t, err := time.Parse(format, content)
                if err == nil </span><span class="cov8" title="1">{
                        dt.Value = t
                        return nil
                }</span>
                <span class="cov8" title="1">lastErr = err</span>
        }

        // If all formats failed, return the last error
        <span class="cov8" title="1">return lastErr</span>
}

// MarshalText implements encoding.TextMarshaler for attribute marshaling
// This is required for DateTime fields used as XML attributes
func (dt DateTime) MarshalText() ([]byte, error) <span class="cov8" title="1">{
        // Use original string if available for exact fidelity
        if dt.Original != "" </span><span class="cov8" title="1">{
                return []byte(dt.Original), nil
        }</span>

        // Fallback to RFC3339 if no original (shouldn't happen in round-trip)
        <span class="cov8" title="1">return []byte(dt.Value.Format(time.RFC3339)), nil</span>
}

// String returns the original string representation
func (dt DateTime) String() string <span class="cov8" title="1">{
        if dt.Original != "" </span><span class="cov8" title="1">{
                return dt.Original
        }</span>
        <span class="cov8" title="1">return dt.Value.Format(time.RFC3339)</span>
}

// Time returns the parsed time.Time value
func (dt DateTime) Time() time.Time <span class="cov8" title="1">{
        return dt.Value
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
