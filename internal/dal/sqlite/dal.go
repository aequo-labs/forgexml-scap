// Package sqlite provides sqlite database implementation
// Auto-generated by ForgeXML - do not edit manually
package sqlite

import (
	"context"
	"database/sql"
	_ "embed"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"
	_ "github.com/mattn/go-sqlite3"

	parent "github.com/aequo-labs/forgexml-scap/internal/generated/dal"
)

//go:embed schema.sql
var schemaDDL string

// dal implements the parent.DAL interface for sqlite
type dal struct {
	db *sql.DB
}

// New creates a new sqlite DAL instance
func New(dsn string) (parent.DAL, error) {
	db, err := sql.Open("sqlite3", dsn)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return &dal{db: db}, nil
}

// NullTime is a nullable time.Time that handles SQLite's string format
type NullTime struct {
	Time  time.Time
	Valid bool
}

// Scan implements the sql.Scanner interface
func (nt *NullTime) Scan(value interface{}) error {
	if value == nil {
		nt.Time, nt.Valid = time.Time{}, false
		return nil
	}
	
	switch v := value.(type) {
	case time.Time:
		nt.Time, nt.Valid = v, true
		return nil
	case string:
		if v == "" {
			nt.Time, nt.Valid = time.Time{}, false
			return nil
		}
		// Try common formats
		formats := []string{
			time.RFC3339,
			time.RFC3339Nano,
			"2006-01-02 15:04:05",
			"2006-01-02T15:04:05",
			"2006-01-02 15:04:05.999999999-07:00",
			"2006-01-02 15:04:05.999999999",
			"2006-01-02",
		}
		for _, f := range formats {
			if parsed, err := time.Parse(f, v); err == nil {
				nt.Time, nt.Valid = parsed, true
				return nil
			}
		}
		return fmt.Errorf("unable to parse time: %s", v)
	case []byte:
		return nt.Scan(string(v))
	default:
		return fmt.Errorf("unexpected type for time: %T", v)
	}
}

// ToTimePtr converts NullTime to *time.Time
func (nt NullTime) ToTimePtr() *time.Time {
	if !nt.Valid {
		return nil
	}
	return &nt.Time
}

// NewWithDB creates a DAL with an existing database connection
func NewWithDB(db *sql.DB) parent.DAL {
	return &dal{db: db}
}

func (d *dal) DB() *sql.DB {
	return d.db
}

func (d *dal) Close() error {
	return d.db.Close()
}

func (d *dal) BeginTx(ctx context.Context) (parent.Transaction, error) {
	tx, err := d.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	return &transaction{tx: tx}, nil
}

func (d *dal) CreateSchema(ctx context.Context) error {
	// Split DDL into individual statements and execute each
	// This is needed because not all databases support multi-statement execution
	statements := strings.Split(schemaDDL, ";")
	for _, stmt := range statements {
		stmt = strings.TrimSpace(stmt)
		if stmt == "" {
			continue
		}
		// Strip comment lines from the statement
		lines := strings.Split(stmt, "\n")
		var sqlLines []string
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if trimmed != "" && !strings.HasPrefix(trimmed, "--") {
				sqlLines = append(sqlLines, line)
			}
		}
		stmt = strings.TrimSpace(strings.Join(sqlLines, "\n"))
		if stmt == "" {
			continue
		}
		if _, err := d.db.ExecContext(ctx, stmt); err != nil {
			// Ignore "duplicate key" errors for indexes (MySQL error 1061)
			// This allows CreateSchema to be idempotent
			errStr := err.Error()
			if strings.Contains(errStr, "Duplicate key name") || strings.Contains(errStr, "1061") {
				continue
			}
			return err
		}
	}
	return nil
}

func (d *dal) DropSchema(ctx context.Context) error {
	var dropStatements = []string{
		"DROP TABLE IF EXISTS xccdf_1_2_value_type",
		"DROP TABLE IF EXISTS xccdf_1_2_text_type",
		"DROP TABLE IF EXISTS xccdf_1_2_signature_type",
		"DROP TABLE IF EXISTS xccdf_1_2_reference_type",
		"DROP TABLE IF EXISTS xccdf_1_2_metadata_type",
		"DROP TABLE IF EXISTS xccdf_1_2_message_type",
		"DROP TABLE IF EXISTS \"xccdf_1_2_check_type\"",
		"DROP TABLE IF EXISTS x_n_l_element_type",
		"DROP TABLE IF EXISTS x_n_l",
		"DROP TABLE IF EXISTS x_a_l_element_type",
		"DROP TABLE IF EXISTS x_a_l",
		"DROP TABLE IF EXISTS x509_issuer_serial_type",
		"DROP TABLE IF EXISTS x509_data_type",
		"DROP TABLE IF EXISTS website_url_element_type",
		"DROP TABLE IF EXISTS website_url",
		"DROP TABLE IF EXISTS website_type",
		"DROP TABLE IF EXISTS warning_type",
		"DROP TABLE IF EXISTS version_element_type",
		"DROP TABLE IF EXISTS variable_component_type",
		"DROP TABLE IF EXISTS url_element_type",
		"DROP TABLE IF EXISTS uri_ref_type",
		"DROP TABLE IF EXISTS \"unique_function_type\"",
		"DROP TABLE IF EXISTS transforms_type",
		"DROP TABLE IF EXISTS transform_type",
		"DROP TABLE IF EXISTS title_elt_type",
		"DROP TABLE IF EXISTS title_element_type",
		"DROP TABLE IF EXISTS time_difference_function_type",
		"DROP TABLE IF EXISTS \"thoroughfare_number_to_element_type\"",
		"DROP TABLE IF EXISTS thoroughfare_number_suffix_element_type",
		"DROP TABLE IF EXISTS thoroughfare_number_suffix",
		"DROP TABLE IF EXISTS thoroughfare_number_range_element_type",
		"DROP TABLE IF EXISTS thoroughfare_number_prefix_element_type",
		"DROP TABLE IF EXISTS thoroughfare_number_prefix",
		"DROP TABLE IF EXISTS \"thoroughfare_number_from_element_type\"",
		"DROP TABLE IF EXISTS thoroughfare_number_element_type",
		"DROP TABLE IF EXISTS thoroughfare_number",
		"DROP TABLE IF EXISTS thoroughfare_name_type",
		"DROP TABLE IF EXISTS thoroughfare_element_type",
		"DROP TABLE IF EXISTS thoroughfare",
		"DROP TABLE IF EXISTS \"text_with_sub_type\"",
		"DROP TABLE IF EXISTS test_type",
		"DROP TABLE IF EXISTS test_result_type",
		"DROP TABLE IF EXISTS telephone_number_element_type",
		"DROP TABLE IF EXISTS telephone_number",
		"DROP TABLE IF EXISTS target_id_ref_type",
		"DROP TABLE IF EXISTS target_facts_type",
		"DROP TABLE IF EXISTS tailoring_type",
		"DROP TABLE IF EXISTS tailoring_version_type",
		"DROP TABLE IF EXISTS tailoring_reference_type",
		"DROP TABLE IF EXISTS tailoring_benchmark_reference_type",
		"DROP TABLE IF EXISTS system_type",
		"DROP TABLE IF EXISTS system_name_element_type",
		"DROP TABLE IF EXISTS synthetic_id_element_type",
		"DROP TABLE IF EXISTS synthetic_id",
		"DROP TABLE IF EXISTS supplementary_postal_service_data_element_type",
		"DROP TABLE IF EXISTS suffix_element_type",
		"DROP TABLE IF EXISTS substring_function_type",
		"DROP TABLE IF EXISTS sub_premise_type",
		"DROP TABLE IF EXISTS sub_premise_number_suffix_element_type",
		"DROP TABLE IF EXISTS sub_premise_number_prefix_element_type",
		"DROP TABLE IF EXISTS sub_premise_number_element_type",
		"DROP TABLE IF EXISTS sub_premise_name_element_type",
		"DROP TABLE IF EXISTS sub_premise_location_element_type",
		"DROP TABLE IF EXISTS sub_administrative_area_name_element_type",
		"DROP TABLE IF EXISTS sub_administrative_area_element_type",
		"DROP TABLE IF EXISTS status_element_type",
		"DROP TABLE IF EXISTS status",
		"DROP TABLE IF EXISTS state_type",
		"DROP TABLE IF EXISTS state_ref_type",
		"DROP TABLE IF EXISTS split_function_type",
		"DROP TABLE IF EXISTS sorting_code_element_type",
		"DROP TABLE IF EXISTS software_type",
		"DROP TABLE IF EXISTS simple",
		"DROP TABLE IF EXISTS signed_info_type",
		"DROP TABLE IF EXISTS signature_value_type",
		"DROP TABLE IF EXISTS signature_property_type",
		"DROP TABLE IF EXISTS signature_properties_type",
		"DROP TABLE IF EXISTS signature_method_type",
		"DROP TABLE IF EXISTS \"set_element_type\"",
		"DROP TABLE IF EXISTS \"set\"",
		"DROP TABLE IF EXISTS service_type",
		"DROP TABLE IF EXISTS sel_string_type",
		"DROP TABLE IF EXISTS sel_num_type",
		"DROP TABLE IF EXISTS sel_complex_value_type",
		"DROP TABLE IF EXISTS sel_choices_type",
		"DROP TABLE IF EXISTS score_type",
		"DROP TABLE IF EXISTS s_p_k_i_data_type",
		"DROP TABLE IF EXISTS rule_type",
		"DROP TABLE IF EXISTS rule_result_type",
		"DROP TABLE IF EXISTS retrieval_method_type",
		"DROP TABLE IF EXISTS restriction_type",
		"DROP TABLE IF EXISTS resource_type",
		"DROP TABLE IF EXISTS reports_element_type",
		"DROP TABLE IF EXISTS report_type",
		"DROP TABLE IF EXISTS report_requests_element_type",
		"DROP TABLE IF EXISTS report_request_type",
		"DROP TABLE IF EXISTS remote_resource_element_type",
		"DROP TABLE IF EXISTS remote_resource",
		"DROP TABLE IF EXISTS relationships_element_type",
		"DROP TABLE IF EXISTS relationship_type",
		"DROP TABLE IF EXISTS regex_capture_function_type",
		"DROP TABLE IF EXISTS reference_element_type",
		"DROP TABLE IF EXISTS \"r_s_a_key_value_type\"",
		"DROP TABLE IF EXISTS protocol_element_type",
		"DROP TABLE IF EXISTS profile_type",
		"DROP TABLE IF EXISTS \"profile_set_value_type\"",
		"DROP TABLE IF EXISTS \"profile_set_complex_value_type\"",
		"DROP TABLE IF EXISTS \"profile_select_type\"",
		"DROP TABLE IF EXISTS profile_refine_value_type",
		"DROP TABLE IF EXISTS profile_refine_rule_type",
		"DROP TABLE IF EXISTS profile_note_type",
		"DROP TABLE IF EXISTS premise_number_suffix_element_type",
		"DROP TABLE IF EXISTS premise_number_suffix",
		"DROP TABLE IF EXISTS \"premise_number_range_to_element_type\"",
		"DROP TABLE IF EXISTS \"premise_number_range_from_element_type\"",
		"DROP TABLE IF EXISTS premise_number_range_element_type",
		"DROP TABLE IF EXISTS premise_number_prefix_element_type",
		"DROP TABLE IF EXISTS premise_number_prefix",
		"DROP TABLE IF EXISTS premise_number_element_type",
		"DROP TABLE IF EXISTS premise_number",
		"DROP TABLE IF EXISTS premise_name_element_type",
		"DROP TABLE IF EXISTS premise_location_element_type",
		"DROP TABLE IF EXISTS premise_element_type",
		"DROP TABLE IF EXISTS premise",
		"DROP TABLE IF EXISTS preceding_title_element_type",
		"DROP TABLE IF EXISTS postal_service_elements_element_type",
		"DROP TABLE IF EXISTS postal_route_number_element_type",
		"DROP TABLE IF EXISTS postal_route_name_element_type",
		"DROP TABLE IF EXISTS postal_code_number_extension_element_type",
		"DROP TABLE IF EXISTS postal_code_number_element_type",
		"DROP TABLE IF EXISTS postal_code_element_type",
		"DROP TABLE IF EXISTS postal_code",
		"DROP TABLE IF EXISTS post_town_suffix_element_type",
		"DROP TABLE IF EXISTS post_town_name_element_type",
		"DROP TABLE IF EXISTS post_town_element_type",
		"DROP TABLE IF EXISTS post_office_number_element_type",
		"DROP TABLE IF EXISTS post_office_name_element_type",
		"DROP TABLE IF EXISTS post_office_element_type",
		"DROP TABLE IF EXISTS postal_route_type",
		"DROP TABLE IF EXISTS post_office",
		"DROP TABLE IF EXISTS post_box_number_suffix_element_type",
		"DROP TABLE IF EXISTS post_box_number_prefix_element_type",
		"DROP TABLE IF EXISTS post_box_number_extension_element_type",
		"DROP TABLE IF EXISTS post_box_number_element_type",
		"DROP TABLE IF EXISTS post_box_element_type",
		"DROP TABLE IF EXISTS post_box",
		"DROP TABLE IF EXISTS port_range_element_type",
		"DROP TABLE IF EXISTS port_element_type",
		"DROP TABLE IF EXISTS platform_type",
		"DROP TABLE IF EXISTS platform_specification_element_type",
		"DROP TABLE IF EXISTS platform_specification",
		"DROP TABLE IF EXISTS plain_text_type",
		"DROP TABLE IF EXISTS person_type",
		"DROP TABLE IF EXISTS person_name_element_type",
		"DROP TABLE IF EXISTS param_type",
		"DROP TABLE IF EXISTS p_g_p_data_type",
		"DROP TABLE IF EXISTS overrideable_c_p_e2idref_type",
		"DROP TABLE IF EXISTS override_type",
		"DROP TABLE IF EXISTS oval_mitre_org_oval__value_type",
		"DROP TABLE IF EXISTS oval_mitre_org_oval__reference_type",
		"DROP TABLE IF EXISTS oval_mitre_org_oval__object_type",
		"DROP TABLE IF EXISTS oval_mitre_org_oval__notes_type",
		"DROP TABLE IF EXISTS oval_mitre_org_oval__metadata_type",
		"DROP TABLE IF EXISTS oval_mitre_org_oval__message_type",
		"DROP TABLE IF EXISTS oval_mitre_org_oval__generator_type",
		"DROP TABLE IF EXISTS oval_definitions_element_type",
		"DROP TABLE IF EXISTS variables_type",
		"DROP TABLE IF EXISTS states_type",
		"DROP TABLE IF EXISTS tests_type",
		"DROP TABLE IF EXISTS oval_definitions",
		"DROP TABLE IF EXISTS other_name_element_type",
		"DROP TABLE IF EXISTS organization_type",
		"DROP TABLE IF EXISTS organisation_type_element_type",
		"DROP TABLE IF EXISTS organisation_name_element_type",
		"DROP TABLE IF EXISTS organisation_name_details_element_type",
		"DROP TABLE IF EXISTS \"organisation_known_as_element_type\"",
		"DROP TABLE IF EXISTS organisation_former_name_element_type",
		"DROP TABLE IF EXISTS objects_type",
		"DROP TABLE IF EXISTS object_ref_type",
		"DROP TABLE IF EXISTS object_ref_element_type",
		"DROP TABLE IF EXISTS object_ref",
		"DROP TABLE IF EXISTS object_component_type",
		"DROP TABLE IF EXISTS oasis_names_tc_ciq_x_person_name",
		"DROP TABLE IF EXISTS oasis_names_tc_ciq_x_organisation_name_details",
		"DROP TABLE IF EXISTS oasis_names_tc_ciq_x_name_details",
		"DROP TABLE IF EXISTS ns_09_xmldsig_signature_type",
		"DROP TABLE IF EXISTS ns_09_xmldsig_reference_type",
		"DROP TABLE IF EXISTS ns_09_xmldsig_object_type",
		"DROP TABLE IF EXISTS notice_type",
		"DROP TABLE IF EXISTS notes_element_type",
		"DROP TABLE IF EXISTS notes",
		"DROP TABLE IF EXISTS network_type",
		"DROP TABLE IF EXISTS network_name_element_type",
		"DROP TABLE IF EXISTS network_interface_type",
		"DROP TABLE IF EXISTS name_prefix_element_type",
		"DROP TABLE IF EXISTS name_line_type",
		"DROP TABLE IF EXISTS name_details_element_type",
		"DROP TABLE IF EXISTS motherboard_guid_element_type",
		"DROP TABLE IF EXISTS model_element_type",
		"DROP TABLE IF EXISTS model",
		"DROP TABLE IF EXISTS middle_name_element_type",
		"DROP TABLE IF EXISTS manifest_type",
		"DROP TABLE IF EXISTS mail_stop_number_element_type",
		"DROP TABLE IF EXISTS mail_stop_name_element_type",
		"DROP TABLE IF EXISTS mac_address_element_type",
		"DROP TABLE IF EXISTS logical_test_type",
		"DROP TABLE IF EXISTS locator_type",
		"DROP TABLE IF EXISTS locations_element_type",
		"DROP TABLE IF EXISTS locations",
		"DROP TABLE IF EXISTS location_region_element_type",
		"DROP TABLE IF EXISTS location_region",
		"DROP TABLE IF EXISTS location_point_element_type",
		"DROP TABLE IF EXISTS location_point",
		"DROP TABLE IF EXISTS locality_name_element_type",
		"DROP TABLE IF EXISTS locality_element_type",
		"DROP TABLE IF EXISTS locality",
		"DROP TABLE IF EXISTS locale_element_type",
		"DROP TABLE IF EXISTS local_variable_element_type",
		"DROP TABLE IF EXISTS local_variable",
		"DROP TABLE IF EXISTS literal_component_type",
		"DROP TABLE IF EXISTS list_type",
		"DROP TABLE IF EXISTS license_element_type",
		"DROP TABLE IF EXISTS last_name_element_type",
		"DROP TABLE IF EXISTS large_mail_user_type",
		"DROP TABLE IF EXISTS large_mail_user_name_element_type",
		"DROP TABLE IF EXISTS large_mail_user_identifier_element_type",
		"DROP TABLE IF EXISTS language_2_0_text_type",
		"DROP TABLE IF EXISTS \"known_as_element_type\"",
		"DROP TABLE IF EXISTS \"key_value_type\"",
		"DROP TABLE IF EXISTS \"key_line_code_element_type\"",
		"DROP TABLE IF EXISTS \"key_info_type\"",
		"DROP TABLE IF EXISTS joint_person_name_element_type",
		"DROP TABLE IF EXISTS joint_person_name",
		"DROP TABLE IF EXISTS ip_v6_element_type",
		"DROP TABLE IF EXISTS ip_v4_element_type",
		"DROP TABLE IF EXISTS ip_net_range_element_type",
		"DROP TABLE IF EXISTS ip_address_type",
		"DROP TABLE IF EXISTS instance_result_type",
		"DROP TABLE IF EXISTS instance_name_element_type",
		"DROP TABLE IF EXISTS installation_id_element_type",
		"DROP TABLE IF EXISTS idref_list_type",
		"DROP TABLE IF EXISTS identity_type",
		"DROP TABLE IF EXISTS ident_type",
		"DROP TABLE IF EXISTS html_text_type",
		"DROP TABLE IF EXISTS hostname_element_type",
		"DROP TABLE IF EXISTS host_element_type",
		"DROP TABLE IF EXISTS \"group_type\"",
		"DROP TABLE IF EXISTS \"glob_to_regex_function_type\"",
		"DROP TABLE IF EXISTS generation_identifier_element_type",
		"DROP TABLE IF EXISTS general_suffix_element_type",
		"DROP TABLE IF EXISTS function",
		"DROP TABLE IF EXISTS fqdn_element_type",
		"DROP TABLE IF EXISTS fqdn",
		"DROP TABLE IF EXISTS former_name_element_type",
		"DROP TABLE IF EXISTS fix_type",
		"DROP TABLE IF EXISTS instance_fix_type",
		"DROP TABLE IF EXISTS fix_text_type",
		"DROP TABLE IF EXISTS \"html_text_with_sub_type\"",
		"DROP TABLE IF EXISTS sub_type",
		"DROP TABLE IF EXISTS idref_type",
		"DROP TABLE IF EXISTS first_name_element_type",
		"DROP TABLE IF EXISTS firm_type",
		"DROP TABLE IF EXISTS firm_name_element_type",
		"DROP TABLE IF EXISTS filter_element_type",
		"DROP TABLE IF EXISTS filter",
		"DROP TABLE IF EXISTS fact_type",
		"DROP TABLE IF EXISTS fact_ref_type",
		"DROP TABLE IF EXISTS external_variable_element_type",
		"DROP TABLE IF EXISTS possible_restriction_type",
		"DROP TABLE IF EXISTS possible_value_type",
		"DROP TABLE IF EXISTS external_variable",
		"DROP TABLE IF EXISTS extended_infos_element_type",
		"DROP TABLE IF EXISTS extended_information_element_type",
		"DROP TABLE IF EXISTS extended_info_element_type",
		"DROP TABLE IF EXISTS extended",
		"DROP TABLE IF EXISTS \"escape_regex_function_type\"",
		"DROP TABLE IF EXISTS entity_state_version_type",
		"DROP TABLE IF EXISTS entity_state_string_type",
		"DROP TABLE IF EXISTS entity_state_record_type",
		"DROP TABLE IF EXISTS entity_state_int_type",
		"DROP TABLE IF EXISTS entity_state_i_p_address_type",
		"DROP TABLE IF EXISTS entity_state_i_p_address_string_type",
		"DROP TABLE IF EXISTS entity_state_i_o_s_version_type",
		"DROP TABLE IF EXISTS entity_state_float_type",
		"DROP TABLE IF EXISTS \"entity_state_file_set_revision_type\"",
		"DROP TABLE IF EXISTS entity_state_field_type",
		"DROP TABLE IF EXISTS entity_state_e_v_r_string_type",
		"DROP TABLE IF EXISTS entity_state_debian_e_v_r_string_type",
		"DROP TABLE IF EXISTS entity_state_bool_type",
		"DROP TABLE IF EXISTS entity_state_binary_type",
		"DROP TABLE IF EXISTS \"entity_state_any_simple_type\"",
		"DROP TABLE IF EXISTS entity_object_version_type",
		"DROP TABLE IF EXISTS entity_object_string_type",
		"DROP TABLE IF EXISTS entity_object_record_type",
		"DROP TABLE IF EXISTS entity_object_int_type",
		"DROP TABLE IF EXISTS entity_object_i_p_address_type",
		"DROP TABLE IF EXISTS entity_object_i_p_address_string_type",
		"DROP TABLE IF EXISTS entity_object_float_type",
		"DROP TABLE IF EXISTS entity_object_field_type",
		"DROP TABLE IF EXISTS entity_object_bool_type",
		"DROP TABLE IF EXISTS entity_object_binary_type",
		"DROP TABLE IF EXISTS \"entity_object_any_simple_type\"",
		"DROP TABLE IF EXISTS endorsement_line_code_element_type",
		"DROP TABLE IF EXISTS \"end_function_type\"",
		"DROP TABLE IF EXISTS email_address_element_type",
		"DROP TABLE IF EXISTS email_address",
		"DROP TABLE IF EXISTS element_map_type",
		"DROP TABLE IF EXISTS element_map_item_type",
		"DROP TABLE IF EXISTS document_root_element_type",
		"DROP TABLE IF EXISTS distinguished_name_element_type",
		"DROP TABLE IF EXISTS digest_method_type",
		"DROP TABLE IF EXISTS dictionary_2_0_text_type",
		"DROP TABLE IF EXISTS dictionary_2_0_notes_type",
		"DROP TABLE IF EXISTS dictionary_2_0_item_type",
		"DROP TABLE IF EXISTS \"references_type\"",
		"DROP TABLE IF EXISTS dictionary_2_0_generator_type",
		"DROP TABLE IF EXISTS schema_version_type",
		"DROP TABLE IF EXISTS \"dictionary_2_0_check_type\"",
		"DROP TABLE IF EXISTS deprecated_info_type",
		"DROP TABLE IF EXISTS dependent_thoroughfare_element_type",
		"DROP TABLE IF EXISTS thoroughfare_post_direction_type",
		"DROP TABLE IF EXISTS thoroughfare_trailing_type_type",
		"DROP TABLE IF EXISTS thoroughfare_leading_type_type",
		"DROP TABLE IF EXISTS thoroughfare_pre_direction_type",
		"DROP TABLE IF EXISTS dependent_locality_type",
		"DROP TABLE IF EXISTS dependent_locality_number_element_type",
		"DROP TABLE IF EXISTS dependent_locality_name_element_type",
		"DROP TABLE IF EXISTS dependency_name_element_type",
		"DROP TABLE IF EXISTS department_name_element_type",
		"DROP TABLE IF EXISTS department_element_type",
		"DROP TABLE IF EXISTS mail_stop_type",
		"DROP TABLE IF EXISTS department",
		"DROP TABLE IF EXISTS definitions_type",
		"DROP TABLE IF EXISTS definition_type",
		"DROP TABLE IF EXISTS dc_status_type",
		"DROP TABLE IF EXISTS database_type",
		"DROP TABLE IF EXISTS data_type",
		"DROP TABLE IF EXISTS \"d_s_a_key_value_type\"",
		"DROP TABLE IF EXISTS criteria_type",
		"DROP TABLE IF EXISTS extend_definition_type",
		"DROP TABLE IF EXISTS criterion_type",
		"DROP TABLE IF EXISTS cpe_element_type",
		"DROP TABLE IF EXISTS cpe",
		"DROP TABLE IF EXISTS country_name_element_type",
		"DROP TABLE IF EXISTS country_name_code_element_type",
		"DROP TABLE IF EXISTS country_name",
		"DROP TABLE IF EXISTS country_element_type",
		"DROP TABLE IF EXISTS count_function_type",
		"DROP TABLE IF EXISTS content_element_type1",
		"DROP TABLE IF EXISTS content_element_type",
		"DROP TABLE IF EXISTS constant_variable_element_type",
		"DROP TABLE IF EXISTS constant_variable",
		"DROP TABLE IF EXISTS variable_type",
		"DROP TABLE IF EXISTS connections_element_type",
		"DROP TABLE IF EXISTS concat_function_type",
		"DROP TABLE IF EXISTS computing_device_type",
		"DROP TABLE IF EXISTS complex_value_type",
		"DROP TABLE IF EXISTS \"complex_check_type\"",
		"DROP TABLE IF EXISTS circuit_type",
		"DROP TABLE IF EXISTS circuit_name_element_type",
		"DROP TABLE IF EXISTS cidr_element_type",
		"DROP TABLE IF EXISTS \"check_import_type\"",
		"DROP TABLE IF EXISTS \"check_export_type\"",
		"DROP TABLE IF EXISTS \"check_content_type\"",
		"DROP TABLE IF EXISTS \"check_content_ref_type\"",
		"DROP TABLE IF EXISTS canonicalization_method_type",
		"DROP TABLE IF EXISTS c_p_e2idref_type",
		"DROP TABLE IF EXISTS building_name_type",
		"DROP TABLE IF EXISTS birthdate_element_type",
		"DROP TABLE IF EXISTS benchmark_reference_type",
		"DROP TABLE IF EXISTS benchmark_element_type",
		"DROP TABLE IF EXISTS version_type",
		"DROP TABLE IF EXISTS benchmark",
		"DROP TABLE IF EXISTS begin_function_type",
		"DROP TABLE IF EXISTS barcode_element_type",
		"DROP TABLE IF EXISTS assets_element_type",
		"DROP TABLE IF EXISTS asset_reporting_form_asset_element_type",
		"DROP TABLE IF EXISTS asset_report_collection_element_type",
		"DROP TABLE IF EXISTS asset_report_collection",
		"DROP TABLE IF EXISTS asset_identification_type",
		"DROP TABLE IF EXISTS assets_type",
		"DROP TABLE IF EXISTS relationships_container_type",
		"DROP TABLE IF EXISTS asset_identification_asset_element_type",
		"DROP TABLE IF EXISTS arithmetic_function_type",
		"DROP TABLE IF EXISTS arc_type",
		"DROP TABLE IF EXISTS alias_element_type",
		"DROP TABLE IF EXISTS affected_type",
		"DROP TABLE IF EXISTS administrative_area_name_element_type",
		"DROP TABLE IF EXISTS administrative_area_element_type",
		"DROP TABLE IF EXISTS administrative_area",
		"DROP TABLE IF EXISTS addressee_indicator_element_type",
		"DROP TABLE IF EXISTS address_longitude_element_type",
		"DROP TABLE IF EXISTS address_longitude_direction_element_type",
		"DROP TABLE IF EXISTS address_lines_type",
		"DROP TABLE IF EXISTS address_line_element_type",
		"DROP TABLE IF EXISTS address_line",
		"DROP TABLE IF EXISTS address_latitude_element_type",
		"DROP TABLE IF EXISTS address_latitude_direction_element_type",
		"DROP TABLE IF EXISTS address_identifier_element_type",
		"DROP TABLE IF EXISTS address_element_type",
		"DROP TABLE IF EXISTS address_details",
	}

	for _, stmt := range dropStatements {
		if _, err := d.db.ExecContext(ctx, stmt); err != nil {
			return err
		}
	}
	return nil
}

type transaction struct {
	tx *sql.Tx
}

func (t *transaction) Commit() error {
	return t.tx.Commit()
}

func (t *transaction) Rollback() error {
	return t.tx.Rollback()
}

func (d *dal) AddressDetails() parent.AddressDetailsRepository {
	return &addressDetailsRepository{db: d.db}
}

type addressDetailsRepository struct {
	db *sql.DB
}

func (r *addressDetailsRepository) Create(ctx context.Context, entity *parent.AddressDetails) (int64, error) {
	query := "INSERT INTO address_details (address_type, current_status, valid_from_date, valid_to_date, usage, address_details_key, postal_service_elements, address, address_lines_id, country) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.AddressType,
		entity.CurrentStatus,
		entity.ValidFromDate,
		entity.ValidToDate,
		entity.Usage,
		entity.AddressDetailsKey,
		entity.PostalServiceElements,
		entity.Address,
		entity.AddressLinesID,
		entity.Country,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressDetailsRepository) CreateBatch(ctx context.Context, entities []*parent.AddressDetails) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_details (address_type, current_status, valid_from_date, valid_to_date, usage, address_details_key, postal_service_elements, address, address_lines_id, country) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.AddressType,
			entity.CurrentStatus,
			entity.ValidFromDate,
			entity.ValidToDate,
			entity.Usage,
			entity.AddressDetailsKey,
			entity.PostalServiceElements,
			entity.Address,
			entity.AddressLinesID,
			entity.Country,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressDetailsRepository) GetByID(ctx context.Context, id int64) (*parent.AddressDetails, error) {
	query := "SELECT id, address_type, current_status, valid_from_date, valid_to_date, usage, address_details_key, postal_service_elements, address, address_lines_id, country FROM address_details WHERE id = ?"

	entity := &parent.AddressDetails{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.AddressType,
		&entity.CurrentStatus,
		&entity.ValidFromDate,
		&entity.ValidToDate,
		&entity.Usage,
		&entity.AddressDetailsKey,
		&entity.PostalServiceElements,
		&entity.Address,
		&entity.AddressLinesID,
		&entity.Country,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressDetailsRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressDetails, error) {
	query := "SELECT id, address_type, current_status, valid_from_date, valid_to_date, usage, address_details_key, postal_service_elements, address, address_lines_id, country FROM address_details LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressDetails
	for rows.Next() {
		entity := &parent.AddressDetails{}
		err := rows.Scan(
			&entity.ID,
			&entity.AddressType,
			&entity.CurrentStatus,
			&entity.ValidFromDate,
			&entity.ValidToDate,
			&entity.Usage,
			&entity.AddressDetailsKey,
			&entity.PostalServiceElements,
			&entity.Address,
			&entity.AddressLinesID,
			&entity.Country,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressDetailsRepository) Update(ctx context.Context, entity *parent.AddressDetails) error {
	query := "UPDATE address_details SET address_type = ?, current_status = ?, valid_from_date = ?, valid_to_date = ?, usage = ?, address_details_key = ?, postal_service_elements = ?, address = ?, address_lines_id = ?, country = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.AddressType,
		entity.CurrentStatus,
		entity.ValidFromDate,
		entity.ValidToDate,
		entity.Usage,
		entity.AddressDetailsKey,
		entity.PostalServiceElements,
		entity.Address,
		entity.AddressLinesID,
		entity.Country,
		entity.ID,
	)
	return err
}

func (r *addressDetailsRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_details WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressDetailsRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_details WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressDetailsRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_details").Scan(&count)
	return count, err
}

func (d *dal) AddressElementType() parent.AddressElementTypeRepository {
	return &addressElementTypeRepository{db: d.db}
}

type addressElementTypeRepository struct {
	db *sql.DB
}

func (r *addressElementTypeRepository) Create(ctx context.Context, entity *parent.AddressElementType) (int64, error) {
	query := "INSERT INTO address_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddressElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddressElementType, error) {
	query := "SELECT id, type FROM address_element_type WHERE id = ?"

	entity := &parent.AddressElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressElementType, error) {
	query := "SELECT id, type FROM address_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressElementType
	for rows.Next() {
		entity := &parent.AddressElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressElementTypeRepository) Update(ctx context.Context, entity *parent.AddressElementType) error {
	query := "UPDATE address_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *addressElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_element_type").Scan(&count)
	return count, err
}

func (d *dal) AddressIdentifierElementType() parent.AddressIdentifierElementTypeRepository {
	return &addressIdentifierElementTypeRepository{db: d.db}
}

type addressIdentifierElementTypeRepository struct {
	db *sql.DB
}

func (r *addressIdentifierElementTypeRepository) Create(ctx context.Context, entity *parent.AddressIdentifierElementType) (int64, error) {
	query := "INSERT INTO address_identifier_element_type (identifier_type, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.IdentifierType,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressIdentifierElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddressIdentifierElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_identifier_element_type (identifier_type, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.IdentifierType,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressIdentifierElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddressIdentifierElementType, error) {
	query := "SELECT id, identifier_type, type FROM address_identifier_element_type WHERE id = ?"

	entity := &parent.AddressIdentifierElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.IdentifierType,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressIdentifierElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressIdentifierElementType, error) {
	query := "SELECT id, identifier_type, type FROM address_identifier_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressIdentifierElementType
	for rows.Next() {
		entity := &parent.AddressIdentifierElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.IdentifierType,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressIdentifierElementTypeRepository) Update(ctx context.Context, entity *parent.AddressIdentifierElementType) error {
	query := "UPDATE address_identifier_element_type SET identifier_type = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.IdentifierType,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *addressIdentifierElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_identifier_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressIdentifierElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_identifier_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressIdentifierElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_identifier_element_type").Scan(&count)
	return count, err
}

func (d *dal) AddressLatitudeDirectionElementType() parent.AddressLatitudeDirectionElementTypeRepository {
	return &addressLatitudeDirectionElementTypeRepository{db: d.db}
}

type addressLatitudeDirectionElementTypeRepository struct {
	db *sql.DB
}

func (r *addressLatitudeDirectionElementTypeRepository) Create(ctx context.Context, entity *parent.AddressLatitudeDirectionElementType) (int64, error) {
	query := "INSERT INTO address_latitude_direction_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressLatitudeDirectionElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddressLatitudeDirectionElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_latitude_direction_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressLatitudeDirectionElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddressLatitudeDirectionElementType, error) {
	query := "SELECT id, type FROM address_latitude_direction_element_type WHERE id = ?"

	entity := &parent.AddressLatitudeDirectionElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressLatitudeDirectionElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressLatitudeDirectionElementType, error) {
	query := "SELECT id, type FROM address_latitude_direction_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressLatitudeDirectionElementType
	for rows.Next() {
		entity := &parent.AddressLatitudeDirectionElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressLatitudeDirectionElementTypeRepository) Update(ctx context.Context, entity *parent.AddressLatitudeDirectionElementType) error {
	query := "UPDATE address_latitude_direction_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *addressLatitudeDirectionElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_latitude_direction_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressLatitudeDirectionElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_latitude_direction_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressLatitudeDirectionElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_latitude_direction_element_type").Scan(&count)
	return count, err
}

func (d *dal) AddressLatitudeElementType() parent.AddressLatitudeElementTypeRepository {
	return &addressLatitudeElementTypeRepository{db: d.db}
}

type addressLatitudeElementTypeRepository struct {
	db *sql.DB
}

func (r *addressLatitudeElementTypeRepository) Create(ctx context.Context, entity *parent.AddressLatitudeElementType) (int64, error) {
	query := "INSERT INTO address_latitude_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressLatitudeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddressLatitudeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_latitude_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressLatitudeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddressLatitudeElementType, error) {
	query := "SELECT id, type FROM address_latitude_element_type WHERE id = ?"

	entity := &parent.AddressLatitudeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressLatitudeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressLatitudeElementType, error) {
	query := "SELECT id, type FROM address_latitude_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressLatitudeElementType
	for rows.Next() {
		entity := &parent.AddressLatitudeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressLatitudeElementTypeRepository) Update(ctx context.Context, entity *parent.AddressLatitudeElementType) error {
	query := "UPDATE address_latitude_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *addressLatitudeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_latitude_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressLatitudeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_latitude_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressLatitudeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_latitude_element_type").Scan(&count)
	return count, err
}

func (d *dal) AddressLine() parent.AddressLineRepository {
	return &addressLineRepository{db: d.db}
}

type addressLineRepository struct {
	db *sql.DB
}

func (r *addressLineRepository) Create(ctx context.Context, entity *parent.AddressLine) (int64, error) {
	query := "INSERT INTO address_line (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressLineRepository) CreateBatch(ctx context.Context, entities []*parent.AddressLine) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_line (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressLineRepository) GetByID(ctx context.Context, id int64) (*parent.AddressLine, error) {
	query := "SELECT id, type FROM address_line WHERE id = ?"

	entity := &parent.AddressLine{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressLineRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressLine, error) {
	query := "SELECT id, type FROM address_line LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressLine
	for rows.Next() {
		entity := &parent.AddressLine{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressLineRepository) Update(ctx context.Context, entity *parent.AddressLine) error {
	query := "UPDATE address_line SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *addressLineRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_line WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressLineRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_line WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressLineRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_line").Scan(&count)
	return count, err
}

func (d *dal) AddressLineElementType() parent.AddressLineElementTypeRepository {
	return &addressLineElementTypeRepository{db: d.db}
}

type addressLineElementTypeRepository struct {
	db *sql.DB
}

func (r *addressLineElementTypeRepository) Create(ctx context.Context, entity *parent.AddressLineElementType) (int64, error) {
	query := "INSERT INTO address_line_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressLineElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddressLineElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_line_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressLineElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddressLineElementType, error) {
	query := "SELECT id, type FROM address_line_element_type WHERE id = ?"

	entity := &parent.AddressLineElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressLineElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressLineElementType, error) {
	query := "SELECT id, type FROM address_line_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressLineElementType
	for rows.Next() {
		entity := &parent.AddressLineElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressLineElementTypeRepository) Update(ctx context.Context, entity *parent.AddressLineElementType) error {
	query := "UPDATE address_line_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *addressLineElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_line_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressLineElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_line_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressLineElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_line_element_type").Scan(&count)
	return count, err
}

func (d *dal) AddressLinesType() parent.AddressLinesTypeRepository {
	return &addressLinesTypeRepository{db: d.db}
}

type addressLinesTypeRepository struct {
	db *sql.DB
}

func (r *addressLinesTypeRepository) Create(ctx context.Context, entity *parent.AddressLinesType) (int64, error) {
	query := "INSERT INTO address_lines_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressLinesTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddressLinesType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_lines_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressLinesTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddressLinesType, error) {
	query := "SELECT id FROM address_lines_type WHERE id = ?"

	entity := &parent.AddressLinesType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressLinesTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressLinesType, error) {
	query := "SELECT id FROM address_lines_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressLinesType
	for rows.Next() {
		entity := &parent.AddressLinesType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressLinesTypeRepository) Update(ctx context.Context, entity *parent.AddressLinesType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *addressLinesTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_lines_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressLinesTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_lines_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressLinesTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_lines_type").Scan(&count)
	return count, err
}

func (d *dal) AddressLongitudeDirectionElementType() parent.AddressLongitudeDirectionElementTypeRepository {
	return &addressLongitudeDirectionElementTypeRepository{db: d.db}
}

type addressLongitudeDirectionElementTypeRepository struct {
	db *sql.DB
}

func (r *addressLongitudeDirectionElementTypeRepository) Create(ctx context.Context, entity *parent.AddressLongitudeDirectionElementType) (int64, error) {
	query := "INSERT INTO address_longitude_direction_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressLongitudeDirectionElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddressLongitudeDirectionElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_longitude_direction_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressLongitudeDirectionElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddressLongitudeDirectionElementType, error) {
	query := "SELECT id, type FROM address_longitude_direction_element_type WHERE id = ?"

	entity := &parent.AddressLongitudeDirectionElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressLongitudeDirectionElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressLongitudeDirectionElementType, error) {
	query := "SELECT id, type FROM address_longitude_direction_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressLongitudeDirectionElementType
	for rows.Next() {
		entity := &parent.AddressLongitudeDirectionElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressLongitudeDirectionElementTypeRepository) Update(ctx context.Context, entity *parent.AddressLongitudeDirectionElementType) error {
	query := "UPDATE address_longitude_direction_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *addressLongitudeDirectionElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_longitude_direction_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressLongitudeDirectionElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_longitude_direction_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressLongitudeDirectionElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_longitude_direction_element_type").Scan(&count)
	return count, err
}

func (d *dal) AddressLongitudeElementType() parent.AddressLongitudeElementTypeRepository {
	return &addressLongitudeElementTypeRepository{db: d.db}
}

type addressLongitudeElementTypeRepository struct {
	db *sql.DB
}

func (r *addressLongitudeElementTypeRepository) Create(ctx context.Context, entity *parent.AddressLongitudeElementType) (int64, error) {
	query := "INSERT INTO address_longitude_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addressLongitudeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddressLongitudeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO address_longitude_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addressLongitudeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddressLongitudeElementType, error) {
	query := "SELECT id, type FROM address_longitude_element_type WHERE id = ?"

	entity := &parent.AddressLongitudeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addressLongitudeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddressLongitudeElementType, error) {
	query := "SELECT id, type FROM address_longitude_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddressLongitudeElementType
	for rows.Next() {
		entity := &parent.AddressLongitudeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addressLongitudeElementTypeRepository) Update(ctx context.Context, entity *parent.AddressLongitudeElementType) error {
	query := "UPDATE address_longitude_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *addressLongitudeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM address_longitude_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addressLongitudeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM address_longitude_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addressLongitudeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM address_longitude_element_type").Scan(&count)
	return count, err
}

func (d *dal) AddresseeIndicatorElementType() parent.AddresseeIndicatorElementTypeRepository {
	return &addresseeIndicatorElementTypeRepository{db: d.db}
}

type addresseeIndicatorElementTypeRepository struct {
	db *sql.DB
}

func (r *addresseeIndicatorElementTypeRepository) Create(ctx context.Context, entity *parent.AddresseeIndicatorElementType) (int64, error) {
	query := "INSERT INTO addressee_indicator_element_type (code) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *addresseeIndicatorElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AddresseeIndicatorElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO addressee_indicator_element_type (code) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *addresseeIndicatorElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AddresseeIndicatorElementType, error) {
	query := "SELECT id, code FROM addressee_indicator_element_type WHERE id = ?"

	entity := &parent.AddresseeIndicatorElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *addresseeIndicatorElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AddresseeIndicatorElementType, error) {
	query := "SELECT id, code FROM addressee_indicator_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AddresseeIndicatorElementType
	for rows.Next() {
		entity := &parent.AddresseeIndicatorElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *addresseeIndicatorElementTypeRepository) Update(ctx context.Context, entity *parent.AddresseeIndicatorElementType) error {
	query := "UPDATE addressee_indicator_element_type SET code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *addresseeIndicatorElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM addressee_indicator_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *addresseeIndicatorElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM addressee_indicator_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *addresseeIndicatorElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM addressee_indicator_element_type").Scan(&count)
	return count, err
}

func (d *dal) AdministrativeArea() parent.AdministrativeAreaRepository {
	return &administrativeAreaRepository{db: d.db}
}

type administrativeAreaRepository struct {
	db *sql.DB
}

func (r *administrativeAreaRepository) Create(ctx context.Context, entity *parent.AdministrativeArea) (int64, error) {
	query := "INSERT INTO administrative_area (type, usage_type, indicator, administrative_area_name, sub_administrative_area) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.AdministrativeAreaName,
		entity.SubAdministrativeArea,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *administrativeAreaRepository) CreateBatch(ctx context.Context, entities []*parent.AdministrativeArea) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO administrative_area (type, usage_type, indicator, administrative_area_name, sub_administrative_area) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.UsageType,
			entity.Indicator,
			entity.AdministrativeAreaName,
			entity.SubAdministrativeArea,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *administrativeAreaRepository) GetByID(ctx context.Context, id int64) (*parent.AdministrativeArea, error) {
	query := "SELECT id, type, usage_type, indicator, administrative_area_name, sub_administrative_area FROM administrative_area WHERE id = ?"

	entity := &parent.AdministrativeArea{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.UsageType,
		&entity.Indicator,
		&entity.AdministrativeAreaName,
		&entity.SubAdministrativeArea,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *administrativeAreaRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AdministrativeArea, error) {
	query := "SELECT id, type, usage_type, indicator, administrative_area_name, sub_administrative_area FROM administrative_area LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AdministrativeArea
	for rows.Next() {
		entity := &parent.AdministrativeArea{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.UsageType,
			&entity.Indicator,
			&entity.AdministrativeAreaName,
			&entity.SubAdministrativeArea,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *administrativeAreaRepository) Update(ctx context.Context, entity *parent.AdministrativeArea) error {
	query := "UPDATE administrative_area SET type = ?, usage_type = ?, indicator = ?, administrative_area_name = ?, sub_administrative_area = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.AdministrativeAreaName,
		entity.SubAdministrativeArea,
		entity.ID,
	)
	return err
}

func (r *administrativeAreaRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM administrative_area WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *administrativeAreaRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM administrative_area WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *administrativeAreaRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM administrative_area").Scan(&count)
	return count, err
}

func (d *dal) AdministrativeAreaElementType() parent.AdministrativeAreaElementTypeRepository {
	return &administrativeAreaElementTypeRepository{db: d.db}
}

type administrativeAreaElementTypeRepository struct {
	db *sql.DB
}

func (r *administrativeAreaElementTypeRepository) Create(ctx context.Context, entity *parent.AdministrativeAreaElementType) (int64, error) {
	query := "INSERT INTO administrative_area_element_type (type, usage_type, indicator, administrative_area_name, sub_administrative_area) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.AdministrativeAreaName,
		entity.SubAdministrativeArea,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *administrativeAreaElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AdministrativeAreaElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO administrative_area_element_type (type, usage_type, indicator, administrative_area_name, sub_administrative_area) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.UsageType,
			entity.Indicator,
			entity.AdministrativeAreaName,
			entity.SubAdministrativeArea,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *administrativeAreaElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AdministrativeAreaElementType, error) {
	query := "SELECT id, type, usage_type, indicator, administrative_area_name, sub_administrative_area FROM administrative_area_element_type WHERE id = ?"

	entity := &parent.AdministrativeAreaElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.UsageType,
		&entity.Indicator,
		&entity.AdministrativeAreaName,
		&entity.SubAdministrativeArea,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *administrativeAreaElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AdministrativeAreaElementType, error) {
	query := "SELECT id, type, usage_type, indicator, administrative_area_name, sub_administrative_area FROM administrative_area_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AdministrativeAreaElementType
	for rows.Next() {
		entity := &parent.AdministrativeAreaElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.UsageType,
			&entity.Indicator,
			&entity.AdministrativeAreaName,
			&entity.SubAdministrativeArea,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *administrativeAreaElementTypeRepository) Update(ctx context.Context, entity *parent.AdministrativeAreaElementType) error {
	query := "UPDATE administrative_area_element_type SET type = ?, usage_type = ?, indicator = ?, administrative_area_name = ?, sub_administrative_area = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.AdministrativeAreaName,
		entity.SubAdministrativeArea,
		entity.ID,
	)
	return err
}

func (r *administrativeAreaElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM administrative_area_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *administrativeAreaElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM administrative_area_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *administrativeAreaElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM administrative_area_element_type").Scan(&count)
	return count, err
}

func (d *dal) AdministrativeAreaNameElementType() parent.AdministrativeAreaNameElementTypeRepository {
	return &administrativeAreaNameElementTypeRepository{db: d.db}
}

type administrativeAreaNameElementTypeRepository struct {
	db *sql.DB
}

func (r *administrativeAreaNameElementTypeRepository) Create(ctx context.Context, entity *parent.AdministrativeAreaNameElementType) (int64, error) {
	query := "INSERT INTO administrative_area_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *administrativeAreaNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AdministrativeAreaNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO administrative_area_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *administrativeAreaNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AdministrativeAreaNameElementType, error) {
	query := "SELECT id, type FROM administrative_area_name_element_type WHERE id = ?"

	entity := &parent.AdministrativeAreaNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *administrativeAreaNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AdministrativeAreaNameElementType, error) {
	query := "SELECT id, type FROM administrative_area_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AdministrativeAreaNameElementType
	for rows.Next() {
		entity := &parent.AdministrativeAreaNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *administrativeAreaNameElementTypeRepository) Update(ctx context.Context, entity *parent.AdministrativeAreaNameElementType) error {
	query := "UPDATE administrative_area_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *administrativeAreaNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM administrative_area_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *administrativeAreaNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM administrative_area_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *administrativeAreaNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM administrative_area_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) AffectedType() parent.AffectedTypeRepository {
	return &affectedTypeRepository{db: d.db}
}

type affectedTypeRepository struct {
	db *sql.DB
}

func (r *affectedTypeRepository) Create(ctx context.Context, entity *parent.AffectedType) (int64, error) {
	query := "INSERT INTO affected_type (family, platform, product) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Family,
		entity.Platform,
		entity.Product,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *affectedTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AffectedType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO affected_type (family, platform, product) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Family,
			entity.Platform,
			entity.Product,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *affectedTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AffectedType, error) {
	query := "SELECT id, family, platform, product FROM affected_type WHERE id = ?"

	entity := &parent.AffectedType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Family,
		&entity.Platform,
		&entity.Product,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *affectedTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AffectedType, error) {
	query := "SELECT id, family, platform, product FROM affected_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AffectedType
	for rows.Next() {
		entity := &parent.AffectedType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Family,
			&entity.Platform,
			&entity.Product,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *affectedTypeRepository) Update(ctx context.Context, entity *parent.AffectedType) error {
	query := "UPDATE affected_type SET family = ?, platform = ?, product = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Family,
		entity.Platform,
		entity.Product,
		entity.ID,
	)
	return err
}

func (r *affectedTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM affected_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *affectedTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM affected_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *affectedTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM affected_type").Scan(&count)
	return count, err
}

func (d *dal) AliasElementType() parent.AliasElementTypeRepository {
	return &aliasElementTypeRepository{db: d.db}
}

type aliasElementTypeRepository struct {
	db *sql.DB
}

func (r *aliasElementTypeRepository) Create(ctx context.Context, entity *parent.AliasElementType) (int64, error) {
	query := "INSERT INTO alias_element_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *aliasElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AliasElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO alias_element_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *aliasElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AliasElementType, error) {
	query := "SELECT id, type, name_type, code FROM alias_element_type WHERE id = ?"

	entity := &parent.AliasElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *aliasElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AliasElementType, error) {
	query := "SELECT id, type, name_type, code FROM alias_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AliasElementType
	for rows.Next() {
		entity := &parent.AliasElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *aliasElementTypeRepository) Update(ctx context.Context, entity *parent.AliasElementType) error {
	query := "UPDATE alias_element_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *aliasElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM alias_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *aliasElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM alias_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *aliasElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM alias_element_type").Scan(&count)
	return count, err
}

func (d *dal) ArcType() parent.ArcTypeRepository {
	return &arcTypeRepository{db: d.db}
}

type arcTypeRepository struct {
	db *sql.DB
}

func (r *arcTypeRepository) Create(ctx context.Context, entity *parent.ArcType) (int64, error) {
	query := "INSERT INTO arc_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *arcTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ArcType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO arc_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *arcTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ArcType, error) {
	query := "SELECT id FROM arc_type WHERE id = ?"

	entity := &parent.ArcType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *arcTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ArcType, error) {
	query := "SELECT id FROM arc_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ArcType
	for rows.Next() {
		entity := &parent.ArcType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *arcTypeRepository) Update(ctx context.Context, entity *parent.ArcType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *arcTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM arc_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *arcTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM arc_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *arcTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM arc_type").Scan(&count)
	return count, err
}

func (d *dal) ArithmeticFunctionType() parent.ArithmeticFunctionTypeRepository {
	return &arithmeticFunctionTypeRepository{db: d.db}
}

type arithmeticFunctionTypeRepository struct {
	db *sql.DB
}

func (r *arithmeticFunctionTypeRepository) Create(ctx context.Context, entity *parent.ArithmeticFunctionType) (int64, error) {
	query := "INSERT INTO arithmetic_function_type (arithmetic_operation) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Arithmetic_operation,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *arithmeticFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ArithmeticFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO arithmetic_function_type (arithmetic_operation) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Arithmetic_operation,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *arithmeticFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ArithmeticFunctionType, error) {
	query := "SELECT id, arithmetic_operation FROM arithmetic_function_type WHERE id = ?"

	entity := &parent.ArithmeticFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Arithmetic_operation,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *arithmeticFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ArithmeticFunctionType, error) {
	query := "SELECT id, arithmetic_operation FROM arithmetic_function_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ArithmeticFunctionType
	for rows.Next() {
		entity := &parent.ArithmeticFunctionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Arithmetic_operation,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *arithmeticFunctionTypeRepository) Update(ctx context.Context, entity *parent.ArithmeticFunctionType) error {
	query := "UPDATE arithmetic_function_type SET arithmetic_operation = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Arithmetic_operation,
		entity.ID,
	)
	return err
}

func (r *arithmeticFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM arithmetic_function_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *arithmeticFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM arithmetic_function_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *arithmeticFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM arithmetic_function_type").Scan(&count)
	return count, err
}

func (d *dal) AssetIdentificationAssetElementType() parent.AssetIdentificationAssetElementTypeRepository {
	return &assetIdentificationAssetElementTypeRepository{db: d.db}
}

type assetIdentificationAssetElementTypeRepository struct {
	db *sql.DB
}

func (r *assetIdentificationAssetElementTypeRepository) Create(ctx context.Context, entity *parent.AssetIdentificationAssetElementType) (int64, error) {
	query := "INSERT INTO asset_identification_asset_element_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *assetIdentificationAssetElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AssetIdentificationAssetElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO asset_identification_asset_element_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *assetIdentificationAssetElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AssetIdentificationAssetElementType, error) {
	query := "SELECT id, xsd_id FROM asset_identification_asset_element_type WHERE id = ?"

	entity := &parent.AssetIdentificationAssetElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *assetIdentificationAssetElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AssetIdentificationAssetElementType, error) {
	query := "SELECT id, xsd_id FROM asset_identification_asset_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetIdentificationAssetElementType
	for rows.Next() {
		entity := &parent.AssetIdentificationAssetElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *assetIdentificationAssetElementTypeRepository) Update(ctx context.Context, entity *parent.AssetIdentificationAssetElementType) error {
	query := "UPDATE asset_identification_asset_element_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *assetIdentificationAssetElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM asset_identification_asset_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *assetIdentificationAssetElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM asset_identification_asset_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *assetIdentificationAssetElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM asset_identification_asset_element_type").Scan(&count)
	return count, err
}

func (d *dal) AssetIdentificationType() parent.AssetIdentificationTypeRepository {
	return &assetIdentificationTypeRepository{db: d.db}
}

type assetIdentificationTypeRepository struct {
	db *sql.DB
}

func (r *assetIdentificationTypeRepository) Create(ctx context.Context, entity *parent.AssetIdentificationType) (int64, error) {
	query := "INSERT INTO asset_identification_type (asset_ref, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.AssetRef,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *assetIdentificationTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AssetIdentificationType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO asset_identification_type (asset_ref, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.AssetRef,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *assetIdentificationTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AssetIdentificationType, error) {
	query := "SELECT id, asset_ref, parent_id FROM asset_identification_type WHERE id = ?"

	entity := &parent.AssetIdentificationType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.AssetRef,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *assetIdentificationTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AssetIdentificationType, error) {
	query := "SELECT id, asset_ref, parent_id FROM asset_identification_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetIdentificationType
	for rows.Next() {
		entity := &parent.AssetIdentificationType{}
		err := rows.Scan(
			&entity.ID,
			&entity.AssetRef,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *assetIdentificationTypeRepository) Update(ctx context.Context, entity *parent.AssetIdentificationType) error {
	query := "UPDATE asset_identification_type SET asset_ref = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.AssetRef,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *assetIdentificationTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM asset_identification_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *assetIdentificationTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM asset_identification_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *assetIdentificationTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM asset_identification_type").Scan(&count)
	return count, err
}

func (r *assetIdentificationTypeRepository) GetByAssetsType(ctx context.Context, assets_typeID int64) ([]*parent.AssetIdentificationType, error) {
	query := "SELECT id, asset_ref, parent_id FROM asset_identification_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, assets_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetIdentificationType
	for rows.Next() {
		entity := &parent.AssetIdentificationType{}
		err := rows.Scan(
			&entity.ID,
			&entity.AssetRef,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) AssetReportCollection() parent.AssetReportCollectionRepository {
	return &assetReportCollectionRepository{db: d.db}
}

type assetReportCollectionRepository struct {
	db *sql.DB
}

func (r *assetReportCollectionRepository) Create(ctx context.Context, entity *parent.AssetReportCollection) (int64, error) {
	query := "INSERT INTO asset_report_collection (xsd_id, report_requests, assets, reports, extended_infos, parent_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ReportRequests,
		entity.Assets,
		entity.Reports,
		entity.ExtendedInfos,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *assetReportCollectionRepository) CreateBatch(ctx context.Context, entities []*parent.AssetReportCollection) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO asset_report_collection (xsd_id, report_requests, assets, reports, extended_infos, parent_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.ReportRequests,
			entity.Assets,
			entity.Reports,
			entity.ExtendedInfos,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *assetReportCollectionRepository) GetByID(ctx context.Context, id int64) (*parent.AssetReportCollection, error) {
	query := "SELECT id, xsd_id, report_requests, assets, reports, extended_infos, parent_id FROM asset_report_collection WHERE id = ?"

	entity := &parent.AssetReportCollection{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.ReportRequests,
		&entity.Assets,
		&entity.Reports,
		&entity.ExtendedInfos,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *assetReportCollectionRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AssetReportCollection, error) {
	query := "SELECT id, xsd_id, report_requests, assets, reports, extended_infos, parent_id FROM asset_report_collection LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetReportCollection
	for rows.Next() {
		entity := &parent.AssetReportCollection{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.ReportRequests,
			&entity.Assets,
			&entity.Reports,
			&entity.ExtendedInfos,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *assetReportCollectionRepository) Update(ctx context.Context, entity *parent.AssetReportCollection) error {
	query := "UPDATE asset_report_collection SET xsd_id = ?, report_requests = ?, assets = ?, reports = ?, extended_infos = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ReportRequests,
		entity.Assets,
		entity.Reports,
		entity.ExtendedInfos,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *assetReportCollectionRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM asset_report_collection WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *assetReportCollectionRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM asset_report_collection WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *assetReportCollectionRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM asset_report_collection").Scan(&count)
	return count, err
}

func (r *assetReportCollectionRepository) GetByRelationshipsContainerType(ctx context.Context, relationships_container_typeID int64) ([]*parent.AssetReportCollection, error) {
	query := "SELECT id, xsd_id, report_requests, assets, reports, extended_infos, parent_id FROM asset_report_collection WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, relationships_container_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetReportCollection
	for rows.Next() {
		entity := &parent.AssetReportCollection{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.ReportRequests,
			&entity.Assets,
			&entity.Reports,
			&entity.ExtendedInfos,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) AssetReportCollectionElementType() parent.AssetReportCollectionElementTypeRepository {
	return &assetReportCollectionElementTypeRepository{db: d.db}
}

type assetReportCollectionElementTypeRepository struct {
	db *sql.DB
}

func (r *assetReportCollectionElementTypeRepository) Create(ctx context.Context, entity *parent.AssetReportCollectionElementType) (int64, error) {
	query := "INSERT INTO asset_report_collection_element_type (xsd_id, report_requests, assets, reports, extended_infos, parent_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ReportRequests,
		entity.Assets,
		entity.Reports,
		entity.ExtendedInfos,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *assetReportCollectionElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AssetReportCollectionElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO asset_report_collection_element_type (xsd_id, report_requests, assets, reports, extended_infos, parent_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.ReportRequests,
			entity.Assets,
			entity.Reports,
			entity.ExtendedInfos,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *assetReportCollectionElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AssetReportCollectionElementType, error) {
	query := "SELECT id, xsd_id, report_requests, assets, reports, extended_infos, parent_id FROM asset_report_collection_element_type WHERE id = ?"

	entity := &parent.AssetReportCollectionElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.ReportRequests,
		&entity.Assets,
		&entity.Reports,
		&entity.ExtendedInfos,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *assetReportCollectionElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AssetReportCollectionElementType, error) {
	query := "SELECT id, xsd_id, report_requests, assets, reports, extended_infos, parent_id FROM asset_report_collection_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetReportCollectionElementType
	for rows.Next() {
		entity := &parent.AssetReportCollectionElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.ReportRequests,
			&entity.Assets,
			&entity.Reports,
			&entity.ExtendedInfos,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *assetReportCollectionElementTypeRepository) Update(ctx context.Context, entity *parent.AssetReportCollectionElementType) error {
	query := "UPDATE asset_report_collection_element_type SET xsd_id = ?, report_requests = ?, assets = ?, reports = ?, extended_infos = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ReportRequests,
		entity.Assets,
		entity.Reports,
		entity.ExtendedInfos,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *assetReportCollectionElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM asset_report_collection_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *assetReportCollectionElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM asset_report_collection_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *assetReportCollectionElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM asset_report_collection_element_type").Scan(&count)
	return count, err
}

func (r *assetReportCollectionElementTypeRepository) GetByRelationshipsContainerType(ctx context.Context, relationships_container_typeID int64) ([]*parent.AssetReportCollectionElementType, error) {
	query := "SELECT id, xsd_id, report_requests, assets, reports, extended_infos, parent_id FROM asset_report_collection_element_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, relationships_container_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetReportCollectionElementType
	for rows.Next() {
		entity := &parent.AssetReportCollectionElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.ReportRequests,
			&entity.Assets,
			&entity.Reports,
			&entity.ExtendedInfos,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) AssetReportingFormAssetElementType() parent.AssetReportingFormAssetElementTypeRepository {
	return &assetReportingFormAssetElementTypeRepository{db: d.db}
}

type assetReportingFormAssetElementTypeRepository struct {
	db *sql.DB
}

func (r *assetReportingFormAssetElementTypeRepository) Create(ctx context.Context, entity *parent.AssetReportingFormAssetElementType) (int64, error) {
	query := "INSERT INTO asset_reporting_form_asset_element_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *assetReportingFormAssetElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AssetReportingFormAssetElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO asset_reporting_form_asset_element_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *assetReportingFormAssetElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AssetReportingFormAssetElementType, error) {
	query := "SELECT id, xsd_id FROM asset_reporting_form_asset_element_type WHERE id = ?"

	entity := &parent.AssetReportingFormAssetElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *assetReportingFormAssetElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AssetReportingFormAssetElementType, error) {
	query := "SELECT id, xsd_id FROM asset_reporting_form_asset_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetReportingFormAssetElementType
	for rows.Next() {
		entity := &parent.AssetReportingFormAssetElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *assetReportingFormAssetElementTypeRepository) Update(ctx context.Context, entity *parent.AssetReportingFormAssetElementType) error {
	query := "UPDATE asset_reporting_form_asset_element_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *assetReportingFormAssetElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM asset_reporting_form_asset_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *assetReportingFormAssetElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM asset_reporting_form_asset_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *assetReportingFormAssetElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM asset_reporting_form_asset_element_type").Scan(&count)
	return count, err
}

func (d *dal) AssetsElementType() parent.AssetsElementTypeRepository {
	return &assetsElementTypeRepository{db: d.db}
}

type assetsElementTypeRepository struct {
	db *sql.DB
}

func (r *assetsElementTypeRepository) Create(ctx context.Context, entity *parent.AssetsElementType) (int64, error) {
	query := "INSERT INTO assets_element_type (asset) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Asset,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *assetsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AssetsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO assets_element_type (asset) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Asset,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *assetsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AssetsElementType, error) {
	query := "SELECT id, asset FROM assets_element_type WHERE id = ?"

	entity := &parent.AssetsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Asset,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *assetsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AssetsElementType, error) {
	query := "SELECT id, asset FROM assets_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetsElementType
	for rows.Next() {
		entity := &parent.AssetsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Asset,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *assetsElementTypeRepository) Update(ctx context.Context, entity *parent.AssetsElementType) error {
	query := "UPDATE assets_element_type SET asset = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Asset,
		entity.ID,
	)
	return err
}

func (r *assetsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM assets_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *assetsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM assets_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *assetsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM assets_element_type").Scan(&count)
	return count, err
}

func (d *dal) AssetsType() parent.AssetsTypeRepository {
	return &assetsTypeRepository{db: d.db}
}

type assetsTypeRepository struct {
	db *sql.DB
}

func (r *assetsTypeRepository) Create(ctx context.Context, entity *parent.AssetsType) (int64, error) {
	query := "INSERT INTO assets_type (asset, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Asset,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *assetsTypeRepository) CreateBatch(ctx context.Context, entities []*parent.AssetsType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO assets_type (asset, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Asset,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *assetsTypeRepository) GetByID(ctx context.Context, id int64) (*parent.AssetsType, error) {
	query := "SELECT id, asset, parent_id FROM assets_type WHERE id = ?"

	entity := &parent.AssetsType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Asset,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *assetsTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.AssetsType, error) {
	query := "SELECT id, asset, parent_id FROM assets_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetsType
	for rows.Next() {
		entity := &parent.AssetsType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Asset,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *assetsTypeRepository) Update(ctx context.Context, entity *parent.AssetsType) error {
	query := "UPDATE assets_type SET asset = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Asset,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *assetsTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM assets_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *assetsTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM assets_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *assetsTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM assets_type").Scan(&count)
	return count, err
}

func (r *assetsTypeRepository) GetByRelationshipsContainerType(ctx context.Context, relationships_container_typeID int64) ([]*parent.AssetsType, error) {
	query := "SELECT id, asset, parent_id FROM assets_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, relationships_container_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.AssetsType
	for rows.Next() {
		entity := &parent.AssetsType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Asset,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) BarcodeElementType() parent.BarcodeElementTypeRepository {
	return &barcodeElementTypeRepository{db: d.db}
}

type barcodeElementTypeRepository struct {
	db *sql.DB
}

func (r *barcodeElementTypeRepository) Create(ctx context.Context, entity *parent.BarcodeElementType) (int64, error) {
	query := "INSERT INTO barcode_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *barcodeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.BarcodeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO barcode_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *barcodeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.BarcodeElementType, error) {
	query := "SELECT id, type FROM barcode_element_type WHERE id = ?"

	entity := &parent.BarcodeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *barcodeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.BarcodeElementType, error) {
	query := "SELECT id, type FROM barcode_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.BarcodeElementType
	for rows.Next() {
		entity := &parent.BarcodeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *barcodeElementTypeRepository) Update(ctx context.Context, entity *parent.BarcodeElementType) error {
	query := "UPDATE barcode_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *barcodeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM barcode_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *barcodeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM barcode_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *barcodeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM barcode_element_type").Scan(&count)
	return count, err
}

func (d *dal) BeginFunctionType() parent.BeginFunctionTypeRepository {
	return &beginFunctionTypeRepository{db: d.db}
}

type beginFunctionTypeRepository struct {
	db *sql.DB
}

func (r *beginFunctionTypeRepository) Create(ctx context.Context, entity *parent.BeginFunctionType) (int64, error) {
	query := "INSERT INTO begin_function_type (character) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Character,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *beginFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.BeginFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO begin_function_type (character) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Character,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *beginFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.BeginFunctionType, error) {
	query := "SELECT id, character FROM begin_function_type WHERE id = ?"

	entity := &parent.BeginFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Character,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *beginFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.BeginFunctionType, error) {
	query := "SELECT id, character FROM begin_function_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.BeginFunctionType
	for rows.Next() {
		entity := &parent.BeginFunctionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Character,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *beginFunctionTypeRepository) Update(ctx context.Context, entity *parent.BeginFunctionType) error {
	query := "UPDATE begin_function_type SET character = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Character,
		entity.ID,
	)
	return err
}

func (r *beginFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM begin_function_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *beginFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM begin_function_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *beginFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM begin_function_type").Scan(&count)
	return count, err
}

func (d *dal) Benchmark() parent.BenchmarkRepository {
	return &benchmarkRepository{db: d.db}
}

type benchmarkRepository struct {
	db *sql.DB
}

func (r *benchmarkRepository) Create(ctx context.Context, entity *parent.Benchmark) (int64, error) {
	query := "INSERT INTO benchmark (xsd_id, resolved, style, style_href, version_id, signature_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Resolved,
		entity.Style,
		entity.StyleHref,
		entity.VersionID,
		entity.SignatureID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *benchmarkRepository) CreateBatch(ctx context.Context, entities []*parent.Benchmark) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO benchmark (xsd_id, resolved, style, style_href, version_id, signature_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Resolved,
			entity.Style,
			entity.StyleHref,
			entity.VersionID,
			entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *benchmarkRepository) GetByID(ctx context.Context, id int64) (*parent.Benchmark, error) {
	query := "SELECT id, xsd_id, resolved, style, style_href, version_id, signature_id FROM benchmark WHERE id = ?"

	entity := &parent.Benchmark{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Resolved,
		&entity.Style,
		&entity.StyleHref,
		&entity.VersionID,
		&entity.SignatureID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *benchmarkRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Benchmark, error) {
	query := "SELECT id, xsd_id, resolved, style, style_href, version_id, signature_id FROM benchmark LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Benchmark
	for rows.Next() {
		entity := &parent.Benchmark{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Resolved,
			&entity.Style,
			&entity.StyleHref,
			&entity.VersionID,
			&entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *benchmarkRepository) Update(ctx context.Context, entity *parent.Benchmark) error {
	query := "UPDATE benchmark SET xsd_id = ?, resolved = ?, style = ?, style_href = ?, version_id = ?, signature_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Resolved,
		entity.Style,
		entity.StyleHref,
		entity.VersionID,
		entity.SignatureID,
		entity.ID,
	)
	return err
}

func (r *benchmarkRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM benchmark WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *benchmarkRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM benchmark WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *benchmarkRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM benchmark").Scan(&count)
	return count, err
}

func (d *dal) BenchmarkElementType() parent.BenchmarkElementTypeRepository {
	return &benchmarkElementTypeRepository{db: d.db}
}

type benchmarkElementTypeRepository struct {
	db *sql.DB
}

func (r *benchmarkElementTypeRepository) Create(ctx context.Context, entity *parent.BenchmarkElementType) (int64, error) {
	query := "INSERT INTO benchmark_element_type (xsd_id, resolved, style, style_href, version_id, signature_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Resolved,
		entity.Style,
		entity.StyleHref,
		entity.VersionID,
		entity.SignatureID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *benchmarkElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.BenchmarkElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO benchmark_element_type (xsd_id, resolved, style, style_href, version_id, signature_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Resolved,
			entity.Style,
			entity.StyleHref,
			entity.VersionID,
			entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *benchmarkElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.BenchmarkElementType, error) {
	query := "SELECT id, xsd_id, resolved, style, style_href, version_id, signature_id FROM benchmark_element_type WHERE id = ?"

	entity := &parent.BenchmarkElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Resolved,
		&entity.Style,
		&entity.StyleHref,
		&entity.VersionID,
		&entity.SignatureID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *benchmarkElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.BenchmarkElementType, error) {
	query := "SELECT id, xsd_id, resolved, style, style_href, version_id, signature_id FROM benchmark_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.BenchmarkElementType
	for rows.Next() {
		entity := &parent.BenchmarkElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Resolved,
			&entity.Style,
			&entity.StyleHref,
			&entity.VersionID,
			&entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *benchmarkElementTypeRepository) Update(ctx context.Context, entity *parent.BenchmarkElementType) error {
	query := "UPDATE benchmark_element_type SET xsd_id = ?, resolved = ?, style = ?, style_href = ?, version_id = ?, signature_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Resolved,
		entity.Style,
		entity.StyleHref,
		entity.VersionID,
		entity.SignatureID,
		entity.ID,
	)
	return err
}

func (r *benchmarkElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM benchmark_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *benchmarkElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM benchmark_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *benchmarkElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM benchmark_element_type").Scan(&count)
	return count, err
}

func (r *benchmarkElementTypeRepository) GetByVersionType(ctx context.Context, version_typeID int64) ([]*parent.BenchmarkElementType, error) {
	query := "SELECT id, xsd_id, resolved, style, style_href, version_id, signature_id FROM benchmark_element_type WHERE version_id = ?"

	rows, err := r.db.QueryContext(ctx, query, version_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.BenchmarkElementType
	for rows.Next() {
		entity := &parent.BenchmarkElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Resolved,
			&entity.Style,
			&entity.StyleHref,
			&entity.VersionID,
			&entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) BenchmarkReferenceType() parent.BenchmarkReferenceTypeRepository {
	return &benchmarkReferenceTypeRepository{db: d.db}
}

type benchmarkReferenceTypeRepository struct {
	db *sql.DB
}

func (r *benchmarkReferenceTypeRepository) Create(ctx context.Context, entity *parent.BenchmarkReferenceType) (int64, error) {
	query := "INSERT INTO benchmark_reference_type (href, xsd_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *benchmarkReferenceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.BenchmarkReferenceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO benchmark_reference_type (href, xsd_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Href,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *benchmarkReferenceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.BenchmarkReferenceType, error) {
	query := "SELECT id, href, xsd_id FROM benchmark_reference_type WHERE id = ?"

	entity := &parent.BenchmarkReferenceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Href,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *benchmarkReferenceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.BenchmarkReferenceType, error) {
	query := "SELECT id, href, xsd_id FROM benchmark_reference_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.BenchmarkReferenceType
	for rows.Next() {
		entity := &parent.BenchmarkReferenceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Href,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *benchmarkReferenceTypeRepository) Update(ctx context.Context, entity *parent.BenchmarkReferenceType) error {
	query := "UPDATE benchmark_reference_type SET href = ?, xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *benchmarkReferenceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM benchmark_reference_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *benchmarkReferenceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM benchmark_reference_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *benchmarkReferenceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM benchmark_reference_type").Scan(&count)
	return count, err
}

func (d *dal) BirthdateElementType() parent.BirthdateElementTypeRepository {
	return &birthdateElementTypeRepository{db: d.db}
}

type birthdateElementTypeRepository struct {
	db *sql.DB
}

func (r *birthdateElementTypeRepository) Create(ctx context.Context, entity *parent.BirthdateElementType) (int64, error) {
	query := "INSERT INTO birthdate_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *birthdateElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.BirthdateElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO birthdate_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *birthdateElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.BirthdateElementType, error) {
	query := "SELECT id FROM birthdate_element_type WHERE id = ?"

	entity := &parent.BirthdateElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *birthdateElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.BirthdateElementType, error) {
	query := "SELECT id FROM birthdate_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.BirthdateElementType
	for rows.Next() {
		entity := &parent.BirthdateElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *birthdateElementTypeRepository) Update(ctx context.Context, entity *parent.BirthdateElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *birthdateElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM birthdate_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *birthdateElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM birthdate_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *birthdateElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM birthdate_element_type").Scan(&count)
	return count, err
}

func (d *dal) BuildingNameType() parent.BuildingNameTypeRepository {
	return &buildingNameTypeRepository{db: d.db}
}

type buildingNameTypeRepository struct {
	db *sql.DB
}

func (r *buildingNameTypeRepository) Create(ctx context.Context, entity *parent.BuildingNameType) (int64, error) {
	query := "INSERT INTO building_name_type (type, type_occurrence) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.TypeOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *buildingNameTypeRepository) CreateBatch(ctx context.Context, entities []*parent.BuildingNameType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO building_name_type (type, type_occurrence) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.TypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *buildingNameTypeRepository) GetByID(ctx context.Context, id int64) (*parent.BuildingNameType, error) {
	query := "SELECT id, type, type_occurrence FROM building_name_type WHERE id = ?"

	entity := &parent.BuildingNameType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.TypeOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *buildingNameTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.BuildingNameType, error) {
	query := "SELECT id, type, type_occurrence FROM building_name_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.BuildingNameType
	for rows.Next() {
		entity := &parent.BuildingNameType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.TypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *buildingNameTypeRepository) Update(ctx context.Context, entity *parent.BuildingNameType) error {
	query := "UPDATE building_name_type SET type = ?, type_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.TypeOccurrence,
		entity.ID,
	)
	return err
}

func (r *buildingNameTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM building_name_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *buildingNameTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM building_name_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *buildingNameTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM building_name_type").Scan(&count)
	return count, err
}

func (d *dal) CPE2idrefType() parent.CPE2idrefTypeRepository {
	return &cPE2idrefTypeRepository{db: d.db}
}

type cPE2idrefTypeRepository struct {
	db *sql.DB
}

func (r *cPE2idrefTypeRepository) Create(ctx context.Context, entity *parent.CPE2idrefType) (int64, error) {
	query := "INSERT INTO c_p_e2idref_type (idref) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Idref,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *cPE2idrefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CPE2idrefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO c_p_e2idref_type (idref) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Idref,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *cPE2idrefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CPE2idrefType, error) {
	query := "SELECT id, idref FROM c_p_e2idref_type WHERE id = ?"

	entity := &parent.CPE2idrefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Idref,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *cPE2idrefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CPE2idrefType, error) {
	query := "SELECT id, idref FROM c_p_e2idref_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CPE2idrefType
	for rows.Next() {
		entity := &parent.CPE2idrefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *cPE2idrefTypeRepository) Update(ctx context.Context, entity *parent.CPE2idrefType) error {
	query := "UPDATE c_p_e2idref_type SET idref = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.ID,
	)
	return err
}

func (r *cPE2idrefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM c_p_e2idref_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *cPE2idrefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM c_p_e2idref_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *cPE2idrefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM c_p_e2idref_type").Scan(&count)
	return count, err
}

func (d *dal) CanonicalizationMethodType() parent.CanonicalizationMethodTypeRepository {
	return &canonicalizationMethodTypeRepository{db: d.db}
}

type canonicalizationMethodTypeRepository struct {
	db *sql.DB
}

func (r *canonicalizationMethodTypeRepository) Create(ctx context.Context, entity *parent.CanonicalizationMethodType) (int64, error) {
	query := "INSERT INTO canonicalization_method_type (algorithm) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Algorithm,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *canonicalizationMethodTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CanonicalizationMethodType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO canonicalization_method_type (algorithm) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Algorithm,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *canonicalizationMethodTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CanonicalizationMethodType, error) {
	query := "SELECT id, algorithm FROM canonicalization_method_type WHERE id = ?"

	entity := &parent.CanonicalizationMethodType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Algorithm,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *canonicalizationMethodTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CanonicalizationMethodType, error) {
	query := "SELECT id, algorithm FROM canonicalization_method_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CanonicalizationMethodType
	for rows.Next() {
		entity := &parent.CanonicalizationMethodType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Algorithm,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *canonicalizationMethodTypeRepository) Update(ctx context.Context, entity *parent.CanonicalizationMethodType) error {
	query := "UPDATE canonicalization_method_type SET algorithm = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Algorithm,
		entity.ID,
	)
	return err
}

func (r *canonicalizationMethodTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM canonicalization_method_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *canonicalizationMethodTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM canonicalization_method_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *canonicalizationMethodTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM canonicalization_method_type").Scan(&count)
	return count, err
}

func (d *dal) CheckContentRefType() parent.CheckContentRefTypeRepository {
	return &checkContentRefTypeRepository{db: d.db}
}

type checkContentRefTypeRepository struct {
	db *sql.DB
}

func (r *checkContentRefTypeRepository) Create(ctx context.Context, entity *parent.CheckContentRefType) (int64, error) {
	query := "INSERT INTO \"check_content_ref_type\" (href, name) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.Name,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *checkContentRefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CheckContentRefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"check_content_ref_type\" (href, name) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Href,
			entity.Name,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *checkContentRefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CheckContentRefType, error) {
	query := "SELECT id, href, name FROM \"check_content_ref_type\" WHERE id = ?"

	entity := &parent.CheckContentRefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Href,
		&entity.Name,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *checkContentRefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CheckContentRefType, error) {
	query := "SELECT id, href, name FROM \"check_content_ref_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CheckContentRefType
	for rows.Next() {
		entity := &parent.CheckContentRefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Href,
			&entity.Name,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *checkContentRefTypeRepository) Update(ctx context.Context, entity *parent.CheckContentRefType) error {
	query := "UPDATE \"check_content_ref_type\" SET href = ?, name = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.Name,
		entity.ID,
	)
	return err
}

func (r *checkContentRefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"check_content_ref_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *checkContentRefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"check_content_ref_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *checkContentRefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"check_content_ref_type\"").Scan(&count)
	return count, err
}

func (d *dal) CheckContentType() parent.CheckContentTypeRepository {
	return &checkContentTypeRepository{db: d.db}
}

type checkContentTypeRepository struct {
	db *sql.DB
}

func (r *checkContentTypeRepository) Create(ctx context.Context, entity *parent.CheckContentType) (int64, error) {
	query := "INSERT INTO \"check_content_type\" DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *checkContentTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CheckContentType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"check_content_type\" DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *checkContentTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CheckContentType, error) {
	query := "SELECT id FROM \"check_content_type\" WHERE id = ?"

	entity := &parent.CheckContentType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *checkContentTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CheckContentType, error) {
	query := "SELECT id FROM \"check_content_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CheckContentType
	for rows.Next() {
		entity := &parent.CheckContentType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *checkContentTypeRepository) Update(ctx context.Context, entity *parent.CheckContentType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *checkContentTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"check_content_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *checkContentTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"check_content_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *checkContentTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"check_content_type\"").Scan(&count)
	return count, err
}

func (d *dal) CheckExportType() parent.CheckExportTypeRepository {
	return &checkExportTypeRepository{db: d.db}
}

type checkExportTypeRepository struct {
	db *sql.DB
}

func (r *checkExportTypeRepository) Create(ctx context.Context, entity *parent.CheckExportType) (int64, error) {
	query := "INSERT INTO \"check_export_type\" (value_id, export_name) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ValueId,
		entity.ExportName,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *checkExportTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CheckExportType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"check_export_type\" (value_id, export_name) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ValueId,
			entity.ExportName,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *checkExportTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CheckExportType, error) {
	query := "SELECT id, value_id, export_name FROM \"check_export_type\" WHERE id = ?"

	entity := &parent.CheckExportType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ValueId,
		&entity.ExportName,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *checkExportTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CheckExportType, error) {
	query := "SELECT id, value_id, export_name FROM \"check_export_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CheckExportType
	for rows.Next() {
		entity := &parent.CheckExportType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ValueId,
			&entity.ExportName,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *checkExportTypeRepository) Update(ctx context.Context, entity *parent.CheckExportType) error {
	query := "UPDATE \"check_export_type\" SET value_id = ?, export_name = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ValueId,
		entity.ExportName,
		entity.ID,
	)
	return err
}

func (r *checkExportTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"check_export_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *checkExportTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"check_export_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *checkExportTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"check_export_type\"").Scan(&count)
	return count, err
}

func (d *dal) CheckImportType() parent.CheckImportTypeRepository {
	return &checkImportTypeRepository{db: d.db}
}

type checkImportTypeRepository struct {
	db *sql.DB
}

func (r *checkImportTypeRepository) Create(ctx context.Context, entity *parent.CheckImportType) (int64, error) {
	query := "INSERT INTO \"check_import_type\" (import_name, import_xpath) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ImportName,
		entity.ImportXpath,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *checkImportTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CheckImportType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"check_import_type\" (import_name, import_xpath) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ImportName,
			entity.ImportXpath,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *checkImportTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CheckImportType, error) {
	query := "SELECT id, import_name, import_xpath FROM \"check_import_type\" WHERE id = ?"

	entity := &parent.CheckImportType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ImportName,
		&entity.ImportXpath,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *checkImportTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CheckImportType, error) {
	query := "SELECT id, import_name, import_xpath FROM \"check_import_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CheckImportType
	for rows.Next() {
		entity := &parent.CheckImportType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ImportName,
			&entity.ImportXpath,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *checkImportTypeRepository) Update(ctx context.Context, entity *parent.CheckImportType) error {
	query := "UPDATE \"check_import_type\" SET import_name = ?, import_xpath = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ImportName,
		entity.ImportXpath,
		entity.ID,
	)
	return err
}

func (r *checkImportTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"check_import_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *checkImportTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"check_import_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *checkImportTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"check_import_type\"").Scan(&count)
	return count, err
}

func (d *dal) CidrElementType() parent.CidrElementTypeRepository {
	return &cidrElementTypeRepository{db: d.db}
}

type cidrElementTypeRepository struct {
	db *sql.DB
}

func (r *cidrElementTypeRepository) Create(ctx context.Context, entity *parent.CidrElementType) (int64, error) {
	query := "INSERT INTO cidr_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *cidrElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CidrElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO cidr_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *cidrElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CidrElementType, error) {
	query := "SELECT id, parent_id FROM cidr_element_type WHERE id = ?"

	entity := &parent.CidrElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *cidrElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CidrElementType, error) {
	query := "SELECT id, parent_id FROM cidr_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CidrElementType
	for rows.Next() {
		entity := &parent.CidrElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *cidrElementTypeRepository) Update(ctx context.Context, entity *parent.CidrElementType) error {
	query := "UPDATE cidr_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *cidrElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM cidr_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *cidrElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM cidr_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *cidrElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM cidr_element_type").Scan(&count)
	return count, err
}

func (d *dal) CircuitNameElementType() parent.CircuitNameElementTypeRepository {
	return &circuitNameElementTypeRepository{db: d.db}
}

type circuitNameElementTypeRepository struct {
	db *sql.DB
}

func (r *circuitNameElementTypeRepository) Create(ctx context.Context, entity *parent.CircuitNameElementType) (int64, error) {
	query := "INSERT INTO circuit_name_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *circuitNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CircuitNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO circuit_name_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *circuitNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CircuitNameElementType, error) {
	query := "SELECT id FROM circuit_name_element_type WHERE id = ?"

	entity := &parent.CircuitNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *circuitNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CircuitNameElementType, error) {
	query := "SELECT id FROM circuit_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CircuitNameElementType
	for rows.Next() {
		entity := &parent.CircuitNameElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *circuitNameElementTypeRepository) Update(ctx context.Context, entity *parent.CircuitNameElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *circuitNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM circuit_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *circuitNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM circuit_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *circuitNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM circuit_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) CircuitType() parent.CircuitTypeRepository {
	return &circuitTypeRepository{db: d.db}
}

type circuitTypeRepository struct {
	db *sql.DB
}

func (r *circuitTypeRepository) Create(ctx context.Context, entity *parent.CircuitType) (int64, error) {
	query := "INSERT INTO circuit_type (circuit_name, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.CircuitName,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *circuitTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CircuitType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO circuit_type (circuit_name, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.CircuitName,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *circuitTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CircuitType, error) {
	query := "SELECT id, circuit_name, parent_id FROM circuit_type WHERE id = ?"

	entity := &parent.CircuitType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.CircuitName,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *circuitTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CircuitType, error) {
	query := "SELECT id, circuit_name, parent_id FROM circuit_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CircuitType
	for rows.Next() {
		entity := &parent.CircuitType{}
		err := rows.Scan(
			&entity.ID,
			&entity.CircuitName,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *circuitTypeRepository) Update(ctx context.Context, entity *parent.CircuitType) error {
	query := "UPDATE circuit_type SET circuit_name = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.CircuitName,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *circuitTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM circuit_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *circuitTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM circuit_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *circuitTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM circuit_type").Scan(&count)
	return count, err
}

func (r *circuitTypeRepository) GetByItAssetType(ctx context.Context, it_asset_typeID int64) ([]*parent.CircuitType, error) {
	query := "SELECT id, circuit_name, parent_id FROM circuit_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, it_asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CircuitType
	for rows.Next() {
		entity := &parent.CircuitType{}
		err := rows.Scan(
			&entity.ID,
			&entity.CircuitName,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ComplexCheckType() parent.ComplexCheckTypeRepository {
	return &complexCheckTypeRepository{db: d.db}
}

type complexCheckTypeRepository struct {
	db *sql.DB
}

func (r *complexCheckTypeRepository) Create(ctx context.Context, entity *parent.ComplexCheckType) (int64, error) {
	query := "INSERT INTO \"complex_check_type\" (operator, negate, check_id, complex_check_id) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Operator,
		entity.Negate,
		entity.CheckID,
		entity.ComplexCheckID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *complexCheckTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ComplexCheckType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"complex_check_type\" (operator, negate, check_id, complex_check_id) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Operator,
			entity.Negate,
			entity.CheckID,
			entity.ComplexCheckID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *complexCheckTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ComplexCheckType, error) {
	query := "SELECT id, operator, negate, check_id, complex_check_id FROM \"complex_check_type\" WHERE id = ?"

	entity := &parent.ComplexCheckType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Operator,
		&entity.Negate,
		&entity.CheckID,
		&entity.ComplexCheckID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *complexCheckTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ComplexCheckType, error) {
	query := "SELECT id, operator, negate, check_id, complex_check_id FROM \"complex_check_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ComplexCheckType
	for rows.Next() {
		entity := &parent.ComplexCheckType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Operator,
			&entity.Negate,
			&entity.CheckID,
			&entity.ComplexCheckID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *complexCheckTypeRepository) Update(ctx context.Context, entity *parent.ComplexCheckType) error {
	query := "UPDATE \"complex_check_type\" SET operator = ?, negate = ?, check_id = ?, complex_check_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Operator,
		entity.Negate,
		entity.CheckID,
		entity.ComplexCheckID,
		entity.ID,
	)
	return err
}

func (r *complexCheckTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"complex_check_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *complexCheckTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"complex_check_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *complexCheckTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"complex_check_type\"").Scan(&count)
	return count, err
}

func (r *complexCheckTypeRepository) GetByComplexCheckType(ctx context.Context, complex_check_typeID int64) ([]*parent.ComplexCheckType, error) {
	query := "SELECT id, operator, negate, check_id, complex_check_id FROM \"complex_check_type\" WHERE complex_check_id = ?"

	rows, err := r.db.QueryContext(ctx, query, complex_check_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ComplexCheckType
	for rows.Next() {
		entity := &parent.ComplexCheckType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Operator,
			&entity.Negate,
			&entity.CheckID,
			&entity.ComplexCheckID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ComplexValueType() parent.ComplexValueTypeRepository {
	return &complexValueTypeRepository{db: d.db}
}

type complexValueTypeRepository struct {
	db *sql.DB
}

func (r *complexValueTypeRepository) Create(ctx context.Context, entity *parent.ComplexValueType) (int64, error) {
	query := "INSERT INTO complex_value_type (item) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Item,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *complexValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ComplexValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO complex_value_type (item) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Item,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *complexValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ComplexValueType, error) {
	query := "SELECT id, item FROM complex_value_type WHERE id = ?"

	entity := &parent.ComplexValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Item,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *complexValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ComplexValueType, error) {
	query := "SELECT id, item FROM complex_value_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ComplexValueType
	for rows.Next() {
		entity := &parent.ComplexValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Item,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *complexValueTypeRepository) Update(ctx context.Context, entity *parent.ComplexValueType) error {
	query := "UPDATE complex_value_type SET item = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Item,
		entity.ID,
	)
	return err
}

func (r *complexValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM complex_value_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *complexValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM complex_value_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *complexValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM complex_value_type").Scan(&count)
	return count, err
}

func (d *dal) ComputingDeviceType() parent.ComputingDeviceTypeRepository {
	return &computingDeviceTypeRepository{db: d.db}
}

type computingDeviceTypeRepository struct {
	db *sql.DB
}

func (r *computingDeviceTypeRepository) Create(ctx context.Context, entity *parent.ComputingDeviceType) (int64, error) {
	query := "INSERT INTO computing_device_type (distinguished_name, connections, hostname, motherboard_guid, parent_id) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.DistinguishedName,
		entity.Connections,
		entity.Hostname,
		entity.MotherboardGuid,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *computingDeviceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ComputingDeviceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO computing_device_type (distinguished_name, connections, hostname, motherboard_guid, parent_id) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.DistinguishedName,
			entity.Connections,
			entity.Hostname,
			entity.MotherboardGuid,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *computingDeviceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ComputingDeviceType, error) {
	query := "SELECT id, distinguished_name, connections, hostname, motherboard_guid, parent_id FROM computing_device_type WHERE id = ?"

	entity := &parent.ComputingDeviceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.DistinguishedName,
		&entity.Connections,
		&entity.Hostname,
		&entity.MotherboardGuid,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *computingDeviceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ComputingDeviceType, error) {
	query := "SELECT id, distinguished_name, connections, hostname, motherboard_guid, parent_id FROM computing_device_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ComputingDeviceType
	for rows.Next() {
		entity := &parent.ComputingDeviceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.DistinguishedName,
			&entity.Connections,
			&entity.Hostname,
			&entity.MotherboardGuid,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *computingDeviceTypeRepository) Update(ctx context.Context, entity *parent.ComputingDeviceType) error {
	query := "UPDATE computing_device_type SET distinguished_name = ?, connections = ?, hostname = ?, motherboard_guid = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.DistinguishedName,
		entity.Connections,
		entity.Hostname,
		entity.MotherboardGuid,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *computingDeviceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM computing_device_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *computingDeviceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM computing_device_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *computingDeviceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM computing_device_type").Scan(&count)
	return count, err
}

func (r *computingDeviceTypeRepository) GetByItAssetType(ctx context.Context, it_asset_typeID int64) ([]*parent.ComputingDeviceType, error) {
	query := "SELECT id, distinguished_name, connections, hostname, motherboard_guid, parent_id FROM computing_device_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, it_asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ComputingDeviceType
	for rows.Next() {
		entity := &parent.ComputingDeviceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.DistinguishedName,
			&entity.Connections,
			&entity.Hostname,
			&entity.MotherboardGuid,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ConcatFunctionType() parent.ConcatFunctionTypeRepository {
	return &concatFunctionTypeRepository{db: d.db}
}

type concatFunctionTypeRepository struct {
	db *sql.DB
}

func (r *concatFunctionTypeRepository) Create(ctx context.Context, entity *parent.ConcatFunctionType) (int64, error) {
	query := "INSERT INTO concat_function_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *concatFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ConcatFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO concat_function_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *concatFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ConcatFunctionType, error) {
	query := "SELECT id FROM concat_function_type WHERE id = ?"

	entity := &parent.ConcatFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *concatFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ConcatFunctionType, error) {
	query := "SELECT id FROM concat_function_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ConcatFunctionType
	for rows.Next() {
		entity := &parent.ConcatFunctionType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *concatFunctionTypeRepository) Update(ctx context.Context, entity *parent.ConcatFunctionType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *concatFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM concat_function_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *concatFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM concat_function_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *concatFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM concat_function_type").Scan(&count)
	return count, err
}

func (d *dal) ConnectionsElementType() parent.ConnectionsElementTypeRepository {
	return &connectionsElementTypeRepository{db: d.db}
}

type connectionsElementTypeRepository struct {
	db *sql.DB
}

func (r *connectionsElementTypeRepository) Create(ctx context.Context, entity *parent.ConnectionsElementType) (int64, error) {
	query := "INSERT INTO connections_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *connectionsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ConnectionsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO connections_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *connectionsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ConnectionsElementType, error) {
	query := "SELECT id FROM connections_element_type WHERE id = ?"

	entity := &parent.ConnectionsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *connectionsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ConnectionsElementType, error) {
	query := "SELECT id FROM connections_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ConnectionsElementType
	for rows.Next() {
		entity := &parent.ConnectionsElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *connectionsElementTypeRepository) Update(ctx context.Context, entity *parent.ConnectionsElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *connectionsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM connections_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *connectionsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM connections_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *connectionsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM connections_element_type").Scan(&count)
	return count, err
}

func (d *dal) ConstantVariable() parent.ConstantVariableRepository {
	return &constantVariableRepository{db: d.db}
}

type constantVariableRepository struct {
	db *sql.DB
}

func (r *constantVariableRepository) Create(ctx context.Context, entity *parent.ConstantVariable) (int64, error) {
	query := "INSERT INTO constant_variable (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *constantVariableRepository) CreateBatch(ctx context.Context, entities []*parent.ConstantVariable) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO constant_variable (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *constantVariableRepository) GetByID(ctx context.Context, id int64) (*parent.ConstantVariable, error) {
	query := "SELECT id, parent_id FROM constant_variable WHERE id = ?"

	entity := &parent.ConstantVariable{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *constantVariableRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ConstantVariable, error) {
	query := "SELECT id, parent_id FROM constant_variable LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ConstantVariable
	for rows.Next() {
		entity := &parent.ConstantVariable{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *constantVariableRepository) Update(ctx context.Context, entity *parent.ConstantVariable) error {
	query := "UPDATE constant_variable SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *constantVariableRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM constant_variable WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *constantVariableRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM constant_variable WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *constantVariableRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM constant_variable").Scan(&count)
	return count, err
}

func (r *constantVariableRepository) GetByVariableType(ctx context.Context, variable_typeID int64) ([]*parent.ConstantVariable, error) {
	query := "SELECT id, parent_id FROM constant_variable WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, variable_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ConstantVariable
	for rows.Next() {
		entity := &parent.ConstantVariable{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ConstantVariableElementType() parent.ConstantVariableElementTypeRepository {
	return &constantVariableElementTypeRepository{db: d.db}
}

type constantVariableElementTypeRepository struct {
	db *sql.DB
}

func (r *constantVariableElementTypeRepository) Create(ctx context.Context, entity *parent.ConstantVariableElementType) (int64, error) {
	query := "INSERT INTO constant_variable_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *constantVariableElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ConstantVariableElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO constant_variable_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *constantVariableElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ConstantVariableElementType, error) {
	query := "SELECT id, parent_id FROM constant_variable_element_type WHERE id = ?"

	entity := &parent.ConstantVariableElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *constantVariableElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ConstantVariableElementType, error) {
	query := "SELECT id, parent_id FROM constant_variable_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ConstantVariableElementType
	for rows.Next() {
		entity := &parent.ConstantVariableElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *constantVariableElementTypeRepository) Update(ctx context.Context, entity *parent.ConstantVariableElementType) error {
	query := "UPDATE constant_variable_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *constantVariableElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM constant_variable_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *constantVariableElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM constant_variable_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *constantVariableElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM constant_variable_element_type").Scan(&count)
	return count, err
}

func (r *constantVariableElementTypeRepository) GetByVariableType(ctx context.Context, variable_typeID int64) ([]*parent.ConstantVariableElementType, error) {
	query := "SELECT id, parent_id FROM constant_variable_element_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, variable_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ConstantVariableElementType
	for rows.Next() {
		entity := &parent.ConstantVariableElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ContentElementType() parent.ContentElementTypeRepository {
	return &contentElementTypeRepository{db: d.db}
}

type contentElementTypeRepository struct {
	db *sql.DB
}

func (r *contentElementTypeRepository) Create(ctx context.Context, entity *parent.ContentElementType) (int64, error) {
	query := "INSERT INTO content_element_type (data_valid_start_date, data_valid_end_date) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.DataValidStartDate,
		entity.DataValidEndDate,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *contentElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ContentElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO content_element_type (data_valid_start_date, data_valid_end_date) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.DataValidStartDate,
			entity.DataValidEndDate,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *contentElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ContentElementType, error) {
	query := "SELECT id, data_valid_start_date, data_valid_end_date FROM content_element_type WHERE id = ?"

	entity := &parent.ContentElementType{}
	var datavalidstartdateTime NullTime
	var datavalidenddateTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&datavalidstartdateTime,
		&datavalidenddateTime,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.DataValidStartDate = datavalidstartdateTime.ToTimePtr()
	entity.DataValidEndDate = datavalidenddateTime.ToTimePtr()

	return entity, nil
}

func (r *contentElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ContentElementType, error) {
	query := "SELECT id, data_valid_start_date, data_valid_end_date FROM content_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ContentElementType
	for rows.Next() {
		entity := &parent.ContentElementType{}
		var datavalidstartdateTime NullTime
		var datavalidenddateTime NullTime
		err := rows.Scan(
			&entity.ID,
			&datavalidstartdateTime,
			&datavalidenddateTime,
		)
		if err != nil {
			return nil, err
		}
		entity.DataValidStartDate = datavalidstartdateTime.ToTimePtr()
		entity.DataValidEndDate = datavalidenddateTime.ToTimePtr()
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *contentElementTypeRepository) Update(ctx context.Context, entity *parent.ContentElementType) error {
	query := "UPDATE content_element_type SET data_valid_start_date = ?, data_valid_end_date = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.DataValidStartDate,
		entity.DataValidEndDate,
		entity.ID,
	)
	return err
}

func (r *contentElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM content_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *contentElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM content_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *contentElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM content_element_type").Scan(&count)
	return count, err
}

func (d *dal) ContentElementType1() parent.ContentElementType1Repository {
	return &contentElementType1Repository{db: d.db}
}

type contentElementType1Repository struct {
	db *sql.DB
}

func (r *contentElementType1Repository) Create(ctx context.Context, entity *parent.ContentElementType1) (int64, error) {
	query := "INSERT INTO content_element_type1 DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *contentElementType1Repository) CreateBatch(ctx context.Context, entities []*parent.ContentElementType1) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO content_element_type1 DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *contentElementType1Repository) GetByID(ctx context.Context, id int64) (*parent.ContentElementType1, error) {
	query := "SELECT id FROM content_element_type1 WHERE id = ?"

	entity := &parent.ContentElementType1{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *contentElementType1Repository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ContentElementType1, error) {
	query := "SELECT id FROM content_element_type1 LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ContentElementType1
	for rows.Next() {
		entity := &parent.ContentElementType1{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *contentElementType1Repository) Update(ctx context.Context, entity *parent.ContentElementType1) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *contentElementType1Repository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM content_element_type1 WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *contentElementType1Repository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM content_element_type1 WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *contentElementType1Repository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM content_element_type1").Scan(&count)
	return count, err
}

func (d *dal) CountFunctionType() parent.CountFunctionTypeRepository {
	return &countFunctionTypeRepository{db: d.db}
}

type countFunctionTypeRepository struct {
	db *sql.DB
}

func (r *countFunctionTypeRepository) Create(ctx context.Context, entity *parent.CountFunctionType) (int64, error) {
	query := "INSERT INTO count_function_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *countFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CountFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO count_function_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *countFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CountFunctionType, error) {
	query := "SELECT id FROM count_function_type WHERE id = ?"

	entity := &parent.CountFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *countFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CountFunctionType, error) {
	query := "SELECT id FROM count_function_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CountFunctionType
	for rows.Next() {
		entity := &parent.CountFunctionType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *countFunctionTypeRepository) Update(ctx context.Context, entity *parent.CountFunctionType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *countFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM count_function_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *countFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM count_function_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *countFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM count_function_type").Scan(&count)
	return count, err
}

func (d *dal) CountryElementType() parent.CountryElementTypeRepository {
	return &countryElementTypeRepository{db: d.db}
}

type countryElementTypeRepository struct {
	db *sql.DB
}

func (r *countryElementTypeRepository) Create(ctx context.Context, entity *parent.CountryElementType) (int64, error) {
	query := "INSERT INTO country_element_type (country_name_code) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.CountryNameCode,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *countryElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CountryElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO country_element_type (country_name_code) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.CountryNameCode,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *countryElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CountryElementType, error) {
	query := "SELECT id, country_name_code FROM country_element_type WHERE id = ?"

	entity := &parent.CountryElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.CountryNameCode,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *countryElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CountryElementType, error) {
	query := "SELECT id, country_name_code FROM country_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CountryElementType
	for rows.Next() {
		entity := &parent.CountryElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.CountryNameCode,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *countryElementTypeRepository) Update(ctx context.Context, entity *parent.CountryElementType) error {
	query := "UPDATE country_element_type SET country_name_code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.CountryNameCode,
		entity.ID,
	)
	return err
}

func (r *countryElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM country_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *countryElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM country_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *countryElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM country_element_type").Scan(&count)
	return count, err
}

func (d *dal) CountryName() parent.CountryNameRepository {
	return &countryNameRepository{db: d.db}
}

type countryNameRepository struct {
	db *sql.DB
}

func (r *countryNameRepository) Create(ctx context.Context, entity *parent.CountryName) (int64, error) {
	query := "INSERT INTO country_name (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *countryNameRepository) CreateBatch(ctx context.Context, entities []*parent.CountryName) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO country_name (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *countryNameRepository) GetByID(ctx context.Context, id int64) (*parent.CountryName, error) {
	query := "SELECT id, type FROM country_name WHERE id = ?"

	entity := &parent.CountryName{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *countryNameRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CountryName, error) {
	query := "SELECT id, type FROM country_name LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CountryName
	for rows.Next() {
		entity := &parent.CountryName{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *countryNameRepository) Update(ctx context.Context, entity *parent.CountryName) error {
	query := "UPDATE country_name SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *countryNameRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM country_name WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *countryNameRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM country_name WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *countryNameRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM country_name").Scan(&count)
	return count, err
}

func (d *dal) CountryNameCodeElementType() parent.CountryNameCodeElementTypeRepository {
	return &countryNameCodeElementTypeRepository{db: d.db}
}

type countryNameCodeElementTypeRepository struct {
	db *sql.DB
}

func (r *countryNameCodeElementTypeRepository) Create(ctx context.Context, entity *parent.CountryNameCodeElementType) (int64, error) {
	query := "INSERT INTO country_name_code_element_type (scheme) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Scheme,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *countryNameCodeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CountryNameCodeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO country_name_code_element_type (scheme) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Scheme,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *countryNameCodeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CountryNameCodeElementType, error) {
	query := "SELECT id, scheme FROM country_name_code_element_type WHERE id = ?"

	entity := &parent.CountryNameCodeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Scheme,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *countryNameCodeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CountryNameCodeElementType, error) {
	query := "SELECT id, scheme FROM country_name_code_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CountryNameCodeElementType
	for rows.Next() {
		entity := &parent.CountryNameCodeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Scheme,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *countryNameCodeElementTypeRepository) Update(ctx context.Context, entity *parent.CountryNameCodeElementType) error {
	query := "UPDATE country_name_code_element_type SET scheme = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Scheme,
		entity.ID,
	)
	return err
}

func (r *countryNameCodeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM country_name_code_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *countryNameCodeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM country_name_code_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *countryNameCodeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM country_name_code_element_type").Scan(&count)
	return count, err
}

func (d *dal) CountryNameElementType() parent.CountryNameElementTypeRepository {
	return &countryNameElementTypeRepository{db: d.db}
}

type countryNameElementTypeRepository struct {
	db *sql.DB
}

func (r *countryNameElementTypeRepository) Create(ctx context.Context, entity *parent.CountryNameElementType) (int64, error) {
	query := "INSERT INTO country_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *countryNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CountryNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO country_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *countryNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CountryNameElementType, error) {
	query := "SELECT id, type FROM country_name_element_type WHERE id = ?"

	entity := &parent.CountryNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *countryNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CountryNameElementType, error) {
	query := "SELECT id, type FROM country_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CountryNameElementType
	for rows.Next() {
		entity := &parent.CountryNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *countryNameElementTypeRepository) Update(ctx context.Context, entity *parent.CountryNameElementType) error {
	query := "UPDATE country_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *countryNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM country_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *countryNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM country_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *countryNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM country_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) Cpe() parent.CpeRepository {
	return &cpeRepository{db: d.db}
}

type cpeRepository struct {
	db *sql.DB
}

func (r *cpeRepository) Create(ctx context.Context, entity *parent.Cpe) (int64, error) {
	query := "INSERT INTO cpe (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *cpeRepository) CreateBatch(ctx context.Context, entities []*parent.Cpe) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO cpe (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *cpeRepository) GetByID(ctx context.Context, id int64) (*parent.Cpe, error) {
	query := "SELECT id, parent_id FROM cpe WHERE id = ?"

	entity := &parent.Cpe{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *cpeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Cpe, error) {
	query := "SELECT id, parent_id FROM cpe LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Cpe
	for rows.Next() {
		entity := &parent.Cpe{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *cpeRepository) Update(ctx context.Context, entity *parent.Cpe) error {
	query := "UPDATE cpe SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *cpeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM cpe WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *cpeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM cpe WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *cpeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM cpe").Scan(&count)
	return count, err
}

func (d *dal) CpeElementType() parent.CpeElementTypeRepository {
	return &cpeElementTypeRepository{db: d.db}
}

type cpeElementTypeRepository struct {
	db *sql.DB
}

func (r *cpeElementTypeRepository) Create(ctx context.Context, entity *parent.CpeElementType) (int64, error) {
	query := "INSERT INTO cpe_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *cpeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CpeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO cpe_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *cpeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CpeElementType, error) {
	query := "SELECT id, parent_id FROM cpe_element_type WHERE id = ?"

	entity := &parent.CpeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *cpeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CpeElementType, error) {
	query := "SELECT id, parent_id FROM cpe_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CpeElementType
	for rows.Next() {
		entity := &parent.CpeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *cpeElementTypeRepository) Update(ctx context.Context, entity *parent.CpeElementType) error {
	query := "UPDATE cpe_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *cpeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM cpe_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *cpeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM cpe_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *cpeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM cpe_element_type").Scan(&count)
	return count, err
}

func (d *dal) CriteriaType() parent.CriteriaTypeRepository {
	return &criteriaTypeRepository{db: d.db}
}

type criteriaTypeRepository struct {
	db *sql.DB
}

func (r *criteriaTypeRepository) Create(ctx context.Context, entity *parent.CriteriaType) (int64, error) {
	query := "INSERT INTO criteria_type (applicability_check, operator, negate, comment, criteria_id, criterion_id, extend_definition_id) VALUES (?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Applicability_check,
		entity.Operator,
		entity.Negate,
		entity.Comment,
		entity.CriteriaID,
		entity.CriterionID,
		entity.Extend_definitionID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *criteriaTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CriteriaType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO criteria_type (applicability_check, operator, negate, comment, criteria_id, criterion_id, extend_definition_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Applicability_check,
			entity.Operator,
			entity.Negate,
			entity.Comment,
			entity.CriteriaID,
			entity.CriterionID,
			entity.Extend_definitionID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *criteriaTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CriteriaType, error) {
	query := "SELECT id, applicability_check, operator, negate, comment, criteria_id, criterion_id, extend_definition_id FROM criteria_type WHERE id = ?"

	entity := &parent.CriteriaType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Applicability_check,
		&entity.Operator,
		&entity.Negate,
		&entity.Comment,
		&entity.CriteriaID,
		&entity.CriterionID,
		&entity.Extend_definitionID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *criteriaTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CriteriaType, error) {
	query := "SELECT id, applicability_check, operator, negate, comment, criteria_id, criterion_id, extend_definition_id FROM criteria_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CriteriaType
	for rows.Next() {
		entity := &parent.CriteriaType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Applicability_check,
			&entity.Operator,
			&entity.Negate,
			&entity.Comment,
			&entity.CriteriaID,
			&entity.CriterionID,
			&entity.Extend_definitionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *criteriaTypeRepository) Update(ctx context.Context, entity *parent.CriteriaType) error {
	query := "UPDATE criteria_type SET applicability_check = ?, operator = ?, negate = ?, comment = ?, criteria_id = ?, criterion_id = ?, extend_definition_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Applicability_check,
		entity.Operator,
		entity.Negate,
		entity.Comment,
		entity.CriteriaID,
		entity.CriterionID,
		entity.Extend_definitionID,
		entity.ID,
	)
	return err
}

func (r *criteriaTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM criteria_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *criteriaTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM criteria_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *criteriaTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM criteria_type").Scan(&count)
	return count, err
}

func (r *criteriaTypeRepository) GetByCriteriaType(ctx context.Context, criteria_typeID int64) ([]*parent.CriteriaType, error) {
	query := "SELECT id, applicability_check, operator, negate, comment, criteria_id, criterion_id, extend_definition_id FROM criteria_type WHERE criteria_id = ?"

	rows, err := r.db.QueryContext(ctx, query, criteria_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CriteriaType
	for rows.Next() {
		entity := &parent.CriteriaType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Applicability_check,
			&entity.Operator,
			&entity.Negate,
			&entity.Comment,
			&entity.CriteriaID,
			&entity.CriterionID,
			&entity.Extend_definitionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *criteriaTypeRepository) GetByCriterionType(ctx context.Context, criterion_typeID int64) ([]*parent.CriteriaType, error) {
	query := "SELECT id, applicability_check, operator, negate, comment, criteria_id, criterion_id, extend_definition_id FROM criteria_type WHERE criterion_id = ?"

	rows, err := r.db.QueryContext(ctx, query, criterion_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CriteriaType
	for rows.Next() {
		entity := &parent.CriteriaType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Applicability_check,
			&entity.Operator,
			&entity.Negate,
			&entity.Comment,
			&entity.CriteriaID,
			&entity.CriterionID,
			&entity.Extend_definitionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *criteriaTypeRepository) GetByExtendDefinitionType(ctx context.Context, extend_definition_typeID int64) ([]*parent.CriteriaType, error) {
	query := "SELECT id, applicability_check, operator, negate, comment, criteria_id, criterion_id, extend_definition_id FROM criteria_type WHERE extend_definition_id = ?"

	rows, err := r.db.QueryContext(ctx, query, extend_definition_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CriteriaType
	for rows.Next() {
		entity := &parent.CriteriaType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Applicability_check,
			&entity.Operator,
			&entity.Negate,
			&entity.Comment,
			&entity.CriteriaID,
			&entity.CriterionID,
			&entity.Extend_definitionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) CriterionType() parent.CriterionTypeRepository {
	return &criterionTypeRepository{db: d.db}
}

type criterionTypeRepository struct {
	db *sql.DB
}

func (r *criterionTypeRepository) Create(ctx context.Context, entity *parent.CriterionType) (int64, error) {
	query := "INSERT INTO criterion_type (applicability_check, test_ref, negate, comment) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Applicability_check,
		entity.Test_ref,
		entity.Negate,
		entity.Comment,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *criterionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.CriterionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO criterion_type (applicability_check, test_ref, negate, comment) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Applicability_check,
			entity.Test_ref,
			entity.Negate,
			entity.Comment,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *criterionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.CriterionType, error) {
	query := "SELECT id, applicability_check, test_ref, negate, comment FROM criterion_type WHERE id = ?"

	entity := &parent.CriterionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Applicability_check,
		&entity.Test_ref,
		&entity.Negate,
		&entity.Comment,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *criterionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.CriterionType, error) {
	query := "SELECT id, applicability_check, test_ref, negate, comment FROM criterion_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.CriterionType
	for rows.Next() {
		entity := &parent.CriterionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Applicability_check,
			&entity.Test_ref,
			&entity.Negate,
			&entity.Comment,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *criterionTypeRepository) Update(ctx context.Context, entity *parent.CriterionType) error {
	query := "UPDATE criterion_type SET applicability_check = ?, test_ref = ?, negate = ?, comment = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Applicability_check,
		entity.Test_ref,
		entity.Negate,
		entity.Comment,
		entity.ID,
	)
	return err
}

func (r *criterionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM criterion_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *criterionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM criterion_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *criterionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM criterion_type").Scan(&count)
	return count, err
}

func (d *dal) DSAKeyValueType() parent.DSAKeyValueTypeRepository {
	return &dSAKeyValueTypeRepository{db: d.db}
}

type dSAKeyValueTypeRepository struct {
	db *sql.DB
}

func (r *dSAKeyValueTypeRepository) Create(ctx context.Context, entity *parent.DSAKeyValueType) (int64, error) {
	query := "INSERT INTO \"d_s_a_key_value_type\" (g_id, y_id, j_id, p_id, q_id, seed_id, pgen_counter_id) VALUES (?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.GID,
		entity.YID,
		entity.JID,
		entity.PID,
		entity.QID,
		entity.SeedID,
		entity.PgenCounterID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dSAKeyValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DSAKeyValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"d_s_a_key_value_type\" (g_id, y_id, j_id, p_id, q_id, seed_id, pgen_counter_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.GID,
			entity.YID,
			entity.JID,
			entity.PID,
			entity.QID,
			entity.SeedID,
			entity.PgenCounterID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dSAKeyValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DSAKeyValueType, error) {
	query := "SELECT id, g_id, y_id, j_id, p_id, q_id, seed_id, pgen_counter_id FROM \"d_s_a_key_value_type\" WHERE id = ?"

	entity := &parent.DSAKeyValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.GID,
		&entity.YID,
		&entity.JID,
		&entity.PID,
		&entity.QID,
		&entity.SeedID,
		&entity.PgenCounterID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dSAKeyValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DSAKeyValueType, error) {
	query := "SELECT id, g_id, y_id, j_id, p_id, q_id, seed_id, pgen_counter_id FROM \"d_s_a_key_value_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DSAKeyValueType
	for rows.Next() {
		entity := &parent.DSAKeyValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.GID,
			&entity.YID,
			&entity.JID,
			&entity.PID,
			&entity.QID,
			&entity.SeedID,
			&entity.PgenCounterID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dSAKeyValueTypeRepository) Update(ctx context.Context, entity *parent.DSAKeyValueType) error {
	query := "UPDATE \"d_s_a_key_value_type\" SET g_id = ?, y_id = ?, j_id = ?, p_id = ?, q_id = ?, seed_id = ?, pgen_counter_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.GID,
		entity.YID,
		entity.JID,
		entity.PID,
		entity.QID,
		entity.SeedID,
		entity.PgenCounterID,
		entity.ID,
	)
	return err
}

func (r *dSAKeyValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"d_s_a_key_value_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dSAKeyValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"d_s_a_key_value_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dSAKeyValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"d_s_a_key_value_type\"").Scan(&count)
	return count, err
}

func (d *dal) DataType() parent.DataTypeRepository {
	return &dataTypeRepository{db: d.db}
}

type dataTypeRepository struct {
	db *sql.DB
}

func (r *dataTypeRepository) Create(ctx context.Context, entity *parent.DataType) (int64, error) {
	query := "INSERT INTO data_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dataTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DataType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO data_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dataTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DataType, error) {
	query := "SELECT id, parent_id FROM data_type WHERE id = ?"

	entity := &parent.DataType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dataTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DataType, error) {
	query := "SELECT id, parent_id FROM data_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DataType
	for rows.Next() {
		entity := &parent.DataType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dataTypeRepository) Update(ctx context.Context, entity *parent.DataType) error {
	query := "UPDATE data_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *dataTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM data_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dataTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM data_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dataTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM data_type").Scan(&count)
	return count, err
}

func (r *dataTypeRepository) GetByAssetType(ctx context.Context, asset_typeID int64) ([]*parent.DataType, error) {
	query := "SELECT id, parent_id FROM data_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DataType
	for rows.Next() {
		entity := &parent.DataType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) DatabaseType() parent.DatabaseTypeRepository {
	return &databaseTypeRepository{db: d.db}
}

type databaseTypeRepository struct {
	db *sql.DB
}

func (r *databaseTypeRepository) Create(ctx context.Context, entity *parent.DatabaseType) (int64, error) {
	query := "INSERT INTO database_type (instance_name, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.InstanceName,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *databaseTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DatabaseType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO database_type (instance_name, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.InstanceName,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *databaseTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DatabaseType, error) {
	query := "SELECT id, instance_name, parent_id FROM database_type WHERE id = ?"

	entity := &parent.DatabaseType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.InstanceName,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *databaseTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DatabaseType, error) {
	query := "SELECT id, instance_name, parent_id FROM database_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DatabaseType
	for rows.Next() {
		entity := &parent.DatabaseType{}
		err := rows.Scan(
			&entity.ID,
			&entity.InstanceName,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *databaseTypeRepository) Update(ctx context.Context, entity *parent.DatabaseType) error {
	query := "UPDATE database_type SET instance_name = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.InstanceName,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *databaseTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM database_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *databaseTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM database_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *databaseTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM database_type").Scan(&count)
	return count, err
}

func (r *databaseTypeRepository) GetByItAssetType(ctx context.Context, it_asset_typeID int64) ([]*parent.DatabaseType, error) {
	query := "SELECT id, instance_name, parent_id FROM database_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, it_asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DatabaseType
	for rows.Next() {
		entity := &parent.DatabaseType{}
		err := rows.Scan(
			&entity.ID,
			&entity.InstanceName,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) DcStatusType() parent.DcStatusTypeRepository {
	return &dcStatusTypeRepository{db: d.db}
}

type dcStatusTypeRepository struct {
	db *sql.DB
}

func (r *dcStatusTypeRepository) Create(ctx context.Context, entity *parent.DcStatusType) (int64, error) {
	query := "INSERT INTO dc_status_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dcStatusTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DcStatusType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dc_status_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dcStatusTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DcStatusType, error) {
	query := "SELECT id FROM dc_status_type WHERE id = ?"

	entity := &parent.DcStatusType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dcStatusTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DcStatusType, error) {
	query := "SELECT id FROM dc_status_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DcStatusType
	for rows.Next() {
		entity := &parent.DcStatusType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dcStatusTypeRepository) Update(ctx context.Context, entity *parent.DcStatusType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *dcStatusTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dc_status_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dcStatusTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dc_status_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dcStatusTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dc_status_type").Scan(&count)
	return count, err
}

func (d *dal) DefinitionType() parent.DefinitionTypeRepository {
	return &definitionTypeRepository{db: d.db}
}

type definitionTypeRepository struct {
	db *sql.DB
}

func (r *definitionTypeRepository) Create(ctx context.Context, entity *parent.DefinitionType) (int64, error) {
	query := "INSERT INTO definition_type (xsd_id, version, class, deprecated, metadata_id, criteria_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Class,
		entity.Deprecated,
		entity.MetadataID,
		entity.CriteriaID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *definitionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DefinitionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO definition_type (xsd_id, version, class, deprecated, metadata_id, criteria_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Version,
			entity.Class,
			entity.Deprecated,
			entity.MetadataID,
			entity.CriteriaID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *definitionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DefinitionType, error) {
	query := "SELECT id, xsd_id, version, class, deprecated, metadata_id, criteria_id FROM definition_type WHERE id = ?"

	entity := &parent.DefinitionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Version,
		&entity.Class,
		&entity.Deprecated,
		&entity.MetadataID,
		&entity.CriteriaID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *definitionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DefinitionType, error) {
	query := "SELECT id, xsd_id, version, class, deprecated, metadata_id, criteria_id FROM definition_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DefinitionType
	for rows.Next() {
		entity := &parent.DefinitionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Version,
			&entity.Class,
			&entity.Deprecated,
			&entity.MetadataID,
			&entity.CriteriaID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *definitionTypeRepository) Update(ctx context.Context, entity *parent.DefinitionType) error {
	query := "UPDATE definition_type SET xsd_id = ?, version = ?, class = ?, deprecated = ?, metadata_id = ?, criteria_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Class,
		entity.Deprecated,
		entity.MetadataID,
		entity.CriteriaID,
		entity.ID,
	)
	return err
}

func (r *definitionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM definition_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *definitionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM definition_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *definitionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM definition_type").Scan(&count)
	return count, err
}

func (r *definitionTypeRepository) GetByCriteriaType(ctx context.Context, criteria_typeID int64) ([]*parent.DefinitionType, error) {
	query := "SELECT id, xsd_id, version, class, deprecated, metadata_id, criteria_id FROM definition_type WHERE criteria_id = ?"

	rows, err := r.db.QueryContext(ctx, query, criteria_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DefinitionType
	for rows.Next() {
		entity := &parent.DefinitionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Version,
			&entity.Class,
			&entity.Deprecated,
			&entity.MetadataID,
			&entity.CriteriaID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) DefinitionsType() parent.DefinitionsTypeRepository {
	return &definitionsTypeRepository{db: d.db}
}

type definitionsTypeRepository struct {
	db *sql.DB
}

func (r *definitionsTypeRepository) Create(ctx context.Context, entity *parent.DefinitionsType) (int64, error) {
	query := "INSERT INTO definitions_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *definitionsTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DefinitionsType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO definitions_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *definitionsTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DefinitionsType, error) {
	query := "SELECT id FROM definitions_type WHERE id = ?"

	entity := &parent.DefinitionsType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *definitionsTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DefinitionsType, error) {
	query := "SELECT id FROM definitions_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DefinitionsType
	for rows.Next() {
		entity := &parent.DefinitionsType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *definitionsTypeRepository) Update(ctx context.Context, entity *parent.DefinitionsType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *definitionsTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM definitions_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *definitionsTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM definitions_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *definitionsTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM definitions_type").Scan(&count)
	return count, err
}

func (d *dal) Department() parent.DepartmentRepository {
	return &departmentRepository{db: d.db}
}

type departmentRepository struct {
	db *sql.DB
}

func (r *departmentRepository) Create(ctx context.Context, entity *parent.Department) (int64, error) {
	query := "INSERT INTO department (type, department_name, mail_stop_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.DepartmentName,
		entity.MailStopID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *departmentRepository) CreateBatch(ctx context.Context, entities []*parent.Department) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO department (type, department_name, mail_stop_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.DepartmentName,
			entity.MailStopID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *departmentRepository) GetByID(ctx context.Context, id int64) (*parent.Department, error) {
	query := "SELECT id, type, department_name, mail_stop_id FROM department WHERE id = ?"

	entity := &parent.Department{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.DepartmentName,
		&entity.MailStopID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *departmentRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Department, error) {
	query := "SELECT id, type, department_name, mail_stop_id FROM department LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Department
	for rows.Next() {
		entity := &parent.Department{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DepartmentName,
			&entity.MailStopID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *departmentRepository) Update(ctx context.Context, entity *parent.Department) error {
	query := "UPDATE department SET type = ?, department_name = ?, mail_stop_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.DepartmentName,
		entity.MailStopID,
		entity.ID,
	)
	return err
}

func (r *departmentRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM department WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *departmentRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM department WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *departmentRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM department").Scan(&count)
	return count, err
}

func (d *dal) DepartmentElementType() parent.DepartmentElementTypeRepository {
	return &departmentElementTypeRepository{db: d.db}
}

type departmentElementTypeRepository struct {
	db *sql.DB
}

func (r *departmentElementTypeRepository) Create(ctx context.Context, entity *parent.DepartmentElementType) (int64, error) {
	query := "INSERT INTO department_element_type (type, department_name, mail_stop_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.DepartmentName,
		entity.MailStopID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *departmentElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DepartmentElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO department_element_type (type, department_name, mail_stop_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.DepartmentName,
			entity.MailStopID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *departmentElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DepartmentElementType, error) {
	query := "SELECT id, type, department_name, mail_stop_id FROM department_element_type WHERE id = ?"

	entity := &parent.DepartmentElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.DepartmentName,
		&entity.MailStopID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *departmentElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DepartmentElementType, error) {
	query := "SELECT id, type, department_name, mail_stop_id FROM department_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DepartmentElementType
	for rows.Next() {
		entity := &parent.DepartmentElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DepartmentName,
			&entity.MailStopID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *departmentElementTypeRepository) Update(ctx context.Context, entity *parent.DepartmentElementType) error {
	query := "UPDATE department_element_type SET type = ?, department_name = ?, mail_stop_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.DepartmentName,
		entity.MailStopID,
		entity.ID,
	)
	return err
}

func (r *departmentElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM department_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *departmentElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM department_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *departmentElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM department_element_type").Scan(&count)
	return count, err
}

func (r *departmentElementTypeRepository) GetByMailStopType(ctx context.Context, mail_stop_typeID int64) ([]*parent.DepartmentElementType, error) {
	query := "SELECT id, type, department_name, mail_stop_id FROM department_element_type WHERE mail_stop_id = ?"

	rows, err := r.db.QueryContext(ctx, query, mail_stop_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DepartmentElementType
	for rows.Next() {
		entity := &parent.DepartmentElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DepartmentName,
			&entity.MailStopID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) DepartmentNameElementType() parent.DepartmentNameElementTypeRepository {
	return &departmentNameElementTypeRepository{db: d.db}
}

type departmentNameElementTypeRepository struct {
	db *sql.DB
}

func (r *departmentNameElementTypeRepository) Create(ctx context.Context, entity *parent.DepartmentNameElementType) (int64, error) {
	query := "INSERT INTO department_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *departmentNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DepartmentNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO department_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *departmentNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DepartmentNameElementType, error) {
	query := "SELECT id, type FROM department_name_element_type WHERE id = ?"

	entity := &parent.DepartmentNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *departmentNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DepartmentNameElementType, error) {
	query := "SELECT id, type FROM department_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DepartmentNameElementType
	for rows.Next() {
		entity := &parent.DepartmentNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *departmentNameElementTypeRepository) Update(ctx context.Context, entity *parent.DepartmentNameElementType) error {
	query := "UPDATE department_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *departmentNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM department_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *departmentNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM department_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *departmentNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM department_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) DependencyNameElementType() parent.DependencyNameElementTypeRepository {
	return &dependencyNameElementTypeRepository{db: d.db}
}

type dependencyNameElementTypeRepository struct {
	db *sql.DB
}

func (r *dependencyNameElementTypeRepository) Create(ctx context.Context, entity *parent.DependencyNameElementType) (int64, error) {
	query := "INSERT INTO dependency_name_element_type (dependency_type, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.DependencyType,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dependencyNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DependencyNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dependency_name_element_type (dependency_type, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.DependencyType,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dependencyNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DependencyNameElementType, error) {
	query := "SELECT id, dependency_type, parent_id FROM dependency_name_element_type WHERE id = ?"

	entity := &parent.DependencyNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.DependencyType,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dependencyNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DependencyNameElementType, error) {
	query := "SELECT id, dependency_type, parent_id FROM dependency_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependencyNameElementType
	for rows.Next() {
		entity := &parent.DependencyNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.DependencyType,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dependencyNameElementTypeRepository) Update(ctx context.Context, entity *parent.DependencyNameElementType) error {
	query := "UPDATE dependency_name_element_type SET dependency_type = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.DependencyType,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *dependencyNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dependency_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dependencyNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dependency_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dependencyNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dependency_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) DependentLocalityNameElementType() parent.DependentLocalityNameElementTypeRepository {
	return &dependentLocalityNameElementTypeRepository{db: d.db}
}

type dependentLocalityNameElementTypeRepository struct {
	db *sql.DB
}

func (r *dependentLocalityNameElementTypeRepository) Create(ctx context.Context, entity *parent.DependentLocalityNameElementType) (int64, error) {
	query := "INSERT INTO dependent_locality_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dependentLocalityNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DependentLocalityNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dependent_locality_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dependentLocalityNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DependentLocalityNameElementType, error) {
	query := "SELECT id, type FROM dependent_locality_name_element_type WHERE id = ?"

	entity := &parent.DependentLocalityNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dependentLocalityNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DependentLocalityNameElementType, error) {
	query := "SELECT id, type FROM dependent_locality_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentLocalityNameElementType
	for rows.Next() {
		entity := &parent.DependentLocalityNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dependentLocalityNameElementTypeRepository) Update(ctx context.Context, entity *parent.DependentLocalityNameElementType) error {
	query := "UPDATE dependent_locality_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *dependentLocalityNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dependent_locality_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dependentLocalityNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dependent_locality_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dependentLocalityNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dependent_locality_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) DependentLocalityNumberElementType() parent.DependentLocalityNumberElementTypeRepository {
	return &dependentLocalityNumberElementTypeRepository{db: d.db}
}

type dependentLocalityNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *dependentLocalityNumberElementTypeRepository) Create(ctx context.Context, entity *parent.DependentLocalityNumberElementType) (int64, error) {
	query := "INSERT INTO dependent_locality_number_element_type (name_number_occurrence) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NameNumberOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dependentLocalityNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DependentLocalityNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dependent_locality_number_element_type (name_number_occurrence) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NameNumberOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dependentLocalityNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DependentLocalityNumberElementType, error) {
	query := "SELECT id, name_number_occurrence FROM dependent_locality_number_element_type WHERE id = ?"

	entity := &parent.DependentLocalityNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NameNumberOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dependentLocalityNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DependentLocalityNumberElementType, error) {
	query := "SELECT id, name_number_occurrence FROM dependent_locality_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentLocalityNumberElementType
	for rows.Next() {
		entity := &parent.DependentLocalityNumberElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NameNumberOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dependentLocalityNumberElementTypeRepository) Update(ctx context.Context, entity *parent.DependentLocalityNumberElementType) error {
	query := "UPDATE dependent_locality_number_element_type SET name_number_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NameNumberOccurrence,
		entity.ID,
	)
	return err
}

func (r *dependentLocalityNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dependent_locality_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dependentLocalityNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dependent_locality_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dependentLocalityNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dependent_locality_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) DependentLocalityType() parent.DependentLocalityTypeRepository {
	return &dependentLocalityTypeRepository{db: d.db}
}

type dependentLocalityTypeRepository struct {
	db *sql.DB
}

func (r *dependentLocalityTypeRepository) Create(ctx context.Context, entity *parent.DependentLocalityType) (int64, error) {
	query := "INSERT INTO dependent_locality_type (type, usage_type, connector, indicator, dependent_locality_name, dependent_locality_number, dependent_locality_id, large_mail_user_id, postal_route_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Connector,
		entity.Indicator,
		entity.DependentLocalityName,
		entity.DependentLocalityNumber,
		entity.DependentLocalityID,
		entity.LargeMailUserID,
		entity.PostalRouteID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dependentLocalityTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DependentLocalityType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dependent_locality_type (type, usage_type, connector, indicator, dependent_locality_name, dependent_locality_number, dependent_locality_id, large_mail_user_id, postal_route_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.UsageType,
			entity.Connector,
			entity.Indicator,
			entity.DependentLocalityName,
			entity.DependentLocalityNumber,
			entity.DependentLocalityID,
			entity.LargeMailUserID,
			entity.PostalRouteID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dependentLocalityTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DependentLocalityType, error) {
	query := "SELECT id, type, usage_type, connector, indicator, dependent_locality_name, dependent_locality_number, dependent_locality_id, large_mail_user_id, postal_route_id FROM dependent_locality_type WHERE id = ?"

	entity := &parent.DependentLocalityType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.UsageType,
		&entity.Connector,
		&entity.Indicator,
		&entity.DependentLocalityName,
		&entity.DependentLocalityNumber,
		&entity.DependentLocalityID,
		&entity.LargeMailUserID,
		&entity.PostalRouteID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dependentLocalityTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DependentLocalityType, error) {
	query := "SELECT id, type, usage_type, connector, indicator, dependent_locality_name, dependent_locality_number, dependent_locality_id, large_mail_user_id, postal_route_id FROM dependent_locality_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentLocalityType
	for rows.Next() {
		entity := &parent.DependentLocalityType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.UsageType,
			&entity.Connector,
			&entity.Indicator,
			&entity.DependentLocalityName,
			&entity.DependentLocalityNumber,
			&entity.DependentLocalityID,
			&entity.LargeMailUserID,
			&entity.PostalRouteID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dependentLocalityTypeRepository) Update(ctx context.Context, entity *parent.DependentLocalityType) error {
	query := "UPDATE dependent_locality_type SET type = ?, usage_type = ?, connector = ?, indicator = ?, dependent_locality_name = ?, dependent_locality_number = ?, dependent_locality_id = ?, large_mail_user_id = ?, postal_route_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Connector,
		entity.Indicator,
		entity.DependentLocalityName,
		entity.DependentLocalityNumber,
		entity.DependentLocalityID,
		entity.LargeMailUserID,
		entity.PostalRouteID,
		entity.ID,
	)
	return err
}

func (r *dependentLocalityTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dependent_locality_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dependentLocalityTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dependent_locality_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dependentLocalityTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dependent_locality_type").Scan(&count)
	return count, err
}

func (r *dependentLocalityTypeRepository) GetByDependentLocalityType(ctx context.Context, dependent_locality_typeID int64) ([]*parent.DependentLocalityType, error) {
	query := "SELECT id, type, usage_type, connector, indicator, dependent_locality_name, dependent_locality_number, dependent_locality_id, large_mail_user_id, postal_route_id FROM dependent_locality_type WHERE dependent_locality_id = ?"

	rows, err := r.db.QueryContext(ctx, query, dependent_locality_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentLocalityType
	for rows.Next() {
		entity := &parent.DependentLocalityType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.UsageType,
			&entity.Connector,
			&entity.Indicator,
			&entity.DependentLocalityName,
			&entity.DependentLocalityNumber,
			&entity.DependentLocalityID,
			&entity.LargeMailUserID,
			&entity.PostalRouteID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) DependentThoroughfareElementType() parent.DependentThoroughfareElementTypeRepository {
	return &dependentThoroughfareElementTypeRepository{db: d.db}
}

type dependentThoroughfareElementTypeRepository struct {
	db *sql.DB
}

func (r *dependentThoroughfareElementTypeRepository) Create(ctx context.Context, entity *parent.DependentThoroughfareElementType) (int64, error) {
	query := "INSERT INTO dependent_thoroughfare_element_type (type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ThoroughfarePreDirectionID,
		entity.ThoroughfareLeadingTypeID,
		entity.ThoroughfareTrailingTypeID,
		entity.ThoroughfarePostDirectionID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dependentThoroughfareElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DependentThoroughfareElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dependent_thoroughfare_element_type (type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.ThoroughfarePreDirectionID,
			entity.ThoroughfareLeadingTypeID,
			entity.ThoroughfareTrailingTypeID,
			entity.ThoroughfarePostDirectionID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dependentThoroughfareElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DependentThoroughfareElementType, error) {
	query := "SELECT id, type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id FROM dependent_thoroughfare_element_type WHERE id = ?"

	entity := &parent.DependentThoroughfareElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.ThoroughfarePreDirectionID,
		&entity.ThoroughfareLeadingTypeID,
		&entity.ThoroughfareTrailingTypeID,
		&entity.ThoroughfarePostDirectionID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dependentThoroughfareElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DependentThoroughfareElementType, error) {
	query := "SELECT id, type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id FROM dependent_thoroughfare_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentThoroughfareElementType
	for rows.Next() {
		entity := &parent.DependentThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dependentThoroughfareElementTypeRepository) Update(ctx context.Context, entity *parent.DependentThoroughfareElementType) error {
	query := "UPDATE dependent_thoroughfare_element_type SET type = ?, thoroughfare_pre_direction_id = ?, thoroughfare_leading_type_id = ?, thoroughfare_trailing_type_id = ?, thoroughfare_post_direction_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ThoroughfarePreDirectionID,
		entity.ThoroughfareLeadingTypeID,
		entity.ThoroughfareTrailingTypeID,
		entity.ThoroughfarePostDirectionID,
		entity.ID,
	)
	return err
}

func (r *dependentThoroughfareElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dependent_thoroughfare_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dependentThoroughfareElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dependent_thoroughfare_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dependentThoroughfareElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dependent_thoroughfare_element_type").Scan(&count)
	return count, err
}

func (r *dependentThoroughfareElementTypeRepository) GetByThoroughfarePreDirectionType(ctx context.Context, thoroughfare_pre_direction_typeID int64) ([]*parent.DependentThoroughfareElementType, error) {
	query := "SELECT id, type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id FROM dependent_thoroughfare_element_type WHERE thoroughfare_pre_direction_id = ?"

	rows, err := r.db.QueryContext(ctx, query, thoroughfare_pre_direction_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentThoroughfareElementType
	for rows.Next() {
		entity := &parent.DependentThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dependentThoroughfareElementTypeRepository) GetByThoroughfareLeadingTypeType(ctx context.Context, thoroughfare_leading_type_typeID int64) ([]*parent.DependentThoroughfareElementType, error) {
	query := "SELECT id, type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id FROM dependent_thoroughfare_element_type WHERE thoroughfare_leading_type_id = ?"

	rows, err := r.db.QueryContext(ctx, query, thoroughfare_leading_type_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentThoroughfareElementType
	for rows.Next() {
		entity := &parent.DependentThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dependentThoroughfareElementTypeRepository) GetByThoroughfareTrailingTypeType(ctx context.Context, thoroughfare_trailing_type_typeID int64) ([]*parent.DependentThoroughfareElementType, error) {
	query := "SELECT id, type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id FROM dependent_thoroughfare_element_type WHERE thoroughfare_trailing_type_id = ?"

	rows, err := r.db.QueryContext(ctx, query, thoroughfare_trailing_type_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentThoroughfareElementType
	for rows.Next() {
		entity := &parent.DependentThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dependentThoroughfareElementTypeRepository) GetByThoroughfarePostDirectionType(ctx context.Context, thoroughfare_post_direction_typeID int64) ([]*parent.DependentThoroughfareElementType, error) {
	query := "SELECT id, type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id FROM dependent_thoroughfare_element_type WHERE thoroughfare_post_direction_id = ?"

	rows, err := r.db.QueryContext(ctx, query, thoroughfare_post_direction_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DependentThoroughfareElementType
	for rows.Next() {
		entity := &parent.DependentThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) DeprecatedInfoType() parent.DeprecatedInfoTypeRepository {
	return &deprecatedInfoTypeRepository{db: d.db}
}

type deprecatedInfoTypeRepository struct {
	db *sql.DB
}

func (r *deprecatedInfoTypeRepository) Create(ctx context.Context, entity *parent.DeprecatedInfoType) (int64, error) {
	query := "INSERT INTO deprecated_info_type (version, reason, comment) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Version,
		entity.Reason,
		entity.Comment,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *deprecatedInfoTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DeprecatedInfoType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO deprecated_info_type (version, reason, comment) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Version,
			entity.Reason,
			entity.Comment,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *deprecatedInfoTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DeprecatedInfoType, error) {
	query := "SELECT id, version, reason, comment FROM deprecated_info_type WHERE id = ?"

	entity := &parent.DeprecatedInfoType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Version,
		&entity.Reason,
		&entity.Comment,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *deprecatedInfoTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DeprecatedInfoType, error) {
	query := "SELECT id, version, reason, comment FROM deprecated_info_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DeprecatedInfoType
	for rows.Next() {
		entity := &parent.DeprecatedInfoType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Version,
			&entity.Reason,
			&entity.Comment,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *deprecatedInfoTypeRepository) Update(ctx context.Context, entity *parent.DeprecatedInfoType) error {
	query := "UPDATE deprecated_info_type SET version = ?, reason = ?, comment = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Version,
		entity.Reason,
		entity.Comment,
		entity.ID,
	)
	return err
}

func (r *deprecatedInfoTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM deprecated_info_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *deprecatedInfoTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM deprecated_info_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *deprecatedInfoTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM deprecated_info_type").Scan(&count)
	return count, err
}

func (d *dal) Dictionary20CheckType() parent.Dictionary20CheckTypeRepository {
	return &dictionary20CheckTypeRepository{db: d.db}
}

type dictionary20CheckTypeRepository struct {
	db *sql.DB
}

func (r *dictionary20CheckTypeRepository) Create(ctx context.Context, entity *parent.Dictionary20CheckType) (int64, error) {
	query := "INSERT INTO \"dictionary_2_0_check_type\" (system, href) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.Href,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dictionary20CheckTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Dictionary20CheckType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"dictionary_2_0_check_type\" (system, href) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.System,
			entity.Href,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dictionary20CheckTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Dictionary20CheckType, error) {
	query := "SELECT id, system, href FROM \"dictionary_2_0_check_type\" WHERE id = ?"

	entity := &parent.Dictionary20CheckType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.System,
		&entity.Href,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dictionary20CheckTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Dictionary20CheckType, error) {
	query := "SELECT id, system, href FROM \"dictionary_2_0_check_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Dictionary20CheckType
	for rows.Next() {
		entity := &parent.Dictionary20CheckType{}
		err := rows.Scan(
			&entity.ID,
			&entity.System,
			&entity.Href,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dictionary20CheckTypeRepository) Update(ctx context.Context, entity *parent.Dictionary20CheckType) error {
	query := "UPDATE \"dictionary_2_0_check_type\" SET system = ?, href = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.Href,
		entity.ID,
	)
	return err
}

func (r *dictionary20CheckTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"dictionary_2_0_check_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dictionary20CheckTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"dictionary_2_0_check_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dictionary20CheckTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"dictionary_2_0_check_type\"").Scan(&count)
	return count, err
}

func (d *dal) Dictionary20GeneratorType() parent.Dictionary20GeneratorTypeRepository {
	return &dictionary20GeneratorTypeRepository{db: d.db}
}

type dictionary20GeneratorTypeRepository struct {
	db *sql.DB
}

func (r *dictionary20GeneratorTypeRepository) Create(ctx context.Context, entity *parent.Dictionary20GeneratorType) (int64, error) {
	query := "INSERT INTO dictionary_2_0_generator_type (product_name, product_version, schema_version, timestamp) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Product_name,
		entity.Product_version,
		entity.Schema_version,
		entity.Timestamp,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dictionary20GeneratorTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Dictionary20GeneratorType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dictionary_2_0_generator_type (product_name, product_version, schema_version, timestamp) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Product_name,
			entity.Product_version,
			entity.Schema_version,
			entity.Timestamp,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dictionary20GeneratorTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Dictionary20GeneratorType, error) {
	query := "SELECT id, product_name, product_version, schema_version, timestamp FROM dictionary_2_0_generator_type WHERE id = ?"

	entity := &parent.Dictionary20GeneratorType{}
	var timestampTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Product_name,
		&entity.Product_version,
		&entity.Schema_version,
		&timestampTime,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Timestamp = timestampTime.Time

	return entity, nil
}

func (r *dictionary20GeneratorTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Dictionary20GeneratorType, error) {
	query := "SELECT id, product_name, product_version, schema_version, timestamp FROM dictionary_2_0_generator_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Dictionary20GeneratorType
	for rows.Next() {
		entity := &parent.Dictionary20GeneratorType{}
		var timestampTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.Product_name,
			&entity.Product_version,
			&entity.Schema_version,
			&timestampTime,
		)
		if err != nil {
			return nil, err
		}
		entity.Timestamp = timestampTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dictionary20GeneratorTypeRepository) Update(ctx context.Context, entity *parent.Dictionary20GeneratorType) error {
	query := "UPDATE dictionary_2_0_generator_type SET product_name = ?, product_version = ?, schema_version = ?, timestamp = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Product_name,
		entity.Product_version,
		entity.Schema_version,
		entity.Timestamp,
		entity.ID,
	)
	return err
}

func (r *dictionary20GeneratorTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dictionary_2_0_generator_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dictionary20GeneratorTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dictionary_2_0_generator_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dictionary20GeneratorTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dictionary_2_0_generator_type").Scan(&count)
	return count, err
}

func (r *dictionary20GeneratorTypeRepository) GetBySchemaVersionType(ctx context.Context, schema_version_typeID int64) ([]*parent.Dictionary20GeneratorType, error) {
	query := "SELECT id, product_name, product_version, schema_version, timestamp FROM dictionary_2_0_generator_type WHERE schema_version = ?"

	rows, err := r.db.QueryContext(ctx, query, schema_version_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Dictionary20GeneratorType
	for rows.Next() {
		entity := &parent.Dictionary20GeneratorType{}
		var timestampTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.Product_name,
			&entity.Product_version,
			&entity.Schema_version,
			&timestampTime,
		)
		if err != nil {
			return nil, err
		}
		entity.Timestamp = timestampTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) Dictionary20ItemType() parent.Dictionary20ItemTypeRepository {
	return &dictionary20ItemTypeRepository{db: d.db}
}

type dictionary20ItemTypeRepository struct {
	db *sql.DB
}

func (r *dictionary20ItemTypeRepository) Create(ctx context.Context, entity *parent.Dictionary20ItemType) (int64, error) {
	query := "INSERT INTO dictionary_2_0_item_type (name, deprecated, deprecated_by, deprecation_date, references_id) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.Deprecated,
		entity.Deprecated_by,
		entity.Deprecation_date,
		entity.ReferencesID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dictionary20ItemTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Dictionary20ItemType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dictionary_2_0_item_type (name, deprecated, deprecated_by, deprecation_date, references_id) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Name,
			entity.Deprecated,
			entity.Deprecated_by,
			entity.Deprecation_date,
			entity.ReferencesID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dictionary20ItemTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Dictionary20ItemType, error) {
	query := "SELECT id, name, deprecated, deprecated_by, deprecation_date, references_id FROM dictionary_2_0_item_type WHERE id = ?"

	entity := &parent.Dictionary20ItemType{}
	var deprecation_dateTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Name,
		&entity.Deprecated,
		&entity.Deprecated_by,
		&deprecation_dateTime,
		&entity.ReferencesID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Deprecation_date = deprecation_dateTime.ToTimePtr()

	return entity, nil
}

func (r *dictionary20ItemTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Dictionary20ItemType, error) {
	query := "SELECT id, name, deprecated, deprecated_by, deprecation_date, references_id FROM dictionary_2_0_item_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Dictionary20ItemType
	for rows.Next() {
		entity := &parent.Dictionary20ItemType{}
		var deprecation_dateTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.Name,
			&entity.Deprecated,
			&entity.Deprecated_by,
			&deprecation_dateTime,
			&entity.ReferencesID,
		)
		if err != nil {
			return nil, err
		}
		entity.Deprecation_date = deprecation_dateTime.ToTimePtr()
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dictionary20ItemTypeRepository) Update(ctx context.Context, entity *parent.Dictionary20ItemType) error {
	query := "UPDATE dictionary_2_0_item_type SET name = ?, deprecated = ?, deprecated_by = ?, deprecation_date = ?, references_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.Deprecated,
		entity.Deprecated_by,
		entity.Deprecation_date,
		entity.ReferencesID,
		entity.ID,
	)
	return err
}

func (r *dictionary20ItemTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dictionary_2_0_item_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dictionary20ItemTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dictionary_2_0_item_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dictionary20ItemTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dictionary_2_0_item_type").Scan(&count)
	return count, err
}

func (r *dictionary20ItemTypeRepository) GetByReferencesType(ctx context.Context, references_typeID int64) ([]*parent.Dictionary20ItemType, error) {
	query := "SELECT id, name, deprecated, deprecated_by, deprecation_date, references_id FROM dictionary_2_0_item_type WHERE references_id = ?"

	rows, err := r.db.QueryContext(ctx, query, references_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Dictionary20ItemType
	for rows.Next() {
		entity := &parent.Dictionary20ItemType{}
		var deprecation_dateTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.Name,
			&entity.Deprecated,
			&entity.Deprecated_by,
			&deprecation_dateTime,
			&entity.ReferencesID,
		)
		if err != nil {
			return nil, err
		}
		entity.Deprecation_date = deprecation_dateTime.ToTimePtr()
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) Dictionary20NotesType() parent.Dictionary20NotesTypeRepository {
	return &dictionary20NotesTypeRepository{db: d.db}
}

type dictionary20NotesTypeRepository struct {
	db *sql.DB
}

func (r *dictionary20NotesTypeRepository) Create(ctx context.Context, entity *parent.Dictionary20NotesType) (int64, error) {
	query := "INSERT INTO dictionary_2_0_notes_type (note) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Note,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dictionary20NotesTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Dictionary20NotesType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dictionary_2_0_notes_type (note) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Note,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dictionary20NotesTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Dictionary20NotesType, error) {
	query := "SELECT id, note FROM dictionary_2_0_notes_type WHERE id = ?"

	entity := &parent.Dictionary20NotesType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Note,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dictionary20NotesTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Dictionary20NotesType, error) {
	query := "SELECT id, note FROM dictionary_2_0_notes_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Dictionary20NotesType
	for rows.Next() {
		entity := &parent.Dictionary20NotesType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Note,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dictionary20NotesTypeRepository) Update(ctx context.Context, entity *parent.Dictionary20NotesType) error {
	query := "UPDATE dictionary_2_0_notes_type SET note = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Note,
		entity.ID,
	)
	return err
}

func (r *dictionary20NotesTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dictionary_2_0_notes_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dictionary20NotesTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dictionary_2_0_notes_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dictionary20NotesTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dictionary_2_0_notes_type").Scan(&count)
	return count, err
}

func (d *dal) Dictionary20TextType() parent.Dictionary20TextTypeRepository {
	return &dictionary20TextTypeRepository{db: d.db}
}

type dictionary20TextTypeRepository struct {
	db *sql.DB
}

func (r *dictionary20TextTypeRepository) Create(ctx context.Context, entity *parent.Dictionary20TextType) (int64, error) {
	query := "INSERT INTO dictionary_2_0_text_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *dictionary20TextTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Dictionary20TextType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO dictionary_2_0_text_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *dictionary20TextTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Dictionary20TextType, error) {
	query := "SELECT id FROM dictionary_2_0_text_type WHERE id = ?"

	entity := &parent.Dictionary20TextType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *dictionary20TextTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Dictionary20TextType, error) {
	query := "SELECT id FROM dictionary_2_0_text_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Dictionary20TextType
	for rows.Next() {
		entity := &parent.Dictionary20TextType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *dictionary20TextTypeRepository) Update(ctx context.Context, entity *parent.Dictionary20TextType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *dictionary20TextTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM dictionary_2_0_text_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *dictionary20TextTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM dictionary_2_0_text_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *dictionary20TextTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM dictionary_2_0_text_type").Scan(&count)
	return count, err
}

func (d *dal) DigestMethodType() parent.DigestMethodTypeRepository {
	return &digestMethodTypeRepository{db: d.db}
}

type digestMethodTypeRepository struct {
	db *sql.DB
}

func (r *digestMethodTypeRepository) Create(ctx context.Context, entity *parent.DigestMethodType) (int64, error) {
	query := "INSERT INTO digest_method_type (algorithm) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Algorithm,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *digestMethodTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DigestMethodType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO digest_method_type (algorithm) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Algorithm,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *digestMethodTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DigestMethodType, error) {
	query := "SELECT id, algorithm FROM digest_method_type WHERE id = ?"

	entity := &parent.DigestMethodType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Algorithm,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *digestMethodTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DigestMethodType, error) {
	query := "SELECT id, algorithm FROM digest_method_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DigestMethodType
	for rows.Next() {
		entity := &parent.DigestMethodType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Algorithm,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *digestMethodTypeRepository) Update(ctx context.Context, entity *parent.DigestMethodType) error {
	query := "UPDATE digest_method_type SET algorithm = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Algorithm,
		entity.ID,
	)
	return err
}

func (r *digestMethodTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM digest_method_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *digestMethodTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM digest_method_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *digestMethodTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM digest_method_type").Scan(&count)
	return count, err
}

func (d *dal) DistinguishedNameElementType() parent.DistinguishedNameElementTypeRepository {
	return &distinguishedNameElementTypeRepository{db: d.db}
}

type distinguishedNameElementTypeRepository struct {
	db *sql.DB
}

func (r *distinguishedNameElementTypeRepository) Create(ctx context.Context, entity *parent.DistinguishedNameElementType) (int64, error) {
	query := "INSERT INTO distinguished_name_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *distinguishedNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DistinguishedNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO distinguished_name_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *distinguishedNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DistinguishedNameElementType, error) {
	query := "SELECT id FROM distinguished_name_element_type WHERE id = ?"

	entity := &parent.DistinguishedNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *distinguishedNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DistinguishedNameElementType, error) {
	query := "SELECT id FROM distinguished_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DistinguishedNameElementType
	for rows.Next() {
		entity := &parent.DistinguishedNameElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *distinguishedNameElementTypeRepository) Update(ctx context.Context, entity *parent.DistinguishedNameElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *distinguishedNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM distinguished_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *distinguishedNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM distinguished_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *distinguishedNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM distinguished_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) DocumentRootElementType() parent.DocumentRootElementTypeRepository {
	return &documentRootElementTypeRepository{db: d.db}
}

type documentRootElementTypeRepository struct {
	db *sql.DB
}

func (r *documentRootElementTypeRepository) Create(ctx context.Context, entity *parent.DocumentRootElementType) (int64, error) {
	query := "INSERT INTO document_root_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *documentRootElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.DocumentRootElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO document_root_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *documentRootElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.DocumentRootElementType, error) {
	query := "SELECT id FROM document_root_element_type WHERE id = ?"

	entity := &parent.DocumentRootElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *documentRootElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.DocumentRootElementType, error) {
	query := "SELECT id FROM document_root_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.DocumentRootElementType
	for rows.Next() {
		entity := &parent.DocumentRootElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *documentRootElementTypeRepository) Update(ctx context.Context, entity *parent.DocumentRootElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *documentRootElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM document_root_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *documentRootElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM document_root_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *documentRootElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM document_root_element_type").Scan(&count)
	return count, err
}

func (d *dal) ElementMapItemType() parent.ElementMapItemTypeRepository {
	return &elementMapItemTypeRepository{db: d.db}
}

type elementMapItemTypeRepository struct {
	db *sql.DB
}

func (r *elementMapItemTypeRepository) Create(ctx context.Context, entity *parent.ElementMapItemType) (int64, error) {
	query := "INSERT INTO element_map_item_type (target_namespace) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Target_namespace,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *elementMapItemTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ElementMapItemType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO element_map_item_type (target_namespace) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Target_namespace,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *elementMapItemTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ElementMapItemType, error) {
	query := "SELECT id, target_namespace FROM element_map_item_type WHERE id = ?"

	entity := &parent.ElementMapItemType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Target_namespace,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *elementMapItemTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ElementMapItemType, error) {
	query := "SELECT id, target_namespace FROM element_map_item_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ElementMapItemType
	for rows.Next() {
		entity := &parent.ElementMapItemType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Target_namespace,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *elementMapItemTypeRepository) Update(ctx context.Context, entity *parent.ElementMapItemType) error {
	query := "UPDATE element_map_item_type SET target_namespace = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Target_namespace,
		entity.ID,
	)
	return err
}

func (r *elementMapItemTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM element_map_item_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *elementMapItemTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM element_map_item_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *elementMapItemTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM element_map_item_type").Scan(&count)
	return count, err
}

func (d *dal) ElementMapType() parent.ElementMapTypeRepository {
	return &elementMapTypeRepository{db: d.db}
}

type elementMapTypeRepository struct {
	db *sql.DB
}

func (r *elementMapTypeRepository) Create(ctx context.Context, entity *parent.ElementMapType) (int64, error) {
	query := "INSERT INTO element_map_type (test_id, object_id, state_id, item_id) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.TestID,
		entity.ObjectID,
		entity.StateID,
		entity.ItemID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *elementMapTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ElementMapType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO element_map_type (test_id, object_id, state_id, item_id) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.TestID,
			entity.ObjectID,
			entity.StateID,
			entity.ItemID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *elementMapTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ElementMapType, error) {
	query := "SELECT id, test_id, object_id, state_id, item_id FROM element_map_type WHERE id = ?"

	entity := &parent.ElementMapType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.TestID,
		&entity.ObjectID,
		&entity.StateID,
		&entity.ItemID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *elementMapTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ElementMapType, error) {
	query := "SELECT id, test_id, object_id, state_id, item_id FROM element_map_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ElementMapType
	for rows.Next() {
		entity := &parent.ElementMapType{}
		err := rows.Scan(
			&entity.ID,
			&entity.TestID,
			&entity.ObjectID,
			&entity.StateID,
			&entity.ItemID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *elementMapTypeRepository) Update(ctx context.Context, entity *parent.ElementMapType) error {
	query := "UPDATE element_map_type SET test_id = ?, object_id = ?, state_id = ?, item_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.TestID,
		entity.ObjectID,
		entity.StateID,
		entity.ItemID,
		entity.ID,
	)
	return err
}

func (r *elementMapTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM element_map_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *elementMapTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM element_map_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *elementMapTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM element_map_type").Scan(&count)
	return count, err
}

func (r *elementMapTypeRepository) GetByElementMapItemType(ctx context.Context, element_map_item_typeID int64) ([]*parent.ElementMapType, error) {
	query := "SELECT id, test_id, object_id, state_id, item_id FROM element_map_type WHERE test_id = ?"

	rows, err := r.db.QueryContext(ctx, query, element_map_item_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ElementMapType
	for rows.Next() {
		entity := &parent.ElementMapType{}
		err := rows.Scan(
			&entity.ID,
			&entity.TestID,
			&entity.ObjectID,
			&entity.StateID,
			&entity.ItemID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EmailAddress() parent.EmailAddressRepository {
	return &emailAddressRepository{db: d.db}
}

type emailAddressRepository struct {
	db *sql.DB
}

func (r *emailAddressRepository) Create(ctx context.Context, entity *parent.EmailAddress) (int64, error) {
	query := "INSERT INTO email_address DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *emailAddressRepository) CreateBatch(ctx context.Context, entities []*parent.EmailAddress) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO email_address DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *emailAddressRepository) GetByID(ctx context.Context, id int64) (*parent.EmailAddress, error) {
	query := "SELECT id FROM email_address WHERE id = ?"

	entity := &parent.EmailAddress{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *emailAddressRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EmailAddress, error) {
	query := "SELECT id FROM email_address LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EmailAddress
	for rows.Next() {
		entity := &parent.EmailAddress{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *emailAddressRepository) Update(ctx context.Context, entity *parent.EmailAddress) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *emailAddressRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM email_address WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *emailAddressRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM email_address WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *emailAddressRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM email_address").Scan(&count)
	return count, err
}

func (d *dal) EmailAddressElementType() parent.EmailAddressElementTypeRepository {
	return &emailAddressElementTypeRepository{db: d.db}
}

type emailAddressElementTypeRepository struct {
	db *sql.DB
}

func (r *emailAddressElementTypeRepository) Create(ctx context.Context, entity *parent.EmailAddressElementType) (int64, error) {
	query := "INSERT INTO email_address_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *emailAddressElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EmailAddressElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO email_address_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *emailAddressElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EmailAddressElementType, error) {
	query := "SELECT id FROM email_address_element_type WHERE id = ?"

	entity := &parent.EmailAddressElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *emailAddressElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EmailAddressElementType, error) {
	query := "SELECT id FROM email_address_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EmailAddressElementType
	for rows.Next() {
		entity := &parent.EmailAddressElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *emailAddressElementTypeRepository) Update(ctx context.Context, entity *parent.EmailAddressElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *emailAddressElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM email_address_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *emailAddressElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM email_address_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *emailAddressElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM email_address_element_type").Scan(&count)
	return count, err
}

func (d *dal) EndFunctionType() parent.EndFunctionTypeRepository {
	return &endFunctionTypeRepository{db: d.db}
}

type endFunctionTypeRepository struct {
	db *sql.DB
}

func (r *endFunctionTypeRepository) Create(ctx context.Context, entity *parent.EndFunctionType) (int64, error) {
	query := "INSERT INTO \"end_function_type\" (character) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Character,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *endFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EndFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"end_function_type\" (character) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Character,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *endFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EndFunctionType, error) {
	query := "SELECT id, character FROM \"end_function_type\" WHERE id = ?"

	entity := &parent.EndFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Character,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *endFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EndFunctionType, error) {
	query := "SELECT id, character FROM \"end_function_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EndFunctionType
	for rows.Next() {
		entity := &parent.EndFunctionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Character,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *endFunctionTypeRepository) Update(ctx context.Context, entity *parent.EndFunctionType) error {
	query := "UPDATE \"end_function_type\" SET character = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Character,
		entity.ID,
	)
	return err
}

func (r *endFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"end_function_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *endFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"end_function_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *endFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"end_function_type\"").Scan(&count)
	return count, err
}

func (d *dal) EndorsementLineCodeElementType() parent.EndorsementLineCodeElementTypeRepository {
	return &endorsementLineCodeElementTypeRepository{db: d.db}
}

type endorsementLineCodeElementTypeRepository struct {
	db *sql.DB
}

func (r *endorsementLineCodeElementTypeRepository) Create(ctx context.Context, entity *parent.EndorsementLineCodeElementType) (int64, error) {
	query := "INSERT INTO endorsement_line_code_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *endorsementLineCodeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EndorsementLineCodeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO endorsement_line_code_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *endorsementLineCodeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EndorsementLineCodeElementType, error) {
	query := "SELECT id, type FROM endorsement_line_code_element_type WHERE id = ?"

	entity := &parent.EndorsementLineCodeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *endorsementLineCodeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EndorsementLineCodeElementType, error) {
	query := "SELECT id, type FROM endorsement_line_code_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EndorsementLineCodeElementType
	for rows.Next() {
		entity := &parent.EndorsementLineCodeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *endorsementLineCodeElementTypeRepository) Update(ctx context.Context, entity *parent.EndorsementLineCodeElementType) error {
	query := "UPDATE endorsement_line_code_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *endorsementLineCodeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM endorsement_line_code_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *endorsementLineCodeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM endorsement_line_code_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *endorsementLineCodeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM endorsement_line_code_element_type").Scan(&count)
	return count, err
}

func (d *dal) EntityObjectAnySimpleType() parent.EntityObjectAnySimpleTypeRepository {
	return &entityObjectAnySimpleTypeRepository{db: d.db}
}

type entityObjectAnySimpleTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectAnySimpleTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectAnySimpleType) (int64, error) {
	query := "INSERT INTO \"entity_object_any_simple_type\" (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectAnySimpleTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectAnySimpleType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"entity_object_any_simple_type\" (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectAnySimpleTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectAnySimpleType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_object_any_simple_type\" WHERE id = ?"

	entity := &parent.EntityObjectAnySimpleType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectAnySimpleTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectAnySimpleType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_object_any_simple_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectAnySimpleType
	for rows.Next() {
		entity := &parent.EntityObjectAnySimpleType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectAnySimpleTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectAnySimpleType) error {
	query := "UPDATE \"entity_object_any_simple_type\" SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectAnySimpleTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"entity_object_any_simple_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectAnySimpleTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"entity_object_any_simple_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectAnySimpleTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"entity_object_any_simple_type\"").Scan(&count)
	return count, err
}

func (r *entityObjectAnySimpleTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectAnySimpleType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_object_any_simple_type\" WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectAnySimpleType
	for rows.Next() {
		entity := &parent.EntityObjectAnySimpleType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectBinaryType() parent.EntityObjectBinaryTypeRepository {
	return &entityObjectBinaryTypeRepository{db: d.db}
}

type entityObjectBinaryTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectBinaryTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectBinaryType) (int64, error) {
	query := "INSERT INTO entity_object_binary_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectBinaryTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectBinaryType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_binary_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectBinaryTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectBinaryType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_binary_type WHERE id = ?"

	entity := &parent.EntityObjectBinaryType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectBinaryTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectBinaryType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_binary_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectBinaryType
	for rows.Next() {
		entity := &parent.EntityObjectBinaryType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectBinaryTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectBinaryType) error {
	query := "UPDATE entity_object_binary_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectBinaryTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_binary_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectBinaryTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_binary_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectBinaryTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_binary_type").Scan(&count)
	return count, err
}

func (r *entityObjectBinaryTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectBinaryType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_binary_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectBinaryType
	for rows.Next() {
		entity := &parent.EntityObjectBinaryType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectBoolType() parent.EntityObjectBoolTypeRepository {
	return &entityObjectBoolTypeRepository{db: d.db}
}

type entityObjectBoolTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectBoolTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectBoolType) (int64, error) {
	query := "INSERT INTO entity_object_bool_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectBoolTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectBoolType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_bool_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectBoolTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectBoolType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_bool_type WHERE id = ?"

	entity := &parent.EntityObjectBoolType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectBoolTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectBoolType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_bool_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectBoolType
	for rows.Next() {
		entity := &parent.EntityObjectBoolType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectBoolTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectBoolType) error {
	query := "UPDATE entity_object_bool_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectBoolTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_bool_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectBoolTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_bool_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectBoolTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_bool_type").Scan(&count)
	return count, err
}

func (r *entityObjectBoolTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectBoolType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_bool_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectBoolType
	for rows.Next() {
		entity := &parent.EntityObjectBoolType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectFieldType() parent.EntityObjectFieldTypeRepository {
	return &entityObjectFieldTypeRepository{db: d.db}
}

type entityObjectFieldTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectFieldTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectFieldType) (int64, error) {
	query := "INSERT INTO entity_object_field_type (name, entity_check) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.Entity_check,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectFieldTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectFieldType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_field_type (name, entity_check) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Name,
			entity.Entity_check,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectFieldTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectFieldType, error) {
	query := "SELECT id, name, entity_check FROM entity_object_field_type WHERE id = ?"

	entity := &parent.EntityObjectFieldType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Name,
		&entity.Entity_check,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectFieldTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectFieldType, error) {
	query := "SELECT id, name, entity_check FROM entity_object_field_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectFieldType
	for rows.Next() {
		entity := &parent.EntityObjectFieldType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Name,
			&entity.Entity_check,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectFieldTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectFieldType) error {
	query := "UPDATE entity_object_field_type SET name = ?, entity_check = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.Entity_check,
		entity.ID,
	)
	return err
}

func (r *entityObjectFieldTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_field_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectFieldTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_field_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectFieldTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_field_type").Scan(&count)
	return count, err
}

func (d *dal) EntityObjectFloatType() parent.EntityObjectFloatTypeRepository {
	return &entityObjectFloatTypeRepository{db: d.db}
}

type entityObjectFloatTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectFloatTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectFloatType) (int64, error) {
	query := "INSERT INTO entity_object_float_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectFloatTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectFloatType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_float_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectFloatTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectFloatType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_float_type WHERE id = ?"

	entity := &parent.EntityObjectFloatType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectFloatTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectFloatType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_float_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectFloatType
	for rows.Next() {
		entity := &parent.EntityObjectFloatType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectFloatTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectFloatType) error {
	query := "UPDATE entity_object_float_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectFloatTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_float_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectFloatTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_float_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectFloatTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_float_type").Scan(&count)
	return count, err
}

func (r *entityObjectFloatTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectFloatType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_float_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectFloatType
	for rows.Next() {
		entity := &parent.EntityObjectFloatType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectIPAddressStringType() parent.EntityObjectIPAddressStringTypeRepository {
	return &entityObjectIPAddressStringTypeRepository{db: d.db}
}

type entityObjectIPAddressStringTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectIPAddressStringTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectIPAddressStringType) (int64, error) {
	query := "INSERT INTO entity_object_i_p_address_string_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectIPAddressStringTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectIPAddressStringType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_i_p_address_string_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectIPAddressStringTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectIPAddressStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_i_p_address_string_type WHERE id = ?"

	entity := &parent.EntityObjectIPAddressStringType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectIPAddressStringTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectIPAddressStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_i_p_address_string_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectIPAddressStringType
	for rows.Next() {
		entity := &parent.EntityObjectIPAddressStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectIPAddressStringTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectIPAddressStringType) error {
	query := "UPDATE entity_object_i_p_address_string_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectIPAddressStringTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_i_p_address_string_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectIPAddressStringTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_i_p_address_string_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectIPAddressStringTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_i_p_address_string_type").Scan(&count)
	return count, err
}

func (r *entityObjectIPAddressStringTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectIPAddressStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_i_p_address_string_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectIPAddressStringType
	for rows.Next() {
		entity := &parent.EntityObjectIPAddressStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectIPAddressType() parent.EntityObjectIPAddressTypeRepository {
	return &entityObjectIPAddressTypeRepository{db: d.db}
}

type entityObjectIPAddressTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectIPAddressTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectIPAddressType) (int64, error) {
	query := "INSERT INTO entity_object_i_p_address_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectIPAddressTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectIPAddressType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_i_p_address_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectIPAddressTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectIPAddressType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_i_p_address_type WHERE id = ?"

	entity := &parent.EntityObjectIPAddressType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectIPAddressTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectIPAddressType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_i_p_address_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectIPAddressType
	for rows.Next() {
		entity := &parent.EntityObjectIPAddressType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectIPAddressTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectIPAddressType) error {
	query := "UPDATE entity_object_i_p_address_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectIPAddressTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_i_p_address_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectIPAddressTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_i_p_address_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectIPAddressTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_i_p_address_type").Scan(&count)
	return count, err
}

func (r *entityObjectIPAddressTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectIPAddressType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_i_p_address_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectIPAddressType
	for rows.Next() {
		entity := &parent.EntityObjectIPAddressType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectIntType() parent.EntityObjectIntTypeRepository {
	return &entityObjectIntTypeRepository{db: d.db}
}

type entityObjectIntTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectIntTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectIntType) (int64, error) {
	query := "INSERT INTO entity_object_int_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectIntTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectIntType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_int_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectIntTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectIntType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_int_type WHERE id = ?"

	entity := &parent.EntityObjectIntType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectIntTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectIntType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_int_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectIntType
	for rows.Next() {
		entity := &parent.EntityObjectIntType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectIntTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectIntType) error {
	query := "UPDATE entity_object_int_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectIntTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_int_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectIntTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_int_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectIntTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_int_type").Scan(&count)
	return count, err
}

func (r *entityObjectIntTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectIntType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_int_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectIntType
	for rows.Next() {
		entity := &parent.EntityObjectIntType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectRecordType() parent.EntityObjectRecordTypeRepository {
	return &entityObjectRecordTypeRepository{db: d.db}
}

type entityObjectRecordTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectRecordTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectRecordType) (int64, error) {
	query := "INSERT INTO entity_object_record_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectRecordTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectRecordType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_record_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectRecordTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectRecordType, error) {
	query := "SELECT id, parent_id FROM entity_object_record_type WHERE id = ?"

	entity := &parent.EntityObjectRecordType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectRecordTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectRecordType, error) {
	query := "SELECT id, parent_id FROM entity_object_record_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectRecordType
	for rows.Next() {
		entity := &parent.EntityObjectRecordType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectRecordTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectRecordType) error {
	query := "UPDATE entity_object_record_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectRecordTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_record_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectRecordTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_record_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectRecordTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_record_type").Scan(&count)
	return count, err
}

func (r *entityObjectRecordTypeRepository) GetByEntityComplexBaseType(ctx context.Context, entity_complex_base_typeID int64) ([]*parent.EntityObjectRecordType, error) {
	query := "SELECT id, parent_id FROM entity_object_record_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_complex_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectRecordType
	for rows.Next() {
		entity := &parent.EntityObjectRecordType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectStringType() parent.EntityObjectStringTypeRepository {
	return &entityObjectStringTypeRepository{db: d.db}
}

type entityObjectStringTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectStringTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectStringType) (int64, error) {
	query := "INSERT INTO entity_object_string_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectStringTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectStringType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_string_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectStringTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_string_type WHERE id = ?"

	entity := &parent.EntityObjectStringType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectStringTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_string_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectStringType
	for rows.Next() {
		entity := &parent.EntityObjectStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectStringTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectStringType) error {
	query := "UPDATE entity_object_string_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectStringTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_string_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectStringTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_string_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectStringTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_string_type").Scan(&count)
	return count, err
}

func (r *entityObjectStringTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_string_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectStringType
	for rows.Next() {
		entity := &parent.EntityObjectStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityObjectVersionType() parent.EntityObjectVersionTypeRepository {
	return &entityObjectVersionTypeRepository{db: d.db}
}

type entityObjectVersionTypeRepository struct {
	db *sql.DB
}

func (r *entityObjectVersionTypeRepository) Create(ctx context.Context, entity *parent.EntityObjectVersionType) (int64, error) {
	query := "INSERT INTO entity_object_version_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityObjectVersionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityObjectVersionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_object_version_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityObjectVersionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityObjectVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_version_type WHERE id = ?"

	entity := &parent.EntityObjectVersionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityObjectVersionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityObjectVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_version_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectVersionType
	for rows.Next() {
		entity := &parent.EntityObjectVersionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityObjectVersionTypeRepository) Update(ctx context.Context, entity *parent.EntityObjectVersionType) error {
	query := "UPDATE entity_object_version_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityObjectVersionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_object_version_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityObjectVersionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_object_version_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityObjectVersionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_object_version_type").Scan(&count)
	return count, err
}

func (r *entityObjectVersionTypeRepository) GetByEntitySimpleBaseType(ctx context.Context, entity_simple_base_typeID int64) ([]*parent.EntityObjectVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_object_version_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityObjectVersionType
	for rows.Next() {
		entity := &parent.EntityObjectVersionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateAnySimpleType() parent.EntityStateAnySimpleTypeRepository {
	return &entityStateAnySimpleTypeRepository{db: d.db}
}

type entityStateAnySimpleTypeRepository struct {
	db *sql.DB
}

func (r *entityStateAnySimpleTypeRepository) Create(ctx context.Context, entity *parent.EntityStateAnySimpleType) (int64, error) {
	query := "INSERT INTO \"entity_state_any_simple_type\" (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateAnySimpleTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateAnySimpleType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"entity_state_any_simple_type\" (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateAnySimpleTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateAnySimpleType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_state_any_simple_type\" WHERE id = ?"

	entity := &parent.EntityStateAnySimpleType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateAnySimpleTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateAnySimpleType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_state_any_simple_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateAnySimpleType
	for rows.Next() {
		entity := &parent.EntityStateAnySimpleType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateAnySimpleTypeRepository) Update(ctx context.Context, entity *parent.EntityStateAnySimpleType) error {
	query := "UPDATE \"entity_state_any_simple_type\" SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateAnySimpleTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"entity_state_any_simple_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateAnySimpleTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"entity_state_any_simple_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateAnySimpleTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"entity_state_any_simple_type\"").Scan(&count)
	return count, err
}

func (r *entityStateAnySimpleTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateAnySimpleType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_state_any_simple_type\" WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateAnySimpleType
	for rows.Next() {
		entity := &parent.EntityStateAnySimpleType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateBinaryType() parent.EntityStateBinaryTypeRepository {
	return &entityStateBinaryTypeRepository{db: d.db}
}

type entityStateBinaryTypeRepository struct {
	db *sql.DB
}

func (r *entityStateBinaryTypeRepository) Create(ctx context.Context, entity *parent.EntityStateBinaryType) (int64, error) {
	query := "INSERT INTO entity_state_binary_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateBinaryTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateBinaryType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_binary_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateBinaryTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateBinaryType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_binary_type WHERE id = ?"

	entity := &parent.EntityStateBinaryType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateBinaryTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateBinaryType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_binary_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateBinaryType
	for rows.Next() {
		entity := &parent.EntityStateBinaryType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateBinaryTypeRepository) Update(ctx context.Context, entity *parent.EntityStateBinaryType) error {
	query := "UPDATE entity_state_binary_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateBinaryTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_binary_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateBinaryTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_binary_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateBinaryTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_binary_type").Scan(&count)
	return count, err
}

func (r *entityStateBinaryTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateBinaryType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_binary_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateBinaryType
	for rows.Next() {
		entity := &parent.EntityStateBinaryType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateBoolType() parent.EntityStateBoolTypeRepository {
	return &entityStateBoolTypeRepository{db: d.db}
}

type entityStateBoolTypeRepository struct {
	db *sql.DB
}

func (r *entityStateBoolTypeRepository) Create(ctx context.Context, entity *parent.EntityStateBoolType) (int64, error) {
	query := "INSERT INTO entity_state_bool_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateBoolTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateBoolType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_bool_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateBoolTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateBoolType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_bool_type WHERE id = ?"

	entity := &parent.EntityStateBoolType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateBoolTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateBoolType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_bool_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateBoolType
	for rows.Next() {
		entity := &parent.EntityStateBoolType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateBoolTypeRepository) Update(ctx context.Context, entity *parent.EntityStateBoolType) error {
	query := "UPDATE entity_state_bool_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateBoolTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_bool_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateBoolTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_bool_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateBoolTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_bool_type").Scan(&count)
	return count, err
}

func (r *entityStateBoolTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateBoolType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_bool_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateBoolType
	for rows.Next() {
		entity := &parent.EntityStateBoolType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateDebianEVRStringType() parent.EntityStateDebianEVRStringTypeRepository {
	return &entityStateDebianEVRStringTypeRepository{db: d.db}
}

type entityStateDebianEVRStringTypeRepository struct {
	db *sql.DB
}

func (r *entityStateDebianEVRStringTypeRepository) Create(ctx context.Context, entity *parent.EntityStateDebianEVRStringType) (int64, error) {
	query := "INSERT INTO entity_state_debian_e_v_r_string_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateDebianEVRStringTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateDebianEVRStringType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_debian_e_v_r_string_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateDebianEVRStringTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateDebianEVRStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_debian_e_v_r_string_type WHERE id = ?"

	entity := &parent.EntityStateDebianEVRStringType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateDebianEVRStringTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateDebianEVRStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_debian_e_v_r_string_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateDebianEVRStringType
	for rows.Next() {
		entity := &parent.EntityStateDebianEVRStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateDebianEVRStringTypeRepository) Update(ctx context.Context, entity *parent.EntityStateDebianEVRStringType) error {
	query := "UPDATE entity_state_debian_e_v_r_string_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateDebianEVRStringTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_debian_e_v_r_string_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateDebianEVRStringTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_debian_e_v_r_string_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateDebianEVRStringTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_debian_e_v_r_string_type").Scan(&count)
	return count, err
}

func (r *entityStateDebianEVRStringTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateDebianEVRStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_debian_e_v_r_string_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateDebianEVRStringType
	for rows.Next() {
		entity := &parent.EntityStateDebianEVRStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateEVRStringType() parent.EntityStateEVRStringTypeRepository {
	return &entityStateEVRStringTypeRepository{db: d.db}
}

type entityStateEVRStringTypeRepository struct {
	db *sql.DB
}

func (r *entityStateEVRStringTypeRepository) Create(ctx context.Context, entity *parent.EntityStateEVRStringType) (int64, error) {
	query := "INSERT INTO entity_state_e_v_r_string_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateEVRStringTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateEVRStringType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_e_v_r_string_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateEVRStringTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateEVRStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_e_v_r_string_type WHERE id = ?"

	entity := &parent.EntityStateEVRStringType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateEVRStringTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateEVRStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_e_v_r_string_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateEVRStringType
	for rows.Next() {
		entity := &parent.EntityStateEVRStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateEVRStringTypeRepository) Update(ctx context.Context, entity *parent.EntityStateEVRStringType) error {
	query := "UPDATE entity_state_e_v_r_string_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateEVRStringTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_e_v_r_string_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateEVRStringTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_e_v_r_string_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateEVRStringTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_e_v_r_string_type").Scan(&count)
	return count, err
}

func (r *entityStateEVRStringTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateEVRStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_e_v_r_string_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateEVRStringType
	for rows.Next() {
		entity := &parent.EntityStateEVRStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateFieldType() parent.EntityStateFieldTypeRepository {
	return &entityStateFieldTypeRepository{db: d.db}
}

type entityStateFieldTypeRepository struct {
	db *sql.DB
}

func (r *entityStateFieldTypeRepository) Create(ctx context.Context, entity *parent.EntityStateFieldType) (int64, error) {
	query := "INSERT INTO entity_state_field_type (name, entity_check) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.Entity_check,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateFieldTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateFieldType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_field_type (name, entity_check) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Name,
			entity.Entity_check,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateFieldTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateFieldType, error) {
	query := "SELECT id, name, entity_check FROM entity_state_field_type WHERE id = ?"

	entity := &parent.EntityStateFieldType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Name,
		&entity.Entity_check,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateFieldTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateFieldType, error) {
	query := "SELECT id, name, entity_check FROM entity_state_field_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateFieldType
	for rows.Next() {
		entity := &parent.EntityStateFieldType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Name,
			&entity.Entity_check,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateFieldTypeRepository) Update(ctx context.Context, entity *parent.EntityStateFieldType) error {
	query := "UPDATE entity_state_field_type SET name = ?, entity_check = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.Entity_check,
		entity.ID,
	)
	return err
}

func (r *entityStateFieldTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_field_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateFieldTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_field_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateFieldTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_field_type").Scan(&count)
	return count, err
}

func (d *dal) EntityStateFileSetRevisionType() parent.EntityStateFileSetRevisionTypeRepository {
	return &entityStateFileSetRevisionTypeRepository{db: d.db}
}

type entityStateFileSetRevisionTypeRepository struct {
	db *sql.DB
}

func (r *entityStateFileSetRevisionTypeRepository) Create(ctx context.Context, entity *parent.EntityStateFileSetRevisionType) (int64, error) {
	query := "INSERT INTO \"entity_state_file_set_revision_type\" (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateFileSetRevisionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateFileSetRevisionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"entity_state_file_set_revision_type\" (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateFileSetRevisionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateFileSetRevisionType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_state_file_set_revision_type\" WHERE id = ?"

	entity := &parent.EntityStateFileSetRevisionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateFileSetRevisionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateFileSetRevisionType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_state_file_set_revision_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateFileSetRevisionType
	for rows.Next() {
		entity := &parent.EntityStateFileSetRevisionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateFileSetRevisionTypeRepository) Update(ctx context.Context, entity *parent.EntityStateFileSetRevisionType) error {
	query := "UPDATE \"entity_state_file_set_revision_type\" SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateFileSetRevisionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"entity_state_file_set_revision_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateFileSetRevisionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"entity_state_file_set_revision_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateFileSetRevisionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"entity_state_file_set_revision_type\"").Scan(&count)
	return count, err
}

func (r *entityStateFileSetRevisionTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateFileSetRevisionType, error) {
	query := "SELECT id, datatype, parent_id FROM \"entity_state_file_set_revision_type\" WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateFileSetRevisionType
	for rows.Next() {
		entity := &parent.EntityStateFileSetRevisionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateFloatType() parent.EntityStateFloatTypeRepository {
	return &entityStateFloatTypeRepository{db: d.db}
}

type entityStateFloatTypeRepository struct {
	db *sql.DB
}

func (r *entityStateFloatTypeRepository) Create(ctx context.Context, entity *parent.EntityStateFloatType) (int64, error) {
	query := "INSERT INTO entity_state_float_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateFloatTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateFloatType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_float_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateFloatTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateFloatType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_float_type WHERE id = ?"

	entity := &parent.EntityStateFloatType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateFloatTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateFloatType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_float_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateFloatType
	for rows.Next() {
		entity := &parent.EntityStateFloatType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateFloatTypeRepository) Update(ctx context.Context, entity *parent.EntityStateFloatType) error {
	query := "UPDATE entity_state_float_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateFloatTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_float_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateFloatTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_float_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateFloatTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_float_type").Scan(&count)
	return count, err
}

func (r *entityStateFloatTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateFloatType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_float_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateFloatType
	for rows.Next() {
		entity := &parent.EntityStateFloatType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateIOSVersionType() parent.EntityStateIOSVersionTypeRepository {
	return &entityStateIOSVersionTypeRepository{db: d.db}
}

type entityStateIOSVersionTypeRepository struct {
	db *sql.DB
}

func (r *entityStateIOSVersionTypeRepository) Create(ctx context.Context, entity *parent.EntityStateIOSVersionType) (int64, error) {
	query := "INSERT INTO entity_state_i_o_s_version_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateIOSVersionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateIOSVersionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_i_o_s_version_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateIOSVersionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateIOSVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_o_s_version_type WHERE id = ?"

	entity := &parent.EntityStateIOSVersionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateIOSVersionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateIOSVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_o_s_version_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateIOSVersionType
	for rows.Next() {
		entity := &parent.EntityStateIOSVersionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateIOSVersionTypeRepository) Update(ctx context.Context, entity *parent.EntityStateIOSVersionType) error {
	query := "UPDATE entity_state_i_o_s_version_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateIOSVersionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_i_o_s_version_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateIOSVersionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_i_o_s_version_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateIOSVersionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_i_o_s_version_type").Scan(&count)
	return count, err
}

func (r *entityStateIOSVersionTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateIOSVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_o_s_version_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateIOSVersionType
	for rows.Next() {
		entity := &parent.EntityStateIOSVersionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateIPAddressStringType() parent.EntityStateIPAddressStringTypeRepository {
	return &entityStateIPAddressStringTypeRepository{db: d.db}
}

type entityStateIPAddressStringTypeRepository struct {
	db *sql.DB
}

func (r *entityStateIPAddressStringTypeRepository) Create(ctx context.Context, entity *parent.EntityStateIPAddressStringType) (int64, error) {
	query := "INSERT INTO entity_state_i_p_address_string_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateIPAddressStringTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateIPAddressStringType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_i_p_address_string_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateIPAddressStringTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateIPAddressStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_p_address_string_type WHERE id = ?"

	entity := &parent.EntityStateIPAddressStringType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateIPAddressStringTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateIPAddressStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_p_address_string_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateIPAddressStringType
	for rows.Next() {
		entity := &parent.EntityStateIPAddressStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateIPAddressStringTypeRepository) Update(ctx context.Context, entity *parent.EntityStateIPAddressStringType) error {
	query := "UPDATE entity_state_i_p_address_string_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateIPAddressStringTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_i_p_address_string_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateIPAddressStringTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_i_p_address_string_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateIPAddressStringTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_i_p_address_string_type").Scan(&count)
	return count, err
}

func (r *entityStateIPAddressStringTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateIPAddressStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_p_address_string_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateIPAddressStringType
	for rows.Next() {
		entity := &parent.EntityStateIPAddressStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateIPAddressType() parent.EntityStateIPAddressTypeRepository {
	return &entityStateIPAddressTypeRepository{db: d.db}
}

type entityStateIPAddressTypeRepository struct {
	db *sql.DB
}

func (r *entityStateIPAddressTypeRepository) Create(ctx context.Context, entity *parent.EntityStateIPAddressType) (int64, error) {
	query := "INSERT INTO entity_state_i_p_address_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateIPAddressTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateIPAddressType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_i_p_address_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateIPAddressTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateIPAddressType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_p_address_type WHERE id = ?"

	entity := &parent.EntityStateIPAddressType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateIPAddressTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateIPAddressType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_p_address_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateIPAddressType
	for rows.Next() {
		entity := &parent.EntityStateIPAddressType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateIPAddressTypeRepository) Update(ctx context.Context, entity *parent.EntityStateIPAddressType) error {
	query := "UPDATE entity_state_i_p_address_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateIPAddressTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_i_p_address_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateIPAddressTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_i_p_address_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateIPAddressTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_i_p_address_type").Scan(&count)
	return count, err
}

func (r *entityStateIPAddressTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateIPAddressType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_i_p_address_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateIPAddressType
	for rows.Next() {
		entity := &parent.EntityStateIPAddressType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateIntType() parent.EntityStateIntTypeRepository {
	return &entityStateIntTypeRepository{db: d.db}
}

type entityStateIntTypeRepository struct {
	db *sql.DB
}

func (r *entityStateIntTypeRepository) Create(ctx context.Context, entity *parent.EntityStateIntType) (int64, error) {
	query := "INSERT INTO entity_state_int_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateIntTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateIntType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_int_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateIntTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateIntType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_int_type WHERE id = ?"

	entity := &parent.EntityStateIntType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateIntTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateIntType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_int_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateIntType
	for rows.Next() {
		entity := &parent.EntityStateIntType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateIntTypeRepository) Update(ctx context.Context, entity *parent.EntityStateIntType) error {
	query := "UPDATE entity_state_int_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateIntTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_int_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateIntTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_int_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateIntTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_int_type").Scan(&count)
	return count, err
}

func (r *entityStateIntTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateIntType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_int_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateIntType
	for rows.Next() {
		entity := &parent.EntityStateIntType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateRecordType() parent.EntityStateRecordTypeRepository {
	return &entityStateRecordTypeRepository{db: d.db}
}

type entityStateRecordTypeRepository struct {
	db *sql.DB
}

func (r *entityStateRecordTypeRepository) Create(ctx context.Context, entity *parent.EntityStateRecordType) (int64, error) {
	query := "INSERT INTO entity_state_record_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateRecordTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateRecordType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_record_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateRecordTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateRecordType, error) {
	query := "SELECT id, parent_id FROM entity_state_record_type WHERE id = ?"

	entity := &parent.EntityStateRecordType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateRecordTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateRecordType, error) {
	query := "SELECT id, parent_id FROM entity_state_record_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateRecordType
	for rows.Next() {
		entity := &parent.EntityStateRecordType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateRecordTypeRepository) Update(ctx context.Context, entity *parent.EntityStateRecordType) error {
	query := "UPDATE entity_state_record_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateRecordTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_record_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateRecordTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_record_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateRecordTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_record_type").Scan(&count)
	return count, err
}

func (r *entityStateRecordTypeRepository) GetByEntityStateComplexBaseType(ctx context.Context, entity_state_complex_base_typeID int64) ([]*parent.EntityStateRecordType, error) {
	query := "SELECT id, parent_id FROM entity_state_record_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_complex_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateRecordType
	for rows.Next() {
		entity := &parent.EntityStateRecordType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateStringType() parent.EntityStateStringTypeRepository {
	return &entityStateStringTypeRepository{db: d.db}
}

type entityStateStringTypeRepository struct {
	db *sql.DB
}

func (r *entityStateStringTypeRepository) Create(ctx context.Context, entity *parent.EntityStateStringType) (int64, error) {
	query := "INSERT INTO entity_state_string_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateStringTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateStringType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_string_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateStringTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_string_type WHERE id = ?"

	entity := &parent.EntityStateStringType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateStringTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_string_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateStringType
	for rows.Next() {
		entity := &parent.EntityStateStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateStringTypeRepository) Update(ctx context.Context, entity *parent.EntityStateStringType) error {
	query := "UPDATE entity_state_string_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateStringTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_string_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateStringTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_string_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateStringTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_string_type").Scan(&count)
	return count, err
}

func (r *entityStateStringTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateStringType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_string_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateStringType
	for rows.Next() {
		entity := &parent.EntityStateStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EntityStateVersionType() parent.EntityStateVersionTypeRepository {
	return &entityStateVersionTypeRepository{db: d.db}
}

type entityStateVersionTypeRepository struct {
	db *sql.DB
}

func (r *entityStateVersionTypeRepository) Create(ctx context.Context, entity *parent.EntityStateVersionType) (int64, error) {
	query := "INSERT INTO entity_state_version_type (datatype, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *entityStateVersionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EntityStateVersionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO entity_state_version_type (datatype, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *entityStateVersionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EntityStateVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_version_type WHERE id = ?"

	entity := &parent.EntityStateVersionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *entityStateVersionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EntityStateVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_version_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateVersionType
	for rows.Next() {
		entity := &parent.EntityStateVersionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *entityStateVersionTypeRepository) Update(ctx context.Context, entity *parent.EntityStateVersionType) error {
	query := "UPDATE entity_state_version_type SET datatype = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *entityStateVersionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM entity_state_version_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *entityStateVersionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM entity_state_version_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *entityStateVersionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM entity_state_version_type").Scan(&count)
	return count, err
}

func (r *entityStateVersionTypeRepository) GetByEntityStateSimpleBaseType(ctx context.Context, entity_state_simple_base_typeID int64) ([]*parent.EntityStateVersionType, error) {
	query := "SELECT id, datatype, parent_id FROM entity_state_version_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, entity_state_simple_base_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EntityStateVersionType
	for rows.Next() {
		entity := &parent.EntityStateVersionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) EscapeRegexFunctionType() parent.EscapeRegexFunctionTypeRepository {
	return &escapeRegexFunctionTypeRepository{db: d.db}
}

type escapeRegexFunctionTypeRepository struct {
	db *sql.DB
}

func (r *escapeRegexFunctionTypeRepository) Create(ctx context.Context, entity *parent.EscapeRegexFunctionType) (int64, error) {
	query := "INSERT INTO \"escape_regex_function_type\" DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *escapeRegexFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.EscapeRegexFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"escape_regex_function_type\" DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *escapeRegexFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.EscapeRegexFunctionType, error) {
	query := "SELECT id FROM \"escape_regex_function_type\" WHERE id = ?"

	entity := &parent.EscapeRegexFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *escapeRegexFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.EscapeRegexFunctionType, error) {
	query := "SELECT id FROM \"escape_regex_function_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.EscapeRegexFunctionType
	for rows.Next() {
		entity := &parent.EscapeRegexFunctionType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *escapeRegexFunctionTypeRepository) Update(ctx context.Context, entity *parent.EscapeRegexFunctionType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *escapeRegexFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"escape_regex_function_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *escapeRegexFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"escape_regex_function_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *escapeRegexFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"escape_regex_function_type\"").Scan(&count)
	return count, err
}

func (d *dal) ExtendDefinitionType() parent.ExtendDefinitionTypeRepository {
	return &extendDefinitionTypeRepository{db: d.db}
}

type extendDefinitionTypeRepository struct {
	db *sql.DB
}

func (r *extendDefinitionTypeRepository) Create(ctx context.Context, entity *parent.ExtendDefinitionType) (int64, error) {
	query := "INSERT INTO extend_definition_type (applicability_check, definition_ref, negate, comment) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Applicability_check,
		entity.Definition_ref,
		entity.Negate,
		entity.Comment,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *extendDefinitionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ExtendDefinitionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO extend_definition_type (applicability_check, definition_ref, negate, comment) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Applicability_check,
			entity.Definition_ref,
			entity.Negate,
			entity.Comment,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *extendDefinitionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ExtendDefinitionType, error) {
	query := "SELECT id, applicability_check, definition_ref, negate, comment FROM extend_definition_type WHERE id = ?"

	entity := &parent.ExtendDefinitionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Applicability_check,
		&entity.Definition_ref,
		&entity.Negate,
		&entity.Comment,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *extendDefinitionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ExtendDefinitionType, error) {
	query := "SELECT id, applicability_check, definition_ref, negate, comment FROM extend_definition_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExtendDefinitionType
	for rows.Next() {
		entity := &parent.ExtendDefinitionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Applicability_check,
			&entity.Definition_ref,
			&entity.Negate,
			&entity.Comment,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *extendDefinitionTypeRepository) Update(ctx context.Context, entity *parent.ExtendDefinitionType) error {
	query := "UPDATE extend_definition_type SET applicability_check = ?, definition_ref = ?, negate = ?, comment = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Applicability_check,
		entity.Definition_ref,
		entity.Negate,
		entity.Comment,
		entity.ID,
	)
	return err
}

func (r *extendDefinitionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM extend_definition_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *extendDefinitionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM extend_definition_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *extendDefinitionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM extend_definition_type").Scan(&count)
	return count, err
}

func (d *dal) Extended() parent.ExtendedRepository {
	return &extendedRepository{db: d.db}
}

type extendedRepository struct {
	db *sql.DB
}

func (r *extendedRepository) Create(ctx context.Context, entity *parent.Extended) (int64, error) {
	query := "INSERT INTO extended DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *extendedRepository) CreateBatch(ctx context.Context, entities []*parent.Extended) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO extended DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *extendedRepository) GetByID(ctx context.Context, id int64) (*parent.Extended, error) {
	query := "SELECT id FROM extended WHERE id = ?"

	entity := &parent.Extended{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *extendedRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Extended, error) {
	query := "SELECT id FROM extended LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Extended
	for rows.Next() {
		entity := &parent.Extended{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *extendedRepository) Update(ctx context.Context, entity *parent.Extended) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *extendedRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM extended WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *extendedRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM extended WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *extendedRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM extended").Scan(&count)
	return count, err
}

func (d *dal) ExtendedInfoElementType() parent.ExtendedInfoElementTypeRepository {
	return &extendedInfoElementTypeRepository{db: d.db}
}

type extendedInfoElementTypeRepository struct {
	db *sql.DB
}

func (r *extendedInfoElementTypeRepository) Create(ctx context.Context, entity *parent.ExtendedInfoElementType) (int64, error) {
	query := "INSERT INTO extended_info_element_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *extendedInfoElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ExtendedInfoElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO extended_info_element_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *extendedInfoElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ExtendedInfoElementType, error) {
	query := "SELECT id, xsd_id FROM extended_info_element_type WHERE id = ?"

	entity := &parent.ExtendedInfoElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *extendedInfoElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ExtendedInfoElementType, error) {
	query := "SELECT id, xsd_id FROM extended_info_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExtendedInfoElementType
	for rows.Next() {
		entity := &parent.ExtendedInfoElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *extendedInfoElementTypeRepository) Update(ctx context.Context, entity *parent.ExtendedInfoElementType) error {
	query := "UPDATE extended_info_element_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *extendedInfoElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM extended_info_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *extendedInfoElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM extended_info_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *extendedInfoElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM extended_info_element_type").Scan(&count)
	return count, err
}

func (d *dal) ExtendedInformationElementType() parent.ExtendedInformationElementTypeRepository {
	return &extendedInformationElementTypeRepository{db: d.db}
}

type extendedInformationElementTypeRepository struct {
	db *sql.DB
}

func (r *extendedInformationElementTypeRepository) Create(ctx context.Context, entity *parent.ExtendedInformationElementType) (int64, error) {
	query := "INSERT INTO extended_information_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *extendedInformationElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ExtendedInformationElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO extended_information_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *extendedInformationElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ExtendedInformationElementType, error) {
	query := "SELECT id FROM extended_information_element_type WHERE id = ?"

	entity := &parent.ExtendedInformationElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *extendedInformationElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ExtendedInformationElementType, error) {
	query := "SELECT id FROM extended_information_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExtendedInformationElementType
	for rows.Next() {
		entity := &parent.ExtendedInformationElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *extendedInformationElementTypeRepository) Update(ctx context.Context, entity *parent.ExtendedInformationElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *extendedInformationElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM extended_information_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *extendedInformationElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM extended_information_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *extendedInformationElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM extended_information_element_type").Scan(&count)
	return count, err
}

func (d *dal) ExtendedInfosElementType() parent.ExtendedInfosElementTypeRepository {
	return &extendedInfosElementTypeRepository{db: d.db}
}

type extendedInfosElementTypeRepository struct {
	db *sql.DB
}

func (r *extendedInfosElementTypeRepository) Create(ctx context.Context, entity *parent.ExtendedInfosElementType) (int64, error) {
	query := "INSERT INTO extended_infos_element_type (extended_info) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ExtendedInfo,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *extendedInfosElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ExtendedInfosElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO extended_infos_element_type (extended_info) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ExtendedInfo,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *extendedInfosElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ExtendedInfosElementType, error) {
	query := "SELECT id, extended_info FROM extended_infos_element_type WHERE id = ?"

	entity := &parent.ExtendedInfosElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ExtendedInfo,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *extendedInfosElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ExtendedInfosElementType, error) {
	query := "SELECT id, extended_info FROM extended_infos_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExtendedInfosElementType
	for rows.Next() {
		entity := &parent.ExtendedInfosElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ExtendedInfo,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *extendedInfosElementTypeRepository) Update(ctx context.Context, entity *parent.ExtendedInfosElementType) error {
	query := "UPDATE extended_infos_element_type SET extended_info = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ExtendedInfo,
		entity.ID,
	)
	return err
}

func (r *extendedInfosElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM extended_infos_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *extendedInfosElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM extended_infos_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *extendedInfosElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM extended_infos_element_type").Scan(&count)
	return count, err
}

func (d *dal) ExternalVariable() parent.ExternalVariableRepository {
	return &externalVariableRepository{db: d.db}
}

type externalVariableRepository struct {
	db *sql.DB
}

func (r *externalVariableRepository) Create(ctx context.Context, entity *parent.ExternalVariable) (int64, error) {
	query := "INSERT INTO external_variable (possible_value_id, possible_restriction_id, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Possible_valueID,
		entity.Possible_restrictionID,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *externalVariableRepository) CreateBatch(ctx context.Context, entities []*parent.ExternalVariable) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO external_variable (possible_value_id, possible_restriction_id, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Possible_valueID,
			entity.Possible_restrictionID,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *externalVariableRepository) GetByID(ctx context.Context, id int64) (*parent.ExternalVariable, error) {
	query := "SELECT id, possible_value_id, possible_restriction_id, parent_id FROM external_variable WHERE id = ?"

	entity := &parent.ExternalVariable{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Possible_valueID,
		&entity.Possible_restrictionID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *externalVariableRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ExternalVariable, error) {
	query := "SELECT id, possible_value_id, possible_restriction_id, parent_id FROM external_variable LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExternalVariable
	for rows.Next() {
		entity := &parent.ExternalVariable{}
		err := rows.Scan(
			&entity.ID,
			&entity.Possible_valueID,
			&entity.Possible_restrictionID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *externalVariableRepository) Update(ctx context.Context, entity *parent.ExternalVariable) error {
	query := "UPDATE external_variable SET possible_value_id = ?, possible_restriction_id = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Possible_valueID,
		entity.Possible_restrictionID,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *externalVariableRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM external_variable WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *externalVariableRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM external_variable WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *externalVariableRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM external_variable").Scan(&count)
	return count, err
}

func (r *externalVariableRepository) GetByVariableType(ctx context.Context, variable_typeID int64) ([]*parent.ExternalVariable, error) {
	query := "SELECT id, possible_value_id, possible_restriction_id, parent_id FROM external_variable WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, variable_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExternalVariable
	for rows.Next() {
		entity := &parent.ExternalVariable{}
		err := rows.Scan(
			&entity.ID,
			&entity.Possible_valueID,
			&entity.Possible_restrictionID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ExternalVariableElementType() parent.ExternalVariableElementTypeRepository {
	return &externalVariableElementTypeRepository{db: d.db}
}

type externalVariableElementTypeRepository struct {
	db *sql.DB
}

func (r *externalVariableElementTypeRepository) Create(ctx context.Context, entity *parent.ExternalVariableElementType) (int64, error) {
	query := "INSERT INTO external_variable_element_type (possible_value_id, possible_restriction_id, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Possible_valueID,
		entity.Possible_restrictionID,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *externalVariableElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ExternalVariableElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO external_variable_element_type (possible_value_id, possible_restriction_id, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Possible_valueID,
			entity.Possible_restrictionID,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *externalVariableElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ExternalVariableElementType, error) {
	query := "SELECT id, possible_value_id, possible_restriction_id, parent_id FROM external_variable_element_type WHERE id = ?"

	entity := &parent.ExternalVariableElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Possible_valueID,
		&entity.Possible_restrictionID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *externalVariableElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ExternalVariableElementType, error) {
	query := "SELECT id, possible_value_id, possible_restriction_id, parent_id FROM external_variable_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExternalVariableElementType
	for rows.Next() {
		entity := &parent.ExternalVariableElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Possible_valueID,
			&entity.Possible_restrictionID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *externalVariableElementTypeRepository) Update(ctx context.Context, entity *parent.ExternalVariableElementType) error {
	query := "UPDATE external_variable_element_type SET possible_value_id = ?, possible_restriction_id = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Possible_valueID,
		entity.Possible_restrictionID,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *externalVariableElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM external_variable_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *externalVariableElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM external_variable_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *externalVariableElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM external_variable_element_type").Scan(&count)
	return count, err
}

func (r *externalVariableElementTypeRepository) GetByVariableType(ctx context.Context, variable_typeID int64) ([]*parent.ExternalVariableElementType, error) {
	query := "SELECT id, possible_value_id, possible_restriction_id, parent_id FROM external_variable_element_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, variable_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExternalVariableElementType
	for rows.Next() {
		entity := &parent.ExternalVariableElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Possible_valueID,
			&entity.Possible_restrictionID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *externalVariableElementTypeRepository) GetByPossibleValueType(ctx context.Context, possible_value_typeID int64) ([]*parent.ExternalVariableElementType, error) {
	query := "SELECT id, possible_value_id, possible_restriction_id, parent_id FROM external_variable_element_type WHERE possible_value_id = ?"

	rows, err := r.db.QueryContext(ctx, query, possible_value_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExternalVariableElementType
	for rows.Next() {
		entity := &parent.ExternalVariableElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Possible_valueID,
			&entity.Possible_restrictionID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *externalVariableElementTypeRepository) GetByPossibleRestrictionType(ctx context.Context, possible_restriction_typeID int64) ([]*parent.ExternalVariableElementType, error) {
	query := "SELECT id, possible_value_id, possible_restriction_id, parent_id FROM external_variable_element_type WHERE possible_restriction_id = ?"

	rows, err := r.db.QueryContext(ctx, query, possible_restriction_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ExternalVariableElementType
	for rows.Next() {
		entity := &parent.ExternalVariableElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Possible_valueID,
			&entity.Possible_restrictionID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) FactRefType() parent.FactRefTypeRepository {
	return &factRefTypeRepository{db: d.db}
}

type factRefTypeRepository struct {
	db *sql.DB
}

func (r *factRefTypeRepository) Create(ctx context.Context, entity *parent.FactRefType) (int64, error) {
	query := "INSERT INTO fact_ref_type (name) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Name,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *factRefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FactRefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO fact_ref_type (name) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Name,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *factRefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FactRefType, error) {
	query := "SELECT id, name FROM fact_ref_type WHERE id = ?"

	entity := &parent.FactRefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Name,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *factRefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FactRefType, error) {
	query := "SELECT id, name FROM fact_ref_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FactRefType
	for rows.Next() {
		entity := &parent.FactRefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Name,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *factRefTypeRepository) Update(ctx context.Context, entity *parent.FactRefType) error {
	query := "UPDATE fact_ref_type SET name = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.ID,
	)
	return err
}

func (r *factRefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM fact_ref_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *factRefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM fact_ref_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *factRefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM fact_ref_type").Scan(&count)
	return count, err
}

func (d *dal) FactType() parent.FactTypeRepository {
	return &factTypeRepository{db: d.db}
}

type factTypeRepository struct {
	db *sql.DB
}

func (r *factTypeRepository) Create(ctx context.Context, entity *parent.FactType) (int64, error) {
	query := "INSERT INTO fact_type (name, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *factTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FactType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO fact_type (name, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Name,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *factTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FactType, error) {
	query := "SELECT id, name, type FROM fact_type WHERE id = ?"

	entity := &parent.FactType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Name,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *factTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FactType, error) {
	query := "SELECT id, name, type FROM fact_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FactType
	for rows.Next() {
		entity := &parent.FactType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Name,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *factTypeRepository) Update(ctx context.Context, entity *parent.FactType) error {
	query := "UPDATE fact_type SET name = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *factTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM fact_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *factTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM fact_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *factTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM fact_type").Scan(&count)
	return count, err
}

func (d *dal) Filter() parent.FilterRepository {
	return &filterRepository{db: d.db}
}

type filterRepository struct {
	db *sql.DB
}

func (r *filterRepository) Create(ctx context.Context, entity *parent.Filter) (int64, error) {
	query := "INSERT INTO filter (action, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Action,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *filterRepository) CreateBatch(ctx context.Context, entities []*parent.Filter) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO filter (action, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Action,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *filterRepository) GetByID(ctx context.Context, id int64) (*parent.Filter, error) {
	query := "SELECT id, action, parent_id FROM filter WHERE id = ?"

	entity := &parent.Filter{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Action,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *filterRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Filter, error) {
	query := "SELECT id, action, parent_id FROM filter LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Filter
	for rows.Next() {
		entity := &parent.Filter{}
		err := rows.Scan(
			&entity.ID,
			&entity.Action,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *filterRepository) Update(ctx context.Context, entity *parent.Filter) error {
	query := "UPDATE filter SET action = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Action,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *filterRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM filter WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *filterRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM filter WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *filterRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM filter").Scan(&count)
	return count, err
}

func (d *dal) FilterElementType() parent.FilterElementTypeRepository {
	return &filterElementTypeRepository{db: d.db}
}

type filterElementTypeRepository struct {
	db *sql.DB
}

func (r *filterElementTypeRepository) Create(ctx context.Context, entity *parent.FilterElementType) (int64, error) {
	query := "INSERT INTO filter_element_type (action, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Action,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *filterElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FilterElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO filter_element_type (action, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Action,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *filterElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FilterElementType, error) {
	query := "SELECT id, action, parent_id FROM filter_element_type WHERE id = ?"

	entity := &parent.FilterElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Action,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *filterElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FilterElementType, error) {
	query := "SELECT id, action, parent_id FROM filter_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FilterElementType
	for rows.Next() {
		entity := &parent.FilterElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Action,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *filterElementTypeRepository) Update(ctx context.Context, entity *parent.FilterElementType) error {
	query := "UPDATE filter_element_type SET action = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Action,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *filterElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM filter_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *filterElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM filter_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *filterElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM filter_element_type").Scan(&count)
	return count, err
}

func (d *dal) FirmNameElementType() parent.FirmNameElementTypeRepository {
	return &firmNameElementTypeRepository{db: d.db}
}

type firmNameElementTypeRepository struct {
	db *sql.DB
}

func (r *firmNameElementTypeRepository) Create(ctx context.Context, entity *parent.FirmNameElementType) (int64, error) {
	query := "INSERT INTO firm_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *firmNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FirmNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO firm_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *firmNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FirmNameElementType, error) {
	query := "SELECT id, type FROM firm_name_element_type WHERE id = ?"

	entity := &parent.FirmNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *firmNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FirmNameElementType, error) {
	query := "SELECT id, type FROM firm_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FirmNameElementType
	for rows.Next() {
		entity := &parent.FirmNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *firmNameElementTypeRepository) Update(ctx context.Context, entity *parent.FirmNameElementType) error {
	query := "UPDATE firm_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *firmNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM firm_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *firmNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM firm_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *firmNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM firm_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) FirmType() parent.FirmTypeRepository {
	return &firmTypeRepository{db: d.db}
}

type firmTypeRepository struct {
	db *sql.DB
}

func (r *firmTypeRepository) Create(ctx context.Context, entity *parent.FirmType) (int64, error) {
	query := "INSERT INTO firm_type (type, firm_name, mail_stop_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.FirmName,
		entity.MailStopID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *firmTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FirmType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO firm_type (type, firm_name, mail_stop_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.FirmName,
			entity.MailStopID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *firmTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FirmType, error) {
	query := "SELECT id, type, firm_name, mail_stop_id FROM firm_type WHERE id = ?"

	entity := &parent.FirmType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.FirmName,
		&entity.MailStopID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *firmTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FirmType, error) {
	query := "SELECT id, type, firm_name, mail_stop_id FROM firm_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FirmType
	for rows.Next() {
		entity := &parent.FirmType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.FirmName,
			&entity.MailStopID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *firmTypeRepository) Update(ctx context.Context, entity *parent.FirmType) error {
	query := "UPDATE firm_type SET type = ?, firm_name = ?, mail_stop_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.FirmName,
		entity.MailStopID,
		entity.ID,
	)
	return err
}

func (r *firmTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM firm_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *firmTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM firm_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *firmTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM firm_type").Scan(&count)
	return count, err
}

func (r *firmTypeRepository) GetByMailStopType(ctx context.Context, mail_stop_typeID int64) ([]*parent.FirmType, error) {
	query := "SELECT id, type, firm_name, mail_stop_id FROM firm_type WHERE mail_stop_id = ?"

	rows, err := r.db.QueryContext(ctx, query, mail_stop_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FirmType
	for rows.Next() {
		entity := &parent.FirmType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.FirmName,
			&entity.MailStopID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) FirstNameElementType() parent.FirstNameElementTypeRepository {
	return &firstNameElementTypeRepository{db: d.db}
}

type firstNameElementTypeRepository struct {
	db *sql.DB
}

func (r *firstNameElementTypeRepository) Create(ctx context.Context, entity *parent.FirstNameElementType) (int64, error) {
	query := "INSERT INTO first_name_element_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *firstNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FirstNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO first_name_element_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *firstNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FirstNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM first_name_element_type WHERE id = ?"

	entity := &parent.FirstNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *firstNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FirstNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM first_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FirstNameElementType
	for rows.Next() {
		entity := &parent.FirstNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *firstNameElementTypeRepository) Update(ctx context.Context, entity *parent.FirstNameElementType) error {
	query := "UPDATE first_name_element_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *firstNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM first_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *firstNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM first_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *firstNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM first_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) FixTextType() parent.FixTextTypeRepository {
	return &fixTextTypeRepository{db: d.db}
}

type fixTextTypeRepository struct {
	db *sql.DB
}

func (r *fixTextTypeRepository) Create(ctx context.Context, entity *parent.FixTextType) (int64, error) {
	query := "INSERT INTO fix_text_type (fixref, reboot, strategy, disruption, complexity, parent_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Fixref,
		entity.Reboot,
		entity.Strategy,
		entity.Disruption,
		entity.Complexity,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *fixTextTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FixTextType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO fix_text_type (fixref, reboot, strategy, disruption, complexity, parent_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Fixref,
			entity.Reboot,
			entity.Strategy,
			entity.Disruption,
			entity.Complexity,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *fixTextTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FixTextType, error) {
	query := "SELECT id, fixref, reboot, strategy, disruption, complexity, parent_id FROM fix_text_type WHERE id = ?"

	entity := &parent.FixTextType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Fixref,
		&entity.Reboot,
		&entity.Strategy,
		&entity.Disruption,
		&entity.Complexity,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *fixTextTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FixTextType, error) {
	query := "SELECT id, fixref, reboot, strategy, disruption, complexity, parent_id FROM fix_text_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FixTextType
	for rows.Next() {
		entity := &parent.FixTextType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Fixref,
			&entity.Reboot,
			&entity.Strategy,
			&entity.Disruption,
			&entity.Complexity,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *fixTextTypeRepository) Update(ctx context.Context, entity *parent.FixTextType) error {
	query := "UPDATE fix_text_type SET fixref = ?, reboot = ?, strategy = ?, disruption = ?, complexity = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Fixref,
		entity.Reboot,
		entity.Strategy,
		entity.Disruption,
		entity.Complexity,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *fixTextTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM fix_text_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *fixTextTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM fix_text_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *fixTextTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM fix_text_type").Scan(&count)
	return count, err
}

func (r *fixTextTypeRepository) GetByHtmlTextWithSubType(ctx context.Context, html_text_with_sub_typeID int64) ([]*parent.FixTextType, error) {
	query := "SELECT id, fixref, reboot, strategy, disruption, complexity, parent_id FROM fix_text_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, html_text_with_sub_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FixTextType
	for rows.Next() {
		entity := &parent.FixTextType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Fixref,
			&entity.Reboot,
			&entity.Strategy,
			&entity.Disruption,
			&entity.Complexity,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) FixType() parent.FixTypeRepository {
	return &fixTypeRepository{db: d.db}
}

type fixTypeRepository struct {
	db *sql.DB
}

func (r *fixTypeRepository) Create(ctx context.Context, entity *parent.FixType) (int64, error) {
	query := "INSERT INTO fix_type (xsd_id, reboot, strategy, disruption, complexity, system, platform, sub_id, instance_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Reboot,
		entity.Strategy,
		entity.Disruption,
		entity.Complexity,
		entity.System,
		entity.Platform,
		entity.SubID,
		entity.InstanceID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *fixTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FixType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO fix_type (xsd_id, reboot, strategy, disruption, complexity, system, platform, sub_id, instance_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Reboot,
			entity.Strategy,
			entity.Disruption,
			entity.Complexity,
			entity.System,
			entity.Platform,
			entity.SubID,
			entity.InstanceID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *fixTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FixType, error) {
	query := "SELECT id, xsd_id, reboot, strategy, disruption, complexity, system, platform, sub_id, instance_id FROM fix_type WHERE id = ?"

	entity := &parent.FixType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Reboot,
		&entity.Strategy,
		&entity.Disruption,
		&entity.Complexity,
		&entity.System,
		&entity.Platform,
		&entity.SubID,
		&entity.InstanceID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *fixTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FixType, error) {
	query := "SELECT id, xsd_id, reboot, strategy, disruption, complexity, system, platform, sub_id, instance_id FROM fix_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FixType
	for rows.Next() {
		entity := &parent.FixType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Reboot,
			&entity.Strategy,
			&entity.Disruption,
			&entity.Complexity,
			&entity.System,
			&entity.Platform,
			&entity.SubID,
			&entity.InstanceID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *fixTypeRepository) Update(ctx context.Context, entity *parent.FixType) error {
	query := "UPDATE fix_type SET xsd_id = ?, reboot = ?, strategy = ?, disruption = ?, complexity = ?, system = ?, platform = ?, sub_id = ?, instance_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Reboot,
		entity.Strategy,
		entity.Disruption,
		entity.Complexity,
		entity.System,
		entity.Platform,
		entity.SubID,
		entity.InstanceID,
		entity.ID,
	)
	return err
}

func (r *fixTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM fix_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *fixTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM fix_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *fixTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM fix_type").Scan(&count)
	return count, err
}

func (r *fixTypeRepository) GetBySubType(ctx context.Context, sub_typeID int64) ([]*parent.FixType, error) {
	query := "SELECT id, xsd_id, reboot, strategy, disruption, complexity, system, platform, sub_id, instance_id FROM fix_type WHERE sub_id = ?"

	rows, err := r.db.QueryContext(ctx, query, sub_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FixType
	for rows.Next() {
		entity := &parent.FixType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Reboot,
			&entity.Strategy,
			&entity.Disruption,
			&entity.Complexity,
			&entity.System,
			&entity.Platform,
			&entity.SubID,
			&entity.InstanceID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *fixTypeRepository) GetByInstanceFixType(ctx context.Context, instance_fix_typeID int64) ([]*parent.FixType, error) {
	query := "SELECT id, xsd_id, reboot, strategy, disruption, complexity, system, platform, sub_id, instance_id FROM fix_type WHERE instance_id = ?"

	rows, err := r.db.QueryContext(ctx, query, instance_fix_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FixType
	for rows.Next() {
		entity := &parent.FixType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Reboot,
			&entity.Strategy,
			&entity.Disruption,
			&entity.Complexity,
			&entity.System,
			&entity.Platform,
			&entity.SubID,
			&entity.InstanceID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) FormerNameElementType() parent.FormerNameElementTypeRepository {
	return &formerNameElementTypeRepository{db: d.db}
}

type formerNameElementTypeRepository struct {
	db *sql.DB
}

func (r *formerNameElementTypeRepository) Create(ctx context.Context, entity *parent.FormerNameElementType) (int64, error) {
	query := "INSERT INTO former_name_element_type (valid_from, valid_to, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ValidFrom,
		entity.ValidTo,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *formerNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FormerNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO former_name_element_type (valid_from, valid_to, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ValidFrom,
			entity.ValidTo,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *formerNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FormerNameElementType, error) {
	query := "SELECT id, valid_from, valid_to, parent_id FROM former_name_element_type WHERE id = ?"

	entity := &parent.FormerNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ValidFrom,
		&entity.ValidTo,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *formerNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FormerNameElementType, error) {
	query := "SELECT id, valid_from, valid_to, parent_id FROM former_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FormerNameElementType
	for rows.Next() {
		entity := &parent.FormerNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ValidFrom,
			&entity.ValidTo,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *formerNameElementTypeRepository) Update(ctx context.Context, entity *parent.FormerNameElementType) error {
	query := "UPDATE former_name_element_type SET valid_from = ?, valid_to = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ValidFrom,
		entity.ValidTo,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *formerNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM former_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *formerNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM former_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *formerNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM former_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) Fqdn() parent.FqdnRepository {
	return &fqdnRepository{db: d.db}
}

type fqdnRepository struct {
	db *sql.DB
}

func (r *fqdnRepository) Create(ctx context.Context, entity *parent.Fqdn) (int64, error) {
	query := "INSERT INTO fqdn DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *fqdnRepository) CreateBatch(ctx context.Context, entities []*parent.Fqdn) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO fqdn DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *fqdnRepository) GetByID(ctx context.Context, id int64) (*parent.Fqdn, error) {
	query := "SELECT id FROM fqdn WHERE id = ?"

	entity := &parent.Fqdn{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *fqdnRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Fqdn, error) {
	query := "SELECT id FROM fqdn LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Fqdn
	for rows.Next() {
		entity := &parent.Fqdn{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *fqdnRepository) Update(ctx context.Context, entity *parent.Fqdn) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *fqdnRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM fqdn WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *fqdnRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM fqdn WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *fqdnRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM fqdn").Scan(&count)
	return count, err
}

func (d *dal) FqdnElementType() parent.FqdnElementTypeRepository {
	return &fqdnElementTypeRepository{db: d.db}
}

type fqdnElementTypeRepository struct {
	db *sql.DB
}

func (r *fqdnElementTypeRepository) Create(ctx context.Context, entity *parent.FqdnElementType) (int64, error) {
	query := "INSERT INTO fqdn_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *fqdnElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.FqdnElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO fqdn_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *fqdnElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.FqdnElementType, error) {
	query := "SELECT id FROM fqdn_element_type WHERE id = ?"

	entity := &parent.FqdnElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *fqdnElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.FqdnElementType, error) {
	query := "SELECT id FROM fqdn_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.FqdnElementType
	for rows.Next() {
		entity := &parent.FqdnElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *fqdnElementTypeRepository) Update(ctx context.Context, entity *parent.FqdnElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *fqdnElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM fqdn_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *fqdnElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM fqdn_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *fqdnElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM fqdn_element_type").Scan(&count)
	return count, err
}

func (d *dal) Function() parent.FunctionRepository {
	return &functionRepository{db: d.db}
}

type functionRepository struct {
	db *sql.DB
}

func (r *functionRepository) Create(ctx context.Context, entity *parent.Function) (int64, error) {
	query := "INSERT INTO function (code) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *functionRepository) CreateBatch(ctx context.Context, entities []*parent.Function) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO function (code) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *functionRepository) GetByID(ctx context.Context, id int64) (*parent.Function, error) {
	query := "SELECT id, code FROM function WHERE id = ?"

	entity := &parent.Function{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *functionRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Function, error) {
	query := "SELECT id, code FROM function LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Function
	for rows.Next() {
		entity := &parent.Function{}
		err := rows.Scan(
			&entity.ID,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *functionRepository) Update(ctx context.Context, entity *parent.Function) error {
	query := "UPDATE function SET code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *functionRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM function WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *functionRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM function WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *functionRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM function").Scan(&count)
	return count, err
}

func (d *dal) GeneralSuffixElementType() parent.GeneralSuffixElementTypeRepository {
	return &generalSuffixElementTypeRepository{db: d.db}
}

type generalSuffixElementTypeRepository struct {
	db *sql.DB
}

func (r *generalSuffixElementTypeRepository) Create(ctx context.Context, entity *parent.GeneralSuffixElementType) (int64, error) {
	query := "INSERT INTO general_suffix_element_type (type, code) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *generalSuffixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.GeneralSuffixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO general_suffix_element_type (type, code) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *generalSuffixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.GeneralSuffixElementType, error) {
	query := "SELECT id, type, code FROM general_suffix_element_type WHERE id = ?"

	entity := &parent.GeneralSuffixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *generalSuffixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.GeneralSuffixElementType, error) {
	query := "SELECT id, type, code FROM general_suffix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.GeneralSuffixElementType
	for rows.Next() {
		entity := &parent.GeneralSuffixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *generalSuffixElementTypeRepository) Update(ctx context.Context, entity *parent.GeneralSuffixElementType) error {
	query := "UPDATE general_suffix_element_type SET type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *generalSuffixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM general_suffix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *generalSuffixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM general_suffix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *generalSuffixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM general_suffix_element_type").Scan(&count)
	return count, err
}

func (d *dal) GenerationIdentifierElementType() parent.GenerationIdentifierElementTypeRepository {
	return &generationIdentifierElementTypeRepository{db: d.db}
}

type generationIdentifierElementTypeRepository struct {
	db *sql.DB
}

func (r *generationIdentifierElementTypeRepository) Create(ctx context.Context, entity *parent.GenerationIdentifierElementType) (int64, error) {
	query := "INSERT INTO generation_identifier_element_type (type, code) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *generationIdentifierElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.GenerationIdentifierElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO generation_identifier_element_type (type, code) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *generationIdentifierElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.GenerationIdentifierElementType, error) {
	query := "SELECT id, type, code FROM generation_identifier_element_type WHERE id = ?"

	entity := &parent.GenerationIdentifierElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *generationIdentifierElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.GenerationIdentifierElementType, error) {
	query := "SELECT id, type, code FROM generation_identifier_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.GenerationIdentifierElementType
	for rows.Next() {
		entity := &parent.GenerationIdentifierElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *generationIdentifierElementTypeRepository) Update(ctx context.Context, entity *parent.GenerationIdentifierElementType) error {
	query := "UPDATE generation_identifier_element_type SET type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *generationIdentifierElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM generation_identifier_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *generationIdentifierElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM generation_identifier_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *generationIdentifierElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM generation_identifier_element_type").Scan(&count)
	return count, err
}

func (d *dal) GlobToRegexFunctionType() parent.GlobToRegexFunctionTypeRepository {
	return &globToRegexFunctionTypeRepository{db: d.db}
}

type globToRegexFunctionTypeRepository struct {
	db *sql.DB
}

func (r *globToRegexFunctionTypeRepository) Create(ctx context.Context, entity *parent.GlobToRegexFunctionType) (int64, error) {
	query := "INSERT INTO \"glob_to_regex_function_type\" (glob_noescape) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Glob_noescape,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *globToRegexFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.GlobToRegexFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"glob_to_regex_function_type\" (glob_noescape) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Glob_noescape,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *globToRegexFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.GlobToRegexFunctionType, error) {
	query := "SELECT id, glob_noescape FROM \"glob_to_regex_function_type\" WHERE id = ?"

	entity := &parent.GlobToRegexFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Glob_noescape,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *globToRegexFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.GlobToRegexFunctionType, error) {
	query := "SELECT id, glob_noescape FROM \"glob_to_regex_function_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.GlobToRegexFunctionType
	for rows.Next() {
		entity := &parent.GlobToRegexFunctionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Glob_noescape,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *globToRegexFunctionTypeRepository) Update(ctx context.Context, entity *parent.GlobToRegexFunctionType) error {
	query := "UPDATE \"glob_to_regex_function_type\" SET glob_noescape = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Glob_noescape,
		entity.ID,
	)
	return err
}

func (r *globToRegexFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"glob_to_regex_function_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *globToRegexFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"glob_to_regex_function_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *globToRegexFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"glob_to_regex_function_type\"").Scan(&count)
	return count, err
}

func (d *dal) GroupType() parent.GroupTypeRepository {
	return &groupTypeRepository{db: d.db}
}

type groupTypeRepository struct {
	db *sql.DB
}

func (r *groupTypeRepository) Create(ctx context.Context, entity *parent.GroupType) (int64, error) {
	query := "INSERT INTO \"group_type\" (xsd_id, signature_id, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.SignatureID,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *groupTypeRepository) CreateBatch(ctx context.Context, entities []*parent.GroupType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"group_type\" (xsd_id, signature_id, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.SignatureID,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *groupTypeRepository) GetByID(ctx context.Context, id int64) (*parent.GroupType, error) {
	query := "SELECT id, xsd_id, signature_id, parent_id FROM \"group_type\" WHERE id = ?"

	entity := &parent.GroupType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.SignatureID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *groupTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.GroupType, error) {
	query := "SELECT id, xsd_id, signature_id, parent_id FROM \"group_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.GroupType
	for rows.Next() {
		entity := &parent.GroupType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.SignatureID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *groupTypeRepository) Update(ctx context.Context, entity *parent.GroupType) error {
	query := "UPDATE \"group_type\" SET xsd_id = ?, signature_id = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.SignatureID,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *groupTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"group_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *groupTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"group_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *groupTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"group_type\"").Scan(&count)
	return count, err
}

func (r *groupTypeRepository) GetBySelectableItemType(ctx context.Context, selectable_item_typeID int64) ([]*parent.GroupType, error) {
	query := "SELECT id, xsd_id, signature_id, parent_id FROM \"group_type\" WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, selectable_item_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.GroupType
	for rows.Next() {
		entity := &parent.GroupType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.SignatureID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) HostElementType() parent.HostElementTypeRepository {
	return &hostElementTypeRepository{db: d.db}
}

type hostElementTypeRepository struct {
	db *sql.DB
}

func (r *hostElementTypeRepository) Create(ctx context.Context, entity *parent.HostElementType) (int64, error) {
	query := "INSERT INTO host_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *hostElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.HostElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO host_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *hostElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.HostElementType, error) {
	query := "SELECT id FROM host_element_type WHERE id = ?"

	entity := &parent.HostElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *hostElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.HostElementType, error) {
	query := "SELECT id FROM host_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.HostElementType
	for rows.Next() {
		entity := &parent.HostElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *hostElementTypeRepository) Update(ctx context.Context, entity *parent.HostElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *hostElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM host_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *hostElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM host_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *hostElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM host_element_type").Scan(&count)
	return count, err
}

func (d *dal) HostnameElementType() parent.HostnameElementTypeRepository {
	return &hostnameElementTypeRepository{db: d.db}
}

type hostnameElementTypeRepository struct {
	db *sql.DB
}

func (r *hostnameElementTypeRepository) Create(ctx context.Context, entity *parent.HostnameElementType) (int64, error) {
	query := "INSERT INTO hostname_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *hostnameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.HostnameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO hostname_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *hostnameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.HostnameElementType, error) {
	query := "SELECT id, parent_id FROM hostname_element_type WHERE id = ?"

	entity := &parent.HostnameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *hostnameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.HostnameElementType, error) {
	query := "SELECT id, parent_id FROM hostname_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.HostnameElementType
	for rows.Next() {
		entity := &parent.HostnameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *hostnameElementTypeRepository) Update(ctx context.Context, entity *parent.HostnameElementType) error {
	query := "UPDATE hostname_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *hostnameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM hostname_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *hostnameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM hostname_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *hostnameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM hostname_element_type").Scan(&count)
	return count, err
}

func (d *dal) HtmlTextType() parent.HtmlTextTypeRepository {
	return &htmlTextTypeRepository{db: d.db}
}

type htmlTextTypeRepository struct {
	db *sql.DB
}

func (r *htmlTextTypeRepository) Create(ctx context.Context, entity *parent.HtmlTextType) (int64, error) {
	query := "INSERT INTO html_text_type (override) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Override,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *htmlTextTypeRepository) CreateBatch(ctx context.Context, entities []*parent.HtmlTextType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO html_text_type (override) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Override,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *htmlTextTypeRepository) GetByID(ctx context.Context, id int64) (*parent.HtmlTextType, error) {
	query := "SELECT id, override FROM html_text_type WHERE id = ?"

	entity := &parent.HtmlTextType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Override,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *htmlTextTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.HtmlTextType, error) {
	query := "SELECT id, override FROM html_text_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.HtmlTextType
	for rows.Next() {
		entity := &parent.HtmlTextType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Override,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *htmlTextTypeRepository) Update(ctx context.Context, entity *parent.HtmlTextType) error {
	query := "UPDATE html_text_type SET override = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Override,
		entity.ID,
	)
	return err
}

func (r *htmlTextTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM html_text_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *htmlTextTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM html_text_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *htmlTextTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM html_text_type").Scan(&count)
	return count, err
}

func (d *dal) HtmlTextWithSubType() parent.HtmlTextWithSubTypeRepository {
	return &htmlTextWithSubTypeRepository{db: d.db}
}

type htmlTextWithSubTypeRepository struct {
	db *sql.DB
}

func (r *htmlTextWithSubTypeRepository) Create(ctx context.Context, entity *parent.HtmlTextWithSubType) (int64, error) {
	query := "INSERT INTO \"html_text_with_sub_type\" (override, sub_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Override,
		entity.SubID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *htmlTextWithSubTypeRepository) CreateBatch(ctx context.Context, entities []*parent.HtmlTextWithSubType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"html_text_with_sub_type\" (override, sub_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Override,
			entity.SubID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *htmlTextWithSubTypeRepository) GetByID(ctx context.Context, id int64) (*parent.HtmlTextWithSubType, error) {
	query := "SELECT id, override, sub_id FROM \"html_text_with_sub_type\" WHERE id = ?"

	entity := &parent.HtmlTextWithSubType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Override,
		&entity.SubID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *htmlTextWithSubTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.HtmlTextWithSubType, error) {
	query := "SELECT id, override, sub_id FROM \"html_text_with_sub_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.HtmlTextWithSubType
	for rows.Next() {
		entity := &parent.HtmlTextWithSubType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Override,
			&entity.SubID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *htmlTextWithSubTypeRepository) Update(ctx context.Context, entity *parent.HtmlTextWithSubType) error {
	query := "UPDATE \"html_text_with_sub_type\" SET override = ?, sub_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Override,
		entity.SubID,
		entity.ID,
	)
	return err
}

func (r *htmlTextWithSubTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"html_text_with_sub_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *htmlTextWithSubTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"html_text_with_sub_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *htmlTextWithSubTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"html_text_with_sub_type\"").Scan(&count)
	return count, err
}

func (r *htmlTextWithSubTypeRepository) GetBySubType(ctx context.Context, sub_typeID int64) ([]*parent.HtmlTextWithSubType, error) {
	query := "SELECT id, override, sub_id FROM \"html_text_with_sub_type\" WHERE sub_id = ?"

	rows, err := r.db.QueryContext(ctx, query, sub_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.HtmlTextWithSubType
	for rows.Next() {
		entity := &parent.HtmlTextWithSubType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Override,
			&entity.SubID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) IdentType() parent.IdentTypeRepository {
	return &identTypeRepository{db: d.db}
}

type identTypeRepository struct {
	db *sql.DB
}

func (r *identTypeRepository) Create(ctx context.Context, entity *parent.IdentType) (int64, error) {
	query := "INSERT INTO ident_type (system) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.System,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *identTypeRepository) CreateBatch(ctx context.Context, entities []*parent.IdentType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO ident_type (system) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.System,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *identTypeRepository) GetByID(ctx context.Context, id int64) (*parent.IdentType, error) {
	query := "SELECT id, system FROM ident_type WHERE id = ?"

	entity := &parent.IdentType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.System,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *identTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.IdentType, error) {
	query := "SELECT id, system FROM ident_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IdentType
	for rows.Next() {
		entity := &parent.IdentType{}
		err := rows.Scan(
			&entity.ID,
			&entity.System,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *identTypeRepository) Update(ctx context.Context, entity *parent.IdentType) error {
	query := "UPDATE ident_type SET system = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.ID,
	)
	return err
}

func (r *identTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM ident_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *identTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM ident_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *identTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM ident_type").Scan(&count)
	return count, err
}

func (d *dal) IdentityType() parent.IdentityTypeRepository {
	return &identityTypeRepository{db: d.db}
}

type identityTypeRepository struct {
	db *sql.DB
}

func (r *identityTypeRepository) Create(ctx context.Context, entity *parent.IdentityType) (int64, error) {
	query := "INSERT INTO identity_type (authenticated, privileged) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Authenticated,
		entity.Privileged,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *identityTypeRepository) CreateBatch(ctx context.Context, entities []*parent.IdentityType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO identity_type (authenticated, privileged) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Authenticated,
			entity.Privileged,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *identityTypeRepository) GetByID(ctx context.Context, id int64) (*parent.IdentityType, error) {
	query := "SELECT id, authenticated, privileged FROM identity_type WHERE id = ?"

	entity := &parent.IdentityType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Authenticated,
		&entity.Privileged,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *identityTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.IdentityType, error) {
	query := "SELECT id, authenticated, privileged FROM identity_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IdentityType
	for rows.Next() {
		entity := &parent.IdentityType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Authenticated,
			&entity.Privileged,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *identityTypeRepository) Update(ctx context.Context, entity *parent.IdentityType) error {
	query := "UPDATE identity_type SET authenticated = ?, privileged = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Authenticated,
		entity.Privileged,
		entity.ID,
	)
	return err
}

func (r *identityTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM identity_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *identityTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM identity_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *identityTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM identity_type").Scan(&count)
	return count, err
}

func (d *dal) IdrefListType() parent.IdrefListTypeRepository {
	return &idrefListTypeRepository{db: d.db}
}

type idrefListTypeRepository struct {
	db *sql.DB
}

func (r *idrefListTypeRepository) Create(ctx context.Context, entity *parent.IdrefListType) (int64, error) {
	idrefJSON, err := json.Marshal(entity.Idref)
	if err != nil {
		return 0, fmt.Errorf("failed to marshal Idref: %w", err)
	}
	query := "INSERT INTO idref_list_type (idref) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		string(idrefJSON),
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *idrefListTypeRepository) CreateBatch(ctx context.Context, entities []*parent.IdrefListType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO idref_list_type (idref) VALUES (?)"
	for _, entity := range entities {
		idrefJSON, err := json.Marshal(entity.Idref)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal Idref: %w", err)
		}
		result, err := tx.ExecContext(ctx, query,
			string(idrefJSON),
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *idrefListTypeRepository) GetByID(ctx context.Context, id int64) (*parent.IdrefListType, error) {
	query := "SELECT id, idref FROM idref_list_type WHERE id = ?"

	entity := &parent.IdrefListType{}
	var idrefJSON string
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&idrefJSON,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	if idrefJSON != "" {
		if err := json.Unmarshal([]byte(idrefJSON), &entity.Idref); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Idref: %w", err)
		}
	}

	return entity, nil
}

func (r *idrefListTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.IdrefListType, error) {
	query := "SELECT id, idref FROM idref_list_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IdrefListType
	for rows.Next() {
		entity := &parent.IdrefListType{}
		var idrefJSON string
		err := rows.Scan(
			&entity.ID,
			&idrefJSON,
		)
		if err != nil {
			return nil, err
		}
		if idrefJSON != "" {
			if err := json.Unmarshal([]byte(idrefJSON), &entity.Idref); err != nil {
				return nil, fmt.Errorf("failed to unmarshal Idref: %w", err)
			}
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *idrefListTypeRepository) Update(ctx context.Context, entity *parent.IdrefListType) error {
	idrefJSON, err := json.Marshal(entity.Idref)
	if err != nil {
		return fmt.Errorf("failed to marshal Idref: %w", err)
	}
	query := "UPDATE idref_list_type SET idref = ? WHERE id = ?"
	
	_, err = r.db.ExecContext(ctx, query,
		string(idrefJSON),
		entity.ID,
	)
	return err
}

func (r *idrefListTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM idref_list_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *idrefListTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM idref_list_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *idrefListTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM idref_list_type").Scan(&count)
	return count, err
}

func (d *dal) IdrefType() parent.IdrefTypeRepository {
	return &idrefTypeRepository{db: d.db}
}

type idrefTypeRepository struct {
	db *sql.DB
}

func (r *idrefTypeRepository) Create(ctx context.Context, entity *parent.IdrefType) (int64, error) {
	query := "INSERT INTO idref_type (idref) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Idref,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *idrefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.IdrefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO idref_type (idref) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Idref,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *idrefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.IdrefType, error) {
	query := "SELECT id, idref FROM idref_type WHERE id = ?"

	entity := &parent.IdrefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Idref,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *idrefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.IdrefType, error) {
	query := "SELECT id, idref FROM idref_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IdrefType
	for rows.Next() {
		entity := &parent.IdrefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *idrefTypeRepository) Update(ctx context.Context, entity *parent.IdrefType) error {
	query := "UPDATE idref_type SET idref = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.ID,
	)
	return err
}

func (r *idrefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM idref_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *idrefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM idref_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *idrefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM idref_type").Scan(&count)
	return count, err
}

func (d *dal) InstallationIdElementType() parent.InstallationIdElementTypeRepository {
	return &installationIdElementTypeRepository{db: d.db}
}

type installationIdElementTypeRepository struct {
	db *sql.DB
}

func (r *installationIdElementTypeRepository) Create(ctx context.Context, entity *parent.InstallationIdElementType) (int64, error) {
	query := "INSERT INTO installation_id_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *installationIdElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.InstallationIdElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO installation_id_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *installationIdElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.InstallationIdElementType, error) {
	query := "SELECT id FROM installation_id_element_type WHERE id = ?"

	entity := &parent.InstallationIdElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *installationIdElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.InstallationIdElementType, error) {
	query := "SELECT id FROM installation_id_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.InstallationIdElementType
	for rows.Next() {
		entity := &parent.InstallationIdElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *installationIdElementTypeRepository) Update(ctx context.Context, entity *parent.InstallationIdElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *installationIdElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM installation_id_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *installationIdElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM installation_id_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *installationIdElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM installation_id_element_type").Scan(&count)
	return count, err
}

func (d *dal) InstanceFixType() parent.InstanceFixTypeRepository {
	return &instanceFixTypeRepository{db: d.db}
}

type instanceFixTypeRepository struct {
	db *sql.DB
}

func (r *instanceFixTypeRepository) Create(ctx context.Context, entity *parent.InstanceFixType) (int64, error) {
	query := "INSERT INTO instance_fix_type (context) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Context,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *instanceFixTypeRepository) CreateBatch(ctx context.Context, entities []*parent.InstanceFixType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO instance_fix_type (context) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Context,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *instanceFixTypeRepository) GetByID(ctx context.Context, id int64) (*parent.InstanceFixType, error) {
	query := "SELECT id, context FROM instance_fix_type WHERE id = ?"

	entity := &parent.InstanceFixType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Context,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *instanceFixTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.InstanceFixType, error) {
	query := "SELECT id, context FROM instance_fix_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.InstanceFixType
	for rows.Next() {
		entity := &parent.InstanceFixType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Context,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *instanceFixTypeRepository) Update(ctx context.Context, entity *parent.InstanceFixType) error {
	query := "UPDATE instance_fix_type SET context = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Context,
		entity.ID,
	)
	return err
}

func (r *instanceFixTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM instance_fix_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *instanceFixTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM instance_fix_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *instanceFixTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM instance_fix_type").Scan(&count)
	return count, err
}

func (d *dal) InstanceNameElementType() parent.InstanceNameElementTypeRepository {
	return &instanceNameElementTypeRepository{db: d.db}
}

type instanceNameElementTypeRepository struct {
	db *sql.DB
}

func (r *instanceNameElementTypeRepository) Create(ctx context.Context, entity *parent.InstanceNameElementType) (int64, error) {
	query := "INSERT INTO instance_name_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *instanceNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.InstanceNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO instance_name_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *instanceNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.InstanceNameElementType, error) {
	query := "SELECT id FROM instance_name_element_type WHERE id = ?"

	entity := &parent.InstanceNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *instanceNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.InstanceNameElementType, error) {
	query := "SELECT id FROM instance_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.InstanceNameElementType
	for rows.Next() {
		entity := &parent.InstanceNameElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *instanceNameElementTypeRepository) Update(ctx context.Context, entity *parent.InstanceNameElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *instanceNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM instance_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *instanceNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM instance_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *instanceNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM instance_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) InstanceResultType() parent.InstanceResultTypeRepository {
	return &instanceResultTypeRepository{db: d.db}
}

type instanceResultTypeRepository struct {
	db *sql.DB
}

func (r *instanceResultTypeRepository) Create(ctx context.Context, entity *parent.InstanceResultType) (int64, error) {
	query := "INSERT INTO instance_result_type (context, parent_context) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Context,
		entity.ParentContext,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *instanceResultTypeRepository) CreateBatch(ctx context.Context, entities []*parent.InstanceResultType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO instance_result_type (context, parent_context) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Context,
			entity.ParentContext,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *instanceResultTypeRepository) GetByID(ctx context.Context, id int64) (*parent.InstanceResultType, error) {
	query := "SELECT id, context, parent_context FROM instance_result_type WHERE id = ?"

	entity := &parent.InstanceResultType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Context,
		&entity.ParentContext,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *instanceResultTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.InstanceResultType, error) {
	query := "SELECT id, context, parent_context FROM instance_result_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.InstanceResultType
	for rows.Next() {
		entity := &parent.InstanceResultType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Context,
			&entity.ParentContext,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *instanceResultTypeRepository) Update(ctx context.Context, entity *parent.InstanceResultType) error {
	query := "UPDATE instance_result_type SET context = ?, parent_context = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Context,
		entity.ParentContext,
		entity.ID,
	)
	return err
}

func (r *instanceResultTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM instance_result_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *instanceResultTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM instance_result_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *instanceResultTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM instance_result_type").Scan(&count)
	return count, err
}

func (d *dal) IpAddressType() parent.IpAddressTypeRepository {
	return &ipAddressTypeRepository{db: d.db}
}

type ipAddressTypeRepository struct {
	db *sql.DB
}

func (r *ipAddressTypeRepository) Create(ctx context.Context, entity *parent.IpAddressType) (int64, error) {
	query := "INSERT INTO ip_address_type (ip_v4, ip_v6) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.IpV4,
		entity.IpV6,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ipAddressTypeRepository) CreateBatch(ctx context.Context, entities []*parent.IpAddressType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO ip_address_type (ip_v4, ip_v6) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.IpV4,
			entity.IpV6,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ipAddressTypeRepository) GetByID(ctx context.Context, id int64) (*parent.IpAddressType, error) {
	query := "SELECT id, ip_v4, ip_v6 FROM ip_address_type WHERE id = ?"

	entity := &parent.IpAddressType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.IpV4,
		&entity.IpV6,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ipAddressTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.IpAddressType, error) {
	query := "SELECT id, ip_v4, ip_v6 FROM ip_address_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IpAddressType
	for rows.Next() {
		entity := &parent.IpAddressType{}
		err := rows.Scan(
			&entity.ID,
			&entity.IpV4,
			&entity.IpV6,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ipAddressTypeRepository) Update(ctx context.Context, entity *parent.IpAddressType) error {
	query := "UPDATE ip_address_type SET ip_v4 = ?, ip_v6 = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.IpV4,
		entity.IpV6,
		entity.ID,
	)
	return err
}

func (r *ipAddressTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM ip_address_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ipAddressTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM ip_address_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ipAddressTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM ip_address_type").Scan(&count)
	return count, err
}

func (d *dal) IpNetRangeElementType() parent.IpNetRangeElementTypeRepository {
	return &ipNetRangeElementTypeRepository{db: d.db}
}

type ipNetRangeElementTypeRepository struct {
	db *sql.DB
}

func (r *ipNetRangeElementTypeRepository) Create(ctx context.Context, entity *parent.IpNetRangeElementType) (int64, error) {
	query := "INSERT INTO ip_net_range_element_type (ip_net_range_start_id, ip_net_range_end_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.IpNetRangeStartID,
		entity.IpNetRangeEndID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ipNetRangeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.IpNetRangeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO ip_net_range_element_type (ip_net_range_start_id, ip_net_range_end_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.IpNetRangeStartID,
			entity.IpNetRangeEndID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ipNetRangeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.IpNetRangeElementType, error) {
	query := "SELECT id, ip_net_range_start_id, ip_net_range_end_id FROM ip_net_range_element_type WHERE id = ?"

	entity := &parent.IpNetRangeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.IpNetRangeStartID,
		&entity.IpNetRangeEndID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ipNetRangeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.IpNetRangeElementType, error) {
	query := "SELECT id, ip_net_range_start_id, ip_net_range_end_id FROM ip_net_range_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IpNetRangeElementType
	for rows.Next() {
		entity := &parent.IpNetRangeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.IpNetRangeStartID,
			&entity.IpNetRangeEndID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ipNetRangeElementTypeRepository) Update(ctx context.Context, entity *parent.IpNetRangeElementType) error {
	query := "UPDATE ip_net_range_element_type SET ip_net_range_start_id = ?, ip_net_range_end_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.IpNetRangeStartID,
		entity.IpNetRangeEndID,
		entity.ID,
	)
	return err
}

func (r *ipNetRangeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM ip_net_range_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ipNetRangeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM ip_net_range_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ipNetRangeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM ip_net_range_element_type").Scan(&count)
	return count, err
}

func (r *ipNetRangeElementTypeRepository) GetByIpAddressType(ctx context.Context, ip_address_typeID int64) ([]*parent.IpNetRangeElementType, error) {
	query := "SELECT id, ip_net_range_start_id, ip_net_range_end_id FROM ip_net_range_element_type WHERE ip_net_range_start_id = ?"

	rows, err := r.db.QueryContext(ctx, query, ip_address_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IpNetRangeElementType
	for rows.Next() {
		entity := &parent.IpNetRangeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.IpNetRangeStartID,
			&entity.IpNetRangeEndID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) IpV4ElementType() parent.IpV4ElementTypeRepository {
	return &ipV4ElementTypeRepository{db: d.db}
}

type ipV4ElementTypeRepository struct {
	db *sql.DB
}

func (r *ipV4ElementTypeRepository) Create(ctx context.Context, entity *parent.IpV4ElementType) (int64, error) {
	query := "INSERT INTO ip_v4_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ipV4ElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.IpV4ElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO ip_v4_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ipV4ElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.IpV4ElementType, error) {
	query := "SELECT id, parent_id FROM ip_v4_element_type WHERE id = ?"

	entity := &parent.IpV4ElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ipV4ElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.IpV4ElementType, error) {
	query := "SELECT id, parent_id FROM ip_v4_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IpV4ElementType
	for rows.Next() {
		entity := &parent.IpV4ElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ipV4ElementTypeRepository) Update(ctx context.Context, entity *parent.IpV4ElementType) error {
	query := "UPDATE ip_v4_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *ipV4ElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM ip_v4_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ipV4ElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM ip_v4_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ipV4ElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM ip_v4_element_type").Scan(&count)
	return count, err
}

func (d *dal) IpV6ElementType() parent.IpV6ElementTypeRepository {
	return &ipV6ElementTypeRepository{db: d.db}
}

type ipV6ElementTypeRepository struct {
	db *sql.DB
}

func (r *ipV6ElementTypeRepository) Create(ctx context.Context, entity *parent.IpV6ElementType) (int64, error) {
	query := "INSERT INTO ip_v6_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ipV6ElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.IpV6ElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO ip_v6_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ipV6ElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.IpV6ElementType, error) {
	query := "SELECT id, parent_id FROM ip_v6_element_type WHERE id = ?"

	entity := &parent.IpV6ElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ipV6ElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.IpV6ElementType, error) {
	query := "SELECT id, parent_id FROM ip_v6_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.IpV6ElementType
	for rows.Next() {
		entity := &parent.IpV6ElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ipV6ElementTypeRepository) Update(ctx context.Context, entity *parent.IpV6ElementType) error {
	query := "UPDATE ip_v6_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *ipV6ElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM ip_v6_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ipV6ElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM ip_v6_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ipV6ElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM ip_v6_element_type").Scan(&count)
	return count, err
}

func (d *dal) JointPersonName() parent.JointPersonNameRepository {
	return &jointPersonNameRepository{db: d.db}
}

type jointPersonNameRepository struct {
	db *sql.DB
}

func (r *jointPersonNameRepository) Create(ctx context.Context, entity *parent.JointPersonName) (int64, error) {
	query := "INSERT INTO joint_person_name (joint_name_connector, code) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.JointNameConnector,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *jointPersonNameRepository) CreateBatch(ctx context.Context, entities []*parent.JointPersonName) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO joint_person_name (joint_name_connector, code) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.JointNameConnector,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *jointPersonNameRepository) GetByID(ctx context.Context, id int64) (*parent.JointPersonName, error) {
	query := "SELECT id, joint_name_connector, code FROM joint_person_name WHERE id = ?"

	entity := &parent.JointPersonName{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.JointNameConnector,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *jointPersonNameRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.JointPersonName, error) {
	query := "SELECT id, joint_name_connector, code FROM joint_person_name LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.JointPersonName
	for rows.Next() {
		entity := &parent.JointPersonName{}
		err := rows.Scan(
			&entity.ID,
			&entity.JointNameConnector,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *jointPersonNameRepository) Update(ctx context.Context, entity *parent.JointPersonName) error {
	query := "UPDATE joint_person_name SET joint_name_connector = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.JointNameConnector,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *jointPersonNameRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM joint_person_name WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *jointPersonNameRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM joint_person_name WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *jointPersonNameRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM joint_person_name").Scan(&count)
	return count, err
}

func (d *dal) JointPersonNameElementType() parent.JointPersonNameElementTypeRepository {
	return &jointPersonNameElementTypeRepository{db: d.db}
}

type jointPersonNameElementTypeRepository struct {
	db *sql.DB
}

func (r *jointPersonNameElementTypeRepository) Create(ctx context.Context, entity *parent.JointPersonNameElementType) (int64, error) {
	query := "INSERT INTO joint_person_name_element_type (joint_name_connector, code) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.JointNameConnector,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *jointPersonNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.JointPersonNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO joint_person_name_element_type (joint_name_connector, code) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.JointNameConnector,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *jointPersonNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.JointPersonNameElementType, error) {
	query := "SELECT id, joint_name_connector, code FROM joint_person_name_element_type WHERE id = ?"

	entity := &parent.JointPersonNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.JointNameConnector,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *jointPersonNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.JointPersonNameElementType, error) {
	query := "SELECT id, joint_name_connector, code FROM joint_person_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.JointPersonNameElementType
	for rows.Next() {
		entity := &parent.JointPersonNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.JointNameConnector,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *jointPersonNameElementTypeRepository) Update(ctx context.Context, entity *parent.JointPersonNameElementType) error {
	query := "UPDATE joint_person_name_element_type SET joint_name_connector = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.JointNameConnector,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *jointPersonNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM joint_person_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *jointPersonNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM joint_person_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *jointPersonNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM joint_person_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) KeyInfoType() parent.KeyInfoTypeRepository {
	return &keyInfoTypeRepository{db: d.db}
}

type keyInfoTypeRepository struct {
	db *sql.DB
}

func (r *keyInfoTypeRepository) Create(ctx context.Context, entity *parent.KeyInfoType) (int64, error) {
	query := "INSERT INTO \"key_info_type\" (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *keyInfoTypeRepository) CreateBatch(ctx context.Context, entities []*parent.KeyInfoType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"key_info_type\" (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *keyInfoTypeRepository) GetByID(ctx context.Context, id int64) (*parent.KeyInfoType, error) {
	query := "SELECT id, xsd_id FROM \"key_info_type\" WHERE id = ?"

	entity := &parent.KeyInfoType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *keyInfoTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.KeyInfoType, error) {
	query := "SELECT id, xsd_id FROM \"key_info_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.KeyInfoType
	for rows.Next() {
		entity := &parent.KeyInfoType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *keyInfoTypeRepository) Update(ctx context.Context, entity *parent.KeyInfoType) error {
	query := "UPDATE \"key_info_type\" SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *keyInfoTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"key_info_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *keyInfoTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"key_info_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *keyInfoTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"key_info_type\"").Scan(&count)
	return count, err
}

func (d *dal) KeyLineCodeElementType() parent.KeyLineCodeElementTypeRepository {
	return &keyLineCodeElementTypeRepository{db: d.db}
}

type keyLineCodeElementTypeRepository struct {
	db *sql.DB
}

func (r *keyLineCodeElementTypeRepository) Create(ctx context.Context, entity *parent.KeyLineCodeElementType) (int64, error) {
	query := "INSERT INTO \"key_line_code_element_type\" (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *keyLineCodeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.KeyLineCodeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"key_line_code_element_type\" (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *keyLineCodeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.KeyLineCodeElementType, error) {
	query := "SELECT id, type FROM \"key_line_code_element_type\" WHERE id = ?"

	entity := &parent.KeyLineCodeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *keyLineCodeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.KeyLineCodeElementType, error) {
	query := "SELECT id, type FROM \"key_line_code_element_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.KeyLineCodeElementType
	for rows.Next() {
		entity := &parent.KeyLineCodeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *keyLineCodeElementTypeRepository) Update(ctx context.Context, entity *parent.KeyLineCodeElementType) error {
	query := "UPDATE \"key_line_code_element_type\" SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *keyLineCodeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"key_line_code_element_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *keyLineCodeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"key_line_code_element_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *keyLineCodeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"key_line_code_element_type\"").Scan(&count)
	return count, err
}

func (d *dal) KeyValueType() parent.KeyValueTypeRepository {
	return &keyValueTypeRepository{db: d.db}
}

type keyValueTypeRepository struct {
	db *sql.DB
}

func (r *keyValueTypeRepository) Create(ctx context.Context, entity *parent.KeyValueType) (int64, error) {
	query := "INSERT INTO \"key_value_type\" DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *keyValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.KeyValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"key_value_type\" DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *keyValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.KeyValueType, error) {
	query := "SELECT id FROM \"key_value_type\" WHERE id = ?"

	entity := &parent.KeyValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *keyValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.KeyValueType, error) {
	query := "SELECT id FROM \"key_value_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.KeyValueType
	for rows.Next() {
		entity := &parent.KeyValueType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *keyValueTypeRepository) Update(ctx context.Context, entity *parent.KeyValueType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *keyValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"key_value_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *keyValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"key_value_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *keyValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"key_value_type\"").Scan(&count)
	return count, err
}

func (d *dal) KnownAsElementType() parent.KnownAsElementTypeRepository {
	return &knownAsElementTypeRepository{db: d.db}
}

type knownAsElementTypeRepository struct {
	db *sql.DB
}

func (r *knownAsElementTypeRepository) Create(ctx context.Context, entity *parent.KnownAsElementType) (int64, error) {
	query := "INSERT INTO \"known_as_element_type\" (valid_from, valid_to, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ValidFrom,
		entity.ValidTo,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *knownAsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.KnownAsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"known_as_element_type\" (valid_from, valid_to, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ValidFrom,
			entity.ValidTo,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *knownAsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.KnownAsElementType, error) {
	query := "SELECT id, valid_from, valid_to, parent_id FROM \"known_as_element_type\" WHERE id = ?"

	entity := &parent.KnownAsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ValidFrom,
		&entity.ValidTo,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *knownAsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.KnownAsElementType, error) {
	query := "SELECT id, valid_from, valid_to, parent_id FROM \"known_as_element_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.KnownAsElementType
	for rows.Next() {
		entity := &parent.KnownAsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ValidFrom,
			&entity.ValidTo,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *knownAsElementTypeRepository) Update(ctx context.Context, entity *parent.KnownAsElementType) error {
	query := "UPDATE \"known_as_element_type\" SET valid_from = ?, valid_to = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ValidFrom,
		entity.ValidTo,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *knownAsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"known_as_element_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *knownAsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"known_as_element_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *knownAsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"known_as_element_type\"").Scan(&count)
	return count, err
}

func (d *dal) Language20TextType() parent.Language20TextTypeRepository {
	return &language20TextTypeRepository{db: d.db}
}

type language20TextTypeRepository struct {
	db *sql.DB
}

func (r *language20TextTypeRepository) Create(ctx context.Context, entity *parent.Language20TextType) (int64, error) {
	query := "INSERT INTO language_2_0_text_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *language20TextTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Language20TextType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO language_2_0_text_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *language20TextTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Language20TextType, error) {
	query := "SELECT id FROM language_2_0_text_type WHERE id = ?"

	entity := &parent.Language20TextType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *language20TextTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Language20TextType, error) {
	query := "SELECT id FROM language_2_0_text_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Language20TextType
	for rows.Next() {
		entity := &parent.Language20TextType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *language20TextTypeRepository) Update(ctx context.Context, entity *parent.Language20TextType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *language20TextTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM language_2_0_text_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *language20TextTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM language_2_0_text_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *language20TextTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM language_2_0_text_type").Scan(&count)
	return count, err
}

func (d *dal) LargeMailUserIdentifierElementType() parent.LargeMailUserIdentifierElementTypeRepository {
	return &largeMailUserIdentifierElementTypeRepository{db: d.db}
}

type largeMailUserIdentifierElementTypeRepository struct {
	db *sql.DB
}

func (r *largeMailUserIdentifierElementTypeRepository) Create(ctx context.Context, entity *parent.LargeMailUserIdentifierElementType) (int64, error) {
	query := "INSERT INTO large_mail_user_identifier_element_type (type, indicator) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *largeMailUserIdentifierElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LargeMailUserIdentifierElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO large_mail_user_identifier_element_type (type, indicator) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Indicator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *largeMailUserIdentifierElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LargeMailUserIdentifierElementType, error) {
	query := "SELECT id, type, indicator FROM large_mail_user_identifier_element_type WHERE id = ?"

	entity := &parent.LargeMailUserIdentifierElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Indicator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *largeMailUserIdentifierElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LargeMailUserIdentifierElementType, error) {
	query := "SELECT id, type, indicator FROM large_mail_user_identifier_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LargeMailUserIdentifierElementType
	for rows.Next() {
		entity := &parent.LargeMailUserIdentifierElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Indicator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *largeMailUserIdentifierElementTypeRepository) Update(ctx context.Context, entity *parent.LargeMailUserIdentifierElementType) error {
	query := "UPDATE large_mail_user_identifier_element_type SET type = ?, indicator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.ID,
	)
	return err
}

func (r *largeMailUserIdentifierElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM large_mail_user_identifier_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *largeMailUserIdentifierElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM large_mail_user_identifier_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *largeMailUserIdentifierElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM large_mail_user_identifier_element_type").Scan(&count)
	return count, err
}

func (d *dal) LargeMailUserNameElementType() parent.LargeMailUserNameElementTypeRepository {
	return &largeMailUserNameElementTypeRepository{db: d.db}
}

type largeMailUserNameElementTypeRepository struct {
	db *sql.DB
}

func (r *largeMailUserNameElementTypeRepository) Create(ctx context.Context, entity *parent.LargeMailUserNameElementType) (int64, error) {
	query := "INSERT INTO large_mail_user_name_element_type (type, code) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *largeMailUserNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LargeMailUserNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO large_mail_user_name_element_type (type, code) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *largeMailUserNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LargeMailUserNameElementType, error) {
	query := "SELECT id, type, code FROM large_mail_user_name_element_type WHERE id = ?"

	entity := &parent.LargeMailUserNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *largeMailUserNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LargeMailUserNameElementType, error) {
	query := "SELECT id, type, code FROM large_mail_user_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LargeMailUserNameElementType
	for rows.Next() {
		entity := &parent.LargeMailUserNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *largeMailUserNameElementTypeRepository) Update(ctx context.Context, entity *parent.LargeMailUserNameElementType) error {
	query := "UPDATE large_mail_user_name_element_type SET type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *largeMailUserNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM large_mail_user_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *largeMailUserNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM large_mail_user_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *largeMailUserNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM large_mail_user_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) LargeMailUserType() parent.LargeMailUserTypeRepository {
	return &largeMailUserTypeRepository{db: d.db}
}

type largeMailUserTypeRepository struct {
	db *sql.DB
}

func (r *largeMailUserTypeRepository) Create(ctx context.Context, entity *parent.LargeMailUserType) (int64, error) {
	query := "INSERT INTO large_mail_user_type (type, large_mail_user_name, large_mail_user_identifier) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.LargeMailUserName,
		entity.LargeMailUserIdentifier,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *largeMailUserTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LargeMailUserType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO large_mail_user_type (type, large_mail_user_name, large_mail_user_identifier) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.LargeMailUserName,
			entity.LargeMailUserIdentifier,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *largeMailUserTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LargeMailUserType, error) {
	query := "SELECT id, type, large_mail_user_name, large_mail_user_identifier FROM large_mail_user_type WHERE id = ?"

	entity := &parent.LargeMailUserType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.LargeMailUserName,
		&entity.LargeMailUserIdentifier,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *largeMailUserTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LargeMailUserType, error) {
	query := "SELECT id, type, large_mail_user_name, large_mail_user_identifier FROM large_mail_user_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LargeMailUserType
	for rows.Next() {
		entity := &parent.LargeMailUserType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.LargeMailUserName,
			&entity.LargeMailUserIdentifier,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *largeMailUserTypeRepository) Update(ctx context.Context, entity *parent.LargeMailUserType) error {
	query := "UPDATE large_mail_user_type SET type = ?, large_mail_user_name = ?, large_mail_user_identifier = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.LargeMailUserName,
		entity.LargeMailUserIdentifier,
		entity.ID,
	)
	return err
}

func (r *largeMailUserTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM large_mail_user_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *largeMailUserTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM large_mail_user_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *largeMailUserTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM large_mail_user_type").Scan(&count)
	return count, err
}

func (d *dal) LastNameElementType() parent.LastNameElementTypeRepository {
	return &lastNameElementTypeRepository{db: d.db}
}

type lastNameElementTypeRepository struct {
	db *sql.DB
}

func (r *lastNameElementTypeRepository) Create(ctx context.Context, entity *parent.LastNameElementType) (int64, error) {
	query := "INSERT INTO last_name_element_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *lastNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LastNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO last_name_element_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *lastNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LastNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM last_name_element_type WHERE id = ?"

	entity := &parent.LastNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *lastNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LastNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM last_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LastNameElementType
	for rows.Next() {
		entity := &parent.LastNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *lastNameElementTypeRepository) Update(ctx context.Context, entity *parent.LastNameElementType) error {
	query := "UPDATE last_name_element_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *lastNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM last_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *lastNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM last_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *lastNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM last_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) LicenseElementType() parent.LicenseElementTypeRepository {
	return &licenseElementTypeRepository{db: d.db}
}

type licenseElementTypeRepository struct {
	db *sql.DB
}

func (r *licenseElementTypeRepository) Create(ctx context.Context, entity *parent.LicenseElementType) (int64, error) {
	query := "INSERT INTO license_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *licenseElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LicenseElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO license_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *licenseElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LicenseElementType, error) {
	query := "SELECT id FROM license_element_type WHERE id = ?"

	entity := &parent.LicenseElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *licenseElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LicenseElementType, error) {
	query := "SELECT id FROM license_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LicenseElementType
	for rows.Next() {
		entity := &parent.LicenseElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *licenseElementTypeRepository) Update(ctx context.Context, entity *parent.LicenseElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *licenseElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM license_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *licenseElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM license_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *licenseElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM license_element_type").Scan(&count)
	return count, err
}

func (d *dal) ListType() parent.ListTypeRepository {
	return &listTypeRepository{db: d.db}
}

type listTypeRepository struct {
	db *sql.DB
}

func (r *listTypeRepository) Create(ctx context.Context, entity *parent.ListType) (int64, error) {
	query := "INSERT INTO list_type (generator_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.GeneratorID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *listTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ListType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO list_type (generator_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.GeneratorID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *listTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ListType, error) {
	query := "SELECT id, generator_id FROM list_type WHERE id = ?"

	entity := &parent.ListType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.GeneratorID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *listTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ListType, error) {
	query := "SELECT id, generator_id FROM list_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ListType
	for rows.Next() {
		entity := &parent.ListType{}
		err := rows.Scan(
			&entity.ID,
			&entity.GeneratorID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *listTypeRepository) Update(ctx context.Context, entity *parent.ListType) error {
	query := "UPDATE list_type SET generator_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.GeneratorID,
		entity.ID,
	)
	return err
}

func (r *listTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM list_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *listTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM list_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *listTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM list_type").Scan(&count)
	return count, err
}

func (d *dal) LiteralComponentType() parent.LiteralComponentTypeRepository {
	return &literalComponentTypeRepository{db: d.db}
}

type literalComponentTypeRepository struct {
	db *sql.DB
}

func (r *literalComponentTypeRepository) Create(ctx context.Context, entity *parent.LiteralComponentType) (int64, error) {
	query := "INSERT INTO literal_component_type (datatype) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *literalComponentTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LiteralComponentType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO literal_component_type (datatype) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Datatype,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *literalComponentTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LiteralComponentType, error) {
	query := "SELECT id, datatype FROM literal_component_type WHERE id = ?"

	entity := &parent.LiteralComponentType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Datatype,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *literalComponentTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LiteralComponentType, error) {
	query := "SELECT id, datatype FROM literal_component_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LiteralComponentType
	for rows.Next() {
		entity := &parent.LiteralComponentType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Datatype,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *literalComponentTypeRepository) Update(ctx context.Context, entity *parent.LiteralComponentType) error {
	query := "UPDATE literal_component_type SET datatype = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Datatype,
		entity.ID,
	)
	return err
}

func (r *literalComponentTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM literal_component_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *literalComponentTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM literal_component_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *literalComponentTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM literal_component_type").Scan(&count)
	return count, err
}

func (d *dal) LocalVariable() parent.LocalVariableRepository {
	return &localVariableRepository{db: d.db}
}

type localVariableRepository struct {
	db *sql.DB
}

func (r *localVariableRepository) Create(ctx context.Context, entity *parent.LocalVariable) (int64, error) {
	query := "INSERT INTO local_variable (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *localVariableRepository) CreateBatch(ctx context.Context, entities []*parent.LocalVariable) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO local_variable (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *localVariableRepository) GetByID(ctx context.Context, id int64) (*parent.LocalVariable, error) {
	query := "SELECT id, parent_id FROM local_variable WHERE id = ?"

	entity := &parent.LocalVariable{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *localVariableRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocalVariable, error) {
	query := "SELECT id, parent_id FROM local_variable LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocalVariable
	for rows.Next() {
		entity := &parent.LocalVariable{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *localVariableRepository) Update(ctx context.Context, entity *parent.LocalVariable) error {
	query := "UPDATE local_variable SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *localVariableRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM local_variable WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *localVariableRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM local_variable WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *localVariableRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM local_variable").Scan(&count)
	return count, err
}

func (r *localVariableRepository) GetByVariableType(ctx context.Context, variable_typeID int64) ([]*parent.LocalVariable, error) {
	query := "SELECT id, parent_id FROM local_variable WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, variable_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocalVariable
	for rows.Next() {
		entity := &parent.LocalVariable{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) LocalVariableElementType() parent.LocalVariableElementTypeRepository {
	return &localVariableElementTypeRepository{db: d.db}
}

type localVariableElementTypeRepository struct {
	db *sql.DB
}

func (r *localVariableElementTypeRepository) Create(ctx context.Context, entity *parent.LocalVariableElementType) (int64, error) {
	query := "INSERT INTO local_variable_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *localVariableElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LocalVariableElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO local_variable_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *localVariableElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LocalVariableElementType, error) {
	query := "SELECT id, parent_id FROM local_variable_element_type WHERE id = ?"

	entity := &parent.LocalVariableElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *localVariableElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocalVariableElementType, error) {
	query := "SELECT id, parent_id FROM local_variable_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocalVariableElementType
	for rows.Next() {
		entity := &parent.LocalVariableElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *localVariableElementTypeRepository) Update(ctx context.Context, entity *parent.LocalVariableElementType) error {
	query := "UPDATE local_variable_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *localVariableElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM local_variable_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *localVariableElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM local_variable_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *localVariableElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM local_variable_element_type").Scan(&count)
	return count, err
}

func (r *localVariableElementTypeRepository) GetByVariableType(ctx context.Context, variable_typeID int64) ([]*parent.LocalVariableElementType, error) {
	query := "SELECT id, parent_id FROM local_variable_element_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, variable_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocalVariableElementType
	for rows.Next() {
		entity := &parent.LocalVariableElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) LocaleElementType() parent.LocaleElementTypeRepository {
	return &localeElementTypeRepository{db: d.db}
}

type localeElementTypeRepository struct {
	db *sql.DB
}

func (r *localeElementTypeRepository) Create(ctx context.Context, entity *parent.LocaleElementType) (int64, error) {
	query := "INSERT INTO locale_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *localeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LocaleElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO locale_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *localeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LocaleElementType, error) {
	query := "SELECT id, parent_id FROM locale_element_type WHERE id = ?"

	entity := &parent.LocaleElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *localeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocaleElementType, error) {
	query := "SELECT id, parent_id FROM locale_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocaleElementType
	for rows.Next() {
		entity := &parent.LocaleElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *localeElementTypeRepository) Update(ctx context.Context, entity *parent.LocaleElementType) error {
	query := "UPDATE locale_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *localeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM locale_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *localeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM locale_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *localeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM locale_element_type").Scan(&count)
	return count, err
}

func (d *dal) Locality() parent.LocalityRepository {
	return &localityRepository{db: d.db}
}

type localityRepository struct {
	db *sql.DB
}

func (r *localityRepository) Create(ctx context.Context, entity *parent.Locality) (int64, error) {
	query := "INSERT INTO locality (type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id) VALUES (?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.LocalityName,
		entity.DependentLocalityID,
		entity.LargeMailUserID,
		entity.PostalRouteID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *localityRepository) CreateBatch(ctx context.Context, entities []*parent.Locality) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO locality (type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.UsageType,
			entity.Indicator,
			entity.LocalityName,
			entity.DependentLocalityID,
			entity.LargeMailUserID,
			entity.PostalRouteID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *localityRepository) GetByID(ctx context.Context, id int64) (*parent.Locality, error) {
	query := "SELECT id, type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id FROM locality WHERE id = ?"

	entity := &parent.Locality{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.UsageType,
		&entity.Indicator,
		&entity.LocalityName,
		&entity.DependentLocalityID,
		&entity.LargeMailUserID,
		&entity.PostalRouteID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *localityRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Locality, error) {
	query := "SELECT id, type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id FROM locality LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Locality
	for rows.Next() {
		entity := &parent.Locality{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.UsageType,
			&entity.Indicator,
			&entity.LocalityName,
			&entity.DependentLocalityID,
			&entity.LargeMailUserID,
			&entity.PostalRouteID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *localityRepository) Update(ctx context.Context, entity *parent.Locality) error {
	query := "UPDATE locality SET type = ?, usage_type = ?, indicator = ?, locality_name = ?, dependent_locality_id = ?, large_mail_user_id = ?, postal_route_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.LocalityName,
		entity.DependentLocalityID,
		entity.LargeMailUserID,
		entity.PostalRouteID,
		entity.ID,
	)
	return err
}

func (r *localityRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM locality WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *localityRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM locality WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *localityRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM locality").Scan(&count)
	return count, err
}

func (d *dal) LocalityElementType() parent.LocalityElementTypeRepository {
	return &localityElementTypeRepository{db: d.db}
}

type localityElementTypeRepository struct {
	db *sql.DB
}

func (r *localityElementTypeRepository) Create(ctx context.Context, entity *parent.LocalityElementType) (int64, error) {
	query := "INSERT INTO locality_element_type (type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id) VALUES (?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.LocalityName,
		entity.DependentLocalityID,
		entity.LargeMailUserID,
		entity.PostalRouteID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *localityElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LocalityElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO locality_element_type (type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.UsageType,
			entity.Indicator,
			entity.LocalityName,
			entity.DependentLocalityID,
			entity.LargeMailUserID,
			entity.PostalRouteID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *localityElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LocalityElementType, error) {
	query := "SELECT id, type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id FROM locality_element_type WHERE id = ?"

	entity := &parent.LocalityElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.UsageType,
		&entity.Indicator,
		&entity.LocalityName,
		&entity.DependentLocalityID,
		&entity.LargeMailUserID,
		&entity.PostalRouteID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *localityElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocalityElementType, error) {
	query := "SELECT id, type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id FROM locality_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocalityElementType
	for rows.Next() {
		entity := &parent.LocalityElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.UsageType,
			&entity.Indicator,
			&entity.LocalityName,
			&entity.DependentLocalityID,
			&entity.LargeMailUserID,
			&entity.PostalRouteID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *localityElementTypeRepository) Update(ctx context.Context, entity *parent.LocalityElementType) error {
	query := "UPDATE locality_element_type SET type = ?, usage_type = ?, indicator = ?, locality_name = ?, dependent_locality_id = ?, large_mail_user_id = ?, postal_route_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.LocalityName,
		entity.DependentLocalityID,
		entity.LargeMailUserID,
		entity.PostalRouteID,
		entity.ID,
	)
	return err
}

func (r *localityElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM locality_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *localityElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM locality_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *localityElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM locality_element_type").Scan(&count)
	return count, err
}

func (r *localityElementTypeRepository) GetByDependentLocalityType(ctx context.Context, dependent_locality_typeID int64) ([]*parent.LocalityElementType, error) {
	query := "SELECT id, type, usage_type, indicator, locality_name, dependent_locality_id, large_mail_user_id, postal_route_id FROM locality_element_type WHERE dependent_locality_id = ?"

	rows, err := r.db.QueryContext(ctx, query, dependent_locality_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocalityElementType
	for rows.Next() {
		entity := &parent.LocalityElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.UsageType,
			&entity.Indicator,
			&entity.LocalityName,
			&entity.DependentLocalityID,
			&entity.LargeMailUserID,
			&entity.PostalRouteID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) LocalityNameElementType() parent.LocalityNameElementTypeRepository {
	return &localityNameElementTypeRepository{db: d.db}
}

type localityNameElementTypeRepository struct {
	db *sql.DB
}

func (r *localityNameElementTypeRepository) Create(ctx context.Context, entity *parent.LocalityNameElementType) (int64, error) {
	query := "INSERT INTO locality_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *localityNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LocalityNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO locality_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *localityNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LocalityNameElementType, error) {
	query := "SELECT id, type FROM locality_name_element_type WHERE id = ?"

	entity := &parent.LocalityNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *localityNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocalityNameElementType, error) {
	query := "SELECT id, type FROM locality_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocalityNameElementType
	for rows.Next() {
		entity := &parent.LocalityNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *localityNameElementTypeRepository) Update(ctx context.Context, entity *parent.LocalityNameElementType) error {
	query := "UPDATE locality_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *localityNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM locality_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *localityNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM locality_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *localityNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM locality_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) LocationPoint() parent.LocationPointRepository {
	return &locationPointRepository{db: d.db}
}

type locationPointRepository struct {
	db *sql.DB
}

func (r *locationPointRepository) Create(ctx context.Context, entity *parent.LocationPoint) (int64, error) {
	query := "INSERT INTO location_point (latitude, longitude, elevation, radius) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Latitude,
		entity.Longitude,
		entity.Elevation,
		entity.Radius,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *locationPointRepository) CreateBatch(ctx context.Context, entities []*parent.LocationPoint) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO location_point (latitude, longitude, elevation, radius) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Latitude,
			entity.Longitude,
			entity.Elevation,
			entity.Radius,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *locationPointRepository) GetByID(ctx context.Context, id int64) (*parent.LocationPoint, error) {
	query := "SELECT id, latitude, longitude, elevation, radius FROM location_point WHERE id = ?"

	entity := &parent.LocationPoint{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Latitude,
		&entity.Longitude,
		&entity.Elevation,
		&entity.Radius,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *locationPointRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocationPoint, error) {
	query := "SELECT id, latitude, longitude, elevation, radius FROM location_point LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocationPoint
	for rows.Next() {
		entity := &parent.LocationPoint{}
		err := rows.Scan(
			&entity.ID,
			&entity.Latitude,
			&entity.Longitude,
			&entity.Elevation,
			&entity.Radius,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *locationPointRepository) Update(ctx context.Context, entity *parent.LocationPoint) error {
	query := "UPDATE location_point SET latitude = ?, longitude = ?, elevation = ?, radius = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Latitude,
		entity.Longitude,
		entity.Elevation,
		entity.Radius,
		entity.ID,
	)
	return err
}

func (r *locationPointRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM location_point WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *locationPointRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM location_point WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *locationPointRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM location_point").Scan(&count)
	return count, err
}

func (d *dal) LocationPointElementType() parent.LocationPointElementTypeRepository {
	return &locationPointElementTypeRepository{db: d.db}
}

type locationPointElementTypeRepository struct {
	db *sql.DB
}

func (r *locationPointElementTypeRepository) Create(ctx context.Context, entity *parent.LocationPointElementType) (int64, error) {
	query := "INSERT INTO location_point_element_type (latitude, longitude, elevation, radius) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Latitude,
		entity.Longitude,
		entity.Elevation,
		entity.Radius,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *locationPointElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LocationPointElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO location_point_element_type (latitude, longitude, elevation, radius) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Latitude,
			entity.Longitude,
			entity.Elevation,
			entity.Radius,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *locationPointElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LocationPointElementType, error) {
	query := "SELECT id, latitude, longitude, elevation, radius FROM location_point_element_type WHERE id = ?"

	entity := &parent.LocationPointElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Latitude,
		&entity.Longitude,
		&entity.Elevation,
		&entity.Radius,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *locationPointElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocationPointElementType, error) {
	query := "SELECT id, latitude, longitude, elevation, radius FROM location_point_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocationPointElementType
	for rows.Next() {
		entity := &parent.LocationPointElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Latitude,
			&entity.Longitude,
			&entity.Elevation,
			&entity.Radius,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *locationPointElementTypeRepository) Update(ctx context.Context, entity *parent.LocationPointElementType) error {
	query := "UPDATE location_point_element_type SET latitude = ?, longitude = ?, elevation = ?, radius = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Latitude,
		entity.Longitude,
		entity.Elevation,
		entity.Radius,
		entity.ID,
	)
	return err
}

func (r *locationPointElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM location_point_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *locationPointElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM location_point_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *locationPointElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM location_point_element_type").Scan(&count)
	return count, err
}

func (d *dal) LocationRegion() parent.LocationRegionRepository {
	return &locationRegionRepository{db: d.db}
}

type locationRegionRepository struct {
	db *sql.DB
}

func (r *locationRegionRepository) Create(ctx context.Context, entity *parent.LocationRegion) (int64, error) {
	query := "INSERT INTO location_region DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *locationRegionRepository) CreateBatch(ctx context.Context, entities []*parent.LocationRegion) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO location_region DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *locationRegionRepository) GetByID(ctx context.Context, id int64) (*parent.LocationRegion, error) {
	query := "SELECT id FROM location_region WHERE id = ?"

	entity := &parent.LocationRegion{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *locationRegionRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocationRegion, error) {
	query := "SELECT id FROM location_region LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocationRegion
	for rows.Next() {
		entity := &parent.LocationRegion{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *locationRegionRepository) Update(ctx context.Context, entity *parent.LocationRegion) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *locationRegionRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM location_region WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *locationRegionRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM location_region WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *locationRegionRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM location_region").Scan(&count)
	return count, err
}

func (d *dal) LocationRegionElementType() parent.LocationRegionElementTypeRepository {
	return &locationRegionElementTypeRepository{db: d.db}
}

type locationRegionElementTypeRepository struct {
	db *sql.DB
}

func (r *locationRegionElementTypeRepository) Create(ctx context.Context, entity *parent.LocationRegionElementType) (int64, error) {
	query := "INSERT INTO location_region_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *locationRegionElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LocationRegionElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO location_region_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *locationRegionElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LocationRegionElementType, error) {
	query := "SELECT id FROM location_region_element_type WHERE id = ?"

	entity := &parent.LocationRegionElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *locationRegionElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocationRegionElementType, error) {
	query := "SELECT id FROM location_region_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocationRegionElementType
	for rows.Next() {
		entity := &parent.LocationRegionElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *locationRegionElementTypeRepository) Update(ctx context.Context, entity *parent.LocationRegionElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *locationRegionElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM location_region_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *locationRegionElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM location_region_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *locationRegionElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM location_region_element_type").Scan(&count)
	return count, err
}

func (d *dal) Locations() parent.LocationsRepository {
	return &locationsRepository{db: d.db}
}

type locationsRepository struct {
	db *sql.DB
}

func (r *locationsRepository) Create(ctx context.Context, entity *parent.Locations) (int64, error) {
	query := "INSERT INTO locations DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *locationsRepository) CreateBatch(ctx context.Context, entities []*parent.Locations) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO locations DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *locationsRepository) GetByID(ctx context.Context, id int64) (*parent.Locations, error) {
	query := "SELECT id FROM locations WHERE id = ?"

	entity := &parent.Locations{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *locationsRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Locations, error) {
	query := "SELECT id FROM locations LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Locations
	for rows.Next() {
		entity := &parent.Locations{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *locationsRepository) Update(ctx context.Context, entity *parent.Locations) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *locationsRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM locations WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *locationsRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM locations WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *locationsRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM locations").Scan(&count)
	return count, err
}

func (d *dal) LocationsElementType() parent.LocationsElementTypeRepository {
	return &locationsElementTypeRepository{db: d.db}
}

type locationsElementTypeRepository struct {
	db *sql.DB
}

func (r *locationsElementTypeRepository) Create(ctx context.Context, entity *parent.LocationsElementType) (int64, error) {
	query := "INSERT INTO locations_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *locationsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LocationsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO locations_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *locationsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LocationsElementType, error) {
	query := "SELECT id FROM locations_element_type WHERE id = ?"

	entity := &parent.LocationsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *locationsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocationsElementType, error) {
	query := "SELECT id FROM locations_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocationsElementType
	for rows.Next() {
		entity := &parent.LocationsElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *locationsElementTypeRepository) Update(ctx context.Context, entity *parent.LocationsElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *locationsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM locations_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *locationsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM locations_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *locationsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM locations_element_type").Scan(&count)
	return count, err
}

func (d *dal) LocatorType() parent.LocatorTypeRepository {
	return &locatorTypeRepository{db: d.db}
}

type locatorTypeRepository struct {
	db *sql.DB
}

func (r *locatorTypeRepository) Create(ctx context.Context, entity *parent.LocatorType) (int64, error) {
	query := "INSERT INTO locator_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *locatorTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LocatorType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO locator_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *locatorTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LocatorType, error) {
	query := "SELECT id FROM locator_type WHERE id = ?"

	entity := &parent.LocatorType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *locatorTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LocatorType, error) {
	query := "SELECT id FROM locator_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LocatorType
	for rows.Next() {
		entity := &parent.LocatorType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *locatorTypeRepository) Update(ctx context.Context, entity *parent.LocatorType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *locatorTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM locator_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *locatorTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM locator_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *locatorTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM locator_type").Scan(&count)
	return count, err
}

func (d *dal) LogicalTestType() parent.LogicalTestTypeRepository {
	return &logicalTestTypeRepository{db: d.db}
}

type logicalTestTypeRepository struct {
	db *sql.DB
}

func (r *logicalTestTypeRepository) Create(ctx context.Context, entity *parent.LogicalTestType) (int64, error) {
	query := "INSERT INTO logical_test_type (operator, negate) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Operator,
		entity.Negate,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *logicalTestTypeRepository) CreateBatch(ctx context.Context, entities []*parent.LogicalTestType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO logical_test_type (operator, negate) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Operator,
			entity.Negate,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *logicalTestTypeRepository) GetByID(ctx context.Context, id int64) (*parent.LogicalTestType, error) {
	query := "SELECT id, operator, negate FROM logical_test_type WHERE id = ?"

	entity := &parent.LogicalTestType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Operator,
		&entity.Negate,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *logicalTestTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.LogicalTestType, error) {
	query := "SELECT id, operator, negate FROM logical_test_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.LogicalTestType
	for rows.Next() {
		entity := &parent.LogicalTestType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Operator,
			&entity.Negate,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *logicalTestTypeRepository) Update(ctx context.Context, entity *parent.LogicalTestType) error {
	query := "UPDATE logical_test_type SET operator = ?, negate = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Operator,
		entity.Negate,
		entity.ID,
	)
	return err
}

func (r *logicalTestTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM logical_test_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *logicalTestTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM logical_test_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *logicalTestTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM logical_test_type").Scan(&count)
	return count, err
}

func (d *dal) MacAddressElementType() parent.MacAddressElementTypeRepository {
	return &macAddressElementTypeRepository{db: d.db}
}

type macAddressElementTypeRepository struct {
	db *sql.DB
}

func (r *macAddressElementTypeRepository) Create(ctx context.Context, entity *parent.MacAddressElementType) (int64, error) {
	query := "INSERT INTO mac_address_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *macAddressElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.MacAddressElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO mac_address_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *macAddressElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.MacAddressElementType, error) {
	query := "SELECT id, parent_id FROM mac_address_element_type WHERE id = ?"

	entity := &parent.MacAddressElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *macAddressElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.MacAddressElementType, error) {
	query := "SELECT id, parent_id FROM mac_address_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.MacAddressElementType
	for rows.Next() {
		entity := &parent.MacAddressElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *macAddressElementTypeRepository) Update(ctx context.Context, entity *parent.MacAddressElementType) error {
	query := "UPDATE mac_address_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *macAddressElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM mac_address_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *macAddressElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM mac_address_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *macAddressElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM mac_address_element_type").Scan(&count)
	return count, err
}

func (d *dal) MailStopNameElementType() parent.MailStopNameElementTypeRepository {
	return &mailStopNameElementTypeRepository{db: d.db}
}

type mailStopNameElementTypeRepository struct {
	db *sql.DB
}

func (r *mailStopNameElementTypeRepository) Create(ctx context.Context, entity *parent.MailStopNameElementType) (int64, error) {
	query := "INSERT INTO mail_stop_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *mailStopNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.MailStopNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO mail_stop_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *mailStopNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.MailStopNameElementType, error) {
	query := "SELECT id, type FROM mail_stop_name_element_type WHERE id = ?"

	entity := &parent.MailStopNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *mailStopNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.MailStopNameElementType, error) {
	query := "SELECT id, type FROM mail_stop_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.MailStopNameElementType
	for rows.Next() {
		entity := &parent.MailStopNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *mailStopNameElementTypeRepository) Update(ctx context.Context, entity *parent.MailStopNameElementType) error {
	query := "UPDATE mail_stop_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *mailStopNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM mail_stop_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *mailStopNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM mail_stop_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *mailStopNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM mail_stop_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) MailStopNumberElementType() parent.MailStopNumberElementTypeRepository {
	return &mailStopNumberElementTypeRepository{db: d.db}
}

type mailStopNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *mailStopNumberElementTypeRepository) Create(ctx context.Context, entity *parent.MailStopNumberElementType) (int64, error) {
	query := "INSERT INTO mail_stop_number_element_type (name_number_separator) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NameNumberSeparator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *mailStopNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.MailStopNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO mail_stop_number_element_type (name_number_separator) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NameNumberSeparator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *mailStopNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.MailStopNumberElementType, error) {
	query := "SELECT id, name_number_separator FROM mail_stop_number_element_type WHERE id = ?"

	entity := &parent.MailStopNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NameNumberSeparator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *mailStopNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.MailStopNumberElementType, error) {
	query := "SELECT id, name_number_separator FROM mail_stop_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.MailStopNumberElementType
	for rows.Next() {
		entity := &parent.MailStopNumberElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NameNumberSeparator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *mailStopNumberElementTypeRepository) Update(ctx context.Context, entity *parent.MailStopNumberElementType) error {
	query := "UPDATE mail_stop_number_element_type SET name_number_separator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NameNumberSeparator,
		entity.ID,
	)
	return err
}

func (r *mailStopNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM mail_stop_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *mailStopNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM mail_stop_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *mailStopNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM mail_stop_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) MailStopType() parent.MailStopTypeRepository {
	return &mailStopTypeRepository{db: d.db}
}

type mailStopTypeRepository struct {
	db *sql.DB
}

func (r *mailStopTypeRepository) Create(ctx context.Context, entity *parent.MailStopType) (int64, error) {
	query := "INSERT INTO mail_stop_type (type, mail_stop_name, mail_stop_number) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.MailStopName,
		entity.MailStopNumber,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *mailStopTypeRepository) CreateBatch(ctx context.Context, entities []*parent.MailStopType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO mail_stop_type (type, mail_stop_name, mail_stop_number) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.MailStopName,
			entity.MailStopNumber,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *mailStopTypeRepository) GetByID(ctx context.Context, id int64) (*parent.MailStopType, error) {
	query := "SELECT id, type, mail_stop_name, mail_stop_number FROM mail_stop_type WHERE id = ?"

	entity := &parent.MailStopType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.MailStopName,
		&entity.MailStopNumber,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *mailStopTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.MailStopType, error) {
	query := "SELECT id, type, mail_stop_name, mail_stop_number FROM mail_stop_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.MailStopType
	for rows.Next() {
		entity := &parent.MailStopType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.MailStopName,
			&entity.MailStopNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *mailStopTypeRepository) Update(ctx context.Context, entity *parent.MailStopType) error {
	query := "UPDATE mail_stop_type SET type = ?, mail_stop_name = ?, mail_stop_number = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.MailStopName,
		entity.MailStopNumber,
		entity.ID,
	)
	return err
}

func (r *mailStopTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM mail_stop_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *mailStopTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM mail_stop_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *mailStopTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM mail_stop_type").Scan(&count)
	return count, err
}

func (d *dal) ManifestType() parent.ManifestTypeRepository {
	return &manifestTypeRepository{db: d.db}
}

type manifestTypeRepository struct {
	db *sql.DB
}

func (r *manifestTypeRepository) Create(ctx context.Context, entity *parent.ManifestType) (int64, error) {
	query := "INSERT INTO manifest_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *manifestTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ManifestType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO manifest_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *manifestTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ManifestType, error) {
	query := "SELECT id, xsd_id FROM manifest_type WHERE id = ?"

	entity := &parent.ManifestType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *manifestTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ManifestType, error) {
	query := "SELECT id, xsd_id FROM manifest_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ManifestType
	for rows.Next() {
		entity := &parent.ManifestType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *manifestTypeRepository) Update(ctx context.Context, entity *parent.ManifestType) error {
	query := "UPDATE manifest_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *manifestTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM manifest_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *manifestTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM manifest_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *manifestTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM manifest_type").Scan(&count)
	return count, err
}

func (d *dal) MiddleNameElementType() parent.MiddleNameElementTypeRepository {
	return &middleNameElementTypeRepository{db: d.db}
}

type middleNameElementTypeRepository struct {
	db *sql.DB
}

func (r *middleNameElementTypeRepository) Create(ctx context.Context, entity *parent.MiddleNameElementType) (int64, error) {
	query := "INSERT INTO middle_name_element_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *middleNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.MiddleNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO middle_name_element_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *middleNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.MiddleNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM middle_name_element_type WHERE id = ?"

	entity := &parent.MiddleNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *middleNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.MiddleNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM middle_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.MiddleNameElementType
	for rows.Next() {
		entity := &parent.MiddleNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *middleNameElementTypeRepository) Update(ctx context.Context, entity *parent.MiddleNameElementType) error {
	query := "UPDATE middle_name_element_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *middleNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM middle_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *middleNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM middle_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *middleNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM middle_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) Model() parent.ModelRepository {
	return &modelRepository{db: d.db}
}

type modelRepository struct {
	db *sql.DB
}

func (r *modelRepository) Create(ctx context.Context, entity *parent.Model) (int64, error) {
	query := "INSERT INTO model (system) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.System,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *modelRepository) CreateBatch(ctx context.Context, entities []*parent.Model) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO model (system) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.System,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *modelRepository) GetByID(ctx context.Context, id int64) (*parent.Model, error) {
	query := "SELECT id, system FROM model WHERE id = ?"

	entity := &parent.Model{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.System,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *modelRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Model, error) {
	query := "SELECT id, system FROM model LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Model
	for rows.Next() {
		entity := &parent.Model{}
		err := rows.Scan(
			&entity.ID,
			&entity.System,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *modelRepository) Update(ctx context.Context, entity *parent.Model) error {
	query := "UPDATE model SET system = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.ID,
	)
	return err
}

func (r *modelRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM model WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *modelRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM model WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *modelRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM model").Scan(&count)
	return count, err
}

func (d *dal) ModelElementType() parent.ModelElementTypeRepository {
	return &modelElementTypeRepository{db: d.db}
}

type modelElementTypeRepository struct {
	db *sql.DB
}

func (r *modelElementTypeRepository) Create(ctx context.Context, entity *parent.ModelElementType) (int64, error) {
	query := "INSERT INTO model_element_type (system) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.System,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *modelElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ModelElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO model_element_type (system) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.System,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *modelElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ModelElementType, error) {
	query := "SELECT id, system FROM model_element_type WHERE id = ?"

	entity := &parent.ModelElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.System,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *modelElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ModelElementType, error) {
	query := "SELECT id, system FROM model_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ModelElementType
	for rows.Next() {
		entity := &parent.ModelElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.System,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *modelElementTypeRepository) Update(ctx context.Context, entity *parent.ModelElementType) error {
	query := "UPDATE model_element_type SET system = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.ID,
	)
	return err
}

func (r *modelElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM model_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *modelElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM model_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *modelElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM model_element_type").Scan(&count)
	return count, err
}

func (d *dal) MotherboardGuidElementType() parent.MotherboardGuidElementTypeRepository {
	return &motherboardGuidElementTypeRepository{db: d.db}
}

type motherboardGuidElementTypeRepository struct {
	db *sql.DB
}

func (r *motherboardGuidElementTypeRepository) Create(ctx context.Context, entity *parent.MotherboardGuidElementType) (int64, error) {
	query := "INSERT INTO motherboard_guid_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *motherboardGuidElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.MotherboardGuidElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO motherboard_guid_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *motherboardGuidElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.MotherboardGuidElementType, error) {
	query := "SELECT id FROM motherboard_guid_element_type WHERE id = ?"

	entity := &parent.MotherboardGuidElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *motherboardGuidElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.MotherboardGuidElementType, error) {
	query := "SELECT id FROM motherboard_guid_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.MotherboardGuidElementType
	for rows.Next() {
		entity := &parent.MotherboardGuidElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *motherboardGuidElementTypeRepository) Update(ctx context.Context, entity *parent.MotherboardGuidElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *motherboardGuidElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM motherboard_guid_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *motherboardGuidElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM motherboard_guid_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *motherboardGuidElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM motherboard_guid_element_type").Scan(&count)
	return count, err
}

func (d *dal) NameDetailsElementType() parent.NameDetailsElementTypeRepository {
	return &nameDetailsElementTypeRepository{db: d.db}
}

type nameDetailsElementTypeRepository struct {
	db *sql.DB
}

func (r *nameDetailsElementTypeRepository) Create(ctx context.Context, entity *parent.NameDetailsElementType) (int64, error) {
	query := "INSERT INTO name_details_element_type (name_details_key, addressee_indicator, dependency_name, parent_id) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NameDetailsKey,
		entity.AddresseeIndicator,
		entity.DependencyName,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *nameDetailsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.NameDetailsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO name_details_element_type (name_details_key, addressee_indicator, dependency_name, parent_id) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NameDetailsKey,
			entity.AddresseeIndicator,
			entity.DependencyName,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *nameDetailsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.NameDetailsElementType, error) {
	query := "SELECT id, name_details_key, addressee_indicator, dependency_name, parent_id FROM name_details_element_type WHERE id = ?"

	entity := &parent.NameDetailsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NameDetailsKey,
		&entity.AddresseeIndicator,
		&entity.DependencyName,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *nameDetailsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.NameDetailsElementType, error) {
	query := "SELECT id, name_details_key, addressee_indicator, dependency_name, parent_id FROM name_details_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NameDetailsElementType
	for rows.Next() {
		entity := &parent.NameDetailsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NameDetailsKey,
			&entity.AddresseeIndicator,
			&entity.DependencyName,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *nameDetailsElementTypeRepository) Update(ctx context.Context, entity *parent.NameDetailsElementType) error {
	query := "UPDATE name_details_element_type SET name_details_key = ?, addressee_indicator = ?, dependency_name = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NameDetailsKey,
		entity.AddresseeIndicator,
		entity.DependencyName,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *nameDetailsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM name_details_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *nameDetailsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM name_details_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *nameDetailsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM name_details_element_type").Scan(&count)
	return count, err
}

func (d *dal) NameLineType() parent.NameLineTypeRepository {
	return &nameLineTypeRepository{db: d.db}
}

type nameLineTypeRepository struct {
	db *sql.DB
}

func (r *nameLineTypeRepository) Create(ctx context.Context, entity *parent.NameLineType) (int64, error) {
	query := "INSERT INTO name_line_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *nameLineTypeRepository) CreateBatch(ctx context.Context, entities []*parent.NameLineType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO name_line_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *nameLineTypeRepository) GetByID(ctx context.Context, id int64) (*parent.NameLineType, error) {
	query := "SELECT id, type, name_type, code FROM name_line_type WHERE id = ?"

	entity := &parent.NameLineType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *nameLineTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.NameLineType, error) {
	query := "SELECT id, type, name_type, code FROM name_line_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NameLineType
	for rows.Next() {
		entity := &parent.NameLineType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *nameLineTypeRepository) Update(ctx context.Context, entity *parent.NameLineType) error {
	query := "UPDATE name_line_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *nameLineTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM name_line_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *nameLineTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM name_line_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *nameLineTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM name_line_type").Scan(&count)
	return count, err
}

func (d *dal) NamePrefixElementType() parent.NamePrefixElementTypeRepository {
	return &namePrefixElementTypeRepository{db: d.db}
}

type namePrefixElementTypeRepository struct {
	db *sql.DB
}

func (r *namePrefixElementTypeRepository) Create(ctx context.Context, entity *parent.NamePrefixElementType) (int64, error) {
	query := "INSERT INTO name_prefix_element_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *namePrefixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.NamePrefixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO name_prefix_element_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *namePrefixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.NamePrefixElementType, error) {
	query := "SELECT id, type, name_type, code FROM name_prefix_element_type WHERE id = ?"

	entity := &parent.NamePrefixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *namePrefixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.NamePrefixElementType, error) {
	query := "SELECT id, type, name_type, code FROM name_prefix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NamePrefixElementType
	for rows.Next() {
		entity := &parent.NamePrefixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *namePrefixElementTypeRepository) Update(ctx context.Context, entity *parent.NamePrefixElementType) error {
	query := "UPDATE name_prefix_element_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *namePrefixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM name_prefix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *namePrefixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM name_prefix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *namePrefixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM name_prefix_element_type").Scan(&count)
	return count, err
}

func (d *dal) NetworkInterfaceType() parent.NetworkInterfaceTypeRepository {
	return &networkInterfaceTypeRepository{db: d.db}
}

type networkInterfaceTypeRepository struct {
	db *sql.DB
}

func (r *networkInterfaceTypeRepository) Create(ctx context.Context, entity *parent.NetworkInterfaceType) (int64, error) {
	query := "INSERT INTO network_interface_type (mac_address, url, subnet_mask_id, default_route_id) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.MacAddress,
		entity.Url,
		entity.SubnetMaskID,
		entity.DefaultRouteID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *networkInterfaceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.NetworkInterfaceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO network_interface_type (mac_address, url, subnet_mask_id, default_route_id) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.MacAddress,
			entity.Url,
			entity.SubnetMaskID,
			entity.DefaultRouteID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *networkInterfaceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.NetworkInterfaceType, error) {
	query := "SELECT id, mac_address, url, subnet_mask_id, default_route_id FROM network_interface_type WHERE id = ?"

	entity := &parent.NetworkInterfaceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.MacAddress,
		&entity.Url,
		&entity.SubnetMaskID,
		&entity.DefaultRouteID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *networkInterfaceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.NetworkInterfaceType, error) {
	query := "SELECT id, mac_address, url, subnet_mask_id, default_route_id FROM network_interface_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NetworkInterfaceType
	for rows.Next() {
		entity := &parent.NetworkInterfaceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.MacAddress,
			&entity.Url,
			&entity.SubnetMaskID,
			&entity.DefaultRouteID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *networkInterfaceTypeRepository) Update(ctx context.Context, entity *parent.NetworkInterfaceType) error {
	query := "UPDATE network_interface_type SET mac_address = ?, url = ?, subnet_mask_id = ?, default_route_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.MacAddress,
		entity.Url,
		entity.SubnetMaskID,
		entity.DefaultRouteID,
		entity.ID,
	)
	return err
}

func (r *networkInterfaceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM network_interface_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *networkInterfaceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM network_interface_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *networkInterfaceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM network_interface_type").Scan(&count)
	return count, err
}

func (r *networkInterfaceTypeRepository) GetByIpAddressType(ctx context.Context, ip_address_typeID int64) ([]*parent.NetworkInterfaceType, error) {
	query := "SELECT id, mac_address, url, subnet_mask_id, default_route_id FROM network_interface_type WHERE subnet_mask_id = ?"

	rows, err := r.db.QueryContext(ctx, query, ip_address_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NetworkInterfaceType
	for rows.Next() {
		entity := &parent.NetworkInterfaceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.MacAddress,
			&entity.Url,
			&entity.SubnetMaskID,
			&entity.DefaultRouteID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) NetworkNameElementType() parent.NetworkNameElementTypeRepository {
	return &networkNameElementTypeRepository{db: d.db}
}

type networkNameElementTypeRepository struct {
	db *sql.DB
}

func (r *networkNameElementTypeRepository) Create(ctx context.Context, entity *parent.NetworkNameElementType) (int64, error) {
	query := "INSERT INTO network_name_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *networkNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.NetworkNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO network_name_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *networkNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.NetworkNameElementType, error) {
	query := "SELECT id FROM network_name_element_type WHERE id = ?"

	entity := &parent.NetworkNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *networkNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.NetworkNameElementType, error) {
	query := "SELECT id FROM network_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NetworkNameElementType
	for rows.Next() {
		entity := &parent.NetworkNameElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *networkNameElementTypeRepository) Update(ctx context.Context, entity *parent.NetworkNameElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *networkNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM network_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *networkNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM network_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *networkNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM network_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) NetworkType() parent.NetworkTypeRepository {
	return &networkTypeRepository{db: d.db}
}

type networkTypeRepository struct {
	db *sql.DB
}

func (r *networkTypeRepository) Create(ctx context.Context, entity *parent.NetworkType) (int64, error) {
	query := "INSERT INTO network_type (network_name, ip_net_range, cidr, parent_id) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NetworkName,
		entity.IpNetRange,
		entity.Cidr,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *networkTypeRepository) CreateBatch(ctx context.Context, entities []*parent.NetworkType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO network_type (network_name, ip_net_range, cidr, parent_id) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NetworkName,
			entity.IpNetRange,
			entity.Cidr,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *networkTypeRepository) GetByID(ctx context.Context, id int64) (*parent.NetworkType, error) {
	query := "SELECT id, network_name, ip_net_range, cidr, parent_id FROM network_type WHERE id = ?"

	entity := &parent.NetworkType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NetworkName,
		&entity.IpNetRange,
		&entity.Cidr,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *networkTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.NetworkType, error) {
	query := "SELECT id, network_name, ip_net_range, cidr, parent_id FROM network_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NetworkType
	for rows.Next() {
		entity := &parent.NetworkType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NetworkName,
			&entity.IpNetRange,
			&entity.Cidr,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *networkTypeRepository) Update(ctx context.Context, entity *parent.NetworkType) error {
	query := "UPDATE network_type SET network_name = ?, ip_net_range = ?, cidr = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NetworkName,
		entity.IpNetRange,
		entity.Cidr,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *networkTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM network_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *networkTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM network_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *networkTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM network_type").Scan(&count)
	return count, err
}

func (r *networkTypeRepository) GetByItAssetType(ctx context.Context, it_asset_typeID int64) ([]*parent.NetworkType, error) {
	query := "SELECT id, network_name, ip_net_range, cidr, parent_id FROM network_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, it_asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NetworkType
	for rows.Next() {
		entity := &parent.NetworkType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NetworkName,
			&entity.IpNetRange,
			&entity.Cidr,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) Notes() parent.NotesRepository {
	return &notesRepository{db: d.db}
}

type notesRepository struct {
	db *sql.DB
}

func (r *notesRepository) Create(ctx context.Context, entity *parent.Notes) (int64, error) {
	query := "INSERT INTO notes (note, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Note,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *notesRepository) CreateBatch(ctx context.Context, entities []*parent.Notes) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO notes (note, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Note,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *notesRepository) GetByID(ctx context.Context, id int64) (*parent.Notes, error) {
	query := "SELECT id, note, parent_id FROM notes WHERE id = ?"

	entity := &parent.Notes{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Note,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *notesRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Notes, error) {
	query := "SELECT id, note, parent_id FROM notes LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Notes
	for rows.Next() {
		entity := &parent.Notes{}
		err := rows.Scan(
			&entity.ID,
			&entity.Note,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *notesRepository) Update(ctx context.Context, entity *parent.Notes) error {
	query := "UPDATE notes SET note = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Note,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *notesRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM notes WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *notesRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM notes WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *notesRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM notes").Scan(&count)
	return count, err
}

func (d *dal) NotesElementType() parent.NotesElementTypeRepository {
	return &notesElementTypeRepository{db: d.db}
}

type notesElementTypeRepository struct {
	db *sql.DB
}

func (r *notesElementTypeRepository) Create(ctx context.Context, entity *parent.NotesElementType) (int64, error) {
	query := "INSERT INTO notes_element_type (note, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Note,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *notesElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.NotesElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO notes_element_type (note, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Note,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *notesElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.NotesElementType, error) {
	query := "SELECT id, note, parent_id FROM notes_element_type WHERE id = ?"

	entity := &parent.NotesElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Note,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *notesElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.NotesElementType, error) {
	query := "SELECT id, note, parent_id FROM notes_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NotesElementType
	for rows.Next() {
		entity := &parent.NotesElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Note,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *notesElementTypeRepository) Update(ctx context.Context, entity *parent.NotesElementType) error {
	query := "UPDATE notes_element_type SET note = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Note,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *notesElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM notes_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *notesElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM notes_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *notesElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM notes_element_type").Scan(&count)
	return count, err
}

func (d *dal) NoticeType() parent.NoticeTypeRepository {
	return &noticeTypeRepository{db: d.db}
}

type noticeTypeRepository struct {
	db *sql.DB
}

func (r *noticeTypeRepository) Create(ctx context.Context, entity *parent.NoticeType) (int64, error) {
	query := "INSERT INTO notice_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *noticeTypeRepository) CreateBatch(ctx context.Context, entities []*parent.NoticeType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO notice_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *noticeTypeRepository) GetByID(ctx context.Context, id int64) (*parent.NoticeType, error) {
	query := "SELECT id, xsd_id FROM notice_type WHERE id = ?"

	entity := &parent.NoticeType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *noticeTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.NoticeType, error) {
	query := "SELECT id, xsd_id FROM notice_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.NoticeType
	for rows.Next() {
		entity := &parent.NoticeType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *noticeTypeRepository) Update(ctx context.Context, entity *parent.NoticeType) error {
	query := "UPDATE notice_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *noticeTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM notice_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *noticeTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM notice_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *noticeTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM notice_type").Scan(&count)
	return count, err
}

func (d *dal) Ns09XmldsigObjectType() parent.Ns09XmldsigObjectTypeRepository {
	return &ns09XmldsigObjectTypeRepository{db: d.db}
}

type ns09XmldsigObjectTypeRepository struct {
	db *sql.DB
}

func (r *ns09XmldsigObjectTypeRepository) Create(ctx context.Context, entity *parent.Ns09XmldsigObjectType) (int64, error) {
	query := "INSERT INTO ns_09_xmldsig_object_type (xsd_id, mime_type, encoding) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.MimeType,
		entity.Encoding,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ns09XmldsigObjectTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Ns09XmldsigObjectType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO ns_09_xmldsig_object_type (xsd_id, mime_type, encoding) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.MimeType,
			entity.Encoding,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ns09XmldsigObjectTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Ns09XmldsigObjectType, error) {
	query := "SELECT id, xsd_id, mime_type, encoding FROM ns_09_xmldsig_object_type WHERE id = ?"

	entity := &parent.Ns09XmldsigObjectType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.MimeType,
		&entity.Encoding,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ns09XmldsigObjectTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Ns09XmldsigObjectType, error) {
	query := "SELECT id, xsd_id, mime_type, encoding FROM ns_09_xmldsig_object_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Ns09XmldsigObjectType
	for rows.Next() {
		entity := &parent.Ns09XmldsigObjectType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.MimeType,
			&entity.Encoding,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ns09XmldsigObjectTypeRepository) Update(ctx context.Context, entity *parent.Ns09XmldsigObjectType) error {
	query := "UPDATE ns_09_xmldsig_object_type SET xsd_id = ?, mime_type = ?, encoding = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.MimeType,
		entity.Encoding,
		entity.ID,
	)
	return err
}

func (r *ns09XmldsigObjectTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM ns_09_xmldsig_object_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ns09XmldsigObjectTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM ns_09_xmldsig_object_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ns09XmldsigObjectTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM ns_09_xmldsig_object_type").Scan(&count)
	return count, err
}

func (d *dal) Ns09XmldsigReferenceType() parent.Ns09XmldsigReferenceTypeRepository {
	return &ns09XmldsigReferenceTypeRepository{db: d.db}
}

type ns09XmldsigReferenceTypeRepository struct {
	db *sql.DB
}

func (r *ns09XmldsigReferenceTypeRepository) Create(ctx context.Context, entity *parent.Ns09XmldsigReferenceType) (int64, error) {
	query := "INSERT INTO ns_09_xmldsig_reference_type (xsd_id, u_r_i, type) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.URI,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ns09XmldsigReferenceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Ns09XmldsigReferenceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO ns_09_xmldsig_reference_type (xsd_id, u_r_i, type) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.URI,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ns09XmldsigReferenceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Ns09XmldsigReferenceType, error) {
	query := "SELECT id, xsd_id, u_r_i, type FROM ns_09_xmldsig_reference_type WHERE id = ?"

	entity := &parent.Ns09XmldsigReferenceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.URI,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ns09XmldsigReferenceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Ns09XmldsigReferenceType, error) {
	query := "SELECT id, xsd_id, u_r_i, type FROM ns_09_xmldsig_reference_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Ns09XmldsigReferenceType
	for rows.Next() {
		entity := &parent.Ns09XmldsigReferenceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.URI,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ns09XmldsigReferenceTypeRepository) Update(ctx context.Context, entity *parent.Ns09XmldsigReferenceType) error {
	query := "UPDATE ns_09_xmldsig_reference_type SET xsd_id = ?, u_r_i = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.URI,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *ns09XmldsigReferenceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM ns_09_xmldsig_reference_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ns09XmldsigReferenceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM ns_09_xmldsig_reference_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ns09XmldsigReferenceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM ns_09_xmldsig_reference_type").Scan(&count)
	return count, err
}

func (d *dal) Ns09XmldsigSignatureType() parent.Ns09XmldsigSignatureTypeRepository {
	return &ns09XmldsigSignatureTypeRepository{db: d.db}
}

type ns09XmldsigSignatureTypeRepository struct {
	db *sql.DB
}

func (r *ns09XmldsigSignatureTypeRepository) Create(ctx context.Context, entity *parent.Ns09XmldsigSignatureType) (int64, error) {
	query := "INSERT INTO ns_09_xmldsig_signature_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ns09XmldsigSignatureTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Ns09XmldsigSignatureType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO ns_09_xmldsig_signature_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ns09XmldsigSignatureTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Ns09XmldsigSignatureType, error) {
	query := "SELECT id, xsd_id FROM ns_09_xmldsig_signature_type WHERE id = ?"

	entity := &parent.Ns09XmldsigSignatureType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ns09XmldsigSignatureTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Ns09XmldsigSignatureType, error) {
	query := "SELECT id, xsd_id FROM ns_09_xmldsig_signature_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Ns09XmldsigSignatureType
	for rows.Next() {
		entity := &parent.Ns09XmldsigSignatureType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ns09XmldsigSignatureTypeRepository) Update(ctx context.Context, entity *parent.Ns09XmldsigSignatureType) error {
	query := "UPDATE ns_09_xmldsig_signature_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *ns09XmldsigSignatureTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM ns_09_xmldsig_signature_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ns09XmldsigSignatureTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM ns_09_xmldsig_signature_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ns09XmldsigSignatureTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM ns_09_xmldsig_signature_type").Scan(&count)
	return count, err
}

func (d *dal) OasisNamesTcCiqXNameDetails() parent.OasisNamesTcCiqXNameDetailsRepository {
	return &oasisNamesTcCiqXNameDetailsRepository{db: d.db}
}

type oasisNamesTcCiqXNameDetailsRepository struct {
	db *sql.DB
}

func (r *oasisNamesTcCiqXNameDetailsRepository) Create(ctx context.Context, entity *parent.OasisNamesTcCiqXNameDetails) (int64, error) {
	query := "INSERT INTO oasis_names_tc_ciq_x_name_details (name_details_key, addressee_indicator, dependency_name, parent_id) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NameDetailsKey,
		entity.AddresseeIndicator,
		entity.DependencyName,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *oasisNamesTcCiqXNameDetailsRepository) CreateBatch(ctx context.Context, entities []*parent.OasisNamesTcCiqXNameDetails) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oasis_names_tc_ciq_x_name_details (name_details_key, addressee_indicator, dependency_name, parent_id) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NameDetailsKey,
			entity.AddresseeIndicator,
			entity.DependencyName,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *oasisNamesTcCiqXNameDetailsRepository) GetByID(ctx context.Context, id int64) (*parent.OasisNamesTcCiqXNameDetails, error) {
	query := "SELECT id, name_details_key, addressee_indicator, dependency_name, parent_id FROM oasis_names_tc_ciq_x_name_details WHERE id = ?"

	entity := &parent.OasisNamesTcCiqXNameDetails{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NameDetailsKey,
		&entity.AddresseeIndicator,
		&entity.DependencyName,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *oasisNamesTcCiqXNameDetailsRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OasisNamesTcCiqXNameDetails, error) {
	query := "SELECT id, name_details_key, addressee_indicator, dependency_name, parent_id FROM oasis_names_tc_ciq_x_name_details LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OasisNamesTcCiqXNameDetails
	for rows.Next() {
		entity := &parent.OasisNamesTcCiqXNameDetails{}
		err := rows.Scan(
			&entity.ID,
			&entity.NameDetailsKey,
			&entity.AddresseeIndicator,
			&entity.DependencyName,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *oasisNamesTcCiqXNameDetailsRepository) Update(ctx context.Context, entity *parent.OasisNamesTcCiqXNameDetails) error {
	query := "UPDATE oasis_names_tc_ciq_x_name_details SET name_details_key = ?, addressee_indicator = ?, dependency_name = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NameDetailsKey,
		entity.AddresseeIndicator,
		entity.DependencyName,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *oasisNamesTcCiqXNameDetailsRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oasis_names_tc_ciq_x_name_details WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *oasisNamesTcCiqXNameDetailsRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oasis_names_tc_ciq_x_name_details WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *oasisNamesTcCiqXNameDetailsRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oasis_names_tc_ciq_x_name_details").Scan(&count)
	return count, err
}

func (d *dal) OasisNamesTcCiqXOrganisationNameDetails() parent.OasisNamesTcCiqXOrganisationNameDetailsRepository {
	return &oasisNamesTcCiqXOrganisationNameDetailsRepository{db: d.db}
}

type oasisNamesTcCiqXOrganisationNameDetailsRepository struct {
	db *sql.DB
}

func (r *oasisNamesTcCiqXOrganisationNameDetailsRepository) Create(ctx context.Context, entity *parent.OasisNamesTcCiqXOrganisationNameDetails) (int64, error) {
	query := "INSERT INTO oasis_names_tc_ciq_x_organisation_name_details (organisation_former_name, organisation_known_as, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.OrganisationFormerName,
		entity.OrganisationKnownAs,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *oasisNamesTcCiqXOrganisationNameDetailsRepository) CreateBatch(ctx context.Context, entities []*parent.OasisNamesTcCiqXOrganisationNameDetails) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oasis_names_tc_ciq_x_organisation_name_details (organisation_former_name, organisation_known_as, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.OrganisationFormerName,
			entity.OrganisationKnownAs,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *oasisNamesTcCiqXOrganisationNameDetailsRepository) GetByID(ctx context.Context, id int64) (*parent.OasisNamesTcCiqXOrganisationNameDetails, error) {
	query := "SELECT id, organisation_former_name, organisation_known_as, parent_id FROM oasis_names_tc_ciq_x_organisation_name_details WHERE id = ?"

	entity := &parent.OasisNamesTcCiqXOrganisationNameDetails{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.OrganisationFormerName,
		&entity.OrganisationKnownAs,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *oasisNamesTcCiqXOrganisationNameDetailsRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OasisNamesTcCiqXOrganisationNameDetails, error) {
	query := "SELECT id, organisation_former_name, organisation_known_as, parent_id FROM oasis_names_tc_ciq_x_organisation_name_details LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OasisNamesTcCiqXOrganisationNameDetails
	for rows.Next() {
		entity := &parent.OasisNamesTcCiqXOrganisationNameDetails{}
		err := rows.Scan(
			&entity.ID,
			&entity.OrganisationFormerName,
			&entity.OrganisationKnownAs,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *oasisNamesTcCiqXOrganisationNameDetailsRepository) Update(ctx context.Context, entity *parent.OasisNamesTcCiqXOrganisationNameDetails) error {
	query := "UPDATE oasis_names_tc_ciq_x_organisation_name_details SET organisation_former_name = ?, organisation_known_as = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.OrganisationFormerName,
		entity.OrganisationKnownAs,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *oasisNamesTcCiqXOrganisationNameDetailsRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oasis_names_tc_ciq_x_organisation_name_details WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *oasisNamesTcCiqXOrganisationNameDetailsRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oasis_names_tc_ciq_x_organisation_name_details WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *oasisNamesTcCiqXOrganisationNameDetailsRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oasis_names_tc_ciq_x_organisation_name_details").Scan(&count)
	return count, err
}

func (d *dal) OasisNamesTcCiqXPersonName() parent.OasisNamesTcCiqXPersonNameRepository {
	return &oasisNamesTcCiqXPersonNameRepository{db: d.db}
}

type oasisNamesTcCiqXPersonNameRepository struct {
	db *sql.DB
}

func (r *oasisNamesTcCiqXPersonNameRepository) Create(ctx context.Context, entity *parent.OasisNamesTcCiqXPersonName) (int64, error) {
	query := "INSERT INTO oasis_names_tc_ciq_x_person_name (former_name, known_as, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.FormerName,
		entity.KnownAs,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *oasisNamesTcCiqXPersonNameRepository) CreateBatch(ctx context.Context, entities []*parent.OasisNamesTcCiqXPersonName) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oasis_names_tc_ciq_x_person_name (former_name, known_as, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.FormerName,
			entity.KnownAs,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *oasisNamesTcCiqXPersonNameRepository) GetByID(ctx context.Context, id int64) (*parent.OasisNamesTcCiqXPersonName, error) {
	query := "SELECT id, former_name, known_as, parent_id FROM oasis_names_tc_ciq_x_person_name WHERE id = ?"

	entity := &parent.OasisNamesTcCiqXPersonName{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.FormerName,
		&entity.KnownAs,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *oasisNamesTcCiqXPersonNameRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OasisNamesTcCiqXPersonName, error) {
	query := "SELECT id, former_name, known_as, parent_id FROM oasis_names_tc_ciq_x_person_name LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OasisNamesTcCiqXPersonName
	for rows.Next() {
		entity := &parent.OasisNamesTcCiqXPersonName{}
		err := rows.Scan(
			&entity.ID,
			&entity.FormerName,
			&entity.KnownAs,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *oasisNamesTcCiqXPersonNameRepository) Update(ctx context.Context, entity *parent.OasisNamesTcCiqXPersonName) error {
	query := "UPDATE oasis_names_tc_ciq_x_person_name SET former_name = ?, known_as = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.FormerName,
		entity.KnownAs,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *oasisNamesTcCiqXPersonNameRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oasis_names_tc_ciq_x_person_name WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *oasisNamesTcCiqXPersonNameRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oasis_names_tc_ciq_x_person_name WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *oasisNamesTcCiqXPersonNameRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oasis_names_tc_ciq_x_person_name").Scan(&count)
	return count, err
}

func (d *dal) ObjectComponentType() parent.ObjectComponentTypeRepository {
	return &objectComponentTypeRepository{db: d.db}
}

type objectComponentTypeRepository struct {
	db *sql.DB
}

func (r *objectComponentTypeRepository) Create(ctx context.Context, entity *parent.ObjectComponentType) (int64, error) {
	query := "INSERT INTO object_component_type (object_ref, item_field, record_field) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Object_ref,
		entity.Item_field,
		entity.Record_field,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *objectComponentTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ObjectComponentType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO object_component_type (object_ref, item_field, record_field) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Object_ref,
			entity.Item_field,
			entity.Record_field,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *objectComponentTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ObjectComponentType, error) {
	query := "SELECT id, object_ref, item_field, record_field FROM object_component_type WHERE id = ?"

	entity := &parent.ObjectComponentType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Object_ref,
		&entity.Item_field,
		&entity.Record_field,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *objectComponentTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ObjectComponentType, error) {
	query := "SELECT id, object_ref, item_field, record_field FROM object_component_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ObjectComponentType
	for rows.Next() {
		entity := &parent.ObjectComponentType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Object_ref,
			&entity.Item_field,
			&entity.Record_field,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *objectComponentTypeRepository) Update(ctx context.Context, entity *parent.ObjectComponentType) error {
	query := "UPDATE object_component_type SET object_ref = ?, item_field = ?, record_field = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Object_ref,
		entity.Item_field,
		entity.Record_field,
		entity.ID,
	)
	return err
}

func (r *objectComponentTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM object_component_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *objectComponentTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM object_component_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *objectComponentTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM object_component_type").Scan(&count)
	return count, err
}

func (d *dal) ObjectRef() parent.ObjectRefRepository {
	return &objectRefRepository{db: d.db}
}

type objectRefRepository struct {
	db *sql.DB
}

func (r *objectRefRepository) Create(ctx context.Context, entity *parent.ObjectRef) (int64, error) {
	query := "INSERT INTO object_ref (ref_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.RefId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *objectRefRepository) CreateBatch(ctx context.Context, entities []*parent.ObjectRef) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO object_ref (ref_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.RefId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *objectRefRepository) GetByID(ctx context.Context, id int64) (*parent.ObjectRef, error) {
	query := "SELECT id, ref_id FROM object_ref WHERE id = ?"

	entity := &parent.ObjectRef{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.RefId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *objectRefRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ObjectRef, error) {
	query := "SELECT id, ref_id FROM object_ref LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ObjectRef
	for rows.Next() {
		entity := &parent.ObjectRef{}
		err := rows.Scan(
			&entity.ID,
			&entity.RefId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *objectRefRepository) Update(ctx context.Context, entity *parent.ObjectRef) error {
	query := "UPDATE object_ref SET ref_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.RefId,
		entity.ID,
	)
	return err
}

func (r *objectRefRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM object_ref WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *objectRefRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM object_ref WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *objectRefRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM object_ref").Scan(&count)
	return count, err
}

func (d *dal) ObjectRefElementType() parent.ObjectRefElementTypeRepository {
	return &objectRefElementTypeRepository{db: d.db}
}

type objectRefElementTypeRepository struct {
	db *sql.DB
}

func (r *objectRefElementTypeRepository) Create(ctx context.Context, entity *parent.ObjectRefElementType) (int64, error) {
	query := "INSERT INTO object_ref_element_type (ref_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.RefId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *objectRefElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ObjectRefElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO object_ref_element_type (ref_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.RefId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *objectRefElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ObjectRefElementType, error) {
	query := "SELECT id, ref_id FROM object_ref_element_type WHERE id = ?"

	entity := &parent.ObjectRefElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.RefId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *objectRefElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ObjectRefElementType, error) {
	query := "SELECT id, ref_id FROM object_ref_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ObjectRefElementType
	for rows.Next() {
		entity := &parent.ObjectRefElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.RefId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *objectRefElementTypeRepository) Update(ctx context.Context, entity *parent.ObjectRefElementType) error {
	query := "UPDATE object_ref_element_type SET ref_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.RefId,
		entity.ID,
	)
	return err
}

func (r *objectRefElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM object_ref_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *objectRefElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM object_ref_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *objectRefElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM object_ref_element_type").Scan(&count)
	return count, err
}

func (d *dal) ObjectRefType() parent.ObjectRefTypeRepository {
	return &objectRefTypeRepository{db: d.db}
}

type objectRefTypeRepository struct {
	db *sql.DB
}

func (r *objectRefTypeRepository) Create(ctx context.Context, entity *parent.ObjectRefType) (int64, error) {
	query := "INSERT INTO object_ref_type (object_ref) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Object_ref,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *objectRefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ObjectRefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO object_ref_type (object_ref) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Object_ref,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *objectRefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ObjectRefType, error) {
	query := "SELECT id, object_ref FROM object_ref_type WHERE id = ?"

	entity := &parent.ObjectRefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Object_ref,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *objectRefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ObjectRefType, error) {
	query := "SELECT id, object_ref FROM object_ref_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ObjectRefType
	for rows.Next() {
		entity := &parent.ObjectRefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Object_ref,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *objectRefTypeRepository) Update(ctx context.Context, entity *parent.ObjectRefType) error {
	query := "UPDATE object_ref_type SET object_ref = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Object_ref,
		entity.ID,
	)
	return err
}

func (r *objectRefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM object_ref_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *objectRefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM object_ref_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *objectRefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM object_ref_type").Scan(&count)
	return count, err
}

func (d *dal) ObjectsType() parent.ObjectsTypeRepository {
	return &objectsTypeRepository{db: d.db}
}

type objectsTypeRepository struct {
	db *sql.DB
}

func (r *objectsTypeRepository) Create(ctx context.Context, entity *parent.ObjectsType) (int64, error) {
	query := "INSERT INTO objects_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *objectsTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ObjectsType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO objects_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *objectsTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ObjectsType, error) {
	query := "SELECT id FROM objects_type WHERE id = ?"

	entity := &parent.ObjectsType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *objectsTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ObjectsType, error) {
	query := "SELECT id FROM objects_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ObjectsType
	for rows.Next() {
		entity := &parent.ObjectsType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *objectsTypeRepository) Update(ctx context.Context, entity *parent.ObjectsType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *objectsTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM objects_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *objectsTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM objects_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *objectsTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM objects_type").Scan(&count)
	return count, err
}

func (d *dal) OrganisationFormerNameElementType() parent.OrganisationFormerNameElementTypeRepository {
	return &organisationFormerNameElementTypeRepository{db: d.db}
}

type organisationFormerNameElementTypeRepository struct {
	db *sql.DB
}

func (r *organisationFormerNameElementTypeRepository) Create(ctx context.Context, entity *parent.OrganisationFormerNameElementType) (int64, error) {
	query := "INSERT INTO organisation_former_name_element_type (valid_from, valid_to, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ValidFrom,
		entity.ValidTo,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *organisationFormerNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OrganisationFormerNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO organisation_former_name_element_type (valid_from, valid_to, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ValidFrom,
			entity.ValidTo,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *organisationFormerNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OrganisationFormerNameElementType, error) {
	query := "SELECT id, valid_from, valid_to, parent_id FROM organisation_former_name_element_type WHERE id = ?"

	entity := &parent.OrganisationFormerNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ValidFrom,
		&entity.ValidTo,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *organisationFormerNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OrganisationFormerNameElementType, error) {
	query := "SELECT id, valid_from, valid_to, parent_id FROM organisation_former_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OrganisationFormerNameElementType
	for rows.Next() {
		entity := &parent.OrganisationFormerNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ValidFrom,
			&entity.ValidTo,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *organisationFormerNameElementTypeRepository) Update(ctx context.Context, entity *parent.OrganisationFormerNameElementType) error {
	query := "UPDATE organisation_former_name_element_type SET valid_from = ?, valid_to = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ValidFrom,
		entity.ValidTo,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *organisationFormerNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM organisation_former_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *organisationFormerNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM organisation_former_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *organisationFormerNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM organisation_former_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) OrganisationKnownAsElementType() parent.OrganisationKnownAsElementTypeRepository {
	return &organisationKnownAsElementTypeRepository{db: d.db}
}

type organisationKnownAsElementTypeRepository struct {
	db *sql.DB
}

func (r *organisationKnownAsElementTypeRepository) Create(ctx context.Context, entity *parent.OrganisationKnownAsElementType) (int64, error) {
	query := "INSERT INTO \"organisation_known_as_element_type\" (valid_from, valid_to, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ValidFrom,
		entity.ValidTo,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *organisationKnownAsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OrganisationKnownAsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"organisation_known_as_element_type\" (valid_from, valid_to, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ValidFrom,
			entity.ValidTo,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *organisationKnownAsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OrganisationKnownAsElementType, error) {
	query := "SELECT id, valid_from, valid_to, parent_id FROM \"organisation_known_as_element_type\" WHERE id = ?"

	entity := &parent.OrganisationKnownAsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ValidFrom,
		&entity.ValidTo,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *organisationKnownAsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OrganisationKnownAsElementType, error) {
	query := "SELECT id, valid_from, valid_to, parent_id FROM \"organisation_known_as_element_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OrganisationKnownAsElementType
	for rows.Next() {
		entity := &parent.OrganisationKnownAsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ValidFrom,
			&entity.ValidTo,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *organisationKnownAsElementTypeRepository) Update(ctx context.Context, entity *parent.OrganisationKnownAsElementType) error {
	query := "UPDATE \"organisation_known_as_element_type\" SET valid_from = ?, valid_to = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ValidFrom,
		entity.ValidTo,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *organisationKnownAsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"organisation_known_as_element_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *organisationKnownAsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"organisation_known_as_element_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *organisationKnownAsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"organisation_known_as_element_type\"").Scan(&count)
	return count, err
}

func (d *dal) OrganisationNameDetailsElementType() parent.OrganisationNameDetailsElementTypeRepository {
	return &organisationNameDetailsElementTypeRepository{db: d.db}
}

type organisationNameDetailsElementTypeRepository struct {
	db *sql.DB
}

func (r *organisationNameDetailsElementTypeRepository) Create(ctx context.Context, entity *parent.OrganisationNameDetailsElementType) (int64, error) {
	query := "INSERT INTO organisation_name_details_element_type (organisation_former_name, organisation_known_as, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.OrganisationFormerName,
		entity.OrganisationKnownAs,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *organisationNameDetailsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OrganisationNameDetailsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO organisation_name_details_element_type (organisation_former_name, organisation_known_as, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.OrganisationFormerName,
			entity.OrganisationKnownAs,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *organisationNameDetailsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OrganisationNameDetailsElementType, error) {
	query := "SELECT id, organisation_former_name, organisation_known_as, parent_id FROM organisation_name_details_element_type WHERE id = ?"

	entity := &parent.OrganisationNameDetailsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.OrganisationFormerName,
		&entity.OrganisationKnownAs,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *organisationNameDetailsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OrganisationNameDetailsElementType, error) {
	query := "SELECT id, organisation_former_name, organisation_known_as, parent_id FROM organisation_name_details_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OrganisationNameDetailsElementType
	for rows.Next() {
		entity := &parent.OrganisationNameDetailsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.OrganisationFormerName,
			&entity.OrganisationKnownAs,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *organisationNameDetailsElementTypeRepository) Update(ctx context.Context, entity *parent.OrganisationNameDetailsElementType) error {
	query := "UPDATE organisation_name_details_element_type SET organisation_former_name = ?, organisation_known_as = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.OrganisationFormerName,
		entity.OrganisationKnownAs,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *organisationNameDetailsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM organisation_name_details_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *organisationNameDetailsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM organisation_name_details_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *organisationNameDetailsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM organisation_name_details_element_type").Scan(&count)
	return count, err
}

func (d *dal) OrganisationNameElementType() parent.OrganisationNameElementTypeRepository {
	return &organisationNameElementTypeRepository{db: d.db}
}

type organisationNameElementTypeRepository struct {
	db *sql.DB
}

func (r *organisationNameElementTypeRepository) Create(ctx context.Context, entity *parent.OrganisationNameElementType) (int64, error) {
	query := "INSERT INTO organisation_name_element_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *organisationNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OrganisationNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO organisation_name_element_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *organisationNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OrganisationNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM organisation_name_element_type WHERE id = ?"

	entity := &parent.OrganisationNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *organisationNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OrganisationNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM organisation_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OrganisationNameElementType
	for rows.Next() {
		entity := &parent.OrganisationNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *organisationNameElementTypeRepository) Update(ctx context.Context, entity *parent.OrganisationNameElementType) error {
	query := "UPDATE organisation_name_element_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *organisationNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM organisation_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *organisationNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM organisation_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *organisationNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM organisation_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) OrganisationTypeElementType() parent.OrganisationTypeElementTypeRepository {
	return &organisationTypeElementTypeRepository{db: d.db}
}

type organisationTypeElementTypeRepository struct {
	db *sql.DB
}

func (r *organisationTypeElementTypeRepository) Create(ctx context.Context, entity *parent.OrganisationTypeElementType) (int64, error) {
	query := "INSERT INTO organisation_type_element_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *organisationTypeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OrganisationTypeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO organisation_type_element_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *organisationTypeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OrganisationTypeElementType, error) {
	query := "SELECT id, type, name_type, code FROM organisation_type_element_type WHERE id = ?"

	entity := &parent.OrganisationTypeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *organisationTypeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OrganisationTypeElementType, error) {
	query := "SELECT id, type, name_type, code FROM organisation_type_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OrganisationTypeElementType
	for rows.Next() {
		entity := &parent.OrganisationTypeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *organisationTypeElementTypeRepository) Update(ctx context.Context, entity *parent.OrganisationTypeElementType) error {
	query := "UPDATE organisation_type_element_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *organisationTypeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM organisation_type_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *organisationTypeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM organisation_type_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *organisationTypeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM organisation_type_element_type").Scan(&count)
	return count, err
}

func (d *dal) OrganizationType() parent.OrganizationTypeRepository {
	return &organizationTypeRepository{db: d.db}
}

type organizationTypeRepository struct {
	db *sql.DB
}

func (r *organizationTypeRepository) Create(ctx context.Context, entity *parent.OrganizationType) (int64, error) {
	query := "INSERT INTO organization_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *organizationTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OrganizationType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO organization_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *organizationTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OrganizationType, error) {
	query := "SELECT id, parent_id FROM organization_type WHERE id = ?"

	entity := &parent.OrganizationType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *organizationTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OrganizationType, error) {
	query := "SELECT id, parent_id FROM organization_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OrganizationType
	for rows.Next() {
		entity := &parent.OrganizationType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *organizationTypeRepository) Update(ctx context.Context, entity *parent.OrganizationType) error {
	query := "UPDATE organization_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *organizationTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM organization_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *organizationTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM organization_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *organizationTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM organization_type").Scan(&count)
	return count, err
}

func (r *organizationTypeRepository) GetByAssetType(ctx context.Context, asset_typeID int64) ([]*parent.OrganizationType, error) {
	query := "SELECT id, parent_id FROM organization_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OrganizationType
	for rows.Next() {
		entity := &parent.OrganizationType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) OtherNameElementType() parent.OtherNameElementTypeRepository {
	return &otherNameElementTypeRepository{db: d.db}
}

type otherNameElementTypeRepository struct {
	db *sql.DB
}

func (r *otherNameElementTypeRepository) Create(ctx context.Context, entity *parent.OtherNameElementType) (int64, error) {
	query := "INSERT INTO other_name_element_type (type, name_type, code) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *otherNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OtherNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO other_name_element_type (type, name_type, code) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NameType,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *otherNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OtherNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM other_name_element_type WHERE id = ?"

	entity := &parent.OtherNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NameType,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *otherNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OtherNameElementType, error) {
	query := "SELECT id, type, name_type, code FROM other_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OtherNameElementType
	for rows.Next() {
		entity := &parent.OtherNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NameType,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *otherNameElementTypeRepository) Update(ctx context.Context, entity *parent.OtherNameElementType) error {
	query := "UPDATE other_name_element_type SET type = ?, name_type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NameType,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *otherNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM other_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *otherNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM other_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *otherNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM other_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) OvalDefinitions() parent.OvalDefinitionsRepository {
	return &ovalDefinitionsRepository{db: d.db}
}

type ovalDefinitionsRepository struct {
	db *sql.DB
}

func (r *ovalDefinitionsRepository) Create(ctx context.Context, entity *parent.OvalDefinitions) (int64, error) {
	query := "INSERT INTO oval_definitions (generator_id, definitions_id, tests_id, objects_id, states_id, variables_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.GeneratorID,
		entity.DefinitionsID,
		entity.TestsID,
		entity.ObjectsID,
		entity.StatesID,
		entity.VariablesID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalDefinitionsRepository) CreateBatch(ctx context.Context, entities []*parent.OvalDefinitions) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_definitions (generator_id, definitions_id, tests_id, objects_id, states_id, variables_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.GeneratorID,
			entity.DefinitionsID,
			entity.TestsID,
			entity.ObjectsID,
			entity.StatesID,
			entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalDefinitionsRepository) GetByID(ctx context.Context, id int64) (*parent.OvalDefinitions, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions WHERE id = ?"

	entity := &parent.OvalDefinitions{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.GeneratorID,
		&entity.DefinitionsID,
		&entity.TestsID,
		&entity.ObjectsID,
		&entity.StatesID,
		&entity.VariablesID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ovalDefinitionsRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalDefinitions, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalDefinitions
	for rows.Next() {
		entity := &parent.OvalDefinitions{}
		err := rows.Scan(
			&entity.ID,
			&entity.GeneratorID,
			&entity.DefinitionsID,
			&entity.TestsID,
			&entity.ObjectsID,
			&entity.StatesID,
			&entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalDefinitionsRepository) Update(ctx context.Context, entity *parent.OvalDefinitions) error {
	query := "UPDATE oval_definitions SET generator_id = ?, definitions_id = ?, tests_id = ?, objects_id = ?, states_id = ?, variables_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.GeneratorID,
		entity.DefinitionsID,
		entity.TestsID,
		entity.ObjectsID,
		entity.StatesID,
		entity.VariablesID,
		entity.ID,
	)
	return err
}

func (r *ovalDefinitionsRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_definitions WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalDefinitionsRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_definitions WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalDefinitionsRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_definitions").Scan(&count)
	return count, err
}

func (d *dal) OvalDefinitionsElementType() parent.OvalDefinitionsElementTypeRepository {
	return &ovalDefinitionsElementTypeRepository{db: d.db}
}

type ovalDefinitionsElementTypeRepository struct {
	db *sql.DB
}

func (r *ovalDefinitionsElementTypeRepository) Create(ctx context.Context, entity *parent.OvalDefinitionsElementType) (int64, error) {
	query := "INSERT INTO oval_definitions_element_type (generator_id, definitions_id, tests_id, objects_id, states_id, variables_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.GeneratorID,
		entity.DefinitionsID,
		entity.TestsID,
		entity.ObjectsID,
		entity.StatesID,
		entity.VariablesID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalDefinitionsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OvalDefinitionsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_definitions_element_type (generator_id, definitions_id, tests_id, objects_id, states_id, variables_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.GeneratorID,
			entity.DefinitionsID,
			entity.TestsID,
			entity.ObjectsID,
			entity.StatesID,
			entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalDefinitionsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OvalDefinitionsElementType, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions_element_type WHERE id = ?"

	entity := &parent.OvalDefinitionsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.GeneratorID,
		&entity.DefinitionsID,
		&entity.TestsID,
		&entity.ObjectsID,
		&entity.StatesID,
		&entity.VariablesID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ovalDefinitionsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalDefinitionsElementType, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalDefinitionsElementType
	for rows.Next() {
		entity := &parent.OvalDefinitionsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.GeneratorID,
			&entity.DefinitionsID,
			&entity.TestsID,
			&entity.ObjectsID,
			&entity.StatesID,
			&entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalDefinitionsElementTypeRepository) Update(ctx context.Context, entity *parent.OvalDefinitionsElementType) error {
	query := "UPDATE oval_definitions_element_type SET generator_id = ?, definitions_id = ?, tests_id = ?, objects_id = ?, states_id = ?, variables_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.GeneratorID,
		entity.DefinitionsID,
		entity.TestsID,
		entity.ObjectsID,
		entity.StatesID,
		entity.VariablesID,
		entity.ID,
	)
	return err
}

func (r *ovalDefinitionsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_definitions_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalDefinitionsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_definitions_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalDefinitionsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_definitions_element_type").Scan(&count)
	return count, err
}

func (r *ovalDefinitionsElementTypeRepository) GetByDefinitionsType(ctx context.Context, definitions_typeID int64) ([]*parent.OvalDefinitionsElementType, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions_element_type WHERE definitions_id = ?"

	rows, err := r.db.QueryContext(ctx, query, definitions_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalDefinitionsElementType
	for rows.Next() {
		entity := &parent.OvalDefinitionsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.GeneratorID,
			&entity.DefinitionsID,
			&entity.TestsID,
			&entity.ObjectsID,
			&entity.StatesID,
			&entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalDefinitionsElementTypeRepository) GetByTestsType(ctx context.Context, tests_typeID int64) ([]*parent.OvalDefinitionsElementType, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions_element_type WHERE tests_id = ?"

	rows, err := r.db.QueryContext(ctx, query, tests_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalDefinitionsElementType
	for rows.Next() {
		entity := &parent.OvalDefinitionsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.GeneratorID,
			&entity.DefinitionsID,
			&entity.TestsID,
			&entity.ObjectsID,
			&entity.StatesID,
			&entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalDefinitionsElementTypeRepository) GetByObjectsType(ctx context.Context, objects_typeID int64) ([]*parent.OvalDefinitionsElementType, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions_element_type WHERE objects_id = ?"

	rows, err := r.db.QueryContext(ctx, query, objects_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalDefinitionsElementType
	for rows.Next() {
		entity := &parent.OvalDefinitionsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.GeneratorID,
			&entity.DefinitionsID,
			&entity.TestsID,
			&entity.ObjectsID,
			&entity.StatesID,
			&entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalDefinitionsElementTypeRepository) GetByStatesType(ctx context.Context, states_typeID int64) ([]*parent.OvalDefinitionsElementType, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions_element_type WHERE states_id = ?"

	rows, err := r.db.QueryContext(ctx, query, states_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalDefinitionsElementType
	for rows.Next() {
		entity := &parent.OvalDefinitionsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.GeneratorID,
			&entity.DefinitionsID,
			&entity.TestsID,
			&entity.ObjectsID,
			&entity.StatesID,
			&entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalDefinitionsElementTypeRepository) GetByVariablesType(ctx context.Context, variables_typeID int64) ([]*parent.OvalDefinitionsElementType, error) {
	query := "SELECT id, generator_id, definitions_id, tests_id, objects_id, states_id, variables_id FROM oval_definitions_element_type WHERE variables_id = ?"

	rows, err := r.db.QueryContext(ctx, query, variables_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalDefinitionsElementType
	for rows.Next() {
		entity := &parent.OvalDefinitionsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.GeneratorID,
			&entity.DefinitionsID,
			&entity.TestsID,
			&entity.ObjectsID,
			&entity.StatesID,
			&entity.VariablesID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) OvalMitreOrgOvalGeneratorType() parent.OvalMitreOrgOvalGeneratorTypeRepository {
	return &ovalMitreOrgOvalGeneratorTypeRepository{db: d.db}
}

type ovalMitreOrgOvalGeneratorTypeRepository struct {
	db *sql.DB
}

func (r *ovalMitreOrgOvalGeneratorTypeRepository) Create(ctx context.Context, entity *parent.OvalMitreOrgOvalGeneratorType) (int64, error) {
	query := "INSERT INTO oval_mitre_org_oval__generator_type (product_name, product_version, timestamp) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Product_name,
		entity.Product_version,
		entity.Timestamp,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalMitreOrgOvalGeneratorTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OvalMitreOrgOvalGeneratorType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_mitre_org_oval__generator_type (product_name, product_version, timestamp) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Product_name,
			entity.Product_version,
			entity.Timestamp,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalMitreOrgOvalGeneratorTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OvalMitreOrgOvalGeneratorType, error) {
	query := "SELECT id, product_name, product_version, timestamp FROM oval_mitre_org_oval__generator_type WHERE id = ?"

	entity := &parent.OvalMitreOrgOvalGeneratorType{}
	var timestampTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Product_name,
		&entity.Product_version,
		&timestampTime,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Timestamp = timestampTime.Time

	return entity, nil
}

func (r *ovalMitreOrgOvalGeneratorTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalMitreOrgOvalGeneratorType, error) {
	query := "SELECT id, product_name, product_version, timestamp FROM oval_mitre_org_oval__generator_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalMitreOrgOvalGeneratorType
	for rows.Next() {
		entity := &parent.OvalMitreOrgOvalGeneratorType{}
		var timestampTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.Product_name,
			&entity.Product_version,
			&timestampTime,
		)
		if err != nil {
			return nil, err
		}
		entity.Timestamp = timestampTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalMitreOrgOvalGeneratorTypeRepository) Update(ctx context.Context, entity *parent.OvalMitreOrgOvalGeneratorType) error {
	query := "UPDATE oval_mitre_org_oval__generator_type SET product_name = ?, product_version = ?, timestamp = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Product_name,
		entity.Product_version,
		entity.Timestamp,
		entity.ID,
	)
	return err
}

func (r *ovalMitreOrgOvalGeneratorTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_mitre_org_oval__generator_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalMitreOrgOvalGeneratorTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_mitre_org_oval__generator_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalMitreOrgOvalGeneratorTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_mitre_org_oval__generator_type").Scan(&count)
	return count, err
}

func (d *dal) OvalMitreOrgOvalMessageType() parent.OvalMitreOrgOvalMessageTypeRepository {
	return &ovalMitreOrgOvalMessageTypeRepository{db: d.db}
}

type ovalMitreOrgOvalMessageTypeRepository struct {
	db *sql.DB
}

func (r *ovalMitreOrgOvalMessageTypeRepository) Create(ctx context.Context, entity *parent.OvalMitreOrgOvalMessageType) (int64, error) {
	query := "INSERT INTO oval_mitre_org_oval__message_type (level) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Level,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalMitreOrgOvalMessageTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OvalMitreOrgOvalMessageType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_mitre_org_oval__message_type (level) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Level,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalMitreOrgOvalMessageTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OvalMitreOrgOvalMessageType, error) {
	query := "SELECT id, level FROM oval_mitre_org_oval__message_type WHERE id = ?"

	entity := &parent.OvalMitreOrgOvalMessageType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Level,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ovalMitreOrgOvalMessageTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalMitreOrgOvalMessageType, error) {
	query := "SELECT id, level FROM oval_mitre_org_oval__message_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalMitreOrgOvalMessageType
	for rows.Next() {
		entity := &parent.OvalMitreOrgOvalMessageType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Level,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalMitreOrgOvalMessageTypeRepository) Update(ctx context.Context, entity *parent.OvalMitreOrgOvalMessageType) error {
	query := "UPDATE oval_mitre_org_oval__message_type SET level = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Level,
		entity.ID,
	)
	return err
}

func (r *ovalMitreOrgOvalMessageTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_mitre_org_oval__message_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalMitreOrgOvalMessageTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_mitre_org_oval__message_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalMitreOrgOvalMessageTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_mitre_org_oval__message_type").Scan(&count)
	return count, err
}

func (d *dal) OvalMitreOrgOvalMetadataType() parent.OvalMitreOrgOvalMetadataTypeRepository {
	return &ovalMitreOrgOvalMetadataTypeRepository{db: d.db}
}

type ovalMitreOrgOvalMetadataTypeRepository struct {
	db *sql.DB
}

func (r *ovalMitreOrgOvalMetadataTypeRepository) Create(ctx context.Context, entity *parent.OvalMitreOrgOvalMetadataType) (int64, error) {
	query := "INSERT INTO oval_mitre_org_oval__metadata_type (title, description) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Title,
		entity.Description,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalMitreOrgOvalMetadataTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OvalMitreOrgOvalMetadataType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_mitre_org_oval__metadata_type (title, description) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Title,
			entity.Description,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalMitreOrgOvalMetadataTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OvalMitreOrgOvalMetadataType, error) {
	query := "SELECT id, title, description FROM oval_mitre_org_oval__metadata_type WHERE id = ?"

	entity := &parent.OvalMitreOrgOvalMetadataType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Title,
		&entity.Description,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ovalMitreOrgOvalMetadataTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalMitreOrgOvalMetadataType, error) {
	query := "SELECT id, title, description FROM oval_mitre_org_oval__metadata_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalMitreOrgOvalMetadataType
	for rows.Next() {
		entity := &parent.OvalMitreOrgOvalMetadataType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Title,
			&entity.Description,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalMitreOrgOvalMetadataTypeRepository) Update(ctx context.Context, entity *parent.OvalMitreOrgOvalMetadataType) error {
	query := "UPDATE oval_mitre_org_oval__metadata_type SET title = ?, description = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Title,
		entity.Description,
		entity.ID,
	)
	return err
}

func (r *ovalMitreOrgOvalMetadataTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_mitre_org_oval__metadata_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalMitreOrgOvalMetadataTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_mitre_org_oval__metadata_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalMitreOrgOvalMetadataTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_mitre_org_oval__metadata_type").Scan(&count)
	return count, err
}

func (d *dal) OvalMitreOrgOvalNotesType() parent.OvalMitreOrgOvalNotesTypeRepository {
	return &ovalMitreOrgOvalNotesTypeRepository{db: d.db}
}

type ovalMitreOrgOvalNotesTypeRepository struct {
	db *sql.DB
}

func (r *ovalMitreOrgOvalNotesTypeRepository) Create(ctx context.Context, entity *parent.OvalMitreOrgOvalNotesType) (int64, error) {
	query := "INSERT INTO oval_mitre_org_oval__notes_type (note) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Note,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalMitreOrgOvalNotesTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OvalMitreOrgOvalNotesType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_mitre_org_oval__notes_type (note) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Note,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalMitreOrgOvalNotesTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OvalMitreOrgOvalNotesType, error) {
	query := "SELECT id, note FROM oval_mitre_org_oval__notes_type WHERE id = ?"

	entity := &parent.OvalMitreOrgOvalNotesType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Note,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ovalMitreOrgOvalNotesTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalMitreOrgOvalNotesType, error) {
	query := "SELECT id, note FROM oval_mitre_org_oval__notes_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalMitreOrgOvalNotesType
	for rows.Next() {
		entity := &parent.OvalMitreOrgOvalNotesType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Note,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalMitreOrgOvalNotesTypeRepository) Update(ctx context.Context, entity *parent.OvalMitreOrgOvalNotesType) error {
	query := "UPDATE oval_mitre_org_oval__notes_type SET note = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Note,
		entity.ID,
	)
	return err
}

func (r *ovalMitreOrgOvalNotesTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_mitre_org_oval__notes_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalMitreOrgOvalNotesTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_mitre_org_oval__notes_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalMitreOrgOvalNotesTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_mitre_org_oval__notes_type").Scan(&count)
	return count, err
}

func (d *dal) OvalMitreOrgOvalObjectType() parent.OvalMitreOrgOvalObjectTypeRepository {
	return &ovalMitreOrgOvalObjectTypeRepository{db: d.db}
}

type ovalMitreOrgOvalObjectTypeRepository struct {
	db *sql.DB
}

func (r *ovalMitreOrgOvalObjectTypeRepository) Create(ctx context.Context, entity *parent.OvalMitreOrgOvalObjectType) (int64, error) {
	query := "INSERT INTO oval_mitre_org_oval__object_type (xsd_id, version, comment, deprecated) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Comment,
		entity.Deprecated,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalMitreOrgOvalObjectTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OvalMitreOrgOvalObjectType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_mitre_org_oval__object_type (xsd_id, version, comment, deprecated) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Version,
			entity.Comment,
			entity.Deprecated,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalMitreOrgOvalObjectTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OvalMitreOrgOvalObjectType, error) {
	query := "SELECT id, xsd_id, version, comment, deprecated FROM oval_mitre_org_oval__object_type WHERE id = ?"

	entity := &parent.OvalMitreOrgOvalObjectType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Version,
		&entity.Comment,
		&entity.Deprecated,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ovalMitreOrgOvalObjectTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalMitreOrgOvalObjectType, error) {
	query := "SELECT id, xsd_id, version, comment, deprecated FROM oval_mitre_org_oval__object_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalMitreOrgOvalObjectType
	for rows.Next() {
		entity := &parent.OvalMitreOrgOvalObjectType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Version,
			&entity.Comment,
			&entity.Deprecated,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalMitreOrgOvalObjectTypeRepository) Update(ctx context.Context, entity *parent.OvalMitreOrgOvalObjectType) error {
	query := "UPDATE oval_mitre_org_oval__object_type SET xsd_id = ?, version = ?, comment = ?, deprecated = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Comment,
		entity.Deprecated,
		entity.ID,
	)
	return err
}

func (r *ovalMitreOrgOvalObjectTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_mitre_org_oval__object_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalMitreOrgOvalObjectTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_mitre_org_oval__object_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalMitreOrgOvalObjectTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_mitre_org_oval__object_type").Scan(&count)
	return count, err
}

func (d *dal) OvalMitreOrgOvalReferenceType() parent.OvalMitreOrgOvalReferenceTypeRepository {
	return &ovalMitreOrgOvalReferenceTypeRepository{db: d.db}
}

type ovalMitreOrgOvalReferenceTypeRepository struct {
	db *sql.DB
}

func (r *ovalMitreOrgOvalReferenceTypeRepository) Create(ctx context.Context, entity *parent.OvalMitreOrgOvalReferenceType) (int64, error) {
	query := "INSERT INTO oval_mitre_org_oval__reference_type (source, ref_id, ref_url) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Source,
		entity.Ref_id,
		entity.Ref_url,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalMitreOrgOvalReferenceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OvalMitreOrgOvalReferenceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_mitre_org_oval__reference_type (source, ref_id, ref_url) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Source,
			entity.Ref_id,
			entity.Ref_url,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalMitreOrgOvalReferenceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OvalMitreOrgOvalReferenceType, error) {
	query := "SELECT id, source, ref_id, ref_url FROM oval_mitre_org_oval__reference_type WHERE id = ?"

	entity := &parent.OvalMitreOrgOvalReferenceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Source,
		&entity.Ref_id,
		&entity.Ref_url,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ovalMitreOrgOvalReferenceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalMitreOrgOvalReferenceType, error) {
	query := "SELECT id, source, ref_id, ref_url FROM oval_mitre_org_oval__reference_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalMitreOrgOvalReferenceType
	for rows.Next() {
		entity := &parent.OvalMitreOrgOvalReferenceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Source,
			&entity.Ref_id,
			&entity.Ref_url,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalMitreOrgOvalReferenceTypeRepository) Update(ctx context.Context, entity *parent.OvalMitreOrgOvalReferenceType) error {
	query := "UPDATE oval_mitre_org_oval__reference_type SET source = ?, ref_id = ?, ref_url = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Source,
		entity.Ref_id,
		entity.Ref_url,
		entity.ID,
	)
	return err
}

func (r *ovalMitreOrgOvalReferenceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_mitre_org_oval__reference_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalMitreOrgOvalReferenceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_mitre_org_oval__reference_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalMitreOrgOvalReferenceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_mitre_org_oval__reference_type").Scan(&count)
	return count, err
}

func (d *dal) OvalMitreOrgOvalValueType() parent.OvalMitreOrgOvalValueTypeRepository {
	return &ovalMitreOrgOvalValueTypeRepository{db: d.db}
}

type ovalMitreOrgOvalValueTypeRepository struct {
	db *sql.DB
}

func (r *ovalMitreOrgOvalValueTypeRepository) Create(ctx context.Context, entity *parent.OvalMitreOrgOvalValueType) (int64, error) {
	query := "INSERT INTO oval_mitre_org_oval__value_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ovalMitreOrgOvalValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OvalMitreOrgOvalValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO oval_mitre_org_oval__value_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ovalMitreOrgOvalValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OvalMitreOrgOvalValueType, error) {
	query := "SELECT id FROM oval_mitre_org_oval__value_type WHERE id = ?"

	entity := &parent.OvalMitreOrgOvalValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ovalMitreOrgOvalValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OvalMitreOrgOvalValueType, error) {
	query := "SELECT id FROM oval_mitre_org_oval__value_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OvalMitreOrgOvalValueType
	for rows.Next() {
		entity := &parent.OvalMitreOrgOvalValueType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ovalMitreOrgOvalValueTypeRepository) Update(ctx context.Context, entity *parent.OvalMitreOrgOvalValueType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *ovalMitreOrgOvalValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM oval_mitre_org_oval__value_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ovalMitreOrgOvalValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM oval_mitre_org_oval__value_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ovalMitreOrgOvalValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM oval_mitre_org_oval__value_type").Scan(&count)
	return count, err
}

func (d *dal) OverrideType() parent.OverrideTypeRepository {
	return &overrideTypeRepository{db: d.db}
}

type overrideTypeRepository struct {
	db *sql.DB
}

func (r *overrideTypeRepository) Create(ctx context.Context, entity *parent.OverrideType) (int64, error) {
	query := "INSERT INTO override_type (time, authority, old_result_id, new_result_id, remark_id) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Time,
		entity.Authority,
		entity.OldResultID,
		entity.NewResultID,
		entity.RemarkID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *overrideTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OverrideType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO override_type (time, authority, old_result_id, new_result_id, remark_id) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Time,
			entity.Authority,
			entity.OldResultID,
			entity.NewResultID,
			entity.RemarkID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *overrideTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OverrideType, error) {
	query := "SELECT id, time, authority, old_result_id, new_result_id, remark_id FROM override_type WHERE id = ?"

	entity := &parent.OverrideType{}
	var timeTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&timeTime,
		&entity.Authority,
		&entity.OldResultID,
		&entity.NewResultID,
		&entity.RemarkID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Time = timeTime.Time

	return entity, nil
}

func (r *overrideTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OverrideType, error) {
	query := "SELECT id, time, authority, old_result_id, new_result_id, remark_id FROM override_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OverrideType
	for rows.Next() {
		entity := &parent.OverrideType{}
		var timeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&timeTime,
			&entity.Authority,
			&entity.OldResultID,
			&entity.NewResultID,
			&entity.RemarkID,
		)
		if err != nil {
			return nil, err
		}
		entity.Time = timeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *overrideTypeRepository) Update(ctx context.Context, entity *parent.OverrideType) error {
	query := "UPDATE override_type SET time = ?, authority = ?, old_result_id = ?, new_result_id = ?, remark_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Time,
		entity.Authority,
		entity.OldResultID,
		entity.NewResultID,
		entity.RemarkID,
		entity.ID,
	)
	return err
}

func (r *overrideTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM override_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *overrideTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM override_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *overrideTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM override_type").Scan(&count)
	return count, err
}

func (d *dal) OverrideableCPE2idrefType() parent.OverrideableCPE2idrefTypeRepository {
	return &overrideableCPE2idrefTypeRepository{db: d.db}
}

type overrideableCPE2idrefTypeRepository struct {
	db *sql.DB
}

func (r *overrideableCPE2idrefTypeRepository) Create(ctx context.Context, entity *parent.OverrideableCPE2idrefType) (int64, error) {
	query := "INSERT INTO overrideable_c_p_e2idref_type (override, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Override,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *overrideableCPE2idrefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.OverrideableCPE2idrefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO overrideable_c_p_e2idref_type (override, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Override,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *overrideableCPE2idrefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.OverrideableCPE2idrefType, error) {
	query := "SELECT id, override, parent_id FROM overrideable_c_p_e2idref_type WHERE id = ?"

	entity := &parent.OverrideableCPE2idrefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Override,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *overrideableCPE2idrefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.OverrideableCPE2idrefType, error) {
	query := "SELECT id, override, parent_id FROM overrideable_c_p_e2idref_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OverrideableCPE2idrefType
	for rows.Next() {
		entity := &parent.OverrideableCPE2idrefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Override,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *overrideableCPE2idrefTypeRepository) Update(ctx context.Context, entity *parent.OverrideableCPE2idrefType) error {
	query := "UPDATE overrideable_c_p_e2idref_type SET override = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Override,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *overrideableCPE2idrefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM overrideable_c_p_e2idref_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *overrideableCPE2idrefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM overrideable_c_p_e2idref_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *overrideableCPE2idrefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM overrideable_c_p_e2idref_type").Scan(&count)
	return count, err
}

func (r *overrideableCPE2idrefTypeRepository) GetByCPE2idrefType(ctx context.Context, c_p_e2idref_typeID int64) ([]*parent.OverrideableCPE2idrefType, error) {
	query := "SELECT id, override, parent_id FROM overrideable_c_p_e2idref_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, c_p_e2idref_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.OverrideableCPE2idrefType
	for rows.Next() {
		entity := &parent.OverrideableCPE2idrefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Override,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) PGPDataType() parent.PGPDataTypeRepository {
	return &pGPDataTypeRepository{db: d.db}
}

type pGPDataTypeRepository struct {
	db *sql.DB
}

func (r *pGPDataTypeRepository) Create(ctx context.Context, entity *parent.PGPDataType) (int64, error) {
	query := "INSERT INTO p_g_p_data_type (p_g_p_key_i_d, p_g_p_key_packet) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.PGPKeyID,
		entity.PGPKeyPacket,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *pGPDataTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PGPDataType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO p_g_p_data_type (p_g_p_key_i_d, p_g_p_key_packet) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.PGPKeyID,
			entity.PGPKeyPacket,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *pGPDataTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PGPDataType, error) {
	query := "SELECT id, p_g_p_key_i_d, p_g_p_key_packet FROM p_g_p_data_type WHERE id = ?"

	entity := &parent.PGPDataType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.PGPKeyID,
		&entity.PGPKeyPacket,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *pGPDataTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PGPDataType, error) {
	query := "SELECT id, p_g_p_key_i_d, p_g_p_key_packet FROM p_g_p_data_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PGPDataType
	for rows.Next() {
		entity := &parent.PGPDataType{}
		err := rows.Scan(
			&entity.ID,
			&entity.PGPKeyID,
			&entity.PGPKeyPacket,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *pGPDataTypeRepository) Update(ctx context.Context, entity *parent.PGPDataType) error {
	query := "UPDATE p_g_p_data_type SET p_g_p_key_i_d = ?, p_g_p_key_packet = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.PGPKeyID,
		entity.PGPKeyPacket,
		entity.ID,
	)
	return err
}

func (r *pGPDataTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM p_g_p_data_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *pGPDataTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM p_g_p_data_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *pGPDataTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM p_g_p_data_type").Scan(&count)
	return count, err
}

func (d *dal) ParamType() parent.ParamTypeRepository {
	return &paramTypeRepository{db: d.db}
}

type paramTypeRepository struct {
	db *sql.DB
}

func (r *paramTypeRepository) Create(ctx context.Context, entity *parent.ParamType) (int64, error) {
	query := "INSERT INTO param_type (name) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Name,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *paramTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ParamType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO param_type (name) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Name,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *paramTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ParamType, error) {
	query := "SELECT id, name FROM param_type WHERE id = ?"

	entity := &parent.ParamType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Name,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *paramTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ParamType, error) {
	query := "SELECT id, name FROM param_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ParamType
	for rows.Next() {
		entity := &parent.ParamType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Name,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *paramTypeRepository) Update(ctx context.Context, entity *parent.ParamType) error {
	query := "UPDATE param_type SET name = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Name,
		entity.ID,
	)
	return err
}

func (r *paramTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM param_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *paramTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM param_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *paramTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM param_type").Scan(&count)
	return count, err
}

func (d *dal) PersonNameElementType() parent.PersonNameElementTypeRepository {
	return &personNameElementTypeRepository{db: d.db}
}

type personNameElementTypeRepository struct {
	db *sql.DB
}

func (r *personNameElementTypeRepository) Create(ctx context.Context, entity *parent.PersonNameElementType) (int64, error) {
	query := "INSERT INTO person_name_element_type (former_name, known_as, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.FormerName,
		entity.KnownAs,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *personNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PersonNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO person_name_element_type (former_name, known_as, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.FormerName,
			entity.KnownAs,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *personNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PersonNameElementType, error) {
	query := "SELECT id, former_name, known_as, parent_id FROM person_name_element_type WHERE id = ?"

	entity := &parent.PersonNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.FormerName,
		&entity.KnownAs,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *personNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PersonNameElementType, error) {
	query := "SELECT id, former_name, known_as, parent_id FROM person_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PersonNameElementType
	for rows.Next() {
		entity := &parent.PersonNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.FormerName,
			&entity.KnownAs,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *personNameElementTypeRepository) Update(ctx context.Context, entity *parent.PersonNameElementType) error {
	query := "UPDATE person_name_element_type SET former_name = ?, known_as = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.FormerName,
		entity.KnownAs,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *personNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM person_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *personNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM person_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *personNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM person_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) PersonType() parent.PersonTypeRepository {
	return &personTypeRepository{db: d.db}
}

type personTypeRepository struct {
	db *sql.DB
}

func (r *personTypeRepository) Create(ctx context.Context, entity *parent.PersonType) (int64, error) {
	query := "INSERT INTO person_type (birthdate, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Birthdate,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *personTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PersonType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO person_type (birthdate, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Birthdate,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *personTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PersonType, error) {
	query := "SELECT id, birthdate, parent_id FROM person_type WHERE id = ?"

	entity := &parent.PersonType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Birthdate,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *personTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PersonType, error) {
	query := "SELECT id, birthdate, parent_id FROM person_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PersonType
	for rows.Next() {
		entity := &parent.PersonType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Birthdate,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *personTypeRepository) Update(ctx context.Context, entity *parent.PersonType) error {
	query := "UPDATE person_type SET birthdate = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Birthdate,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *personTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM person_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *personTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM person_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *personTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM person_type").Scan(&count)
	return count, err
}

func (r *personTypeRepository) GetByAssetType(ctx context.Context, asset_typeID int64) ([]*parent.PersonType, error) {
	query := "SELECT id, birthdate, parent_id FROM person_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PersonType
	for rows.Next() {
		entity := &parent.PersonType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Birthdate,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) PlainTextType() parent.PlainTextTypeRepository {
	return &plainTextTypeRepository{db: d.db}
}

type plainTextTypeRepository struct {
	db *sql.DB
}

func (r *plainTextTypeRepository) Create(ctx context.Context, entity *parent.PlainTextType) (int64, error) {
	query := "INSERT INTO plain_text_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *plainTextTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PlainTextType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO plain_text_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *plainTextTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PlainTextType, error) {
	query := "SELECT id, xsd_id FROM plain_text_type WHERE id = ?"

	entity := &parent.PlainTextType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *plainTextTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PlainTextType, error) {
	query := "SELECT id, xsd_id FROM plain_text_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PlainTextType
	for rows.Next() {
		entity := &parent.PlainTextType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *plainTextTypeRepository) Update(ctx context.Context, entity *parent.PlainTextType) error {
	query := "UPDATE plain_text_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *plainTextTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM plain_text_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *plainTextTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM plain_text_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *plainTextTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM plain_text_type").Scan(&count)
	return count, err
}

func (d *dal) PlatformSpecification() parent.PlatformSpecificationRepository {
	return &platformSpecificationRepository{db: d.db}
}

type platformSpecificationRepository struct {
	db *sql.DB
}

func (r *platformSpecificationRepository) Create(ctx context.Context, entity *parent.PlatformSpecification) (int64, error) {
	query := "INSERT INTO platform_specification DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *platformSpecificationRepository) CreateBatch(ctx context.Context, entities []*parent.PlatformSpecification) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO platform_specification DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *platformSpecificationRepository) GetByID(ctx context.Context, id int64) (*parent.PlatformSpecification, error) {
	query := "SELECT id FROM platform_specification WHERE id = ?"

	entity := &parent.PlatformSpecification{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *platformSpecificationRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PlatformSpecification, error) {
	query := "SELECT id FROM platform_specification LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PlatformSpecification
	for rows.Next() {
		entity := &parent.PlatformSpecification{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *platformSpecificationRepository) Update(ctx context.Context, entity *parent.PlatformSpecification) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *platformSpecificationRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM platform_specification WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *platformSpecificationRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM platform_specification WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *platformSpecificationRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM platform_specification").Scan(&count)
	return count, err
}

func (d *dal) PlatformSpecificationElementType() parent.PlatformSpecificationElementTypeRepository {
	return &platformSpecificationElementTypeRepository{db: d.db}
}

type platformSpecificationElementTypeRepository struct {
	db *sql.DB
}

func (r *platformSpecificationElementTypeRepository) Create(ctx context.Context, entity *parent.PlatformSpecificationElementType) (int64, error) {
	query := "INSERT INTO platform_specification_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *platformSpecificationElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PlatformSpecificationElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO platform_specification_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *platformSpecificationElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PlatformSpecificationElementType, error) {
	query := "SELECT id FROM platform_specification_element_type WHERE id = ?"

	entity := &parent.PlatformSpecificationElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *platformSpecificationElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PlatformSpecificationElementType, error) {
	query := "SELECT id FROM platform_specification_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PlatformSpecificationElementType
	for rows.Next() {
		entity := &parent.PlatformSpecificationElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *platformSpecificationElementTypeRepository) Update(ctx context.Context, entity *parent.PlatformSpecificationElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *platformSpecificationElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM platform_specification_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *platformSpecificationElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM platform_specification_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *platformSpecificationElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM platform_specification_element_type").Scan(&count)
	return count, err
}

func (d *dal) PlatformType() parent.PlatformTypeRepository {
	return &platformTypeRepository{db: d.db}
}

type platformTypeRepository struct {
	db *sql.DB
}

func (r *platformTypeRepository) Create(ctx context.Context, entity *parent.PlatformType) (int64, error) {
	query := "INSERT INTO platform_type (xsd_id, logical_test_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.LogicalTestID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *platformTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PlatformType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO platform_type (xsd_id, logical_test_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.LogicalTestID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *platformTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PlatformType, error) {
	query := "SELECT id, xsd_id, logical_test_id FROM platform_type WHERE id = ?"

	entity := &parent.PlatformType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.LogicalTestID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *platformTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PlatformType, error) {
	query := "SELECT id, xsd_id, logical_test_id FROM platform_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PlatformType
	for rows.Next() {
		entity := &parent.PlatformType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.LogicalTestID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *platformTypeRepository) Update(ctx context.Context, entity *parent.PlatformType) error {
	query := "UPDATE platform_type SET xsd_id = ?, logical_test_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.LogicalTestID,
		entity.ID,
	)
	return err
}

func (r *platformTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM platform_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *platformTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM platform_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *platformTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM platform_type").Scan(&count)
	return count, err
}

func (r *platformTypeRepository) GetByLogicalTestType(ctx context.Context, logical_test_typeID int64) ([]*parent.PlatformType, error) {
	query := "SELECT id, xsd_id, logical_test_id FROM platform_type WHERE logical_test_id = ?"

	rows, err := r.db.QueryContext(ctx, query, logical_test_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PlatformType
	for rows.Next() {
		entity := &parent.PlatformType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.LogicalTestID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) PortElementType() parent.PortElementTypeRepository {
	return &portElementTypeRepository{db: d.db}
}

type portElementTypeRepository struct {
	db *sql.DB
}

func (r *portElementTypeRepository) Create(ctx context.Context, entity *parent.PortElementType) (int64, error) {
	query := "INSERT INTO port_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *portElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PortElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO port_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *portElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PortElementType, error) {
	query := "SELECT id, parent_id FROM port_element_type WHERE id = ?"

	entity := &parent.PortElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *portElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PortElementType, error) {
	query := "SELECT id, parent_id FROM port_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PortElementType
	for rows.Next() {
		entity := &parent.PortElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *portElementTypeRepository) Update(ctx context.Context, entity *parent.PortElementType) error {
	query := "UPDATE port_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *portElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM port_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *portElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM port_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *portElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM port_element_type").Scan(&count)
	return count, err
}

func (d *dal) PortRangeElementType() parent.PortRangeElementTypeRepository {
	return &portRangeElementTypeRepository{db: d.db}
}

type portRangeElementTypeRepository struct {
	db *sql.DB
}

func (r *portRangeElementTypeRepository) Create(ctx context.Context, entity *parent.PortRangeElementType) (int64, error) {
	query := "INSERT INTO port_range_element_type (lower_bound, upper_bound) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.LowerBound,
		entity.UpperBound,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *portRangeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PortRangeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO port_range_element_type (lower_bound, upper_bound) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.LowerBound,
			entity.UpperBound,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *portRangeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PortRangeElementType, error) {
	query := "SELECT id, lower_bound, upper_bound FROM port_range_element_type WHERE id = ?"

	entity := &parent.PortRangeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.LowerBound,
		&entity.UpperBound,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *portRangeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PortRangeElementType, error) {
	query := "SELECT id, lower_bound, upper_bound FROM port_range_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PortRangeElementType
	for rows.Next() {
		entity := &parent.PortRangeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.LowerBound,
			&entity.UpperBound,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *portRangeElementTypeRepository) Update(ctx context.Context, entity *parent.PortRangeElementType) error {
	query := "UPDATE port_range_element_type SET lower_bound = ?, upper_bound = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.LowerBound,
		entity.UpperBound,
		entity.ID,
	)
	return err
}

func (r *portRangeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM port_range_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *portRangeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM port_range_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *portRangeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM port_range_element_type").Scan(&count)
	return count, err
}

func (d *dal) PossibleRestrictionType() parent.PossibleRestrictionTypeRepository {
	return &possibleRestrictionTypeRepository{db: d.db}
}

type possibleRestrictionTypeRepository struct {
	db *sql.DB
}

func (r *possibleRestrictionTypeRepository) Create(ctx context.Context, entity *parent.PossibleRestrictionType) (int64, error) {
	query := "INSERT INTO possible_restriction_type (operator, hint) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Operator,
		entity.Hint,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *possibleRestrictionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PossibleRestrictionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO possible_restriction_type (operator, hint) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Operator,
			entity.Hint,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *possibleRestrictionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PossibleRestrictionType, error) {
	query := "SELECT id, operator, hint FROM possible_restriction_type WHERE id = ?"

	entity := &parent.PossibleRestrictionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Operator,
		&entity.Hint,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *possibleRestrictionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PossibleRestrictionType, error) {
	query := "SELECT id, operator, hint FROM possible_restriction_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PossibleRestrictionType
	for rows.Next() {
		entity := &parent.PossibleRestrictionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Operator,
			&entity.Hint,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *possibleRestrictionTypeRepository) Update(ctx context.Context, entity *parent.PossibleRestrictionType) error {
	query := "UPDATE possible_restriction_type SET operator = ?, hint = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Operator,
		entity.Hint,
		entity.ID,
	)
	return err
}

func (r *possibleRestrictionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM possible_restriction_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *possibleRestrictionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM possible_restriction_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *possibleRestrictionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM possible_restriction_type").Scan(&count)
	return count, err
}

func (d *dal) PossibleValueType() parent.PossibleValueTypeRepository {
	return &possibleValueTypeRepository{db: d.db}
}

type possibleValueTypeRepository struct {
	db *sql.DB
}

func (r *possibleValueTypeRepository) Create(ctx context.Context, entity *parent.PossibleValueType) (int64, error) {
	query := "INSERT INTO possible_value_type (hint) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Hint,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *possibleValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PossibleValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO possible_value_type (hint) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Hint,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *possibleValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PossibleValueType, error) {
	query := "SELECT id, hint FROM possible_value_type WHERE id = ?"

	entity := &parent.PossibleValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Hint,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *possibleValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PossibleValueType, error) {
	query := "SELECT id, hint FROM possible_value_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PossibleValueType
	for rows.Next() {
		entity := &parent.PossibleValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Hint,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *possibleValueTypeRepository) Update(ctx context.Context, entity *parent.PossibleValueType) error {
	query := "UPDATE possible_value_type SET hint = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Hint,
		entity.ID,
	)
	return err
}

func (r *possibleValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM possible_value_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *possibleValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM possible_value_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *possibleValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM possible_value_type").Scan(&count)
	return count, err
}

func (d *dal) PostBox() parent.PostBoxRepository {
	return &postBoxRepository{db: d.db}
}

type postBoxRepository struct {
	db *sql.DB
}

func (r *postBoxRepository) Create(ctx context.Context, entity *parent.PostBox) (int64, error) {
	query := "INSERT INTO post_box (type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.PostBoxNumber,
		entity.PostBoxNumberPrefix,
		entity.PostBoxNumberSuffix,
		entity.PostBoxNumberExtension,
		entity.FirmID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postBoxRepository) CreateBatch(ctx context.Context, entities []*parent.PostBox) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_box (type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Indicator,
			entity.PostBoxNumber,
			entity.PostBoxNumberPrefix,
			entity.PostBoxNumberSuffix,
			entity.PostBoxNumberExtension,
			entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postBoxRepository) GetByID(ctx context.Context, id int64) (*parent.PostBox, error) {
	query := "SELECT id, type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id FROM post_box WHERE id = ?"

	entity := &parent.PostBox{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Indicator,
		&entity.PostBoxNumber,
		&entity.PostBoxNumberPrefix,
		&entity.PostBoxNumberSuffix,
		&entity.PostBoxNumberExtension,
		&entity.FirmID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postBoxRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostBox, error) {
	query := "SELECT id, type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id FROM post_box LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostBox
	for rows.Next() {
		entity := &parent.PostBox{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Indicator,
			&entity.PostBoxNumber,
			&entity.PostBoxNumberPrefix,
			&entity.PostBoxNumberSuffix,
			&entity.PostBoxNumberExtension,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postBoxRepository) Update(ctx context.Context, entity *parent.PostBox) error {
	query := "UPDATE post_box SET type = ?, indicator = ?, post_box_number = ?, post_box_number_prefix = ?, post_box_number_suffix = ?, post_box_number_extension = ?, firm_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.PostBoxNumber,
		entity.PostBoxNumberPrefix,
		entity.PostBoxNumberSuffix,
		entity.PostBoxNumberExtension,
		entity.FirmID,
		entity.ID,
	)
	return err
}

func (r *postBoxRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_box WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postBoxRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_box WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postBoxRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_box").Scan(&count)
	return count, err
}

func (d *dal) PostBoxElementType() parent.PostBoxElementTypeRepository {
	return &postBoxElementTypeRepository{db: d.db}
}

type postBoxElementTypeRepository struct {
	db *sql.DB
}

func (r *postBoxElementTypeRepository) Create(ctx context.Context, entity *parent.PostBoxElementType) (int64, error) {
	query := "INSERT INTO post_box_element_type (type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.PostBoxNumber,
		entity.PostBoxNumberPrefix,
		entity.PostBoxNumberSuffix,
		entity.PostBoxNumberExtension,
		entity.FirmID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postBoxElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostBoxElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_box_element_type (type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Indicator,
			entity.PostBoxNumber,
			entity.PostBoxNumberPrefix,
			entity.PostBoxNumberSuffix,
			entity.PostBoxNumberExtension,
			entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postBoxElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostBoxElementType, error) {
	query := "SELECT id, type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id FROM post_box_element_type WHERE id = ?"

	entity := &parent.PostBoxElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Indicator,
		&entity.PostBoxNumber,
		&entity.PostBoxNumberPrefix,
		&entity.PostBoxNumberSuffix,
		&entity.PostBoxNumberExtension,
		&entity.FirmID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postBoxElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostBoxElementType, error) {
	query := "SELECT id, type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id FROM post_box_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostBoxElementType
	for rows.Next() {
		entity := &parent.PostBoxElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Indicator,
			&entity.PostBoxNumber,
			&entity.PostBoxNumberPrefix,
			&entity.PostBoxNumberSuffix,
			&entity.PostBoxNumberExtension,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postBoxElementTypeRepository) Update(ctx context.Context, entity *parent.PostBoxElementType) error {
	query := "UPDATE post_box_element_type SET type = ?, indicator = ?, post_box_number = ?, post_box_number_prefix = ?, post_box_number_suffix = ?, post_box_number_extension = ?, firm_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.PostBoxNumber,
		entity.PostBoxNumberPrefix,
		entity.PostBoxNumberSuffix,
		entity.PostBoxNumberExtension,
		entity.FirmID,
		entity.ID,
	)
	return err
}

func (r *postBoxElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_box_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postBoxElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_box_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postBoxElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_box_element_type").Scan(&count)
	return count, err
}

func (r *postBoxElementTypeRepository) GetByFirmType(ctx context.Context, firm_typeID int64) ([]*parent.PostBoxElementType, error) {
	query := "SELECT id, type, indicator, post_box_number, post_box_number_prefix, post_box_number_suffix, post_box_number_extension, firm_id FROM post_box_element_type WHERE firm_id = ?"

	rows, err := r.db.QueryContext(ctx, query, firm_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostBoxElementType
	for rows.Next() {
		entity := &parent.PostBoxElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Indicator,
			&entity.PostBoxNumber,
			&entity.PostBoxNumberPrefix,
			&entity.PostBoxNumberSuffix,
			&entity.PostBoxNumberExtension,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) PostBoxNumberElementType() parent.PostBoxNumberElementTypeRepository {
	return &postBoxNumberElementTypeRepository{db: d.db}
}

type postBoxNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *postBoxNumberElementTypeRepository) Create(ctx context.Context, entity *parent.PostBoxNumberElementType) (int64, error) {
	query := "INSERT INTO post_box_number_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postBoxNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostBoxNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_box_number_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postBoxNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostBoxNumberElementType, error) {
	query := "SELECT id FROM post_box_number_element_type WHERE id = ?"

	entity := &parent.PostBoxNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postBoxNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostBoxNumberElementType, error) {
	query := "SELECT id FROM post_box_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostBoxNumberElementType
	for rows.Next() {
		entity := &parent.PostBoxNumberElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postBoxNumberElementTypeRepository) Update(ctx context.Context, entity *parent.PostBoxNumberElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *postBoxNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_box_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postBoxNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_box_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postBoxNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_box_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostBoxNumberExtensionElementType() parent.PostBoxNumberExtensionElementTypeRepository {
	return &postBoxNumberExtensionElementTypeRepository{db: d.db}
}

type postBoxNumberExtensionElementTypeRepository struct {
	db *sql.DB
}

func (r *postBoxNumberExtensionElementTypeRepository) Create(ctx context.Context, entity *parent.PostBoxNumberExtensionElementType) (int64, error) {
	query := "INSERT INTO post_box_number_extension_element_type (number_extension_separator) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberExtensionSeparator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postBoxNumberExtensionElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostBoxNumberExtensionElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_box_number_extension_element_type (number_extension_separator) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberExtensionSeparator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postBoxNumberExtensionElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostBoxNumberExtensionElementType, error) {
	query := "SELECT id, number_extension_separator FROM post_box_number_extension_element_type WHERE id = ?"

	entity := &parent.PostBoxNumberExtensionElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberExtensionSeparator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postBoxNumberExtensionElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostBoxNumberExtensionElementType, error) {
	query := "SELECT id, number_extension_separator FROM post_box_number_extension_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostBoxNumberExtensionElementType
	for rows.Next() {
		entity := &parent.PostBoxNumberExtensionElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberExtensionSeparator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postBoxNumberExtensionElementTypeRepository) Update(ctx context.Context, entity *parent.PostBoxNumberExtensionElementType) error {
	query := "UPDATE post_box_number_extension_element_type SET number_extension_separator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberExtensionSeparator,
		entity.ID,
	)
	return err
}

func (r *postBoxNumberExtensionElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_box_number_extension_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postBoxNumberExtensionElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_box_number_extension_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postBoxNumberExtensionElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_box_number_extension_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostBoxNumberPrefixElementType() parent.PostBoxNumberPrefixElementTypeRepository {
	return &postBoxNumberPrefixElementTypeRepository{db: d.db}
}

type postBoxNumberPrefixElementTypeRepository struct {
	db *sql.DB
}

func (r *postBoxNumberPrefixElementTypeRepository) Create(ctx context.Context, entity *parent.PostBoxNumberPrefixElementType) (int64, error) {
	query := "INSERT INTO post_box_number_prefix_element_type (number_prefix_separator) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postBoxNumberPrefixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostBoxNumberPrefixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_box_number_prefix_element_type (number_prefix_separator) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberPrefixSeparator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postBoxNumberPrefixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostBoxNumberPrefixElementType, error) {
	query := "SELECT id, number_prefix_separator FROM post_box_number_prefix_element_type WHERE id = ?"

	entity := &parent.PostBoxNumberPrefixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberPrefixSeparator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postBoxNumberPrefixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostBoxNumberPrefixElementType, error) {
	query := "SELECT id, number_prefix_separator FROM post_box_number_prefix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostBoxNumberPrefixElementType
	for rows.Next() {
		entity := &parent.PostBoxNumberPrefixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberPrefixSeparator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postBoxNumberPrefixElementTypeRepository) Update(ctx context.Context, entity *parent.PostBoxNumberPrefixElementType) error {
	query := "UPDATE post_box_number_prefix_element_type SET number_prefix_separator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.ID,
	)
	return err
}

func (r *postBoxNumberPrefixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_box_number_prefix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postBoxNumberPrefixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_box_number_prefix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postBoxNumberPrefixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_box_number_prefix_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostBoxNumberSuffixElementType() parent.PostBoxNumberSuffixElementTypeRepository {
	return &postBoxNumberSuffixElementTypeRepository{db: d.db}
}

type postBoxNumberSuffixElementTypeRepository struct {
	db *sql.DB
}

func (r *postBoxNumberSuffixElementTypeRepository) Create(ctx context.Context, entity *parent.PostBoxNumberSuffixElementType) (int64, error) {
	query := "INSERT INTO post_box_number_suffix_element_type (number_suffix_separator) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postBoxNumberSuffixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostBoxNumberSuffixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_box_number_suffix_element_type (number_suffix_separator) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberSuffixSeparator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postBoxNumberSuffixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostBoxNumberSuffixElementType, error) {
	query := "SELECT id, number_suffix_separator FROM post_box_number_suffix_element_type WHERE id = ?"

	entity := &parent.PostBoxNumberSuffixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberSuffixSeparator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postBoxNumberSuffixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostBoxNumberSuffixElementType, error) {
	query := "SELECT id, number_suffix_separator FROM post_box_number_suffix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostBoxNumberSuffixElementType
	for rows.Next() {
		entity := &parent.PostBoxNumberSuffixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberSuffixSeparator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postBoxNumberSuffixElementTypeRepository) Update(ctx context.Context, entity *parent.PostBoxNumberSuffixElementType) error {
	query := "UPDATE post_box_number_suffix_element_type SET number_suffix_separator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.ID,
	)
	return err
}

func (r *postBoxNumberSuffixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_box_number_suffix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postBoxNumberSuffixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_box_number_suffix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postBoxNumberSuffixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_box_number_suffix_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostOffice() parent.PostOfficeRepository {
	return &postOfficeRepository{db: d.db}
}

type postOfficeRepository struct {
	db *sql.DB
}

func (r *postOfficeRepository) Create(ctx context.Context, entity *parent.PostOffice) (int64, error) {
	query := "INSERT INTO post_office (type, indicator, postal_route_id, post_office_name, post_office_number) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.PostalRouteID,
		entity.PostOfficeName,
		entity.PostOfficeNumber,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postOfficeRepository) CreateBatch(ctx context.Context, entities []*parent.PostOffice) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_office (type, indicator, postal_route_id, post_office_name, post_office_number) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Indicator,
			entity.PostalRouteID,
			entity.PostOfficeName,
			entity.PostOfficeNumber,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postOfficeRepository) GetByID(ctx context.Context, id int64) (*parent.PostOffice, error) {
	query := "SELECT id, type, indicator, postal_route_id, post_office_name, post_office_number FROM post_office WHERE id = ?"

	entity := &parent.PostOffice{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Indicator,
		&entity.PostalRouteID,
		&entity.PostOfficeName,
		&entity.PostOfficeNumber,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postOfficeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostOffice, error) {
	query := "SELECT id, type, indicator, postal_route_id, post_office_name, post_office_number FROM post_office LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostOffice
	for rows.Next() {
		entity := &parent.PostOffice{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Indicator,
			&entity.PostalRouteID,
			&entity.PostOfficeName,
			&entity.PostOfficeNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postOfficeRepository) Update(ctx context.Context, entity *parent.PostOffice) error {
	query := "UPDATE post_office SET type = ?, indicator = ?, postal_route_id = ?, post_office_name = ?, post_office_number = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.PostalRouteID,
		entity.PostOfficeName,
		entity.PostOfficeNumber,
		entity.ID,
	)
	return err
}

func (r *postOfficeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_office WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postOfficeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_office WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postOfficeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_office").Scan(&count)
	return count, err
}

func (d *dal) PostOfficeElementType() parent.PostOfficeElementTypeRepository {
	return &postOfficeElementTypeRepository{db: d.db}
}

type postOfficeElementTypeRepository struct {
	db *sql.DB
}

func (r *postOfficeElementTypeRepository) Create(ctx context.Context, entity *parent.PostOfficeElementType) (int64, error) {
	query := "INSERT INTO post_office_element_type (type, indicator, postal_route_id, post_office_name, post_office_number) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.PostalRouteID,
		entity.PostOfficeName,
		entity.PostOfficeNumber,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postOfficeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostOfficeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_office_element_type (type, indicator, postal_route_id, post_office_name, post_office_number) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Indicator,
			entity.PostalRouteID,
			entity.PostOfficeName,
			entity.PostOfficeNumber,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postOfficeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostOfficeElementType, error) {
	query := "SELECT id, type, indicator, postal_route_id, post_office_name, post_office_number FROM post_office_element_type WHERE id = ?"

	entity := &parent.PostOfficeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Indicator,
		&entity.PostalRouteID,
		&entity.PostOfficeName,
		&entity.PostOfficeNumber,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postOfficeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostOfficeElementType, error) {
	query := "SELECT id, type, indicator, postal_route_id, post_office_name, post_office_number FROM post_office_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostOfficeElementType
	for rows.Next() {
		entity := &parent.PostOfficeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Indicator,
			&entity.PostalRouteID,
			&entity.PostOfficeName,
			&entity.PostOfficeNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postOfficeElementTypeRepository) Update(ctx context.Context, entity *parent.PostOfficeElementType) error {
	query := "UPDATE post_office_element_type SET type = ?, indicator = ?, postal_route_id = ?, post_office_name = ?, post_office_number = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Indicator,
		entity.PostalRouteID,
		entity.PostOfficeName,
		entity.PostOfficeNumber,
		entity.ID,
	)
	return err
}

func (r *postOfficeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_office_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postOfficeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_office_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postOfficeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_office_element_type").Scan(&count)
	return count, err
}

func (r *postOfficeElementTypeRepository) GetByPostalRouteType(ctx context.Context, postal_route_typeID int64) ([]*parent.PostOfficeElementType, error) {
	query := "SELECT id, type, indicator, postal_route_id, post_office_name, post_office_number FROM post_office_element_type WHERE postal_route_id = ?"

	rows, err := r.db.QueryContext(ctx, query, postal_route_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostOfficeElementType
	for rows.Next() {
		entity := &parent.PostOfficeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Indicator,
			&entity.PostalRouteID,
			&entity.PostOfficeName,
			&entity.PostOfficeNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) PostOfficeNameElementType() parent.PostOfficeNameElementTypeRepository {
	return &postOfficeNameElementTypeRepository{db: d.db}
}

type postOfficeNameElementTypeRepository struct {
	db *sql.DB
}

func (r *postOfficeNameElementTypeRepository) Create(ctx context.Context, entity *parent.PostOfficeNameElementType) (int64, error) {
	query := "INSERT INTO post_office_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postOfficeNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostOfficeNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_office_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postOfficeNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostOfficeNameElementType, error) {
	query := "SELECT id, type FROM post_office_name_element_type WHERE id = ?"

	entity := &parent.PostOfficeNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postOfficeNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostOfficeNameElementType, error) {
	query := "SELECT id, type FROM post_office_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostOfficeNameElementType
	for rows.Next() {
		entity := &parent.PostOfficeNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postOfficeNameElementTypeRepository) Update(ctx context.Context, entity *parent.PostOfficeNameElementType) error {
	query := "UPDATE post_office_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *postOfficeNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_office_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postOfficeNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_office_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postOfficeNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_office_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostOfficeNumberElementType() parent.PostOfficeNumberElementTypeRepository {
	return &postOfficeNumberElementTypeRepository{db: d.db}
}

type postOfficeNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *postOfficeNumberElementTypeRepository) Create(ctx context.Context, entity *parent.PostOfficeNumberElementType) (int64, error) {
	query := "INSERT INTO post_office_number_element_type (indicator, indicator_occurrence) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Indicator,
		entity.IndicatorOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postOfficeNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostOfficeNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_office_number_element_type (indicator, indicator_occurrence) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Indicator,
			entity.IndicatorOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postOfficeNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostOfficeNumberElementType, error) {
	query := "SELECT id, indicator, indicator_occurrence FROM post_office_number_element_type WHERE id = ?"

	entity := &parent.PostOfficeNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Indicator,
		&entity.IndicatorOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postOfficeNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostOfficeNumberElementType, error) {
	query := "SELECT id, indicator, indicator_occurrence FROM post_office_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostOfficeNumberElementType
	for rows.Next() {
		entity := &parent.PostOfficeNumberElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Indicator,
			&entity.IndicatorOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postOfficeNumberElementTypeRepository) Update(ctx context.Context, entity *parent.PostOfficeNumberElementType) error {
	query := "UPDATE post_office_number_element_type SET indicator = ?, indicator_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.ID,
	)
	return err
}

func (r *postOfficeNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_office_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postOfficeNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_office_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postOfficeNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_office_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostTownElementType() parent.PostTownElementTypeRepository {
	return &postTownElementTypeRepository{db: d.db}
}

type postTownElementTypeRepository struct {
	db *sql.DB
}

func (r *postTownElementTypeRepository) Create(ctx context.Context, entity *parent.PostTownElementType) (int64, error) {
	query := "INSERT INTO post_town_element_type (type, post_town_name, post_town_suffix) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PostTownName,
		entity.PostTownSuffix,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postTownElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostTownElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_town_element_type (type, post_town_name, post_town_suffix) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.PostTownName,
			entity.PostTownSuffix,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postTownElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostTownElementType, error) {
	query := "SELECT id, type, post_town_name, post_town_suffix FROM post_town_element_type WHERE id = ?"

	entity := &parent.PostTownElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.PostTownName,
		&entity.PostTownSuffix,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postTownElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostTownElementType, error) {
	query := "SELECT id, type, post_town_name, post_town_suffix FROM post_town_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostTownElementType
	for rows.Next() {
		entity := &parent.PostTownElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.PostTownName,
			&entity.PostTownSuffix,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postTownElementTypeRepository) Update(ctx context.Context, entity *parent.PostTownElementType) error {
	query := "UPDATE post_town_element_type SET type = ?, post_town_name = ?, post_town_suffix = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PostTownName,
		entity.PostTownSuffix,
		entity.ID,
	)
	return err
}

func (r *postTownElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_town_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postTownElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_town_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postTownElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_town_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostTownNameElementType() parent.PostTownNameElementTypeRepository {
	return &postTownNameElementTypeRepository{db: d.db}
}

type postTownNameElementTypeRepository struct {
	db *sql.DB
}

func (r *postTownNameElementTypeRepository) Create(ctx context.Context, entity *parent.PostTownNameElementType) (int64, error) {
	query := "INSERT INTO post_town_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postTownNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostTownNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_town_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postTownNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostTownNameElementType, error) {
	query := "SELECT id, type FROM post_town_name_element_type WHERE id = ?"

	entity := &parent.PostTownNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postTownNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostTownNameElementType, error) {
	query := "SELECT id, type FROM post_town_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostTownNameElementType
	for rows.Next() {
		entity := &parent.PostTownNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postTownNameElementTypeRepository) Update(ctx context.Context, entity *parent.PostTownNameElementType) error {
	query := "UPDATE post_town_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *postTownNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_town_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postTownNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_town_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postTownNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_town_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostTownSuffixElementType() parent.PostTownSuffixElementTypeRepository {
	return &postTownSuffixElementTypeRepository{db: d.db}
}

type postTownSuffixElementTypeRepository struct {
	db *sql.DB
}

func (r *postTownSuffixElementTypeRepository) Create(ctx context.Context, entity *parent.PostTownSuffixElementType) (int64, error) {
	query := "INSERT INTO post_town_suffix_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postTownSuffixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostTownSuffixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO post_town_suffix_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postTownSuffixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostTownSuffixElementType, error) {
	query := "SELECT id FROM post_town_suffix_element_type WHERE id = ?"

	entity := &parent.PostTownSuffixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postTownSuffixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostTownSuffixElementType, error) {
	query := "SELECT id FROM post_town_suffix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostTownSuffixElementType
	for rows.Next() {
		entity := &parent.PostTownSuffixElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postTownSuffixElementTypeRepository) Update(ctx context.Context, entity *parent.PostTownSuffixElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *postTownSuffixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM post_town_suffix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postTownSuffixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM post_town_suffix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postTownSuffixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM post_town_suffix_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostalCode() parent.PostalCodeRepository {
	return &postalCodeRepository{db: d.db}
}

type postalCodeRepository struct {
	db *sql.DB
}

func (r *postalCodeRepository) Create(ctx context.Context, entity *parent.PostalCode) (int64, error) {
	query := "INSERT INTO postal_code (type, postal_code_number, postal_code_number_extension, post_town) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PostalCodeNumber,
		entity.PostalCodeNumberExtension,
		entity.PostTown,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postalCodeRepository) CreateBatch(ctx context.Context, entities []*parent.PostalCode) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO postal_code (type, postal_code_number, postal_code_number_extension, post_town) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.PostalCodeNumber,
			entity.PostalCodeNumberExtension,
			entity.PostTown,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postalCodeRepository) GetByID(ctx context.Context, id int64) (*parent.PostalCode, error) {
	query := "SELECT id, type, postal_code_number, postal_code_number_extension, post_town FROM postal_code WHERE id = ?"

	entity := &parent.PostalCode{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.PostalCodeNumber,
		&entity.PostalCodeNumberExtension,
		&entity.PostTown,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postalCodeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostalCode, error) {
	query := "SELECT id, type, postal_code_number, postal_code_number_extension, post_town FROM postal_code LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostalCode
	for rows.Next() {
		entity := &parent.PostalCode{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.PostalCodeNumber,
			&entity.PostalCodeNumberExtension,
			&entity.PostTown,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postalCodeRepository) Update(ctx context.Context, entity *parent.PostalCode) error {
	query := "UPDATE postal_code SET type = ?, postal_code_number = ?, postal_code_number_extension = ?, post_town = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PostalCodeNumber,
		entity.PostalCodeNumberExtension,
		entity.PostTown,
		entity.ID,
	)
	return err
}

func (r *postalCodeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM postal_code WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postalCodeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM postal_code WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postalCodeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM postal_code").Scan(&count)
	return count, err
}

func (d *dal) PostalCodeElementType() parent.PostalCodeElementTypeRepository {
	return &postalCodeElementTypeRepository{db: d.db}
}

type postalCodeElementTypeRepository struct {
	db *sql.DB
}

func (r *postalCodeElementTypeRepository) Create(ctx context.Context, entity *parent.PostalCodeElementType) (int64, error) {
	query := "INSERT INTO postal_code_element_type (type, postal_code_number, postal_code_number_extension, post_town) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PostalCodeNumber,
		entity.PostalCodeNumberExtension,
		entity.PostTown,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postalCodeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostalCodeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO postal_code_element_type (type, postal_code_number, postal_code_number_extension, post_town) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.PostalCodeNumber,
			entity.PostalCodeNumberExtension,
			entity.PostTown,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postalCodeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostalCodeElementType, error) {
	query := "SELECT id, type, postal_code_number, postal_code_number_extension, post_town FROM postal_code_element_type WHERE id = ?"

	entity := &parent.PostalCodeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.PostalCodeNumber,
		&entity.PostalCodeNumberExtension,
		&entity.PostTown,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postalCodeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostalCodeElementType, error) {
	query := "SELECT id, type, postal_code_number, postal_code_number_extension, post_town FROM postal_code_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostalCodeElementType
	for rows.Next() {
		entity := &parent.PostalCodeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.PostalCodeNumber,
			&entity.PostalCodeNumberExtension,
			&entity.PostTown,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postalCodeElementTypeRepository) Update(ctx context.Context, entity *parent.PostalCodeElementType) error {
	query := "UPDATE postal_code_element_type SET type = ?, postal_code_number = ?, postal_code_number_extension = ?, post_town = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PostalCodeNumber,
		entity.PostalCodeNumberExtension,
		entity.PostTown,
		entity.ID,
	)
	return err
}

func (r *postalCodeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM postal_code_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postalCodeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM postal_code_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postalCodeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM postal_code_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostalCodeNumberElementType() parent.PostalCodeNumberElementTypeRepository {
	return &postalCodeNumberElementTypeRepository{db: d.db}
}

type postalCodeNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *postalCodeNumberElementTypeRepository) Create(ctx context.Context, entity *parent.PostalCodeNumberElementType) (int64, error) {
	query := "INSERT INTO postal_code_number_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postalCodeNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostalCodeNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO postal_code_number_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postalCodeNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostalCodeNumberElementType, error) {
	query := "SELECT id, type FROM postal_code_number_element_type WHERE id = ?"

	entity := &parent.PostalCodeNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postalCodeNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostalCodeNumberElementType, error) {
	query := "SELECT id, type FROM postal_code_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostalCodeNumberElementType
	for rows.Next() {
		entity := &parent.PostalCodeNumberElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postalCodeNumberElementTypeRepository) Update(ctx context.Context, entity *parent.PostalCodeNumberElementType) error {
	query := "UPDATE postal_code_number_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *postalCodeNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM postal_code_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postalCodeNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM postal_code_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postalCodeNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM postal_code_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostalCodeNumberExtensionElementType() parent.PostalCodeNumberExtensionElementTypeRepository {
	return &postalCodeNumberExtensionElementTypeRepository{db: d.db}
}

type postalCodeNumberExtensionElementTypeRepository struct {
	db *sql.DB
}

func (r *postalCodeNumberExtensionElementTypeRepository) Create(ctx context.Context, entity *parent.PostalCodeNumberExtensionElementType) (int64, error) {
	query := "INSERT INTO postal_code_number_extension_element_type (type, number_extension_separator) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NumberExtensionSeparator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postalCodeNumberExtensionElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostalCodeNumberExtensionElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO postal_code_number_extension_element_type (type, number_extension_separator) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.NumberExtensionSeparator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postalCodeNumberExtensionElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostalCodeNumberExtensionElementType, error) {
	query := "SELECT id, type, number_extension_separator FROM postal_code_number_extension_element_type WHERE id = ?"

	entity := &parent.PostalCodeNumberExtensionElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.NumberExtensionSeparator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postalCodeNumberExtensionElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostalCodeNumberExtensionElementType, error) {
	query := "SELECT id, type, number_extension_separator FROM postal_code_number_extension_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostalCodeNumberExtensionElementType
	for rows.Next() {
		entity := &parent.PostalCodeNumberExtensionElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.NumberExtensionSeparator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postalCodeNumberExtensionElementTypeRepository) Update(ctx context.Context, entity *parent.PostalCodeNumberExtensionElementType) error {
	query := "UPDATE postal_code_number_extension_element_type SET type = ?, number_extension_separator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.NumberExtensionSeparator,
		entity.ID,
	)
	return err
}

func (r *postalCodeNumberExtensionElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM postal_code_number_extension_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postalCodeNumberExtensionElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM postal_code_number_extension_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postalCodeNumberExtensionElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM postal_code_number_extension_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostalRouteNameElementType() parent.PostalRouteNameElementTypeRepository {
	return &postalRouteNameElementTypeRepository{db: d.db}
}

type postalRouteNameElementTypeRepository struct {
	db *sql.DB
}

func (r *postalRouteNameElementTypeRepository) Create(ctx context.Context, entity *parent.PostalRouteNameElementType) (int64, error) {
	query := "INSERT INTO postal_route_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postalRouteNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostalRouteNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO postal_route_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postalRouteNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostalRouteNameElementType, error) {
	query := "SELECT id, type FROM postal_route_name_element_type WHERE id = ?"

	entity := &parent.PostalRouteNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postalRouteNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostalRouteNameElementType, error) {
	query := "SELECT id, type FROM postal_route_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostalRouteNameElementType
	for rows.Next() {
		entity := &parent.PostalRouteNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postalRouteNameElementTypeRepository) Update(ctx context.Context, entity *parent.PostalRouteNameElementType) error {
	query := "UPDATE postal_route_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *postalRouteNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM postal_route_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postalRouteNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM postal_route_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postalRouteNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM postal_route_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostalRouteNumberElementType() parent.PostalRouteNumberElementTypeRepository {
	return &postalRouteNumberElementTypeRepository{db: d.db}
}

type postalRouteNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *postalRouteNumberElementTypeRepository) Create(ctx context.Context, entity *parent.PostalRouteNumberElementType) (int64, error) {
	query := "INSERT INTO postal_route_number_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postalRouteNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostalRouteNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO postal_route_number_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postalRouteNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostalRouteNumberElementType, error) {
	query := "SELECT id FROM postal_route_number_element_type WHERE id = ?"

	entity := &parent.PostalRouteNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postalRouteNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostalRouteNumberElementType, error) {
	query := "SELECT id FROM postal_route_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostalRouteNumberElementType
	for rows.Next() {
		entity := &parent.PostalRouteNumberElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postalRouteNumberElementTypeRepository) Update(ctx context.Context, entity *parent.PostalRouteNumberElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *postalRouteNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM postal_route_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postalRouteNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM postal_route_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postalRouteNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM postal_route_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) PostalRouteType() parent.PostalRouteTypeRepository {
	return &postalRouteTypeRepository{db: d.db}
}

type postalRouteTypeRepository struct {
	db *sql.DB
}

func (r *postalRouteTypeRepository) Create(ctx context.Context, entity *parent.PostalRouteType) (int64, error) {
	query := "INSERT INTO postal_route_type (type, postal_route_name, postal_route_number) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PostalRouteName,
		entity.PostalRouteNumber,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postalRouteTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostalRouteType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO postal_route_type (type, postal_route_name, postal_route_number) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.PostalRouteName,
			entity.PostalRouteNumber,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postalRouteTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostalRouteType, error) {
	query := "SELECT id, type, postal_route_name, postal_route_number FROM postal_route_type WHERE id = ?"

	entity := &parent.PostalRouteType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.PostalRouteName,
		&entity.PostalRouteNumber,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postalRouteTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostalRouteType, error) {
	query := "SELECT id, type, postal_route_name, postal_route_number FROM postal_route_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostalRouteType
	for rows.Next() {
		entity := &parent.PostalRouteType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.PostalRouteName,
			&entity.PostalRouteNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postalRouteTypeRepository) Update(ctx context.Context, entity *parent.PostalRouteType) error {
	query := "UPDATE postal_route_type SET type = ?, postal_route_name = ?, postal_route_number = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PostalRouteName,
		entity.PostalRouteNumber,
		entity.ID,
	)
	return err
}

func (r *postalRouteTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM postal_route_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postalRouteTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM postal_route_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postalRouteTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM postal_route_type").Scan(&count)
	return count, err
}

func (d *dal) PostalServiceElementsElementType() parent.PostalServiceElementsElementTypeRepository {
	return &postalServiceElementsElementTypeRepository{db: d.db}
}

type postalServiceElementsElementTypeRepository struct {
	db *sql.DB
}

func (r *postalServiceElementsElementTypeRepository) Create(ctx context.Context, entity *parent.PostalServiceElementsElementType) (int64, error) {
	query := "INSERT INTO postal_service_elements_element_type (type, address_identifier, endorsement_line_code, key_line_code, barcode, sorting_code, address_latitude, address_latitude_direction, address_longitude, address_longitude_direction, supplementary_postal_service_data) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.AddressIdentifier,
		entity.EndorsementLineCode,
		entity.KeyLineCode,
		entity.Barcode,
		entity.SortingCode,
		entity.AddressLatitude,
		entity.AddressLatitudeDirection,
		entity.AddressLongitude,
		entity.AddressLongitudeDirection,
		entity.SupplementaryPostalServiceData,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *postalServiceElementsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PostalServiceElementsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO postal_service_elements_element_type (type, address_identifier, endorsement_line_code, key_line_code, barcode, sorting_code, address_latitude, address_latitude_direction, address_longitude, address_longitude_direction, supplementary_postal_service_data) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.AddressIdentifier,
			entity.EndorsementLineCode,
			entity.KeyLineCode,
			entity.Barcode,
			entity.SortingCode,
			entity.AddressLatitude,
			entity.AddressLatitudeDirection,
			entity.AddressLongitude,
			entity.AddressLongitudeDirection,
			entity.SupplementaryPostalServiceData,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *postalServiceElementsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PostalServiceElementsElementType, error) {
	query := "SELECT id, type, address_identifier, endorsement_line_code, key_line_code, barcode, sorting_code, address_latitude, address_latitude_direction, address_longitude, address_longitude_direction, supplementary_postal_service_data FROM postal_service_elements_element_type WHERE id = ?"

	entity := &parent.PostalServiceElementsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.AddressIdentifier,
		&entity.EndorsementLineCode,
		&entity.KeyLineCode,
		&entity.Barcode,
		&entity.SortingCode,
		&entity.AddressLatitude,
		&entity.AddressLatitudeDirection,
		&entity.AddressLongitude,
		&entity.AddressLongitudeDirection,
		&entity.SupplementaryPostalServiceData,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *postalServiceElementsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PostalServiceElementsElementType, error) {
	query := "SELECT id, type, address_identifier, endorsement_line_code, key_line_code, barcode, sorting_code, address_latitude, address_latitude_direction, address_longitude, address_longitude_direction, supplementary_postal_service_data FROM postal_service_elements_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PostalServiceElementsElementType
	for rows.Next() {
		entity := &parent.PostalServiceElementsElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.AddressIdentifier,
			&entity.EndorsementLineCode,
			&entity.KeyLineCode,
			&entity.Barcode,
			&entity.SortingCode,
			&entity.AddressLatitude,
			&entity.AddressLatitudeDirection,
			&entity.AddressLongitude,
			&entity.AddressLongitudeDirection,
			&entity.SupplementaryPostalServiceData,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *postalServiceElementsElementTypeRepository) Update(ctx context.Context, entity *parent.PostalServiceElementsElementType) error {
	query := "UPDATE postal_service_elements_element_type SET type = ?, address_identifier = ?, endorsement_line_code = ?, key_line_code = ?, barcode = ?, sorting_code = ?, address_latitude = ?, address_latitude_direction = ?, address_longitude = ?, address_longitude_direction = ?, supplementary_postal_service_data = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.AddressIdentifier,
		entity.EndorsementLineCode,
		entity.KeyLineCode,
		entity.Barcode,
		entity.SortingCode,
		entity.AddressLatitude,
		entity.AddressLatitudeDirection,
		entity.AddressLongitude,
		entity.AddressLongitudeDirection,
		entity.SupplementaryPostalServiceData,
		entity.ID,
	)
	return err
}

func (r *postalServiceElementsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM postal_service_elements_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *postalServiceElementsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM postal_service_elements_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *postalServiceElementsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM postal_service_elements_element_type").Scan(&count)
	return count, err
}

func (d *dal) PrecedingTitleElementType() parent.PrecedingTitleElementTypeRepository {
	return &precedingTitleElementTypeRepository{db: d.db}
}

type precedingTitleElementTypeRepository struct {
	db *sql.DB
}

func (r *precedingTitleElementTypeRepository) Create(ctx context.Context, entity *parent.PrecedingTitleElementType) (int64, error) {
	query := "INSERT INTO preceding_title_element_type (type, code) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *precedingTitleElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PrecedingTitleElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO preceding_title_element_type (type, code) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *precedingTitleElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PrecedingTitleElementType, error) {
	query := "SELECT id, type, code FROM preceding_title_element_type WHERE id = ?"

	entity := &parent.PrecedingTitleElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *precedingTitleElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PrecedingTitleElementType, error) {
	query := "SELECT id, type, code FROM preceding_title_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PrecedingTitleElementType
	for rows.Next() {
		entity := &parent.PrecedingTitleElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *precedingTitleElementTypeRepository) Update(ctx context.Context, entity *parent.PrecedingTitleElementType) error {
	query := "UPDATE preceding_title_element_type SET type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *precedingTitleElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM preceding_title_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *precedingTitleElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM preceding_title_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *precedingTitleElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM preceding_title_element_type").Scan(&count)
	return count, err
}

func (d *dal) Premise() parent.PremiseRepository {
	return &premiseRepository{db: d.db}
}

type premiseRepository struct {
	db *sql.DB
}

func (r *premiseRepository) Create(ctx context.Context, entity *parent.Premise) (int64, error) {
	query := "INSERT INTO premise (type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PremiseDependency,
		entity.PremiseDependencyType,
		entity.PremiseThoroughfareConnector,
		entity.PremiseName,
		entity.MailStopID,
		entity.PremiseLocation,
		entity.PremiseNumberRange,
		entity.FirmID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseRepository) CreateBatch(ctx context.Context, entities []*parent.Premise) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise (type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.PremiseDependency,
			entity.PremiseDependencyType,
			entity.PremiseThoroughfareConnector,
			entity.PremiseName,
			entity.MailStopID,
			entity.PremiseLocation,
			entity.PremiseNumberRange,
			entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseRepository) GetByID(ctx context.Context, id int64) (*parent.Premise, error) {
	query := "SELECT id, type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id FROM premise WHERE id = ?"

	entity := &parent.Premise{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.PremiseDependency,
		&entity.PremiseDependencyType,
		&entity.PremiseThoroughfareConnector,
		&entity.PremiseName,
		&entity.MailStopID,
		&entity.PremiseLocation,
		&entity.PremiseNumberRange,
		&entity.FirmID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Premise, error) {
	query := "SELECT id, type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id FROM premise LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Premise
	for rows.Next() {
		entity := &parent.Premise{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.PremiseDependency,
			&entity.PremiseDependencyType,
			&entity.PremiseThoroughfareConnector,
			&entity.PremiseName,
			&entity.MailStopID,
			&entity.PremiseLocation,
			&entity.PremiseNumberRange,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseRepository) Update(ctx context.Context, entity *parent.Premise) error {
	query := "UPDATE premise SET type = ?, premise_dependency = ?, premise_dependency_type = ?, premise_thoroughfare_connector = ?, premise_name = ?, mail_stop_id = ?, premise_location = ?, premise_number_range = ?, firm_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PremiseDependency,
		entity.PremiseDependencyType,
		entity.PremiseThoroughfareConnector,
		entity.PremiseName,
		entity.MailStopID,
		entity.PremiseLocation,
		entity.PremiseNumberRange,
		entity.FirmID,
		entity.ID,
	)
	return err
}

func (r *premiseRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise").Scan(&count)
	return count, err
}

func (d *dal) PremiseElementType() parent.PremiseElementTypeRepository {
	return &premiseElementTypeRepository{db: d.db}
}

type premiseElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseElementType) (int64, error) {
	query := "INSERT INTO premise_element_type (type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PremiseDependency,
		entity.PremiseDependencyType,
		entity.PremiseThoroughfareConnector,
		entity.PremiseName,
		entity.MailStopID,
		entity.PremiseLocation,
		entity.PremiseNumberRange,
		entity.FirmID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_element_type (type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.PremiseDependency,
			entity.PremiseDependencyType,
			entity.PremiseThoroughfareConnector,
			entity.PremiseName,
			entity.MailStopID,
			entity.PremiseLocation,
			entity.PremiseNumberRange,
			entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseElementType, error) {
	query := "SELECT id, type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id FROM premise_element_type WHERE id = ?"

	entity := &parent.PremiseElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.PremiseDependency,
		&entity.PremiseDependencyType,
		&entity.PremiseThoroughfareConnector,
		&entity.PremiseName,
		&entity.MailStopID,
		&entity.PremiseLocation,
		&entity.PremiseNumberRange,
		&entity.FirmID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseElementType, error) {
	query := "SELECT id, type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id FROM premise_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseElementType
	for rows.Next() {
		entity := &parent.PremiseElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.PremiseDependency,
			&entity.PremiseDependencyType,
			&entity.PremiseThoroughfareConnector,
			&entity.PremiseName,
			&entity.MailStopID,
			&entity.PremiseLocation,
			&entity.PremiseNumberRange,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseElementType) error {
	query := "UPDATE premise_element_type SET type = ?, premise_dependency = ?, premise_dependency_type = ?, premise_thoroughfare_connector = ?, premise_name = ?, mail_stop_id = ?, premise_location = ?, premise_number_range = ?, firm_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.PremiseDependency,
		entity.PremiseDependencyType,
		entity.PremiseThoroughfareConnector,
		entity.PremiseName,
		entity.MailStopID,
		entity.PremiseLocation,
		entity.PremiseNumberRange,
		entity.FirmID,
		entity.ID,
	)
	return err
}

func (r *premiseElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_element_type").Scan(&count)
	return count, err
}

func (r *premiseElementTypeRepository) GetByMailStopType(ctx context.Context, mail_stop_typeID int64) ([]*parent.PremiseElementType, error) {
	query := "SELECT id, type, premise_dependency, premise_dependency_type, premise_thoroughfare_connector, premise_name, mail_stop_id, premise_location, premise_number_range, firm_id FROM premise_element_type WHERE mail_stop_id = ?"

	rows, err := r.db.QueryContext(ctx, query, mail_stop_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseElementType
	for rows.Next() {
		entity := &parent.PremiseElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.PremiseDependency,
			&entity.PremiseDependencyType,
			&entity.PremiseThoroughfareConnector,
			&entity.PremiseName,
			&entity.MailStopID,
			&entity.PremiseLocation,
			&entity.PremiseNumberRange,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) PremiseLocationElementType() parent.PremiseLocationElementTypeRepository {
	return &premiseLocationElementTypeRepository{db: d.db}
}

type premiseLocationElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseLocationElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseLocationElementType) (int64, error) {
	query := "INSERT INTO premise_location_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseLocationElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseLocationElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_location_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseLocationElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseLocationElementType, error) {
	query := "SELECT id FROM premise_location_element_type WHERE id = ?"

	entity := &parent.PremiseLocationElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseLocationElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseLocationElementType, error) {
	query := "SELECT id FROM premise_location_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseLocationElementType
	for rows.Next() {
		entity := &parent.PremiseLocationElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseLocationElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseLocationElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *premiseLocationElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_location_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseLocationElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_location_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseLocationElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_location_element_type").Scan(&count)
	return count, err
}

func (d *dal) PremiseNameElementType() parent.PremiseNameElementTypeRepository {
	return &premiseNameElementTypeRepository{db: d.db}
}

type premiseNameElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseNameElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseNameElementType) (int64, error) {
	query := "INSERT INTO premise_name_element_type (type, type_occurrence) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.TypeOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_name_element_type (type, type_occurrence) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.TypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNameElementType, error) {
	query := "SELECT id, type, type_occurrence FROM premise_name_element_type WHERE id = ?"

	entity := &parent.PremiseNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.TypeOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNameElementType, error) {
	query := "SELECT id, type, type_occurrence FROM premise_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNameElementType
	for rows.Next() {
		entity := &parent.PremiseNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.TypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNameElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseNameElementType) error {
	query := "UPDATE premise_name_element_type SET type = ?, type_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.TypeOccurrence,
		entity.ID,
	)
	return err
}

func (r *premiseNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumber() parent.PremiseNumberRepository {
	return &premiseNumberRepository{db: d.db}
}

type premiseNumberRepository struct {
	db *sql.DB
}

func (r *premiseNumberRepository) Create(ctx context.Context, entity *parent.PremiseNumber) (int64, error) {
	query := "INSERT INTO premise_number (number_type, type, indicator, indicator_occurrence, number_type_occurrence) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberType,
		entity.Type,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberTypeOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumber) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_number (number_type, type, indicator, indicator_occurrence, number_type_occurrence) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberType,
			entity.Type,
			entity.Indicator,
			entity.IndicatorOccurrence,
			entity.NumberTypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumber, error) {
	query := "SELECT id, number_type, type, indicator, indicator_occurrence, number_type_occurrence FROM premise_number WHERE id = ?"

	entity := &parent.PremiseNumber{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberType,
		&entity.Type,
		&entity.Indicator,
		&entity.IndicatorOccurrence,
		&entity.NumberTypeOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumber, error) {
	query := "SELECT id, number_type, type, indicator, indicator_occurrence, number_type_occurrence FROM premise_number LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumber
	for rows.Next() {
		entity := &parent.PremiseNumber{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberType,
			&entity.Type,
			&entity.Indicator,
			&entity.IndicatorOccurrence,
			&entity.NumberTypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberRepository) Update(ctx context.Context, entity *parent.PremiseNumber) error {
	query := "UPDATE premise_number SET number_type = ?, type = ?, indicator = ?, indicator_occurrence = ?, number_type_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberType,
		entity.Type,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberTypeOccurrence,
		entity.ID,
	)
	return err
}

func (r *premiseNumberRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_number WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_number WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_number").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumberElementType() parent.PremiseNumberElementTypeRepository {
	return &premiseNumberElementTypeRepository{db: d.db}
}

type premiseNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseNumberElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseNumberElementType) (int64, error) {
	query := "INSERT INTO premise_number_element_type (number_type, type, indicator, indicator_occurrence, number_type_occurrence) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberType,
		entity.Type,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberTypeOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_number_element_type (number_type, type, indicator, indicator_occurrence, number_type_occurrence) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberType,
			entity.Type,
			entity.Indicator,
			entity.IndicatorOccurrence,
			entity.NumberTypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumberElementType, error) {
	query := "SELECT id, number_type, type, indicator, indicator_occurrence, number_type_occurrence FROM premise_number_element_type WHERE id = ?"

	entity := &parent.PremiseNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberType,
		&entity.Type,
		&entity.Indicator,
		&entity.IndicatorOccurrence,
		&entity.NumberTypeOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumberElementType, error) {
	query := "SELECT id, number_type, type, indicator, indicator_occurrence, number_type_occurrence FROM premise_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumberElementType
	for rows.Next() {
		entity := &parent.PremiseNumberElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberType,
			&entity.Type,
			&entity.Indicator,
			&entity.IndicatorOccurrence,
			&entity.NumberTypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseNumberElementType) error {
	query := "UPDATE premise_number_element_type SET number_type = ?, type = ?, indicator = ?, indicator_occurrence = ?, number_type_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberType,
		entity.Type,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberTypeOccurrence,
		entity.ID,
	)
	return err
}

func (r *premiseNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumberPrefix() parent.PremiseNumberPrefixRepository {
	return &premiseNumberPrefixRepository{db: d.db}
}

type premiseNumberPrefixRepository struct {
	db *sql.DB
}

func (r *premiseNumberPrefixRepository) Create(ctx context.Context, entity *parent.PremiseNumberPrefix) (int64, error) {
	query := "INSERT INTO premise_number_prefix (number_prefix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberPrefixRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumberPrefix) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_number_prefix (number_prefix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberPrefixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberPrefixRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumberPrefix, error) {
	query := "SELECT id, number_prefix_separator, type FROM premise_number_prefix WHERE id = ?"

	entity := &parent.PremiseNumberPrefix{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberPrefixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberPrefixRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumberPrefix, error) {
	query := "SELECT id, number_prefix_separator, type FROM premise_number_prefix LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumberPrefix
	for rows.Next() {
		entity := &parent.PremiseNumberPrefix{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberPrefixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberPrefixRepository) Update(ctx context.Context, entity *parent.PremiseNumberPrefix) error {
	query := "UPDATE premise_number_prefix SET number_prefix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *premiseNumberPrefixRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_number_prefix WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberPrefixRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_number_prefix WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberPrefixRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_number_prefix").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumberPrefixElementType() parent.PremiseNumberPrefixElementTypeRepository {
	return &premiseNumberPrefixElementTypeRepository{db: d.db}
}

type premiseNumberPrefixElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseNumberPrefixElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseNumberPrefixElementType) (int64, error) {
	query := "INSERT INTO premise_number_prefix_element_type (number_prefix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberPrefixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumberPrefixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_number_prefix_element_type (number_prefix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberPrefixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberPrefixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumberPrefixElementType, error) {
	query := "SELECT id, number_prefix_separator, type FROM premise_number_prefix_element_type WHERE id = ?"

	entity := &parent.PremiseNumberPrefixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberPrefixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberPrefixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumberPrefixElementType, error) {
	query := "SELECT id, number_prefix_separator, type FROM premise_number_prefix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumberPrefixElementType
	for rows.Next() {
		entity := &parent.PremiseNumberPrefixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberPrefixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberPrefixElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseNumberPrefixElementType) error {
	query := "UPDATE premise_number_prefix_element_type SET number_prefix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *premiseNumberPrefixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_number_prefix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberPrefixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_number_prefix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberPrefixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_number_prefix_element_type").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumberRangeElementType() parent.PremiseNumberRangeElementTypeRepository {
	return &premiseNumberRangeElementTypeRepository{db: d.db}
}

type premiseNumberRangeElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseNumberRangeElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseNumberRangeElementType) (int64, error) {
	query := "INSERT INTO premise_number_range_element_type (range_type, indicator, separator, type, indicator_occurence, number_range_occurence, premise_number_range_from, premise_number_range_to) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.RangeType,
		entity.Indicator,
		entity.Separator,
		entity.Type,
		entity.IndicatorOccurence,
		entity.NumberRangeOccurence,
		entity.PremiseNumberRangeFrom,
		entity.PremiseNumberRangeTo,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberRangeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumberRangeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_number_range_element_type (range_type, indicator, separator, type, indicator_occurence, number_range_occurence, premise_number_range_from, premise_number_range_to) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.RangeType,
			entity.Indicator,
			entity.Separator,
			entity.Type,
			entity.IndicatorOccurence,
			entity.NumberRangeOccurence,
			entity.PremiseNumberRangeFrom,
			entity.PremiseNumberRangeTo,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberRangeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumberRangeElementType, error) {
	query := "SELECT id, range_type, indicator, separator, type, indicator_occurence, number_range_occurence, premise_number_range_from, premise_number_range_to FROM premise_number_range_element_type WHERE id = ?"

	entity := &parent.PremiseNumberRangeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.RangeType,
		&entity.Indicator,
		&entity.Separator,
		&entity.Type,
		&entity.IndicatorOccurence,
		&entity.NumberRangeOccurence,
		&entity.PremiseNumberRangeFrom,
		&entity.PremiseNumberRangeTo,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberRangeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumberRangeElementType, error) {
	query := "SELECT id, range_type, indicator, separator, type, indicator_occurence, number_range_occurence, premise_number_range_from, premise_number_range_to FROM premise_number_range_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumberRangeElementType
	for rows.Next() {
		entity := &parent.PremiseNumberRangeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.RangeType,
			&entity.Indicator,
			&entity.Separator,
			&entity.Type,
			&entity.IndicatorOccurence,
			&entity.NumberRangeOccurence,
			&entity.PremiseNumberRangeFrom,
			&entity.PremiseNumberRangeTo,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberRangeElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseNumberRangeElementType) error {
	query := "UPDATE premise_number_range_element_type SET range_type = ?, indicator = ?, separator = ?, type = ?, indicator_occurence = ?, number_range_occurence = ?, premise_number_range_from = ?, premise_number_range_to = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.RangeType,
		entity.Indicator,
		entity.Separator,
		entity.Type,
		entity.IndicatorOccurence,
		entity.NumberRangeOccurence,
		entity.PremiseNumberRangeFrom,
		entity.PremiseNumberRangeTo,
		entity.ID,
	)
	return err
}

func (r *premiseNumberRangeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_number_range_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberRangeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_number_range_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberRangeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_number_range_element_type").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumberRangeFromElementType() parent.PremiseNumberRangeFromElementTypeRepository {
	return &premiseNumberRangeFromElementTypeRepository{db: d.db}
}

type premiseNumberRangeFromElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseNumberRangeFromElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseNumberRangeFromElementType) (int64, error) {
	query := "INSERT INTO \"premise_number_range_from_element_type\" DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberRangeFromElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumberRangeFromElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"premise_number_range_from_element_type\" DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberRangeFromElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumberRangeFromElementType, error) {
	query := "SELECT id FROM \"premise_number_range_from_element_type\" WHERE id = ?"

	entity := &parent.PremiseNumberRangeFromElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberRangeFromElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumberRangeFromElementType, error) {
	query := "SELECT id FROM \"premise_number_range_from_element_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumberRangeFromElementType
	for rows.Next() {
		entity := &parent.PremiseNumberRangeFromElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberRangeFromElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseNumberRangeFromElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *premiseNumberRangeFromElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"premise_number_range_from_element_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberRangeFromElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"premise_number_range_from_element_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberRangeFromElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"premise_number_range_from_element_type\"").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumberRangeToElementType() parent.PremiseNumberRangeToElementTypeRepository {
	return &premiseNumberRangeToElementTypeRepository{db: d.db}
}

type premiseNumberRangeToElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseNumberRangeToElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseNumberRangeToElementType) (int64, error) {
	query := "INSERT INTO \"premise_number_range_to_element_type\" DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberRangeToElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumberRangeToElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"premise_number_range_to_element_type\" DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberRangeToElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumberRangeToElementType, error) {
	query := "SELECT id FROM \"premise_number_range_to_element_type\" WHERE id = ?"

	entity := &parent.PremiseNumberRangeToElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberRangeToElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumberRangeToElementType, error) {
	query := "SELECT id FROM \"premise_number_range_to_element_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumberRangeToElementType
	for rows.Next() {
		entity := &parent.PremiseNumberRangeToElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberRangeToElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseNumberRangeToElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *premiseNumberRangeToElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"premise_number_range_to_element_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberRangeToElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"premise_number_range_to_element_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberRangeToElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"premise_number_range_to_element_type\"").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumberSuffix() parent.PremiseNumberSuffixRepository {
	return &premiseNumberSuffixRepository{db: d.db}
}

type premiseNumberSuffixRepository struct {
	db *sql.DB
}

func (r *premiseNumberSuffixRepository) Create(ctx context.Context, entity *parent.PremiseNumberSuffix) (int64, error) {
	query := "INSERT INTO premise_number_suffix (number_suffix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberSuffixRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumberSuffix) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_number_suffix (number_suffix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberSuffixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberSuffixRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumberSuffix, error) {
	query := "SELECT id, number_suffix_separator, type FROM premise_number_suffix WHERE id = ?"

	entity := &parent.PremiseNumberSuffix{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberSuffixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberSuffixRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumberSuffix, error) {
	query := "SELECT id, number_suffix_separator, type FROM premise_number_suffix LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumberSuffix
	for rows.Next() {
		entity := &parent.PremiseNumberSuffix{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberSuffixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberSuffixRepository) Update(ctx context.Context, entity *parent.PremiseNumberSuffix) error {
	query := "UPDATE premise_number_suffix SET number_suffix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *premiseNumberSuffixRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_number_suffix WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberSuffixRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_number_suffix WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberSuffixRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_number_suffix").Scan(&count)
	return count, err
}

func (d *dal) PremiseNumberSuffixElementType() parent.PremiseNumberSuffixElementTypeRepository {
	return &premiseNumberSuffixElementTypeRepository{db: d.db}
}

type premiseNumberSuffixElementTypeRepository struct {
	db *sql.DB
}

func (r *premiseNumberSuffixElementTypeRepository) Create(ctx context.Context, entity *parent.PremiseNumberSuffixElementType) (int64, error) {
	query := "INSERT INTO premise_number_suffix_element_type (number_suffix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *premiseNumberSuffixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.PremiseNumberSuffixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO premise_number_suffix_element_type (number_suffix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberSuffixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *premiseNumberSuffixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.PremiseNumberSuffixElementType, error) {
	query := "SELECT id, number_suffix_separator, type FROM premise_number_suffix_element_type WHERE id = ?"

	entity := &parent.PremiseNumberSuffixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberSuffixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *premiseNumberSuffixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.PremiseNumberSuffixElementType, error) {
	query := "SELECT id, number_suffix_separator, type FROM premise_number_suffix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.PremiseNumberSuffixElementType
	for rows.Next() {
		entity := &parent.PremiseNumberSuffixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberSuffixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *premiseNumberSuffixElementTypeRepository) Update(ctx context.Context, entity *parent.PremiseNumberSuffixElementType) error {
	query := "UPDATE premise_number_suffix_element_type SET number_suffix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *premiseNumberSuffixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM premise_number_suffix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *premiseNumberSuffixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM premise_number_suffix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *premiseNumberSuffixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM premise_number_suffix_element_type").Scan(&count)
	return count, err
}

func (d *dal) ProfileNoteType() parent.ProfileNoteTypeRepository {
	return &profileNoteTypeRepository{db: d.db}
}

type profileNoteTypeRepository struct {
	db *sql.DB
}

func (r *profileNoteTypeRepository) Create(ctx context.Context, entity *parent.ProfileNoteType) (int64, error) {
	query := "INSERT INTO profile_note_type (tag, sub_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Tag,
		entity.SubID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *profileNoteTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ProfileNoteType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO profile_note_type (tag, sub_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Tag,
			entity.SubID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *profileNoteTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ProfileNoteType, error) {
	query := "SELECT id, tag, sub_id FROM profile_note_type WHERE id = ?"

	entity := &parent.ProfileNoteType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Tag,
		&entity.SubID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *profileNoteTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ProfileNoteType, error) {
	query := "SELECT id, tag, sub_id FROM profile_note_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileNoteType
	for rows.Next() {
		entity := &parent.ProfileNoteType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Tag,
			&entity.SubID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *profileNoteTypeRepository) Update(ctx context.Context, entity *parent.ProfileNoteType) error {
	query := "UPDATE profile_note_type SET tag = ?, sub_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Tag,
		entity.SubID,
		entity.ID,
	)
	return err
}

func (r *profileNoteTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM profile_note_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *profileNoteTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM profile_note_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *profileNoteTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM profile_note_type").Scan(&count)
	return count, err
}

func (r *profileNoteTypeRepository) GetBySubType(ctx context.Context, sub_typeID int64) ([]*parent.ProfileNoteType, error) {
	query := "SELECT id, tag, sub_id FROM profile_note_type WHERE sub_id = ?"

	rows, err := r.db.QueryContext(ctx, query, sub_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileNoteType
	for rows.Next() {
		entity := &parent.ProfileNoteType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Tag,
			&entity.SubID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ProfileRefineRuleType() parent.ProfileRefineRuleTypeRepository {
	return &profileRefineRuleTypeRepository{db: d.db}
}

type profileRefineRuleTypeRepository struct {
	db *sql.DB
}

func (r *profileRefineRuleTypeRepository) Create(ctx context.Context, entity *parent.ProfileRefineRuleType) (int64, error) {
	query := "INSERT INTO profile_refine_rule_type (idref, weight, selector, severity, role) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.Weight,
		entity.Selector,
		entity.Severity,
		entity.Role,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *profileRefineRuleTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ProfileRefineRuleType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO profile_refine_rule_type (idref, weight, selector, severity, role) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Idref,
			entity.Weight,
			entity.Selector,
			entity.Severity,
			entity.Role,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *profileRefineRuleTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ProfileRefineRuleType, error) {
	query := "SELECT id, idref, weight, selector, severity, role FROM profile_refine_rule_type WHERE id = ?"

	entity := &parent.ProfileRefineRuleType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Idref,
		&entity.Weight,
		&entity.Selector,
		&entity.Severity,
		&entity.Role,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *profileRefineRuleTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ProfileRefineRuleType, error) {
	query := "SELECT id, idref, weight, selector, severity, role FROM profile_refine_rule_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileRefineRuleType
	for rows.Next() {
		entity := &parent.ProfileRefineRuleType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
			&entity.Weight,
			&entity.Selector,
			&entity.Severity,
			&entity.Role,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *profileRefineRuleTypeRepository) Update(ctx context.Context, entity *parent.ProfileRefineRuleType) error {
	query := "UPDATE profile_refine_rule_type SET idref = ?, weight = ?, selector = ?, severity = ?, role = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.Weight,
		entity.Selector,
		entity.Severity,
		entity.Role,
		entity.ID,
	)
	return err
}

func (r *profileRefineRuleTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM profile_refine_rule_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *profileRefineRuleTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM profile_refine_rule_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *profileRefineRuleTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM profile_refine_rule_type").Scan(&count)
	return count, err
}

func (d *dal) ProfileRefineValueType() parent.ProfileRefineValueTypeRepository {
	return &profileRefineValueTypeRepository{db: d.db}
}

type profileRefineValueTypeRepository struct {
	db *sql.DB
}

func (r *profileRefineValueTypeRepository) Create(ctx context.Context, entity *parent.ProfileRefineValueType) (int64, error) {
	query := "INSERT INTO profile_refine_value_type (idref, selector, operator) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.Selector,
		entity.Operator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *profileRefineValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ProfileRefineValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO profile_refine_value_type (idref, selector, operator) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Idref,
			entity.Selector,
			entity.Operator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *profileRefineValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ProfileRefineValueType, error) {
	query := "SELECT id, idref, selector, operator FROM profile_refine_value_type WHERE id = ?"

	entity := &parent.ProfileRefineValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Idref,
		&entity.Selector,
		&entity.Operator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *profileRefineValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ProfileRefineValueType, error) {
	query := "SELECT id, idref, selector, operator FROM profile_refine_value_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileRefineValueType
	for rows.Next() {
		entity := &parent.ProfileRefineValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
			&entity.Selector,
			&entity.Operator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *profileRefineValueTypeRepository) Update(ctx context.Context, entity *parent.ProfileRefineValueType) error {
	query := "UPDATE profile_refine_value_type SET idref = ?, selector = ?, operator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.Selector,
		entity.Operator,
		entity.ID,
	)
	return err
}

func (r *profileRefineValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM profile_refine_value_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *profileRefineValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM profile_refine_value_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *profileRefineValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM profile_refine_value_type").Scan(&count)
	return count, err
}

func (d *dal) ProfileSelectType() parent.ProfileSelectTypeRepository {
	return &profileSelectTypeRepository{db: d.db}
}

type profileSelectTypeRepository struct {
	db *sql.DB
}

func (r *profileSelectTypeRepository) Create(ctx context.Context, entity *parent.ProfileSelectType) (int64, error) {
	query := "INSERT INTO \"profile_select_type\" (idref, selected) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.Selected,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *profileSelectTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ProfileSelectType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"profile_select_type\" (idref, selected) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Idref,
			entity.Selected,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *profileSelectTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ProfileSelectType, error) {
	query := "SELECT id, idref, selected FROM \"profile_select_type\" WHERE id = ?"

	entity := &parent.ProfileSelectType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Idref,
		&entity.Selected,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *profileSelectTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ProfileSelectType, error) {
	query := "SELECT id, idref, selected FROM \"profile_select_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileSelectType
	for rows.Next() {
		entity := &parent.ProfileSelectType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
			&entity.Selected,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *profileSelectTypeRepository) Update(ctx context.Context, entity *parent.ProfileSelectType) error {
	query := "UPDATE \"profile_select_type\" SET idref = ?, selected = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.Selected,
		entity.ID,
	)
	return err
}

func (r *profileSelectTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"profile_select_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *profileSelectTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"profile_select_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *profileSelectTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"profile_select_type\"").Scan(&count)
	return count, err
}

func (d *dal) ProfileSetComplexValueType() parent.ProfileSetComplexValueTypeRepository {
	return &profileSetComplexValueTypeRepository{db: d.db}
}

type profileSetComplexValueTypeRepository struct {
	db *sql.DB
}

func (r *profileSetComplexValueTypeRepository) Create(ctx context.Context, entity *parent.ProfileSetComplexValueType) (int64, error) {
	query := "INSERT INTO \"profile_set_complex_value_type\" (idref, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *profileSetComplexValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ProfileSetComplexValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"profile_set_complex_value_type\" (idref, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Idref,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *profileSetComplexValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ProfileSetComplexValueType, error) {
	query := "SELECT id, idref, parent_id FROM \"profile_set_complex_value_type\" WHERE id = ?"

	entity := &parent.ProfileSetComplexValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Idref,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *profileSetComplexValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ProfileSetComplexValueType, error) {
	query := "SELECT id, idref, parent_id FROM \"profile_set_complex_value_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileSetComplexValueType
	for rows.Next() {
		entity := &parent.ProfileSetComplexValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *profileSetComplexValueTypeRepository) Update(ctx context.Context, entity *parent.ProfileSetComplexValueType) error {
	query := "UPDATE \"profile_set_complex_value_type\" SET idref = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *profileSetComplexValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"profile_set_complex_value_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *profileSetComplexValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"profile_set_complex_value_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *profileSetComplexValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"profile_set_complex_value_type\"").Scan(&count)
	return count, err
}

func (r *profileSetComplexValueTypeRepository) GetByComplexValueType(ctx context.Context, complex_value_typeID int64) ([]*parent.ProfileSetComplexValueType, error) {
	query := "SELECT id, idref, parent_id FROM \"profile_set_complex_value_type\" WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, complex_value_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileSetComplexValueType
	for rows.Next() {
		entity := &parent.ProfileSetComplexValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ProfileSetValueType() parent.ProfileSetValueTypeRepository {
	return &profileSetValueTypeRepository{db: d.db}
}

type profileSetValueTypeRepository struct {
	db *sql.DB
}

func (r *profileSetValueTypeRepository) Create(ctx context.Context, entity *parent.ProfileSetValueType) (int64, error) {
	query := "INSERT INTO \"profile_set_value_type\" (idref) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Idref,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *profileSetValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ProfileSetValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"profile_set_value_type\" (idref) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Idref,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *profileSetValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ProfileSetValueType, error) {
	query := "SELECT id, idref FROM \"profile_set_value_type\" WHERE id = ?"

	entity := &parent.ProfileSetValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Idref,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *profileSetValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ProfileSetValueType, error) {
	query := "SELECT id, idref FROM \"profile_set_value_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileSetValueType
	for rows.Next() {
		entity := &parent.ProfileSetValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *profileSetValueTypeRepository) Update(ctx context.Context, entity *parent.ProfileSetValueType) error {
	query := "UPDATE \"profile_set_value_type\" SET idref = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.ID,
	)
	return err
}

func (r *profileSetValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"profile_set_value_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *profileSetValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"profile_set_value_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *profileSetValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"profile_set_value_type\"").Scan(&count)
	return count, err
}

func (d *dal) ProfileType() parent.ProfileTypeRepository {
	return &profileTypeRepository{db: d.db}
}

type profileTypeRepository struct {
	db *sql.DB
}

func (r *profileTypeRepository) Create(ctx context.Context, entity *parent.ProfileType) (int64, error) {
	query := "INSERT INTO profile_type (xsd_id, prohibit_changes, abstract, note_tag, extends, version_id, signature_id, select_id, set_complex_value_id, set_value_id, refine_value_id, refine_rule_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ProhibitChanges,
		entity.Abstract,
		entity.NoteTag,
		entity.Extends,
		entity.VersionID,
		entity.SignatureID,
		entity.SelectID,
		entity.SetComplexValueID,
		entity.SetValueID,
		entity.RefineValueID,
		entity.RefineRuleID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *profileTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ProfileType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO profile_type (xsd_id, prohibit_changes, abstract, note_tag, extends, version_id, signature_id, select_id, set_complex_value_id, set_value_id, refine_value_id, refine_rule_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.ProhibitChanges,
			entity.Abstract,
			entity.NoteTag,
			entity.Extends,
			entity.VersionID,
			entity.SignatureID,
			entity.SelectID,
			entity.SetComplexValueID,
			entity.SetValueID,
			entity.RefineValueID,
			entity.RefineRuleID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *profileTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ProfileType, error) {
	query := "SELECT id, xsd_id, prohibit_changes, abstract, note_tag, extends, version_id, signature_id, select_id, set_complex_value_id, set_value_id, refine_value_id, refine_rule_id FROM profile_type WHERE id = ?"

	entity := &parent.ProfileType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.ProhibitChanges,
		&entity.Abstract,
		&entity.NoteTag,
		&entity.Extends,
		&entity.VersionID,
		&entity.SignatureID,
		&entity.SelectID,
		&entity.SetComplexValueID,
		&entity.SetValueID,
		&entity.RefineValueID,
		&entity.RefineRuleID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *profileTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ProfileType, error) {
	query := "SELECT id, xsd_id, prohibit_changes, abstract, note_tag, extends, version_id, signature_id, select_id, set_complex_value_id, set_value_id, refine_value_id, refine_rule_id FROM profile_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileType
	for rows.Next() {
		entity := &parent.ProfileType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.ProhibitChanges,
			&entity.Abstract,
			&entity.NoteTag,
			&entity.Extends,
			&entity.VersionID,
			&entity.SignatureID,
			&entity.SelectID,
			&entity.SetComplexValueID,
			&entity.SetValueID,
			&entity.RefineValueID,
			&entity.RefineRuleID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *profileTypeRepository) Update(ctx context.Context, entity *parent.ProfileType) error {
	query := "UPDATE profile_type SET xsd_id = ?, prohibit_changes = ?, abstract = ?, note_tag = ?, extends = ?, version_id = ?, signature_id = ?, select_id = ?, set_complex_value_id = ?, set_value_id = ?, refine_value_id = ?, refine_rule_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ProhibitChanges,
		entity.Abstract,
		entity.NoteTag,
		entity.Extends,
		entity.VersionID,
		entity.SignatureID,
		entity.SelectID,
		entity.SetComplexValueID,
		entity.SetValueID,
		entity.RefineValueID,
		entity.RefineRuleID,
		entity.ID,
	)
	return err
}

func (r *profileTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM profile_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *profileTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM profile_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *profileTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM profile_type").Scan(&count)
	return count, err
}

func (r *profileTypeRepository) GetByVersionType(ctx context.Context, version_typeID int64) ([]*parent.ProfileType, error) {
	query := "SELECT id, xsd_id, prohibit_changes, abstract, note_tag, extends, version_id, signature_id, select_id, set_complex_value_id, set_value_id, refine_value_id, refine_rule_id FROM profile_type WHERE version_id = ?"

	rows, err := r.db.QueryContext(ctx, query, version_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProfileType
	for rows.Next() {
		entity := &parent.ProfileType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.ProhibitChanges,
			&entity.Abstract,
			&entity.NoteTag,
			&entity.Extends,
			&entity.VersionID,
			&entity.SignatureID,
			&entity.SelectID,
			&entity.SetComplexValueID,
			&entity.SetValueID,
			&entity.RefineValueID,
			&entity.RefineRuleID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ProtocolElementType() parent.ProtocolElementTypeRepository {
	return &protocolElementTypeRepository{db: d.db}
}

type protocolElementTypeRepository struct {
	db *sql.DB
}

func (r *protocolElementTypeRepository) Create(ctx context.Context, entity *parent.ProtocolElementType) (int64, error) {
	query := "INSERT INTO protocol_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *protocolElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ProtocolElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO protocol_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *protocolElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ProtocolElementType, error) {
	query := "SELECT id FROM protocol_element_type WHERE id = ?"

	entity := &parent.ProtocolElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *protocolElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ProtocolElementType, error) {
	query := "SELECT id FROM protocol_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ProtocolElementType
	for rows.Next() {
		entity := &parent.ProtocolElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *protocolElementTypeRepository) Update(ctx context.Context, entity *parent.ProtocolElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *protocolElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM protocol_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *protocolElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM protocol_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *protocolElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM protocol_element_type").Scan(&count)
	return count, err
}

func (d *dal) RSAKeyValueType() parent.RSAKeyValueTypeRepository {
	return &rSAKeyValueTypeRepository{db: d.db}
}

type rSAKeyValueTypeRepository struct {
	db *sql.DB
}

func (r *rSAKeyValueTypeRepository) Create(ctx context.Context, entity *parent.RSAKeyValueType) (int64, error) {
	query := "INSERT INTO \"r_s_a_key_value_type\" (modulus_id, exponent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ModulusID,
		entity.ExponentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *rSAKeyValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RSAKeyValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"r_s_a_key_value_type\" (modulus_id, exponent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ModulusID,
			entity.ExponentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *rSAKeyValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RSAKeyValueType, error) {
	query := "SELECT id, modulus_id, exponent_id FROM \"r_s_a_key_value_type\" WHERE id = ?"

	entity := &parent.RSAKeyValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ModulusID,
		&entity.ExponentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *rSAKeyValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RSAKeyValueType, error) {
	query := "SELECT id, modulus_id, exponent_id FROM \"r_s_a_key_value_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RSAKeyValueType
	for rows.Next() {
		entity := &parent.RSAKeyValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ModulusID,
			&entity.ExponentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *rSAKeyValueTypeRepository) Update(ctx context.Context, entity *parent.RSAKeyValueType) error {
	query := "UPDATE \"r_s_a_key_value_type\" SET modulus_id = ?, exponent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ModulusID,
		entity.ExponentID,
		entity.ID,
	)
	return err
}

func (r *rSAKeyValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"r_s_a_key_value_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *rSAKeyValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"r_s_a_key_value_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *rSAKeyValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"r_s_a_key_value_type\"").Scan(&count)
	return count, err
}

func (d *dal) ReferenceElementType() parent.ReferenceElementTypeRepository {
	return &referenceElementTypeRepository{db: d.db}
}

type referenceElementTypeRepository struct {
	db *sql.DB
}

func (r *referenceElementTypeRepository) Create(ctx context.Context, entity *parent.ReferenceElementType) (int64, error) {
	query := "INSERT INTO reference_element_type (href) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Href,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *referenceElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ReferenceElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO reference_element_type (href) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Href,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *referenceElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ReferenceElementType, error) {
	query := "SELECT id, href FROM reference_element_type WHERE id = ?"

	entity := &parent.ReferenceElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Href,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *referenceElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ReferenceElementType, error) {
	query := "SELECT id, href FROM reference_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ReferenceElementType
	for rows.Next() {
		entity := &parent.ReferenceElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Href,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *referenceElementTypeRepository) Update(ctx context.Context, entity *parent.ReferenceElementType) error {
	query := "UPDATE reference_element_type SET href = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.ID,
	)
	return err
}

func (r *referenceElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM reference_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *referenceElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM reference_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *referenceElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM reference_element_type").Scan(&count)
	return count, err
}

func (d *dal) ReferencesType() parent.ReferencesTypeRepository {
	return &referencesTypeRepository{db: d.db}
}

type referencesTypeRepository struct {
	db *sql.DB
}

func (r *referencesTypeRepository) Create(ctx context.Context, entity *parent.ReferencesType) (int64, error) {
	query := "INSERT INTO \"references_type\" (reference) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Reference,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *referencesTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ReferencesType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"references_type\" (reference) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Reference,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *referencesTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ReferencesType, error) {
	query := "SELECT id, reference FROM \"references_type\" WHERE id = ?"

	entity := &parent.ReferencesType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Reference,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *referencesTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ReferencesType, error) {
	query := "SELECT id, reference FROM \"references_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ReferencesType
	for rows.Next() {
		entity := &parent.ReferencesType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Reference,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *referencesTypeRepository) Update(ctx context.Context, entity *parent.ReferencesType) error {
	query := "UPDATE \"references_type\" SET reference = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Reference,
		entity.ID,
	)
	return err
}

func (r *referencesTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"references_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *referencesTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"references_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *referencesTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"references_type\"").Scan(&count)
	return count, err
}

func (d *dal) RegexCaptureFunctionType() parent.RegexCaptureFunctionTypeRepository {
	return &regexCaptureFunctionTypeRepository{db: d.db}
}

type regexCaptureFunctionTypeRepository struct {
	db *sql.DB
}

func (r *regexCaptureFunctionTypeRepository) Create(ctx context.Context, entity *parent.RegexCaptureFunctionType) (int64, error) {
	query := "INSERT INTO regex_capture_function_type (pattern) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Pattern,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *regexCaptureFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RegexCaptureFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO regex_capture_function_type (pattern) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Pattern,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *regexCaptureFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RegexCaptureFunctionType, error) {
	query := "SELECT id, pattern FROM regex_capture_function_type WHERE id = ?"

	entity := &parent.RegexCaptureFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Pattern,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *regexCaptureFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RegexCaptureFunctionType, error) {
	query := "SELECT id, pattern FROM regex_capture_function_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RegexCaptureFunctionType
	for rows.Next() {
		entity := &parent.RegexCaptureFunctionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Pattern,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *regexCaptureFunctionTypeRepository) Update(ctx context.Context, entity *parent.RegexCaptureFunctionType) error {
	query := "UPDATE regex_capture_function_type SET pattern = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Pattern,
		entity.ID,
	)
	return err
}

func (r *regexCaptureFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM regex_capture_function_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *regexCaptureFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM regex_capture_function_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *regexCaptureFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM regex_capture_function_type").Scan(&count)
	return count, err
}

func (d *dal) RelationshipType() parent.RelationshipTypeRepository {
	return &relationshipTypeRepository{db: d.db}
}

type relationshipTypeRepository struct {
	db *sql.DB
}

func (r *relationshipTypeRepository) Create(ctx context.Context, entity *parent.RelationshipType) (int64, error) {
	query := "INSERT INTO relationship_type (type, scope, subject, ref) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Scope,
		entity.Subject,
		entity.Ref,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *relationshipTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RelationshipType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO relationship_type (type, scope, subject, ref) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Scope,
			entity.Subject,
			entity.Ref,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *relationshipTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RelationshipType, error) {
	query := "SELECT id, type, scope, subject, ref FROM relationship_type WHERE id = ?"

	entity := &parent.RelationshipType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Scope,
		&entity.Subject,
		&entity.Ref,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *relationshipTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RelationshipType, error) {
	query := "SELECT id, type, scope, subject, ref FROM relationship_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RelationshipType
	for rows.Next() {
		entity := &parent.RelationshipType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Scope,
			&entity.Subject,
			&entity.Ref,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *relationshipTypeRepository) Update(ctx context.Context, entity *parent.RelationshipType) error {
	query := "UPDATE relationship_type SET type = ?, scope = ?, subject = ?, ref = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Scope,
		entity.Subject,
		entity.Ref,
		entity.ID,
	)
	return err
}

func (r *relationshipTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM relationship_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *relationshipTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM relationship_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *relationshipTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM relationship_type").Scan(&count)
	return count, err
}

func (d *dal) RelationshipsContainerType() parent.RelationshipsContainerTypeRepository {
	return &relationshipsContainerTypeRepository{db: d.db}
}

type relationshipsContainerTypeRepository struct {
	db *sql.DB
}

func (r *relationshipsContainerTypeRepository) Create(ctx context.Context, entity *parent.RelationshipsContainerType) (int64, error) {
	query := "INSERT INTO relationships_container_type (relationships) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Relationships,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *relationshipsContainerTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RelationshipsContainerType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO relationships_container_type (relationships) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Relationships,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *relationshipsContainerTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RelationshipsContainerType, error) {
	query := "SELECT id, relationships FROM relationships_container_type WHERE id = ?"

	entity := &parent.RelationshipsContainerType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Relationships,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *relationshipsContainerTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RelationshipsContainerType, error) {
	query := "SELECT id, relationships FROM relationships_container_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RelationshipsContainerType
	for rows.Next() {
		entity := &parent.RelationshipsContainerType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Relationships,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *relationshipsContainerTypeRepository) Update(ctx context.Context, entity *parent.RelationshipsContainerType) error {
	query := "UPDATE relationships_container_type SET relationships = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Relationships,
		entity.ID,
	)
	return err
}

func (r *relationshipsContainerTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM relationships_container_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *relationshipsContainerTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM relationships_container_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *relationshipsContainerTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM relationships_container_type").Scan(&count)
	return count, err
}

func (d *dal) RelationshipsElementType() parent.RelationshipsElementTypeRepository {
	return &relationshipsElementTypeRepository{db: d.db}
}

type relationshipsElementTypeRepository struct {
	db *sql.DB
}

func (r *relationshipsElementTypeRepository) Create(ctx context.Context, entity *parent.RelationshipsElementType) (int64, error) {
	query := "INSERT INTO relationships_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *relationshipsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RelationshipsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO relationships_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *relationshipsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RelationshipsElementType, error) {
	query := "SELECT id FROM relationships_element_type WHERE id = ?"

	entity := &parent.RelationshipsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *relationshipsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RelationshipsElementType, error) {
	query := "SELECT id FROM relationships_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RelationshipsElementType
	for rows.Next() {
		entity := &parent.RelationshipsElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *relationshipsElementTypeRepository) Update(ctx context.Context, entity *parent.RelationshipsElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *relationshipsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM relationships_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *relationshipsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM relationships_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *relationshipsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM relationships_element_type").Scan(&count)
	return count, err
}

func (d *dal) RemoteResource() parent.RemoteResourceRepository {
	return &remoteResourceRepository{db: d.db}
}

type remoteResourceRepository struct {
	db *sql.DB
}

func (r *remoteResourceRepository) Create(ctx context.Context, entity *parent.RemoteResource) (int64, error) {
	query := "INSERT INTO remote_resource DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *remoteResourceRepository) CreateBatch(ctx context.Context, entities []*parent.RemoteResource) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO remote_resource DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *remoteResourceRepository) GetByID(ctx context.Context, id int64) (*parent.RemoteResource, error) {
	query := "SELECT id FROM remote_resource WHERE id = ?"

	entity := &parent.RemoteResource{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *remoteResourceRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RemoteResource, error) {
	query := "SELECT id FROM remote_resource LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RemoteResource
	for rows.Next() {
		entity := &parent.RemoteResource{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *remoteResourceRepository) Update(ctx context.Context, entity *parent.RemoteResource) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *remoteResourceRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM remote_resource WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *remoteResourceRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM remote_resource WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *remoteResourceRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM remote_resource").Scan(&count)
	return count, err
}

func (d *dal) RemoteResourceElementType() parent.RemoteResourceElementTypeRepository {
	return &remoteResourceElementTypeRepository{db: d.db}
}

type remoteResourceElementTypeRepository struct {
	db *sql.DB
}

func (r *remoteResourceElementTypeRepository) Create(ctx context.Context, entity *parent.RemoteResourceElementType) (int64, error) {
	query := "INSERT INTO remote_resource_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *remoteResourceElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RemoteResourceElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO remote_resource_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *remoteResourceElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RemoteResourceElementType, error) {
	query := "SELECT id FROM remote_resource_element_type WHERE id = ?"

	entity := &parent.RemoteResourceElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *remoteResourceElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RemoteResourceElementType, error) {
	query := "SELECT id FROM remote_resource_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RemoteResourceElementType
	for rows.Next() {
		entity := &parent.RemoteResourceElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *remoteResourceElementTypeRepository) Update(ctx context.Context, entity *parent.RemoteResourceElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *remoteResourceElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM remote_resource_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *remoteResourceElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM remote_resource_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *remoteResourceElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM remote_resource_element_type").Scan(&count)
	return count, err
}

func (d *dal) ReportRequestType() parent.ReportRequestTypeRepository {
	return &reportRequestTypeRepository{db: d.db}
}

type reportRequestTypeRepository struct {
	db *sql.DB
}

func (r *reportRequestTypeRepository) Create(ctx context.Context, entity *parent.ReportRequestType) (int64, error) {
	query := "INSERT INTO report_request_type (xsd_id, content) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Content,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *reportRequestTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ReportRequestType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO report_request_type (xsd_id, content) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Content,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *reportRequestTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ReportRequestType, error) {
	query := "SELECT id, xsd_id, content FROM report_request_type WHERE id = ?"

	entity := &parent.ReportRequestType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Content,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *reportRequestTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ReportRequestType, error) {
	query := "SELECT id, xsd_id, content FROM report_request_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ReportRequestType
	for rows.Next() {
		entity := &parent.ReportRequestType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Content,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *reportRequestTypeRepository) Update(ctx context.Context, entity *parent.ReportRequestType) error {
	query := "UPDATE report_request_type SET xsd_id = ?, content = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Content,
		entity.ID,
	)
	return err
}

func (r *reportRequestTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM report_request_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *reportRequestTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM report_request_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *reportRequestTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM report_request_type").Scan(&count)
	return count, err
}

func (d *dal) ReportRequestsElementType() parent.ReportRequestsElementTypeRepository {
	return &reportRequestsElementTypeRepository{db: d.db}
}

type reportRequestsElementTypeRepository struct {
	db *sql.DB
}

func (r *reportRequestsElementTypeRepository) Create(ctx context.Context, entity *parent.ReportRequestsElementType) (int64, error) {
	query := "INSERT INTO report_requests_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *reportRequestsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ReportRequestsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO report_requests_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *reportRequestsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ReportRequestsElementType, error) {
	query := "SELECT id FROM report_requests_element_type WHERE id = ?"

	entity := &parent.ReportRequestsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *reportRequestsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ReportRequestsElementType, error) {
	query := "SELECT id FROM report_requests_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ReportRequestsElementType
	for rows.Next() {
		entity := &parent.ReportRequestsElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *reportRequestsElementTypeRepository) Update(ctx context.Context, entity *parent.ReportRequestsElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *reportRequestsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM report_requests_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *reportRequestsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM report_requests_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *reportRequestsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM report_requests_element_type").Scan(&count)
	return count, err
}

func (d *dal) ReportType() parent.ReportTypeRepository {
	return &reportTypeRepository{db: d.db}
}

type reportTypeRepository struct {
	db *sql.DB
}

func (r *reportTypeRepository) Create(ctx context.Context, entity *parent.ReportType) (int64, error) {
	query := "INSERT INTO report_type (xsd_id, content) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Content,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *reportTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ReportType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO report_type (xsd_id, content) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Content,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *reportTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ReportType, error) {
	query := "SELECT id, xsd_id, content FROM report_type WHERE id = ?"

	entity := &parent.ReportType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Content,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *reportTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ReportType, error) {
	query := "SELECT id, xsd_id, content FROM report_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ReportType
	for rows.Next() {
		entity := &parent.ReportType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Content,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *reportTypeRepository) Update(ctx context.Context, entity *parent.ReportType) error {
	query := "UPDATE report_type SET xsd_id = ?, content = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Content,
		entity.ID,
	)
	return err
}

func (r *reportTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM report_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *reportTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM report_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *reportTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM report_type").Scan(&count)
	return count, err
}

func (d *dal) ReportsElementType() parent.ReportsElementTypeRepository {
	return &reportsElementTypeRepository{db: d.db}
}

type reportsElementTypeRepository struct {
	db *sql.DB
}

func (r *reportsElementTypeRepository) Create(ctx context.Context, entity *parent.ReportsElementType) (int64, error) {
	query := "INSERT INTO reports_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *reportsElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ReportsElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO reports_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *reportsElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ReportsElementType, error) {
	query := "SELECT id FROM reports_element_type WHERE id = ?"

	entity := &parent.ReportsElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *reportsElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ReportsElementType, error) {
	query := "SELECT id FROM reports_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ReportsElementType
	for rows.Next() {
		entity := &parent.ReportsElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *reportsElementTypeRepository) Update(ctx context.Context, entity *parent.ReportsElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *reportsElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM reports_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *reportsElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM reports_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *reportsElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM reports_element_type").Scan(&count)
	return count, err
}

func (d *dal) ResourceType() parent.ResourceTypeRepository {
	return &resourceTypeRepository{db: d.db}
}

type resourceTypeRepository struct {
	db *sql.DB
}

func (r *resourceTypeRepository) Create(ctx context.Context, entity *parent.ResourceType) (int64, error) {
	query := "INSERT INTO resource_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *resourceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ResourceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO resource_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *resourceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ResourceType, error) {
	query := "SELECT id FROM resource_type WHERE id = ?"

	entity := &parent.ResourceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *resourceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ResourceType, error) {
	query := "SELECT id FROM resource_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ResourceType
	for rows.Next() {
		entity := &parent.ResourceType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *resourceTypeRepository) Update(ctx context.Context, entity *parent.ResourceType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *resourceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM resource_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *resourceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM resource_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *resourceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM resource_type").Scan(&count)
	return count, err
}

func (d *dal) RestrictionType() parent.RestrictionTypeRepository {
	return &restrictionTypeRepository{db: d.db}
}

type restrictionTypeRepository struct {
	db *sql.DB
}

func (r *restrictionTypeRepository) Create(ctx context.Context, entity *parent.RestrictionType) (int64, error) {
	query := "INSERT INTO restriction_type (operation) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Operation,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *restrictionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RestrictionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO restriction_type (operation) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Operation,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *restrictionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RestrictionType, error) {
	query := "SELECT id, operation FROM restriction_type WHERE id = ?"

	entity := &parent.RestrictionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Operation,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *restrictionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RestrictionType, error) {
	query := "SELECT id, operation FROM restriction_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RestrictionType
	for rows.Next() {
		entity := &parent.RestrictionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Operation,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *restrictionTypeRepository) Update(ctx context.Context, entity *parent.RestrictionType) error {
	query := "UPDATE restriction_type SET operation = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Operation,
		entity.ID,
	)
	return err
}

func (r *restrictionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM restriction_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *restrictionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM restriction_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *restrictionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM restriction_type").Scan(&count)
	return count, err
}

func (d *dal) RetrievalMethodType() parent.RetrievalMethodTypeRepository {
	return &retrievalMethodTypeRepository{db: d.db}
}

type retrievalMethodTypeRepository struct {
	db *sql.DB
}

func (r *retrievalMethodTypeRepository) Create(ctx context.Context, entity *parent.RetrievalMethodType) (int64, error) {
	query := "INSERT INTO retrieval_method_type (u_r_i, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.URI,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *retrievalMethodTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RetrievalMethodType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO retrieval_method_type (u_r_i, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.URI,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *retrievalMethodTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RetrievalMethodType, error) {
	query := "SELECT id, u_r_i, type FROM retrieval_method_type WHERE id = ?"

	entity := &parent.RetrievalMethodType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.URI,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *retrievalMethodTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RetrievalMethodType, error) {
	query := "SELECT id, u_r_i, type FROM retrieval_method_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RetrievalMethodType
	for rows.Next() {
		entity := &parent.RetrievalMethodType{}
		err := rows.Scan(
			&entity.ID,
			&entity.URI,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *retrievalMethodTypeRepository) Update(ctx context.Context, entity *parent.RetrievalMethodType) error {
	query := "UPDATE retrieval_method_type SET u_r_i = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.URI,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *retrievalMethodTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM retrieval_method_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *retrievalMethodTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM retrieval_method_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *retrievalMethodTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM retrieval_method_type").Scan(&count)
	return count, err
}

func (d *dal) RuleResultType() parent.RuleResultTypeRepository {
	return &ruleResultTypeRepository{db: d.db}
}

type ruleResultTypeRepository struct {
	db *sql.DB
}

func (r *ruleResultTypeRepository) Create(ctx context.Context, entity *parent.RuleResultType) (int64, error) {
	query := "INSERT INTO rule_result_type (idref, role, severity, time, version, weight, result_id, complex_check_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.Role,
		entity.Severity,
		entity.Time,
		entity.Version,
		entity.Weight,
		entity.ResultID,
		entity.ComplexCheckID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ruleResultTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RuleResultType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO rule_result_type (idref, role, severity, time, version, weight, result_id, complex_check_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Idref,
			entity.Role,
			entity.Severity,
			entity.Time,
			entity.Version,
			entity.Weight,
			entity.ResultID,
			entity.ComplexCheckID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ruleResultTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RuleResultType, error) {
	query := "SELECT id, idref, role, severity, time, version, weight, result_id, complex_check_id FROM rule_result_type WHERE id = ?"

	entity := &parent.RuleResultType{}
	var timeTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Idref,
		&entity.Role,
		&entity.Severity,
		&timeTime,
		&entity.Version,
		&entity.Weight,
		&entity.ResultID,
		&entity.ComplexCheckID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Time = timeTime.ToTimePtr()

	return entity, nil
}

func (r *ruleResultTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RuleResultType, error) {
	query := "SELECT id, idref, role, severity, time, version, weight, result_id, complex_check_id FROM rule_result_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RuleResultType
	for rows.Next() {
		entity := &parent.RuleResultType{}
		var timeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.Idref,
			&entity.Role,
			&entity.Severity,
			&timeTime,
			&entity.Version,
			&entity.Weight,
			&entity.ResultID,
			&entity.ComplexCheckID,
		)
		if err != nil {
			return nil, err
		}
		entity.Time = timeTime.ToTimePtr()
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ruleResultTypeRepository) Update(ctx context.Context, entity *parent.RuleResultType) error {
	query := "UPDATE rule_result_type SET idref = ?, role = ?, severity = ?, time = ?, version = ?, weight = ?, result_id = ?, complex_check_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Idref,
		entity.Role,
		entity.Severity,
		entity.Time,
		entity.Version,
		entity.Weight,
		entity.ResultID,
		entity.ComplexCheckID,
		entity.ID,
	)
	return err
}

func (r *ruleResultTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM rule_result_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ruleResultTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM rule_result_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ruleResultTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM rule_result_type").Scan(&count)
	return count, err
}

func (d *dal) RuleType() parent.RuleTypeRepository {
	return &ruleTypeRepository{db: d.db}
}

type ruleTypeRepository struct {
	db *sql.DB
}

func (r *ruleTypeRepository) Create(ctx context.Context, entity *parent.RuleType) (int64, error) {
	query := "INSERT INTO rule_type (xsd_id, role, severity, multiple, impact_metric, signature_id, complex_check_id, parent_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Role,
		entity.Severity,
		entity.Multiple,
		entity.ImpactMetric,
		entity.SignatureID,
		entity.ComplexCheckID,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *ruleTypeRepository) CreateBatch(ctx context.Context, entities []*parent.RuleType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO rule_type (xsd_id, role, severity, multiple, impact_metric, signature_id, complex_check_id, parent_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Role,
			entity.Severity,
			entity.Multiple,
			entity.ImpactMetric,
			entity.SignatureID,
			entity.ComplexCheckID,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *ruleTypeRepository) GetByID(ctx context.Context, id int64) (*parent.RuleType, error) {
	query := "SELECT id, xsd_id, role, severity, multiple, impact_metric, signature_id, complex_check_id, parent_id FROM rule_type WHERE id = ?"

	entity := &parent.RuleType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Role,
		&entity.Severity,
		&entity.Multiple,
		&entity.ImpactMetric,
		&entity.SignatureID,
		&entity.ComplexCheckID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *ruleTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.RuleType, error) {
	query := "SELECT id, xsd_id, role, severity, multiple, impact_metric, signature_id, complex_check_id, parent_id FROM rule_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RuleType
	for rows.Next() {
		entity := &parent.RuleType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Role,
			&entity.Severity,
			&entity.Multiple,
			&entity.ImpactMetric,
			&entity.SignatureID,
			&entity.ComplexCheckID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *ruleTypeRepository) Update(ctx context.Context, entity *parent.RuleType) error {
	query := "UPDATE rule_type SET xsd_id = ?, role = ?, severity = ?, multiple = ?, impact_metric = ?, signature_id = ?, complex_check_id = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Role,
		entity.Severity,
		entity.Multiple,
		entity.ImpactMetric,
		entity.SignatureID,
		entity.ComplexCheckID,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *ruleTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM rule_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *ruleTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM rule_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *ruleTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM rule_type").Scan(&count)
	return count, err
}

func (r *ruleTypeRepository) GetBySelectableItemType(ctx context.Context, selectable_item_typeID int64) ([]*parent.RuleType, error) {
	query := "SELECT id, xsd_id, role, severity, multiple, impact_metric, signature_id, complex_check_id, parent_id FROM rule_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, selectable_item_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.RuleType
	for rows.Next() {
		entity := &parent.RuleType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Role,
			&entity.Severity,
			&entity.Multiple,
			&entity.ImpactMetric,
			&entity.SignatureID,
			&entity.ComplexCheckID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) SPKIDataType() parent.SPKIDataTypeRepository {
	return &sPKIDataTypeRepository{db: d.db}
}

type sPKIDataTypeRepository struct {
	db *sql.DB
}

func (r *sPKIDataTypeRepository) Create(ctx context.Context, entity *parent.SPKIDataType) (int64, error) {
	query := "INSERT INTO s_p_k_i_data_type (s_p_k_i_sexp) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.SPKISexp,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *sPKIDataTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SPKIDataType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO s_p_k_i_data_type (s_p_k_i_sexp) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.SPKISexp,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *sPKIDataTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SPKIDataType, error) {
	query := "SELECT id, s_p_k_i_sexp FROM s_p_k_i_data_type WHERE id = ?"

	entity := &parent.SPKIDataType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.SPKISexp,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *sPKIDataTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SPKIDataType, error) {
	query := "SELECT id, s_p_k_i_sexp FROM s_p_k_i_data_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SPKIDataType
	for rows.Next() {
		entity := &parent.SPKIDataType{}
		err := rows.Scan(
			&entity.ID,
			&entity.SPKISexp,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *sPKIDataTypeRepository) Update(ctx context.Context, entity *parent.SPKIDataType) error {
	query := "UPDATE s_p_k_i_data_type SET s_p_k_i_sexp = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.SPKISexp,
		entity.ID,
	)
	return err
}

func (r *sPKIDataTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM s_p_k_i_data_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *sPKIDataTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM s_p_k_i_data_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *sPKIDataTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM s_p_k_i_data_type").Scan(&count)
	return count, err
}

func (d *dal) SchemaVersionType() parent.SchemaVersionTypeRepository {
	return &schemaVersionTypeRepository{db: d.db}
}

type schemaVersionTypeRepository struct {
	db *sql.DB
}

func (r *schemaVersionTypeRepository) Create(ctx context.Context, entity *parent.SchemaVersionType) (int64, error) {
	query := "INSERT INTO schema_version_type (platform, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Platform,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *schemaVersionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SchemaVersionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO schema_version_type (platform, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Platform,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *schemaVersionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SchemaVersionType, error) {
	query := "SELECT id, platform, parent_id FROM schema_version_type WHERE id = ?"

	entity := &parent.SchemaVersionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Platform,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *schemaVersionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SchemaVersionType, error) {
	query := "SELECT id, platform, parent_id FROM schema_version_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SchemaVersionType
	for rows.Next() {
		entity := &parent.SchemaVersionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Platform,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *schemaVersionTypeRepository) Update(ctx context.Context, entity *parent.SchemaVersionType) error {
	query := "UPDATE schema_version_type SET platform = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Platform,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *schemaVersionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM schema_version_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *schemaVersionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM schema_version_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *schemaVersionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM schema_version_type").Scan(&count)
	return count, err
}

func (d *dal) ScoreType() parent.ScoreTypeRepository {
	return &scoreTypeRepository{db: d.db}
}

type scoreTypeRepository struct {
	db *sql.DB
}

func (r *scoreTypeRepository) Create(ctx context.Context, entity *parent.ScoreType) (int64, error) {
	query := "INSERT INTO score_type (system, maximum) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.Maximum,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *scoreTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ScoreType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO score_type (system, maximum) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.System,
			entity.Maximum,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *scoreTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ScoreType, error) {
	query := "SELECT id, system, maximum FROM score_type WHERE id = ?"

	entity := &parent.ScoreType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.System,
		&entity.Maximum,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *scoreTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ScoreType, error) {
	query := "SELECT id, system, maximum FROM score_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ScoreType
	for rows.Next() {
		entity := &parent.ScoreType{}
		err := rows.Scan(
			&entity.ID,
			&entity.System,
			&entity.Maximum,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *scoreTypeRepository) Update(ctx context.Context, entity *parent.ScoreType) error {
	query := "UPDATE score_type SET system = ?, maximum = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.Maximum,
		entity.ID,
	)
	return err
}

func (r *scoreTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM score_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *scoreTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM score_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *scoreTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM score_type").Scan(&count)
	return count, err
}

func (d *dal) SelChoicesType() parent.SelChoicesTypeRepository {
	return &selChoicesTypeRepository{db: d.db}
}

type selChoicesTypeRepository struct {
	db *sql.DB
}

func (r *selChoicesTypeRepository) Create(ctx context.Context, entity *parent.SelChoicesType) (int64, error) {
	query := "INSERT INTO sel_choices_type (must_match, selector, choice, complex_choice_id) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.MustMatch,
		entity.Selector,
		entity.Choice,
		entity.ComplexChoiceID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *selChoicesTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SelChoicesType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sel_choices_type (must_match, selector, choice, complex_choice_id) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.MustMatch,
			entity.Selector,
			entity.Choice,
			entity.ComplexChoiceID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *selChoicesTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SelChoicesType, error) {
	query := "SELECT id, must_match, selector, choice, complex_choice_id FROM sel_choices_type WHERE id = ?"

	entity := &parent.SelChoicesType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.MustMatch,
		&entity.Selector,
		&entity.Choice,
		&entity.ComplexChoiceID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *selChoicesTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SelChoicesType, error) {
	query := "SELECT id, must_match, selector, choice, complex_choice_id FROM sel_choices_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SelChoicesType
	for rows.Next() {
		entity := &parent.SelChoicesType{}
		err := rows.Scan(
			&entity.ID,
			&entity.MustMatch,
			&entity.Selector,
			&entity.Choice,
			&entity.ComplexChoiceID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *selChoicesTypeRepository) Update(ctx context.Context, entity *parent.SelChoicesType) error {
	query := "UPDATE sel_choices_type SET must_match = ?, selector = ?, choice = ?, complex_choice_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.MustMatch,
		entity.Selector,
		entity.Choice,
		entity.ComplexChoiceID,
		entity.ID,
	)
	return err
}

func (r *selChoicesTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sel_choices_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *selChoicesTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sel_choices_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *selChoicesTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sel_choices_type").Scan(&count)
	return count, err
}

func (r *selChoicesTypeRepository) GetByComplexValueType(ctx context.Context, complex_value_typeID int64) ([]*parent.SelChoicesType, error) {
	query := "SELECT id, must_match, selector, choice, complex_choice_id FROM sel_choices_type WHERE complex_choice_id = ?"

	rows, err := r.db.QueryContext(ctx, query, complex_value_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SelChoicesType
	for rows.Next() {
		entity := &parent.SelChoicesType{}
		err := rows.Scan(
			&entity.ID,
			&entity.MustMatch,
			&entity.Selector,
			&entity.Choice,
			&entity.ComplexChoiceID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) SelComplexValueType() parent.SelComplexValueTypeRepository {
	return &selComplexValueTypeRepository{db: d.db}
}

type selComplexValueTypeRepository struct {
	db *sql.DB
}

func (r *selComplexValueTypeRepository) Create(ctx context.Context, entity *parent.SelComplexValueType) (int64, error) {
	query := "INSERT INTO sel_complex_value_type (selector, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Selector,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *selComplexValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SelComplexValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sel_complex_value_type (selector, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Selector,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *selComplexValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SelComplexValueType, error) {
	query := "SELECT id, selector, parent_id FROM sel_complex_value_type WHERE id = ?"

	entity := &parent.SelComplexValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Selector,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *selComplexValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SelComplexValueType, error) {
	query := "SELECT id, selector, parent_id FROM sel_complex_value_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SelComplexValueType
	for rows.Next() {
		entity := &parent.SelComplexValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Selector,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *selComplexValueTypeRepository) Update(ctx context.Context, entity *parent.SelComplexValueType) error {
	query := "UPDATE sel_complex_value_type SET selector = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Selector,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *selComplexValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sel_complex_value_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *selComplexValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sel_complex_value_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *selComplexValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sel_complex_value_type").Scan(&count)
	return count, err
}

func (r *selComplexValueTypeRepository) GetByComplexValueType(ctx context.Context, complex_value_typeID int64) ([]*parent.SelComplexValueType, error) {
	query := "SELECT id, selector, parent_id FROM sel_complex_value_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, complex_value_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SelComplexValueType
	for rows.Next() {
		entity := &parent.SelComplexValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Selector,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) SelNumType() parent.SelNumTypeRepository {
	return &selNumTypeRepository{db: d.db}
}

type selNumTypeRepository struct {
	db *sql.DB
}

func (r *selNumTypeRepository) Create(ctx context.Context, entity *parent.SelNumType) (int64, error) {
	query := "INSERT INTO sel_num_type (selector) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Selector,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *selNumTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SelNumType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sel_num_type (selector) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Selector,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *selNumTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SelNumType, error) {
	query := "SELECT id, selector FROM sel_num_type WHERE id = ?"

	entity := &parent.SelNumType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Selector,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *selNumTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SelNumType, error) {
	query := "SELECT id, selector FROM sel_num_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SelNumType
	for rows.Next() {
		entity := &parent.SelNumType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Selector,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *selNumTypeRepository) Update(ctx context.Context, entity *parent.SelNumType) error {
	query := "UPDATE sel_num_type SET selector = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Selector,
		entity.ID,
	)
	return err
}

func (r *selNumTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sel_num_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *selNumTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sel_num_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *selNumTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sel_num_type").Scan(&count)
	return count, err
}

func (d *dal) SelStringType() parent.SelStringTypeRepository {
	return &selStringTypeRepository{db: d.db}
}

type selStringTypeRepository struct {
	db *sql.DB
}

func (r *selStringTypeRepository) Create(ctx context.Context, entity *parent.SelStringType) (int64, error) {
	query := "INSERT INTO sel_string_type (selector) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Selector,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *selStringTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SelStringType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sel_string_type (selector) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Selector,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *selStringTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SelStringType, error) {
	query := "SELECT id, selector FROM sel_string_type WHERE id = ?"

	entity := &parent.SelStringType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Selector,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *selStringTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SelStringType, error) {
	query := "SELECT id, selector FROM sel_string_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SelStringType
	for rows.Next() {
		entity := &parent.SelStringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Selector,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *selStringTypeRepository) Update(ctx context.Context, entity *parent.SelStringType) error {
	query := "UPDATE sel_string_type SET selector = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Selector,
		entity.ID,
	)
	return err
}

func (r *selStringTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sel_string_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *selStringTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sel_string_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *selStringTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sel_string_type").Scan(&count)
	return count, err
}

func (d *dal) ServiceType() parent.ServiceTypeRepository {
	return &serviceTypeRepository{db: d.db}
}

type serviceTypeRepository struct {
	db *sql.DB
}

func (r *serviceTypeRepository) Create(ctx context.Context, entity *parent.ServiceType) (int64, error) {
	query := "INSERT INTO service_type (host, port, port_range, protocol, parent_id) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Host,
		entity.Port,
		entity.PortRange,
		entity.Protocol,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *serviceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ServiceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO service_type (host, port, port_range, protocol, parent_id) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Host,
			entity.Port,
			entity.PortRange,
			entity.Protocol,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *serviceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ServiceType, error) {
	query := "SELECT id, host, port, port_range, protocol, parent_id FROM service_type WHERE id = ?"

	entity := &parent.ServiceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Host,
		&entity.Port,
		&entity.PortRange,
		&entity.Protocol,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *serviceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ServiceType, error) {
	query := "SELECT id, host, port, port_range, protocol, parent_id FROM service_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ServiceType
	for rows.Next() {
		entity := &parent.ServiceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Host,
			&entity.Port,
			&entity.PortRange,
			&entity.Protocol,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *serviceTypeRepository) Update(ctx context.Context, entity *parent.ServiceType) error {
	query := "UPDATE service_type SET host = ?, port = ?, port_range = ?, protocol = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Host,
		entity.Port,
		entity.PortRange,
		entity.Protocol,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *serviceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM service_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *serviceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM service_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *serviceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM service_type").Scan(&count)
	return count, err
}

func (r *serviceTypeRepository) GetByItAssetType(ctx context.Context, it_asset_typeID int64) ([]*parent.ServiceType, error) {
	query := "SELECT id, host, port, port_range, protocol, parent_id FROM service_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, it_asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ServiceType
	for rows.Next() {
		entity := &parent.ServiceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Host,
			&entity.Port,
			&entity.PortRange,
			&entity.Protocol,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) Set() parent.SetRepository {
	return &setRepository{db: d.db}
}

type setRepository struct {
	db *sql.DB
}

func (r *setRepository) Create(ctx context.Context, entity *parent.Set) (int64, error) {
	query := "INSERT INTO \"set\" (set_operator) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Set_operator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *setRepository) CreateBatch(ctx context.Context, entities []*parent.Set) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"set\" (set_operator) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Set_operator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *setRepository) GetByID(ctx context.Context, id int64) (*parent.Set, error) {
	query := "SELECT id, set_operator FROM \"set\" WHERE id = ?"

	entity := &parent.Set{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Set_operator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *setRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Set, error) {
	query := "SELECT id, set_operator FROM \"set\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Set
	for rows.Next() {
		entity := &parent.Set{}
		err := rows.Scan(
			&entity.ID,
			&entity.Set_operator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *setRepository) Update(ctx context.Context, entity *parent.Set) error {
	query := "UPDATE \"set\" SET set_operator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Set_operator,
		entity.ID,
	)
	return err
}

func (r *setRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"set\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *setRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"set\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *setRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"set\"").Scan(&count)
	return count, err
}

func (d *dal) SetElementType() parent.SetElementTypeRepository {
	return &setElementTypeRepository{db: d.db}
}

type setElementTypeRepository struct {
	db *sql.DB
}

func (r *setElementTypeRepository) Create(ctx context.Context, entity *parent.SetElementType) (int64, error) {
	query := "INSERT INTO \"set_element_type\" (set_operator) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Set_operator,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *setElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SetElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"set_element_type\" (set_operator) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Set_operator,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *setElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SetElementType, error) {
	query := "SELECT id, set_operator FROM \"set_element_type\" WHERE id = ?"

	entity := &parent.SetElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Set_operator,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *setElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SetElementType, error) {
	query := "SELECT id, set_operator FROM \"set_element_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SetElementType
	for rows.Next() {
		entity := &parent.SetElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Set_operator,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *setElementTypeRepository) Update(ctx context.Context, entity *parent.SetElementType) error {
	query := "UPDATE \"set_element_type\" SET set_operator = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Set_operator,
		entity.ID,
	)
	return err
}

func (r *setElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"set_element_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *setElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"set_element_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *setElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"set_element_type\"").Scan(&count)
	return count, err
}

func (d *dal) SignatureMethodType() parent.SignatureMethodTypeRepository {
	return &signatureMethodTypeRepository{db: d.db}
}

type signatureMethodTypeRepository struct {
	db *sql.DB
}

func (r *signatureMethodTypeRepository) Create(ctx context.Context, entity *parent.SignatureMethodType) (int64, error) {
	query := "INSERT INTO signature_method_type (algorithm, h_m_a_c_output_length_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Algorithm,
		entity.HMACOutputLengthID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *signatureMethodTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SignatureMethodType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO signature_method_type (algorithm, h_m_a_c_output_length_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Algorithm,
			entity.HMACOutputLengthID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *signatureMethodTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SignatureMethodType, error) {
	query := "SELECT id, algorithm, h_m_a_c_output_length_id FROM signature_method_type WHERE id = ?"

	entity := &parent.SignatureMethodType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Algorithm,
		&entity.HMACOutputLengthID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *signatureMethodTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SignatureMethodType, error) {
	query := "SELECT id, algorithm, h_m_a_c_output_length_id FROM signature_method_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SignatureMethodType
	for rows.Next() {
		entity := &parent.SignatureMethodType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Algorithm,
			&entity.HMACOutputLengthID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *signatureMethodTypeRepository) Update(ctx context.Context, entity *parent.SignatureMethodType) error {
	query := "UPDATE signature_method_type SET algorithm = ?, h_m_a_c_output_length_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Algorithm,
		entity.HMACOutputLengthID,
		entity.ID,
	)
	return err
}

func (r *signatureMethodTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM signature_method_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *signatureMethodTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM signature_method_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *signatureMethodTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM signature_method_type").Scan(&count)
	return count, err
}

func (d *dal) SignaturePropertiesType() parent.SignaturePropertiesTypeRepository {
	return &signaturePropertiesTypeRepository{db: d.db}
}

type signaturePropertiesTypeRepository struct {
	db *sql.DB
}

func (r *signaturePropertiesTypeRepository) Create(ctx context.Context, entity *parent.SignaturePropertiesType) (int64, error) {
	query := "INSERT INTO signature_properties_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *signaturePropertiesTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SignaturePropertiesType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO signature_properties_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *signaturePropertiesTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SignaturePropertiesType, error) {
	query := "SELECT id, xsd_id FROM signature_properties_type WHERE id = ?"

	entity := &parent.SignaturePropertiesType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *signaturePropertiesTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SignaturePropertiesType, error) {
	query := "SELECT id, xsd_id FROM signature_properties_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SignaturePropertiesType
	for rows.Next() {
		entity := &parent.SignaturePropertiesType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *signaturePropertiesTypeRepository) Update(ctx context.Context, entity *parent.SignaturePropertiesType) error {
	query := "UPDATE signature_properties_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *signaturePropertiesTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM signature_properties_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *signaturePropertiesTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM signature_properties_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *signaturePropertiesTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM signature_properties_type").Scan(&count)
	return count, err
}

func (d *dal) SignaturePropertyType() parent.SignaturePropertyTypeRepository {
	return &signaturePropertyTypeRepository{db: d.db}
}

type signaturePropertyTypeRepository struct {
	db *sql.DB
}

func (r *signaturePropertyTypeRepository) Create(ctx context.Context, entity *parent.SignaturePropertyType) (int64, error) {
	query := "INSERT INTO signature_property_type (target, xsd_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Target,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *signaturePropertyTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SignaturePropertyType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO signature_property_type (target, xsd_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Target,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *signaturePropertyTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SignaturePropertyType, error) {
	query := "SELECT id, target, xsd_id FROM signature_property_type WHERE id = ?"

	entity := &parent.SignaturePropertyType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Target,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *signaturePropertyTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SignaturePropertyType, error) {
	query := "SELECT id, target, xsd_id FROM signature_property_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SignaturePropertyType
	for rows.Next() {
		entity := &parent.SignaturePropertyType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Target,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *signaturePropertyTypeRepository) Update(ctx context.Context, entity *parent.SignaturePropertyType) error {
	query := "UPDATE signature_property_type SET target = ?, xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Target,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *signaturePropertyTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM signature_property_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *signaturePropertyTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM signature_property_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *signaturePropertyTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM signature_property_type").Scan(&count)
	return count, err
}

func (d *dal) SignatureValueType() parent.SignatureValueTypeRepository {
	return &signatureValueTypeRepository{db: d.db}
}

type signatureValueTypeRepository struct {
	db *sql.DB
}

func (r *signatureValueTypeRepository) Create(ctx context.Context, entity *parent.SignatureValueType) (int64, error) {
	query := "INSERT INTO signature_value_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *signatureValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SignatureValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO signature_value_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *signatureValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SignatureValueType, error) {
	query := "SELECT id, xsd_id FROM signature_value_type WHERE id = ?"

	entity := &parent.SignatureValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *signatureValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SignatureValueType, error) {
	query := "SELECT id, xsd_id FROM signature_value_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SignatureValueType
	for rows.Next() {
		entity := &parent.SignatureValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *signatureValueTypeRepository) Update(ctx context.Context, entity *parent.SignatureValueType) error {
	query := "UPDATE signature_value_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *signatureValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM signature_value_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *signatureValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM signature_value_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *signatureValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM signature_value_type").Scan(&count)
	return count, err
}

func (d *dal) SignedInfoType() parent.SignedInfoTypeRepository {
	return &signedInfoTypeRepository{db: d.db}
}

type signedInfoTypeRepository struct {
	db *sql.DB
}

func (r *signedInfoTypeRepository) Create(ctx context.Context, entity *parent.SignedInfoType) (int64, error) {
	query := "INSERT INTO signed_info_type (xsd_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *signedInfoTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SignedInfoType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO signed_info_type (xsd_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *signedInfoTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SignedInfoType, error) {
	query := "SELECT id, xsd_id FROM signed_info_type WHERE id = ?"

	entity := &parent.SignedInfoType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *signedInfoTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SignedInfoType, error) {
	query := "SELECT id, xsd_id FROM signed_info_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SignedInfoType
	for rows.Next() {
		entity := &parent.SignedInfoType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *signedInfoTypeRepository) Update(ctx context.Context, entity *parent.SignedInfoType) error {
	query := "UPDATE signed_info_type SET xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *signedInfoTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM signed_info_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *signedInfoTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM signed_info_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *signedInfoTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM signed_info_type").Scan(&count)
	return count, err
}

func (d *dal) Simple() parent.SimpleRepository {
	return &simpleRepository{db: d.db}
}

type simpleRepository struct {
	db *sql.DB
}

func (r *simpleRepository) Create(ctx context.Context, entity *parent.Simple) (int64, error) {
	query := "INSERT INTO simple DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *simpleRepository) CreateBatch(ctx context.Context, entities []*parent.Simple) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO simple DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *simpleRepository) GetByID(ctx context.Context, id int64) (*parent.Simple, error) {
	query := "SELECT id FROM simple WHERE id = ?"

	entity := &parent.Simple{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *simpleRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Simple, error) {
	query := "SELECT id FROM simple LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Simple
	for rows.Next() {
		entity := &parent.Simple{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *simpleRepository) Update(ctx context.Context, entity *parent.Simple) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *simpleRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM simple WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *simpleRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM simple WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *simpleRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM simple").Scan(&count)
	return count, err
}

func (d *dal) SoftwareType() parent.SoftwareTypeRepository {
	return &softwareTypeRepository{db: d.db}
}

type softwareTypeRepository struct {
	db *sql.DB
}

func (r *softwareTypeRepository) Create(ctx context.Context, entity *parent.SoftwareType) (int64, error) {
	query := "INSERT INTO software_type (installation_id, license, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.InstallationId,
		entity.License,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *softwareTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SoftwareType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO software_type (installation_id, license, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.InstallationId,
			entity.License,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *softwareTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SoftwareType, error) {
	query := "SELECT id, installation_id, license, parent_id FROM software_type WHERE id = ?"

	entity := &parent.SoftwareType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.InstallationId,
		&entity.License,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *softwareTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SoftwareType, error) {
	query := "SELECT id, installation_id, license, parent_id FROM software_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SoftwareType
	for rows.Next() {
		entity := &parent.SoftwareType{}
		err := rows.Scan(
			&entity.ID,
			&entity.InstallationId,
			&entity.License,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *softwareTypeRepository) Update(ctx context.Context, entity *parent.SoftwareType) error {
	query := "UPDATE software_type SET installation_id = ?, license = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.InstallationId,
		entity.License,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *softwareTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM software_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *softwareTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM software_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *softwareTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM software_type").Scan(&count)
	return count, err
}

func (r *softwareTypeRepository) GetByItAssetType(ctx context.Context, it_asset_typeID int64) ([]*parent.SoftwareType, error) {
	query := "SELECT id, installation_id, license, parent_id FROM software_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, it_asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SoftwareType
	for rows.Next() {
		entity := &parent.SoftwareType{}
		err := rows.Scan(
			&entity.ID,
			&entity.InstallationId,
			&entity.License,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) SortingCodeElementType() parent.SortingCodeElementTypeRepository {
	return &sortingCodeElementTypeRepository{db: d.db}
}

type sortingCodeElementTypeRepository struct {
	db *sql.DB
}

func (r *sortingCodeElementTypeRepository) Create(ctx context.Context, entity *parent.SortingCodeElementType) (int64, error) {
	query := "INSERT INTO sorting_code_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *sortingCodeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SortingCodeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sorting_code_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *sortingCodeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SortingCodeElementType, error) {
	query := "SELECT id, type FROM sorting_code_element_type WHERE id = ?"

	entity := &parent.SortingCodeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *sortingCodeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SortingCodeElementType, error) {
	query := "SELECT id, type FROM sorting_code_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SortingCodeElementType
	for rows.Next() {
		entity := &parent.SortingCodeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *sortingCodeElementTypeRepository) Update(ctx context.Context, entity *parent.SortingCodeElementType) error {
	query := "UPDATE sorting_code_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *sortingCodeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sorting_code_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *sortingCodeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sorting_code_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *sortingCodeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sorting_code_element_type").Scan(&count)
	return count, err
}

func (d *dal) SplitFunctionType() parent.SplitFunctionTypeRepository {
	return &splitFunctionTypeRepository{db: d.db}
}

type splitFunctionTypeRepository struct {
	db *sql.DB
}

func (r *splitFunctionTypeRepository) Create(ctx context.Context, entity *parent.SplitFunctionType) (int64, error) {
	query := "INSERT INTO split_function_type (delimiter) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Delimiter,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *splitFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SplitFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO split_function_type (delimiter) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Delimiter,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *splitFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SplitFunctionType, error) {
	query := "SELECT id, delimiter FROM split_function_type WHERE id = ?"

	entity := &parent.SplitFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Delimiter,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *splitFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SplitFunctionType, error) {
	query := "SELECT id, delimiter FROM split_function_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SplitFunctionType
	for rows.Next() {
		entity := &parent.SplitFunctionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Delimiter,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *splitFunctionTypeRepository) Update(ctx context.Context, entity *parent.SplitFunctionType) error {
	query := "UPDATE split_function_type SET delimiter = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Delimiter,
		entity.ID,
	)
	return err
}

func (r *splitFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM split_function_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *splitFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM split_function_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *splitFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM split_function_type").Scan(&count)
	return count, err
}

func (d *dal) StateRefType() parent.StateRefTypeRepository {
	return &stateRefTypeRepository{db: d.db}
}

type stateRefTypeRepository struct {
	db *sql.DB
}

func (r *stateRefTypeRepository) Create(ctx context.Context, entity *parent.StateRefType) (int64, error) {
	query := "INSERT INTO state_ref_type (state_ref) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.State_ref,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *stateRefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.StateRefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO state_ref_type (state_ref) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.State_ref,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *stateRefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.StateRefType, error) {
	query := "SELECT id, state_ref FROM state_ref_type WHERE id = ?"

	entity := &parent.StateRefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.State_ref,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *stateRefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.StateRefType, error) {
	query := "SELECT id, state_ref FROM state_ref_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.StateRefType
	for rows.Next() {
		entity := &parent.StateRefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.State_ref,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *stateRefTypeRepository) Update(ctx context.Context, entity *parent.StateRefType) error {
	query := "UPDATE state_ref_type SET state_ref = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.State_ref,
		entity.ID,
	)
	return err
}

func (r *stateRefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM state_ref_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *stateRefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM state_ref_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *stateRefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM state_ref_type").Scan(&count)
	return count, err
}

func (d *dal) StateType() parent.StateTypeRepository {
	return &stateTypeRepository{db: d.db}
}

type stateTypeRepository struct {
	db *sql.DB
}

func (r *stateTypeRepository) Create(ctx context.Context, entity *parent.StateType) (int64, error) {
	query := "INSERT INTO state_type (xsd_id, version, operator, comment, deprecated) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Operator,
		entity.Comment,
		entity.Deprecated,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *stateTypeRepository) CreateBatch(ctx context.Context, entities []*parent.StateType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO state_type (xsd_id, version, operator, comment, deprecated) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Version,
			entity.Operator,
			entity.Comment,
			entity.Deprecated,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *stateTypeRepository) GetByID(ctx context.Context, id int64) (*parent.StateType, error) {
	query := "SELECT id, xsd_id, version, operator, comment, deprecated FROM state_type WHERE id = ?"

	entity := &parent.StateType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Version,
		&entity.Operator,
		&entity.Comment,
		&entity.Deprecated,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *stateTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.StateType, error) {
	query := "SELECT id, xsd_id, version, operator, comment, deprecated FROM state_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.StateType
	for rows.Next() {
		entity := &parent.StateType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Version,
			&entity.Operator,
			&entity.Comment,
			&entity.Deprecated,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *stateTypeRepository) Update(ctx context.Context, entity *parent.StateType) error {
	query := "UPDATE state_type SET xsd_id = ?, version = ?, operator = ?, comment = ?, deprecated = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Operator,
		entity.Comment,
		entity.Deprecated,
		entity.ID,
	)
	return err
}

func (r *stateTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM state_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *stateTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM state_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *stateTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM state_type").Scan(&count)
	return count, err
}

func (d *dal) StatesType() parent.StatesTypeRepository {
	return &statesTypeRepository{db: d.db}
}

type statesTypeRepository struct {
	db *sql.DB
}

func (r *statesTypeRepository) Create(ctx context.Context, entity *parent.StatesType) (int64, error) {
	query := "INSERT INTO states_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *statesTypeRepository) CreateBatch(ctx context.Context, entities []*parent.StatesType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO states_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *statesTypeRepository) GetByID(ctx context.Context, id int64) (*parent.StatesType, error) {
	query := "SELECT id FROM states_type WHERE id = ?"

	entity := &parent.StatesType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *statesTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.StatesType, error) {
	query := "SELECT id FROM states_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.StatesType
	for rows.Next() {
		entity := &parent.StatesType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *statesTypeRepository) Update(ctx context.Context, entity *parent.StatesType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *statesTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM states_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *statesTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM states_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *statesTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM states_type").Scan(&count)
	return count, err
}

func (d *dal) Status() parent.StatusRepository {
	return &statusRepository{db: d.db}
}

type statusRepository struct {
	db *sql.DB
}

func (r *statusRepository) Create(ctx context.Context, entity *parent.Status) (int64, error) {
	query := "INSERT INTO status (date, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Date,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *statusRepository) CreateBatch(ctx context.Context, entities []*parent.Status) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO status (date, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Date,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *statusRepository) GetByID(ctx context.Context, id int64) (*parent.Status, error) {
	query := "SELECT id, date, parent_id FROM status WHERE id = ?"

	entity := &parent.Status{}
	var dateTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&dateTime,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Date = dateTime.ToTimePtr()

	return entity, nil
}

func (r *statusRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Status, error) {
	query := "SELECT id, date, parent_id FROM status LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Status
	for rows.Next() {
		entity := &parent.Status{}
		var dateTime NullTime
		err := rows.Scan(
			&entity.ID,
			&dateTime,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entity.Date = dateTime.ToTimePtr()
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *statusRepository) Update(ctx context.Context, entity *parent.Status) error {
	query := "UPDATE status SET date = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Date,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *statusRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM status WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *statusRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM status WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *statusRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM status").Scan(&count)
	return count, err
}

func (d *dal) StatusElementType() parent.StatusElementTypeRepository {
	return &statusElementTypeRepository{db: d.db}
}

type statusElementTypeRepository struct {
	db *sql.DB
}

func (r *statusElementTypeRepository) Create(ctx context.Context, entity *parent.StatusElementType) (int64, error) {
	query := "INSERT INTO status_element_type (date, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Date,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *statusElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.StatusElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO status_element_type (date, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Date,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *statusElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.StatusElementType, error) {
	query := "SELECT id, date, parent_id FROM status_element_type WHERE id = ?"

	entity := &parent.StatusElementType{}
	var dateTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&dateTime,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Date = dateTime.ToTimePtr()

	return entity, nil
}

func (r *statusElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.StatusElementType, error) {
	query := "SELECT id, date, parent_id FROM status_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.StatusElementType
	for rows.Next() {
		entity := &parent.StatusElementType{}
		var dateTime NullTime
		err := rows.Scan(
			&entity.ID,
			&dateTime,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entity.Date = dateTime.ToTimePtr()
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *statusElementTypeRepository) Update(ctx context.Context, entity *parent.StatusElementType) error {
	query := "UPDATE status_element_type SET date = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Date,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *statusElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM status_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *statusElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM status_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *statusElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM status_element_type").Scan(&count)
	return count, err
}

func (d *dal) SubAdministrativeAreaElementType() parent.SubAdministrativeAreaElementTypeRepository {
	return &subAdministrativeAreaElementTypeRepository{db: d.db}
}

type subAdministrativeAreaElementTypeRepository struct {
	db *sql.DB
}

func (r *subAdministrativeAreaElementTypeRepository) Create(ctx context.Context, entity *parent.SubAdministrativeAreaElementType) (int64, error) {
	query := "INSERT INTO sub_administrative_area_element_type (type, usage_type, indicator, sub_administrative_area_name) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.SubAdministrativeAreaName,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subAdministrativeAreaElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubAdministrativeAreaElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_administrative_area_element_type (type, usage_type, indicator, sub_administrative_area_name) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.UsageType,
			entity.Indicator,
			entity.SubAdministrativeAreaName,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subAdministrativeAreaElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubAdministrativeAreaElementType, error) {
	query := "SELECT id, type, usage_type, indicator, sub_administrative_area_name FROM sub_administrative_area_element_type WHERE id = ?"

	entity := &parent.SubAdministrativeAreaElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.UsageType,
		&entity.Indicator,
		&entity.SubAdministrativeAreaName,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subAdministrativeAreaElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubAdministrativeAreaElementType, error) {
	query := "SELECT id, type, usage_type, indicator, sub_administrative_area_name FROM sub_administrative_area_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubAdministrativeAreaElementType
	for rows.Next() {
		entity := &parent.SubAdministrativeAreaElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.UsageType,
			&entity.Indicator,
			&entity.SubAdministrativeAreaName,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subAdministrativeAreaElementTypeRepository) Update(ctx context.Context, entity *parent.SubAdministrativeAreaElementType) error {
	query := "UPDATE sub_administrative_area_element_type SET type = ?, usage_type = ?, indicator = ?, sub_administrative_area_name = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.UsageType,
		entity.Indicator,
		entity.SubAdministrativeAreaName,
		entity.ID,
	)
	return err
}

func (r *subAdministrativeAreaElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_administrative_area_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subAdministrativeAreaElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_administrative_area_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subAdministrativeAreaElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_administrative_area_element_type").Scan(&count)
	return count, err
}

func (d *dal) SubAdministrativeAreaNameElementType() parent.SubAdministrativeAreaNameElementTypeRepository {
	return &subAdministrativeAreaNameElementTypeRepository{db: d.db}
}

type subAdministrativeAreaNameElementTypeRepository struct {
	db *sql.DB
}

func (r *subAdministrativeAreaNameElementTypeRepository) Create(ctx context.Context, entity *parent.SubAdministrativeAreaNameElementType) (int64, error) {
	query := "INSERT INTO sub_administrative_area_name_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subAdministrativeAreaNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubAdministrativeAreaNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_administrative_area_name_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subAdministrativeAreaNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubAdministrativeAreaNameElementType, error) {
	query := "SELECT id, type FROM sub_administrative_area_name_element_type WHERE id = ?"

	entity := &parent.SubAdministrativeAreaNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subAdministrativeAreaNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubAdministrativeAreaNameElementType, error) {
	query := "SELECT id, type FROM sub_administrative_area_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubAdministrativeAreaNameElementType
	for rows.Next() {
		entity := &parent.SubAdministrativeAreaNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subAdministrativeAreaNameElementTypeRepository) Update(ctx context.Context, entity *parent.SubAdministrativeAreaNameElementType) error {
	query := "UPDATE sub_administrative_area_name_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *subAdministrativeAreaNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_administrative_area_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subAdministrativeAreaNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_administrative_area_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subAdministrativeAreaNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_administrative_area_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) SubPremiseLocationElementType() parent.SubPremiseLocationElementTypeRepository {
	return &subPremiseLocationElementTypeRepository{db: d.db}
}

type subPremiseLocationElementTypeRepository struct {
	db *sql.DB
}

func (r *subPremiseLocationElementTypeRepository) Create(ctx context.Context, entity *parent.SubPremiseLocationElementType) (int64, error) {
	query := "INSERT INTO sub_premise_location_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subPremiseLocationElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubPremiseLocationElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_premise_location_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subPremiseLocationElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubPremiseLocationElementType, error) {
	query := "SELECT id FROM sub_premise_location_element_type WHERE id = ?"

	entity := &parent.SubPremiseLocationElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subPremiseLocationElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubPremiseLocationElementType, error) {
	query := "SELECT id FROM sub_premise_location_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseLocationElementType
	for rows.Next() {
		entity := &parent.SubPremiseLocationElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subPremiseLocationElementTypeRepository) Update(ctx context.Context, entity *parent.SubPremiseLocationElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *subPremiseLocationElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_premise_location_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subPremiseLocationElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_premise_location_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subPremiseLocationElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_premise_location_element_type").Scan(&count)
	return count, err
}

func (d *dal) SubPremiseNameElementType() parent.SubPremiseNameElementTypeRepository {
	return &subPremiseNameElementTypeRepository{db: d.db}
}

type subPremiseNameElementTypeRepository struct {
	db *sql.DB
}

func (r *subPremiseNameElementTypeRepository) Create(ctx context.Context, entity *parent.SubPremiseNameElementType) (int64, error) {
	query := "INSERT INTO sub_premise_name_element_type (type, type_occurrence) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.TypeOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subPremiseNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubPremiseNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_premise_name_element_type (type, type_occurrence) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.TypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subPremiseNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubPremiseNameElementType, error) {
	query := "SELECT id, type, type_occurrence FROM sub_premise_name_element_type WHERE id = ?"

	entity := &parent.SubPremiseNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.TypeOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subPremiseNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubPremiseNameElementType, error) {
	query := "SELECT id, type, type_occurrence FROM sub_premise_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseNameElementType
	for rows.Next() {
		entity := &parent.SubPremiseNameElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.TypeOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subPremiseNameElementTypeRepository) Update(ctx context.Context, entity *parent.SubPremiseNameElementType) error {
	query := "UPDATE sub_premise_name_element_type SET type = ?, type_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.TypeOccurrence,
		entity.ID,
	)
	return err
}

func (r *subPremiseNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_premise_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subPremiseNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_premise_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subPremiseNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_premise_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) SubPremiseNumberElementType() parent.SubPremiseNumberElementTypeRepository {
	return &subPremiseNumberElementTypeRepository{db: d.db}
}

type subPremiseNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *subPremiseNumberElementTypeRepository) Create(ctx context.Context, entity *parent.SubPremiseNumberElementType) (int64, error) {
	query := "INSERT INTO sub_premise_number_element_type (indicator, indicator_occurrence, number_type_occurrence, premise_number_separator, type) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberTypeOccurrence,
		entity.PremiseNumberSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subPremiseNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubPremiseNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_premise_number_element_type (indicator, indicator_occurrence, number_type_occurrence, premise_number_separator, type) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Indicator,
			entity.IndicatorOccurrence,
			entity.NumberTypeOccurrence,
			entity.PremiseNumberSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subPremiseNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubPremiseNumberElementType, error) {
	query := "SELECT id, indicator, indicator_occurrence, number_type_occurrence, premise_number_separator, type FROM sub_premise_number_element_type WHERE id = ?"

	entity := &parent.SubPremiseNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Indicator,
		&entity.IndicatorOccurrence,
		&entity.NumberTypeOccurrence,
		&entity.PremiseNumberSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subPremiseNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubPremiseNumberElementType, error) {
	query := "SELECT id, indicator, indicator_occurrence, number_type_occurrence, premise_number_separator, type FROM sub_premise_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseNumberElementType
	for rows.Next() {
		entity := &parent.SubPremiseNumberElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Indicator,
			&entity.IndicatorOccurrence,
			&entity.NumberTypeOccurrence,
			&entity.PremiseNumberSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subPremiseNumberElementTypeRepository) Update(ctx context.Context, entity *parent.SubPremiseNumberElementType) error {
	query := "UPDATE sub_premise_number_element_type SET indicator = ?, indicator_occurrence = ?, number_type_occurrence = ?, premise_number_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberTypeOccurrence,
		entity.PremiseNumberSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *subPremiseNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_premise_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subPremiseNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_premise_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subPremiseNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_premise_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) SubPremiseNumberPrefixElementType() parent.SubPremiseNumberPrefixElementTypeRepository {
	return &subPremiseNumberPrefixElementTypeRepository{db: d.db}
}

type subPremiseNumberPrefixElementTypeRepository struct {
	db *sql.DB
}

func (r *subPremiseNumberPrefixElementTypeRepository) Create(ctx context.Context, entity *parent.SubPremiseNumberPrefixElementType) (int64, error) {
	query := "INSERT INTO sub_premise_number_prefix_element_type (number_prefix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subPremiseNumberPrefixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubPremiseNumberPrefixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_premise_number_prefix_element_type (number_prefix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberPrefixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subPremiseNumberPrefixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubPremiseNumberPrefixElementType, error) {
	query := "SELECT id, number_prefix_separator, type FROM sub_premise_number_prefix_element_type WHERE id = ?"

	entity := &parent.SubPremiseNumberPrefixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberPrefixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subPremiseNumberPrefixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubPremiseNumberPrefixElementType, error) {
	query := "SELECT id, number_prefix_separator, type FROM sub_premise_number_prefix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseNumberPrefixElementType
	for rows.Next() {
		entity := &parent.SubPremiseNumberPrefixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberPrefixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subPremiseNumberPrefixElementTypeRepository) Update(ctx context.Context, entity *parent.SubPremiseNumberPrefixElementType) error {
	query := "UPDATE sub_premise_number_prefix_element_type SET number_prefix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *subPremiseNumberPrefixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_premise_number_prefix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subPremiseNumberPrefixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_premise_number_prefix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subPremiseNumberPrefixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_premise_number_prefix_element_type").Scan(&count)
	return count, err
}

func (d *dal) SubPremiseNumberSuffixElementType() parent.SubPremiseNumberSuffixElementTypeRepository {
	return &subPremiseNumberSuffixElementTypeRepository{db: d.db}
}

type subPremiseNumberSuffixElementTypeRepository struct {
	db *sql.DB
}

func (r *subPremiseNumberSuffixElementTypeRepository) Create(ctx context.Context, entity *parent.SubPremiseNumberSuffixElementType) (int64, error) {
	query := "INSERT INTO sub_premise_number_suffix_element_type (number_suffix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subPremiseNumberSuffixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubPremiseNumberSuffixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_premise_number_suffix_element_type (number_suffix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberSuffixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subPremiseNumberSuffixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubPremiseNumberSuffixElementType, error) {
	query := "SELECT id, number_suffix_separator, type FROM sub_premise_number_suffix_element_type WHERE id = ?"

	entity := &parent.SubPremiseNumberSuffixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberSuffixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subPremiseNumberSuffixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubPremiseNumberSuffixElementType, error) {
	query := "SELECT id, number_suffix_separator, type FROM sub_premise_number_suffix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseNumberSuffixElementType
	for rows.Next() {
		entity := &parent.SubPremiseNumberSuffixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberSuffixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subPremiseNumberSuffixElementTypeRepository) Update(ctx context.Context, entity *parent.SubPremiseNumberSuffixElementType) error {
	query := "UPDATE sub_premise_number_suffix_element_type SET number_suffix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *subPremiseNumberSuffixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_premise_number_suffix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subPremiseNumberSuffixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_premise_number_suffix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subPremiseNumberSuffixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_premise_number_suffix_element_type").Scan(&count)
	return count, err
}

func (d *dal) SubPremiseType() parent.SubPremiseTypeRepository {
	return &subPremiseTypeRepository{db: d.db}
}

type subPremiseTypeRepository struct {
	db *sql.DB
}

func (r *subPremiseTypeRepository) Create(ctx context.Context, entity *parent.SubPremiseType) (int64, error) {
	query := "INSERT INTO sub_premise_type (type, sub_premise_name, sub_premise_number_prefix, sub_premise_number_suffix, firm_id, mail_stop_id, sub_premise_id, sub_premise_location, sub_premise_number) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.SubPremiseName,
		entity.SubPremiseNumberPrefix,
		entity.SubPremiseNumberSuffix,
		entity.FirmID,
		entity.MailStopID,
		entity.SubPremiseID,
		entity.SubPremiseLocation,
		entity.SubPremiseNumber,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subPremiseTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubPremiseType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_premise_type (type, sub_premise_name, sub_premise_number_prefix, sub_premise_number_suffix, firm_id, mail_stop_id, sub_premise_id, sub_premise_location, sub_premise_number) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.SubPremiseName,
			entity.SubPremiseNumberPrefix,
			entity.SubPremiseNumberSuffix,
			entity.FirmID,
			entity.MailStopID,
			entity.SubPremiseID,
			entity.SubPremiseLocation,
			entity.SubPremiseNumber,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subPremiseTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubPremiseType, error) {
	query := "SELECT id, type, sub_premise_name, sub_premise_number_prefix, sub_premise_number_suffix, firm_id, mail_stop_id, sub_premise_id, sub_premise_location, sub_premise_number FROM sub_premise_type WHERE id = ?"

	entity := &parent.SubPremiseType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.SubPremiseName,
		&entity.SubPremiseNumberPrefix,
		&entity.SubPremiseNumberSuffix,
		&entity.FirmID,
		&entity.MailStopID,
		&entity.SubPremiseID,
		&entity.SubPremiseLocation,
		&entity.SubPremiseNumber,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subPremiseTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubPremiseType, error) {
	query := "SELECT id, type, sub_premise_name, sub_premise_number_prefix, sub_premise_number_suffix, firm_id, mail_stop_id, sub_premise_id, sub_premise_location, sub_premise_number FROM sub_premise_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseType
	for rows.Next() {
		entity := &parent.SubPremiseType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.SubPremiseName,
			&entity.SubPremiseNumberPrefix,
			&entity.SubPremiseNumberSuffix,
			&entity.FirmID,
			&entity.MailStopID,
			&entity.SubPremiseID,
			&entity.SubPremiseLocation,
			&entity.SubPremiseNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subPremiseTypeRepository) Update(ctx context.Context, entity *parent.SubPremiseType) error {
	query := "UPDATE sub_premise_type SET type = ?, sub_premise_name = ?, sub_premise_number_prefix = ?, sub_premise_number_suffix = ?, firm_id = ?, mail_stop_id = ?, sub_premise_id = ?, sub_premise_location = ?, sub_premise_number = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.SubPremiseName,
		entity.SubPremiseNumberPrefix,
		entity.SubPremiseNumberSuffix,
		entity.FirmID,
		entity.MailStopID,
		entity.SubPremiseID,
		entity.SubPremiseLocation,
		entity.SubPremiseNumber,
		entity.ID,
	)
	return err
}

func (r *subPremiseTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_premise_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subPremiseTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_premise_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subPremiseTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_premise_type").Scan(&count)
	return count, err
}

func (r *subPremiseTypeRepository) GetByFirmType(ctx context.Context, firm_typeID int64) ([]*parent.SubPremiseType, error) {
	query := "SELECT id, type, sub_premise_name, sub_premise_number_prefix, sub_premise_number_suffix, firm_id, mail_stop_id, sub_premise_id, sub_premise_location, sub_premise_number FROM sub_premise_type WHERE firm_id = ?"

	rows, err := r.db.QueryContext(ctx, query, firm_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseType
	for rows.Next() {
		entity := &parent.SubPremiseType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.SubPremiseName,
			&entity.SubPremiseNumberPrefix,
			&entity.SubPremiseNumberSuffix,
			&entity.FirmID,
			&entity.MailStopID,
			&entity.SubPremiseID,
			&entity.SubPremiseLocation,
			&entity.SubPremiseNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subPremiseTypeRepository) GetByMailStopType(ctx context.Context, mail_stop_typeID int64) ([]*parent.SubPremiseType, error) {
	query := "SELECT id, type, sub_premise_name, sub_premise_number_prefix, sub_premise_number_suffix, firm_id, mail_stop_id, sub_premise_id, sub_premise_location, sub_premise_number FROM sub_premise_type WHERE mail_stop_id = ?"

	rows, err := r.db.QueryContext(ctx, query, mail_stop_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseType
	for rows.Next() {
		entity := &parent.SubPremiseType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.SubPremiseName,
			&entity.SubPremiseNumberPrefix,
			&entity.SubPremiseNumberSuffix,
			&entity.FirmID,
			&entity.MailStopID,
			&entity.SubPremiseID,
			&entity.SubPremiseLocation,
			&entity.SubPremiseNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subPremiseTypeRepository) GetBySubPremiseType(ctx context.Context, sub_premise_typeID int64) ([]*parent.SubPremiseType, error) {
	query := "SELECT id, type, sub_premise_name, sub_premise_number_prefix, sub_premise_number_suffix, firm_id, mail_stop_id, sub_premise_id, sub_premise_location, sub_premise_number FROM sub_premise_type WHERE sub_premise_id = ?"

	rows, err := r.db.QueryContext(ctx, query, sub_premise_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubPremiseType
	for rows.Next() {
		entity := &parent.SubPremiseType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.SubPremiseName,
			&entity.SubPremiseNumberPrefix,
			&entity.SubPremiseNumberSuffix,
			&entity.FirmID,
			&entity.MailStopID,
			&entity.SubPremiseID,
			&entity.SubPremiseLocation,
			&entity.SubPremiseNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) SubType() parent.SubTypeRepository {
	return &subTypeRepository{db: d.db}
}

type subTypeRepository struct {
	db *sql.DB
}

func (r *subTypeRepository) Create(ctx context.Context, entity *parent.SubType) (int64, error) {
	query := "INSERT INTO sub_type (use, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Use,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *subTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO sub_type (use, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Use,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *subTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubType, error) {
	query := "SELECT id, use, parent_id FROM sub_type WHERE id = ?"

	entity := &parent.SubType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Use,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *subTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubType, error) {
	query := "SELECT id, use, parent_id FROM sub_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubType
	for rows.Next() {
		entity := &parent.SubType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Use,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *subTypeRepository) Update(ctx context.Context, entity *parent.SubType) error {
	query := "UPDATE sub_type SET use = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Use,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *subTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM sub_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *subTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM sub_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *subTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM sub_type").Scan(&count)
	return count, err
}

func (r *subTypeRepository) GetByIdrefType(ctx context.Context, idref_typeID int64) ([]*parent.SubType, error) {
	query := "SELECT id, use, parent_id FROM sub_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, idref_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubType
	for rows.Next() {
		entity := &parent.SubType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Use,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) SubstringFunctionType() parent.SubstringFunctionTypeRepository {
	return &substringFunctionTypeRepository{db: d.db}
}

type substringFunctionTypeRepository struct {
	db *sql.DB
}

func (r *substringFunctionTypeRepository) Create(ctx context.Context, entity *parent.SubstringFunctionType) (int64, error) {
	query := "INSERT INTO substring_function_type (substring_start, substring_length) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Substring_start,
		entity.Substring_length,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *substringFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SubstringFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO substring_function_type (substring_start, substring_length) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Substring_start,
			entity.Substring_length,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *substringFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SubstringFunctionType, error) {
	query := "SELECT id, substring_start, substring_length FROM substring_function_type WHERE id = ?"

	entity := &parent.SubstringFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Substring_start,
		&entity.Substring_length,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *substringFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SubstringFunctionType, error) {
	query := "SELECT id, substring_start, substring_length FROM substring_function_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SubstringFunctionType
	for rows.Next() {
		entity := &parent.SubstringFunctionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Substring_start,
			&entity.Substring_length,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *substringFunctionTypeRepository) Update(ctx context.Context, entity *parent.SubstringFunctionType) error {
	query := "UPDATE substring_function_type SET substring_start = ?, substring_length = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Substring_start,
		entity.Substring_length,
		entity.ID,
	)
	return err
}

func (r *substringFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM substring_function_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *substringFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM substring_function_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *substringFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM substring_function_type").Scan(&count)
	return count, err
}

func (d *dal) SuffixElementType() parent.SuffixElementTypeRepository {
	return &suffixElementTypeRepository{db: d.db}
}

type suffixElementTypeRepository struct {
	db *sql.DB
}

func (r *suffixElementTypeRepository) Create(ctx context.Context, entity *parent.SuffixElementType) (int64, error) {
	query := "INSERT INTO suffix_element_type (type, code) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *suffixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SuffixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO suffix_element_type (type, code) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *suffixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SuffixElementType, error) {
	query := "SELECT id, type, code FROM suffix_element_type WHERE id = ?"

	entity := &parent.SuffixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *suffixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SuffixElementType, error) {
	query := "SELECT id, type, code FROM suffix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SuffixElementType
	for rows.Next() {
		entity := &parent.SuffixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *suffixElementTypeRepository) Update(ctx context.Context, entity *parent.SuffixElementType) error {
	query := "UPDATE suffix_element_type SET type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *suffixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM suffix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *suffixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM suffix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *suffixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM suffix_element_type").Scan(&count)
	return count, err
}

func (d *dal) SupplementaryPostalServiceDataElementType() parent.SupplementaryPostalServiceDataElementTypeRepository {
	return &supplementaryPostalServiceDataElementTypeRepository{db: d.db}
}

type supplementaryPostalServiceDataElementTypeRepository struct {
	db *sql.DB
}

func (r *supplementaryPostalServiceDataElementTypeRepository) Create(ctx context.Context, entity *parent.SupplementaryPostalServiceDataElementType) (int64, error) {
	query := "INSERT INTO supplementary_postal_service_data_element_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *supplementaryPostalServiceDataElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SupplementaryPostalServiceDataElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO supplementary_postal_service_data_element_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *supplementaryPostalServiceDataElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SupplementaryPostalServiceDataElementType, error) {
	query := "SELECT id, type FROM supplementary_postal_service_data_element_type WHERE id = ?"

	entity := &parent.SupplementaryPostalServiceDataElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *supplementaryPostalServiceDataElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SupplementaryPostalServiceDataElementType, error) {
	query := "SELECT id, type FROM supplementary_postal_service_data_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SupplementaryPostalServiceDataElementType
	for rows.Next() {
		entity := &parent.SupplementaryPostalServiceDataElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *supplementaryPostalServiceDataElementTypeRepository) Update(ctx context.Context, entity *parent.SupplementaryPostalServiceDataElementType) error {
	query := "UPDATE supplementary_postal_service_data_element_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *supplementaryPostalServiceDataElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM supplementary_postal_service_data_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *supplementaryPostalServiceDataElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM supplementary_postal_service_data_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *supplementaryPostalServiceDataElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM supplementary_postal_service_data_element_type").Scan(&count)
	return count, err
}

func (d *dal) SyntheticId() parent.SyntheticIdRepository {
	return &syntheticIdRepository{db: d.db}
}

type syntheticIdRepository struct {
	db *sql.DB
}

func (r *syntheticIdRepository) Create(ctx context.Context, entity *parent.SyntheticId) (int64, error) {
	query := "INSERT INTO synthetic_id (resource, xsd_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Resource,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *syntheticIdRepository) CreateBatch(ctx context.Context, entities []*parent.SyntheticId) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO synthetic_id (resource, xsd_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Resource,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *syntheticIdRepository) GetByID(ctx context.Context, id int64) (*parent.SyntheticId, error) {
	query := "SELECT id, resource, xsd_id FROM synthetic_id WHERE id = ?"

	entity := &parent.SyntheticId{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Resource,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *syntheticIdRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SyntheticId, error) {
	query := "SELECT id, resource, xsd_id FROM synthetic_id LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SyntheticId
	for rows.Next() {
		entity := &parent.SyntheticId{}
		err := rows.Scan(
			&entity.ID,
			&entity.Resource,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *syntheticIdRepository) Update(ctx context.Context, entity *parent.SyntheticId) error {
	query := "UPDATE synthetic_id SET resource = ?, xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Resource,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *syntheticIdRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM synthetic_id WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *syntheticIdRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM synthetic_id WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *syntheticIdRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM synthetic_id").Scan(&count)
	return count, err
}

func (d *dal) SyntheticIdElementType() parent.SyntheticIdElementTypeRepository {
	return &syntheticIdElementTypeRepository{db: d.db}
}

type syntheticIdElementTypeRepository struct {
	db *sql.DB
}

func (r *syntheticIdElementTypeRepository) Create(ctx context.Context, entity *parent.SyntheticIdElementType) (int64, error) {
	query := "INSERT INTO synthetic_id_element_type (resource, xsd_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Resource,
		entity.XsdId,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *syntheticIdElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SyntheticIdElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO synthetic_id_element_type (resource, xsd_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Resource,
			entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *syntheticIdElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SyntheticIdElementType, error) {
	query := "SELECT id, resource, xsd_id FROM synthetic_id_element_type WHERE id = ?"

	entity := &parent.SyntheticIdElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Resource,
		&entity.XsdId,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *syntheticIdElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SyntheticIdElementType, error) {
	query := "SELECT id, resource, xsd_id FROM synthetic_id_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SyntheticIdElementType
	for rows.Next() {
		entity := &parent.SyntheticIdElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Resource,
			&entity.XsdId,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *syntheticIdElementTypeRepository) Update(ctx context.Context, entity *parent.SyntheticIdElementType) error {
	query := "UPDATE synthetic_id_element_type SET resource = ?, xsd_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Resource,
		entity.XsdId,
		entity.ID,
	)
	return err
}

func (r *syntheticIdElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM synthetic_id_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *syntheticIdElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM synthetic_id_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *syntheticIdElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM synthetic_id_element_type").Scan(&count)
	return count, err
}

func (d *dal) SystemNameElementType() parent.SystemNameElementTypeRepository {
	return &systemNameElementTypeRepository{db: d.db}
}

type systemNameElementTypeRepository struct {
	db *sql.DB
}

func (r *systemNameElementTypeRepository) Create(ctx context.Context, entity *parent.SystemNameElementType) (int64, error) {
	query := "INSERT INTO system_name_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *systemNameElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SystemNameElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO system_name_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *systemNameElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SystemNameElementType, error) {
	query := "SELECT id FROM system_name_element_type WHERE id = ?"

	entity := &parent.SystemNameElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *systemNameElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SystemNameElementType, error) {
	query := "SELECT id FROM system_name_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SystemNameElementType
	for rows.Next() {
		entity := &parent.SystemNameElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *systemNameElementTypeRepository) Update(ctx context.Context, entity *parent.SystemNameElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *systemNameElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM system_name_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *systemNameElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM system_name_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *systemNameElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM system_name_element_type").Scan(&count)
	return count, err
}

func (d *dal) SystemType() parent.SystemTypeRepository {
	return &systemTypeRepository{db: d.db}
}

type systemTypeRepository struct {
	db *sql.DB
}

func (r *systemTypeRepository) Create(ctx context.Context, entity *parent.SystemType) (int64, error) {
	query := "INSERT INTO system_type (system_name, version, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.SystemName,
		entity.Version,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *systemTypeRepository) CreateBatch(ctx context.Context, entities []*parent.SystemType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO system_type (system_name, version, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.SystemName,
			entity.Version,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *systemTypeRepository) GetByID(ctx context.Context, id int64) (*parent.SystemType, error) {
	query := "SELECT id, system_name, version, parent_id FROM system_type WHERE id = ?"

	entity := &parent.SystemType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.SystemName,
		&entity.Version,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *systemTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.SystemType, error) {
	query := "SELECT id, system_name, version, parent_id FROM system_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SystemType
	for rows.Next() {
		entity := &parent.SystemType{}
		err := rows.Scan(
			&entity.ID,
			&entity.SystemName,
			&entity.Version,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *systemTypeRepository) Update(ctx context.Context, entity *parent.SystemType) error {
	query := "UPDATE system_type SET system_name = ?, version = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.SystemName,
		entity.Version,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *systemTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM system_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *systemTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM system_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *systemTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM system_type").Scan(&count)
	return count, err
}

func (r *systemTypeRepository) GetByItAssetType(ctx context.Context, it_asset_typeID int64) ([]*parent.SystemType, error) {
	query := "SELECT id, system_name, version, parent_id FROM system_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, it_asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.SystemType
	for rows.Next() {
		entity := &parent.SystemType{}
		err := rows.Scan(
			&entity.ID,
			&entity.SystemName,
			&entity.Version,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) TailoringBenchmarkReferenceType() parent.TailoringBenchmarkReferenceTypeRepository {
	return &tailoringBenchmarkReferenceTypeRepository{db: d.db}
}

type tailoringBenchmarkReferenceTypeRepository struct {
	db *sql.DB
}

func (r *tailoringBenchmarkReferenceTypeRepository) Create(ctx context.Context, entity *parent.TailoringBenchmarkReferenceType) (int64, error) {
	query := "INSERT INTO tailoring_benchmark_reference_type (version, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Version,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *tailoringBenchmarkReferenceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TailoringBenchmarkReferenceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO tailoring_benchmark_reference_type (version, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Version,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *tailoringBenchmarkReferenceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TailoringBenchmarkReferenceType, error) {
	query := "SELECT id, version, parent_id FROM tailoring_benchmark_reference_type WHERE id = ?"

	entity := &parent.TailoringBenchmarkReferenceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Version,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *tailoringBenchmarkReferenceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TailoringBenchmarkReferenceType, error) {
	query := "SELECT id, version, parent_id FROM tailoring_benchmark_reference_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TailoringBenchmarkReferenceType
	for rows.Next() {
		entity := &parent.TailoringBenchmarkReferenceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Version,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *tailoringBenchmarkReferenceTypeRepository) Update(ctx context.Context, entity *parent.TailoringBenchmarkReferenceType) error {
	query := "UPDATE tailoring_benchmark_reference_type SET version = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Version,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *tailoringBenchmarkReferenceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM tailoring_benchmark_reference_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *tailoringBenchmarkReferenceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM tailoring_benchmark_reference_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *tailoringBenchmarkReferenceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tailoring_benchmark_reference_type").Scan(&count)
	return count, err
}

func (r *tailoringBenchmarkReferenceTypeRepository) GetByBenchmarkReferenceType(ctx context.Context, benchmark_reference_typeID int64) ([]*parent.TailoringBenchmarkReferenceType, error) {
	query := "SELECT id, version, parent_id FROM tailoring_benchmark_reference_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, benchmark_reference_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TailoringBenchmarkReferenceType
	for rows.Next() {
		entity := &parent.TailoringBenchmarkReferenceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Version,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) TailoringReferenceType() parent.TailoringReferenceTypeRepository {
	return &tailoringReferenceTypeRepository{db: d.db}
}

type tailoringReferenceTypeRepository struct {
	db *sql.DB
}

func (r *tailoringReferenceTypeRepository) Create(ctx context.Context, entity *parent.TailoringReferenceType) (int64, error) {
	query := "INSERT INTO tailoring_reference_type (href, xsd_id, version, time) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.XsdId,
		entity.Version,
		entity.Time,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *tailoringReferenceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TailoringReferenceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO tailoring_reference_type (href, xsd_id, version, time) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Href,
			entity.XsdId,
			entity.Version,
			entity.Time,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *tailoringReferenceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TailoringReferenceType, error) {
	query := "SELECT id, href, xsd_id, version, time FROM tailoring_reference_type WHERE id = ?"

	entity := &parent.TailoringReferenceType{}
	var timeTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Href,
		&entity.XsdId,
		&entity.Version,
		&timeTime,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Time = timeTime.Time

	return entity, nil
}

func (r *tailoringReferenceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TailoringReferenceType, error) {
	query := "SELECT id, href, xsd_id, version, time FROM tailoring_reference_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TailoringReferenceType
	for rows.Next() {
		entity := &parent.TailoringReferenceType{}
		var timeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.Href,
			&entity.XsdId,
			&entity.Version,
			&timeTime,
		)
		if err != nil {
			return nil, err
		}
		entity.Time = timeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *tailoringReferenceTypeRepository) Update(ctx context.Context, entity *parent.TailoringReferenceType) error {
	query := "UPDATE tailoring_reference_type SET href = ?, xsd_id = ?, version = ?, time = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.XsdId,
		entity.Version,
		entity.Time,
		entity.ID,
	)
	return err
}

func (r *tailoringReferenceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM tailoring_reference_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *tailoringReferenceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM tailoring_reference_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *tailoringReferenceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tailoring_reference_type").Scan(&count)
	return count, err
}

func (d *dal) TailoringType() parent.TailoringTypeRepository {
	return &tailoringTypeRepository{db: d.db}
}

type tailoringTypeRepository struct {
	db *sql.DB
}

func (r *tailoringTypeRepository) Create(ctx context.Context, entity *parent.TailoringType) (int64, error) {
	query := "INSERT INTO tailoring_type (xsd_id, benchmark_id, version_id, signature_id) VALUES (?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.BenchmarkID,
		entity.VersionID,
		entity.SignatureID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *tailoringTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TailoringType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO tailoring_type (xsd_id, benchmark_id, version_id, signature_id) VALUES (?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.BenchmarkID,
			entity.VersionID,
			entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *tailoringTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TailoringType, error) {
	query := "SELECT id, xsd_id, benchmark_id, version_id, signature_id FROM tailoring_type WHERE id = ?"

	entity := &parent.TailoringType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.BenchmarkID,
		&entity.VersionID,
		&entity.SignatureID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *tailoringTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TailoringType, error) {
	query := "SELECT id, xsd_id, benchmark_id, version_id, signature_id FROM tailoring_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TailoringType
	for rows.Next() {
		entity := &parent.TailoringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.BenchmarkID,
			&entity.VersionID,
			&entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *tailoringTypeRepository) Update(ctx context.Context, entity *parent.TailoringType) error {
	query := "UPDATE tailoring_type SET xsd_id = ?, benchmark_id = ?, version_id = ?, signature_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.BenchmarkID,
		entity.VersionID,
		entity.SignatureID,
		entity.ID,
	)
	return err
}

func (r *tailoringTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM tailoring_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *tailoringTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM tailoring_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *tailoringTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tailoring_type").Scan(&count)
	return count, err
}

func (r *tailoringTypeRepository) GetByTailoringBenchmarkReferenceType(ctx context.Context, tailoring_benchmark_reference_typeID int64) ([]*parent.TailoringType, error) {
	query := "SELECT id, xsd_id, benchmark_id, version_id, signature_id FROM tailoring_type WHERE benchmark_id = ?"

	rows, err := r.db.QueryContext(ctx, query, tailoring_benchmark_reference_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TailoringType
	for rows.Next() {
		entity := &parent.TailoringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.BenchmarkID,
			&entity.VersionID,
			&entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *tailoringTypeRepository) GetByTailoringVersionType(ctx context.Context, tailoring_version_typeID int64) ([]*parent.TailoringType, error) {
	query := "SELECT id, xsd_id, benchmark_id, version_id, signature_id FROM tailoring_type WHERE version_id = ?"

	rows, err := r.db.QueryContext(ctx, query, tailoring_version_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TailoringType
	for rows.Next() {
		entity := &parent.TailoringType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.BenchmarkID,
			&entity.VersionID,
			&entity.SignatureID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) TailoringVersionType() parent.TailoringVersionTypeRepository {
	return &tailoringVersionTypeRepository{db: d.db}
}

type tailoringVersionTypeRepository struct {
	db *sql.DB
}

func (r *tailoringVersionTypeRepository) Create(ctx context.Context, entity *parent.TailoringVersionType) (int64, error) {
	query := "INSERT INTO tailoring_version_type (time) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Time,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *tailoringVersionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TailoringVersionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO tailoring_version_type (time) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Time,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *tailoringVersionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TailoringVersionType, error) {
	query := "SELECT id, time FROM tailoring_version_type WHERE id = ?"

	entity := &parent.TailoringVersionType{}
	var timeTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&timeTime,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Time = timeTime.Time

	return entity, nil
}

func (r *tailoringVersionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TailoringVersionType, error) {
	query := "SELECT id, time FROM tailoring_version_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TailoringVersionType
	for rows.Next() {
		entity := &parent.TailoringVersionType{}
		var timeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&timeTime,
		)
		if err != nil {
			return nil, err
		}
		entity.Time = timeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *tailoringVersionTypeRepository) Update(ctx context.Context, entity *parent.TailoringVersionType) error {
	query := "UPDATE tailoring_version_type SET time = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Time,
		entity.ID,
	)
	return err
}

func (r *tailoringVersionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM tailoring_version_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *tailoringVersionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM tailoring_version_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *tailoringVersionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tailoring_version_type").Scan(&count)
	return count, err
}

func (d *dal) TargetFactsType() parent.TargetFactsTypeRepository {
	return &targetFactsTypeRepository{db: d.db}
}

type targetFactsTypeRepository struct {
	db *sql.DB
}

func (r *targetFactsTypeRepository) Create(ctx context.Context, entity *parent.TargetFactsType) (int64, error) {
	query := "INSERT INTO target_facts_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *targetFactsTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TargetFactsType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO target_facts_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *targetFactsTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TargetFactsType, error) {
	query := "SELECT id FROM target_facts_type WHERE id = ?"

	entity := &parent.TargetFactsType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *targetFactsTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TargetFactsType, error) {
	query := "SELECT id FROM target_facts_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TargetFactsType
	for rows.Next() {
		entity := &parent.TargetFactsType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *targetFactsTypeRepository) Update(ctx context.Context, entity *parent.TargetFactsType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *targetFactsTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM target_facts_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *targetFactsTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM target_facts_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *targetFactsTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM target_facts_type").Scan(&count)
	return count, err
}

func (d *dal) TargetIdRefType() parent.TargetIdRefTypeRepository {
	return &targetIdRefTypeRepository{db: d.db}
}

type targetIdRefTypeRepository struct {
	db *sql.DB
}

func (r *targetIdRefTypeRepository) Create(ctx context.Context, entity *parent.TargetIdRefType) (int64, error) {
	query := "INSERT INTO target_id_ref_type (system, href, name) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.Href,
		entity.Name,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *targetIdRefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TargetIdRefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO target_id_ref_type (system, href, name) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.System,
			entity.Href,
			entity.Name,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *targetIdRefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TargetIdRefType, error) {
	query := "SELECT id, system, href, name FROM target_id_ref_type WHERE id = ?"

	entity := &parent.TargetIdRefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.System,
		&entity.Href,
		&entity.Name,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *targetIdRefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TargetIdRefType, error) {
	query := "SELECT id, system, href, name FROM target_id_ref_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TargetIdRefType
	for rows.Next() {
		entity := &parent.TargetIdRefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.System,
			&entity.Href,
			&entity.Name,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *targetIdRefTypeRepository) Update(ctx context.Context, entity *parent.TargetIdRefType) error {
	query := "UPDATE target_id_ref_type SET system = ?, href = ?, name = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.Href,
		entity.Name,
		entity.ID,
	)
	return err
}

func (r *targetIdRefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM target_id_ref_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *targetIdRefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM target_id_ref_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *targetIdRefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM target_id_ref_type").Scan(&count)
	return count, err
}

func (d *dal) TelephoneNumber() parent.TelephoneNumberRepository {
	return &telephoneNumberRepository{db: d.db}
}

type telephoneNumberRepository struct {
	db *sql.DB
}

func (r *telephoneNumberRepository) Create(ctx context.Context, entity *parent.TelephoneNumber) (int64, error) {
	query := "INSERT INTO telephone_number (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *telephoneNumberRepository) CreateBatch(ctx context.Context, entities []*parent.TelephoneNumber) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO telephone_number (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *telephoneNumberRepository) GetByID(ctx context.Context, id int64) (*parent.TelephoneNumber, error) {
	query := "SELECT id, parent_id FROM telephone_number WHERE id = ?"

	entity := &parent.TelephoneNumber{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *telephoneNumberRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TelephoneNumber, error) {
	query := "SELECT id, parent_id FROM telephone_number LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TelephoneNumber
	for rows.Next() {
		entity := &parent.TelephoneNumber{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *telephoneNumberRepository) Update(ctx context.Context, entity *parent.TelephoneNumber) error {
	query := "UPDATE telephone_number SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *telephoneNumberRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM telephone_number WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *telephoneNumberRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM telephone_number WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *telephoneNumberRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM telephone_number").Scan(&count)
	return count, err
}

func (d *dal) TelephoneNumberElementType() parent.TelephoneNumberElementTypeRepository {
	return &telephoneNumberElementTypeRepository{db: d.db}
}

type telephoneNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *telephoneNumberElementTypeRepository) Create(ctx context.Context, entity *parent.TelephoneNumberElementType) (int64, error) {
	query := "INSERT INTO telephone_number_element_type (parent_id) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *telephoneNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TelephoneNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO telephone_number_element_type (parent_id) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *telephoneNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TelephoneNumberElementType, error) {
	query := "SELECT id, parent_id FROM telephone_number_element_type WHERE id = ?"

	entity := &parent.TelephoneNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *telephoneNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TelephoneNumberElementType, error) {
	query := "SELECT id, parent_id FROM telephone_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TelephoneNumberElementType
	for rows.Next() {
		entity := &parent.TelephoneNumberElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *telephoneNumberElementTypeRepository) Update(ctx context.Context, entity *parent.TelephoneNumberElementType) error {
	query := "UPDATE telephone_number_element_type SET parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *telephoneNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM telephone_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *telephoneNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM telephone_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *telephoneNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM telephone_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) TestResultType() parent.TestResultTypeRepository {
	return &testResultTypeRepository{db: d.db}
}

type testResultTypeRepository struct {
	db *sql.DB
}

func (r *testResultTypeRepository) Create(ctx context.Context, entity *parent.TestResultType) (int64, error) {
	query := "INSERT INTO test_result_type (xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.StartTime,
		entity.EndTime,
		entity.TestSystem,
		entity.Version,
		entity.BenchmarkID,
		entity.TailoringFileID,
		entity.Organization,
		entity.IdentityID,
		entity.ProfileID,
		entity.Target,
		entity.TargetAddress,
		entity.TargetFactsID,
		entity.SignatureID,
		entity.TargetIdRefID,
		entity.SetValueID,
		entity.SetComplexValueID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *testResultTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TestResultType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO test_result_type (xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.StartTime,
			entity.EndTime,
			entity.TestSystem,
			entity.Version,
			entity.BenchmarkID,
			entity.TailoringFileID,
			entity.Organization,
			entity.IdentityID,
			entity.ProfileID,
			entity.Target,
			entity.TargetAddress,
			entity.TargetFactsID,
			entity.SignatureID,
			entity.TargetIdRefID,
			entity.SetValueID,
			entity.SetComplexValueID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *testResultTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TestResultType, error) {
	query := "SELECT id, xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id FROM test_result_type WHERE id = ?"

	entity := &parent.TestResultType{}
	var starttimeTime NullTime
	var endtimeTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&starttimeTime,
		&endtimeTime,
		&entity.TestSystem,
		&entity.Version,
		&entity.BenchmarkID,
		&entity.TailoringFileID,
		&entity.Organization,
		&entity.IdentityID,
		&entity.ProfileID,
		&entity.Target,
		&entity.TargetAddress,
		&entity.TargetFactsID,
		&entity.SignatureID,
		&entity.TargetIdRefID,
		&entity.SetValueID,
		&entity.SetComplexValueID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.StartTime = starttimeTime.ToTimePtr()
	entity.EndTime = endtimeTime.Time

	return entity, nil
}

func (r *testResultTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TestResultType, error) {
	query := "SELECT id, xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id FROM test_result_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TestResultType
	for rows.Next() {
		entity := &parent.TestResultType{}
		var starttimeTime NullTime
		var endtimeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&starttimeTime,
			&endtimeTime,
			&entity.TestSystem,
			&entity.Version,
			&entity.BenchmarkID,
			&entity.TailoringFileID,
			&entity.Organization,
			&entity.IdentityID,
			&entity.ProfileID,
			&entity.Target,
			&entity.TargetAddress,
			&entity.TargetFactsID,
			&entity.SignatureID,
			&entity.TargetIdRefID,
			&entity.SetValueID,
			&entity.SetComplexValueID,
		)
		if err != nil {
			return nil, err
		}
		entity.StartTime = starttimeTime.ToTimePtr()
		entity.EndTime = endtimeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *testResultTypeRepository) Update(ctx context.Context, entity *parent.TestResultType) error {
	query := "UPDATE test_result_type SET xsd_id = ?, start_time = ?, end_time = ?, test_system = ?, version = ?, benchmark_id = ?, tailoring_file_id = ?, organization = ?, identity_id = ?, profile_id = ?, target = ?, target_address = ?, target_facts_id = ?, signature_id = ?, target_id_ref_id = ?, set_value_id = ?, set_complex_value_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.StartTime,
		entity.EndTime,
		entity.TestSystem,
		entity.Version,
		entity.BenchmarkID,
		entity.TailoringFileID,
		entity.Organization,
		entity.IdentityID,
		entity.ProfileID,
		entity.Target,
		entity.TargetAddress,
		entity.TargetFactsID,
		entity.SignatureID,
		entity.TargetIdRefID,
		entity.SetValueID,
		entity.SetComplexValueID,
		entity.ID,
	)
	return err
}

func (r *testResultTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM test_result_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *testResultTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM test_result_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *testResultTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM test_result_type").Scan(&count)
	return count, err
}

func (r *testResultTypeRepository) GetByBenchmarkReferenceType(ctx context.Context, benchmark_reference_typeID int64) ([]*parent.TestResultType, error) {
	query := "SELECT id, xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id FROM test_result_type WHERE benchmark_id = ?"

	rows, err := r.db.QueryContext(ctx, query, benchmark_reference_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TestResultType
	for rows.Next() {
		entity := &parent.TestResultType{}
		var starttimeTime NullTime
		var endtimeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&starttimeTime,
			&endtimeTime,
			&entity.TestSystem,
			&entity.Version,
			&entity.BenchmarkID,
			&entity.TailoringFileID,
			&entity.Organization,
			&entity.IdentityID,
			&entity.ProfileID,
			&entity.Target,
			&entity.TargetAddress,
			&entity.TargetFactsID,
			&entity.SignatureID,
			&entity.TargetIdRefID,
			&entity.SetValueID,
			&entity.SetComplexValueID,
		)
		if err != nil {
			return nil, err
		}
		entity.StartTime = starttimeTime.ToTimePtr()
		entity.EndTime = endtimeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *testResultTypeRepository) GetByTailoringReferenceType(ctx context.Context, tailoring_reference_typeID int64) ([]*parent.TestResultType, error) {
	query := "SELECT id, xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id FROM test_result_type WHERE tailoring_file_id = ?"

	rows, err := r.db.QueryContext(ctx, query, tailoring_reference_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TestResultType
	for rows.Next() {
		entity := &parent.TestResultType{}
		var starttimeTime NullTime
		var endtimeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&starttimeTime,
			&endtimeTime,
			&entity.TestSystem,
			&entity.Version,
			&entity.BenchmarkID,
			&entity.TailoringFileID,
			&entity.Organization,
			&entity.IdentityID,
			&entity.ProfileID,
			&entity.Target,
			&entity.TargetAddress,
			&entity.TargetFactsID,
			&entity.SignatureID,
			&entity.TargetIdRefID,
			&entity.SetValueID,
			&entity.SetComplexValueID,
		)
		if err != nil {
			return nil, err
		}
		entity.StartTime = starttimeTime.ToTimePtr()
		entity.EndTime = endtimeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *testResultTypeRepository) GetByIdentityType(ctx context.Context, identity_typeID int64) ([]*parent.TestResultType, error) {
	query := "SELECT id, xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id FROM test_result_type WHERE identity_id = ?"

	rows, err := r.db.QueryContext(ctx, query, identity_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TestResultType
	for rows.Next() {
		entity := &parent.TestResultType{}
		var starttimeTime NullTime
		var endtimeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&starttimeTime,
			&endtimeTime,
			&entity.TestSystem,
			&entity.Version,
			&entity.BenchmarkID,
			&entity.TailoringFileID,
			&entity.Organization,
			&entity.IdentityID,
			&entity.ProfileID,
			&entity.Target,
			&entity.TargetAddress,
			&entity.TargetFactsID,
			&entity.SignatureID,
			&entity.TargetIdRefID,
			&entity.SetValueID,
			&entity.SetComplexValueID,
		)
		if err != nil {
			return nil, err
		}
		entity.StartTime = starttimeTime.ToTimePtr()
		entity.EndTime = endtimeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *testResultTypeRepository) GetByIdrefType(ctx context.Context, idref_typeID int64) ([]*parent.TestResultType, error) {
	query := "SELECT id, xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id FROM test_result_type WHERE profile_id = ?"

	rows, err := r.db.QueryContext(ctx, query, idref_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TestResultType
	for rows.Next() {
		entity := &parent.TestResultType{}
		var starttimeTime NullTime
		var endtimeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&starttimeTime,
			&endtimeTime,
			&entity.TestSystem,
			&entity.Version,
			&entity.BenchmarkID,
			&entity.TailoringFileID,
			&entity.Organization,
			&entity.IdentityID,
			&entity.ProfileID,
			&entity.Target,
			&entity.TargetAddress,
			&entity.TargetFactsID,
			&entity.SignatureID,
			&entity.TargetIdRefID,
			&entity.SetValueID,
			&entity.SetComplexValueID,
		)
		if err != nil {
			return nil, err
		}
		entity.StartTime = starttimeTime.ToTimePtr()
		entity.EndTime = endtimeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *testResultTypeRepository) GetByTargetFactsType(ctx context.Context, target_facts_typeID int64) ([]*parent.TestResultType, error) {
	query := "SELECT id, xsd_id, start_time, end_time, test_system, version, benchmark_id, tailoring_file_id, organization, identity_id, profile_id, target, target_address, target_facts_id, signature_id, target_id_ref_id, set_value_id, set_complex_value_id FROM test_result_type WHERE target_facts_id = ?"

	rows, err := r.db.QueryContext(ctx, query, target_facts_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TestResultType
	for rows.Next() {
		entity := &parent.TestResultType{}
		var starttimeTime NullTime
		var endtimeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&starttimeTime,
			&endtimeTime,
			&entity.TestSystem,
			&entity.Version,
			&entity.BenchmarkID,
			&entity.TailoringFileID,
			&entity.Organization,
			&entity.IdentityID,
			&entity.ProfileID,
			&entity.Target,
			&entity.TargetAddress,
			&entity.TargetFactsID,
			&entity.SignatureID,
			&entity.TargetIdRefID,
			&entity.SetValueID,
			&entity.SetComplexValueID,
		)
		if err != nil {
			return nil, err
		}
		entity.StartTime = starttimeTime.ToTimePtr()
		entity.EndTime = endtimeTime.Time
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) TestType() parent.TestTypeRepository {
	return &testTypeRepository{db: d.db}
}

type testTypeRepository struct {
	db *sql.DB
}

func (r *testTypeRepository) Create(ctx context.Context, entity *parent.TestType) (int64, error) {
	query := "INSERT INTO test_type (xsd_id, version, check_existence, \"check\", state_operator, comment, deprecated) VALUES (?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Check_existence,
		entity.Check,
		entity.State_operator,
		entity.Comment,
		entity.Deprecated,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *testTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TestType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO test_type (xsd_id, version, check_existence, \"check\", state_operator, comment, deprecated) VALUES (?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Version,
			entity.Check_existence,
			entity.Check,
			entity.State_operator,
			entity.Comment,
			entity.Deprecated,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *testTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TestType, error) {
	query := "SELECT id, xsd_id, version, check_existence, \"check\", state_operator, comment, deprecated FROM test_type WHERE id = ?"

	entity := &parent.TestType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Version,
		&entity.Check_existence,
		&entity.Check,
		&entity.State_operator,
		&entity.Comment,
		&entity.Deprecated,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *testTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TestType, error) {
	query := "SELECT id, xsd_id, version, check_existence, \"check\", state_operator, comment, deprecated FROM test_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TestType
	for rows.Next() {
		entity := &parent.TestType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Version,
			&entity.Check_existence,
			&entity.Check,
			&entity.State_operator,
			&entity.Comment,
			&entity.Deprecated,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *testTypeRepository) Update(ctx context.Context, entity *parent.TestType) error {
	query := "UPDATE test_type SET xsd_id = ?, version = ?, check_existence = ?, \"check\" = ?, state_operator = ?, comment = ?, deprecated = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Check_existence,
		entity.Check,
		entity.State_operator,
		entity.Comment,
		entity.Deprecated,
		entity.ID,
	)
	return err
}

func (r *testTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM test_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *testTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM test_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *testTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM test_type").Scan(&count)
	return count, err
}

func (d *dal) TestsType() parent.TestsTypeRepository {
	return &testsTypeRepository{db: d.db}
}

type testsTypeRepository struct {
	db *sql.DB
}

func (r *testsTypeRepository) Create(ctx context.Context, entity *parent.TestsType) (int64, error) {
	query := "INSERT INTO tests_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *testsTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TestsType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO tests_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *testsTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TestsType, error) {
	query := "SELECT id FROM tests_type WHERE id = ?"

	entity := &parent.TestsType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *testsTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TestsType, error) {
	query := "SELECT id FROM tests_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TestsType
	for rows.Next() {
		entity := &parent.TestsType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *testsTypeRepository) Update(ctx context.Context, entity *parent.TestsType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *testsTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM tests_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *testsTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM tests_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *testsTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM tests_type").Scan(&count)
	return count, err
}

func (d *dal) TextWithSubType() parent.TextWithSubTypeRepository {
	return &textWithSubTypeRepository{db: d.db}
}

type textWithSubTypeRepository struct {
	db *sql.DB
}

func (r *textWithSubTypeRepository) Create(ctx context.Context, entity *parent.TextWithSubType) (int64, error) {
	query := "INSERT INTO \"text_with_sub_type\" (override) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Override,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *textWithSubTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TextWithSubType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"text_with_sub_type\" (override) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Override,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *textWithSubTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TextWithSubType, error) {
	query := "SELECT id, override FROM \"text_with_sub_type\" WHERE id = ?"

	entity := &parent.TextWithSubType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Override,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *textWithSubTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TextWithSubType, error) {
	query := "SELECT id, override FROM \"text_with_sub_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TextWithSubType
	for rows.Next() {
		entity := &parent.TextWithSubType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Override,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *textWithSubTypeRepository) Update(ctx context.Context, entity *parent.TextWithSubType) error {
	query := "UPDATE \"text_with_sub_type\" SET override = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Override,
		entity.ID,
	)
	return err
}

func (r *textWithSubTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"text_with_sub_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *textWithSubTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"text_with_sub_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *textWithSubTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"text_with_sub_type\"").Scan(&count)
	return count, err
}

func (d *dal) Thoroughfare() parent.ThoroughfareRepository {
	return &thoroughfareRepository{db: d.db}
}

type thoroughfareRepository struct {
	db *sql.DB
}

func (r *thoroughfareRepository) Create(ctx context.Context, entity *parent.Thoroughfare) (int64, error) {
	query := "INSERT INTO thoroughfare (type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.DependentThoroughfares,
		entity.DependentThoroughfaresIndicator,
		entity.DependentThoroughfaresConnector,
		entity.DependentThoroughfaresType,
		entity.ThoroughfarePreDirectionID,
		entity.ThoroughfareLeadingTypeID,
		entity.ThoroughfareTrailingTypeID,
		entity.ThoroughfarePostDirectionID,
		entity.DependentThoroughfare,
		entity.ThoroughfareNumberRange,
		entity.DependentLocalityID,
		entity.FirmID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareRepository) CreateBatch(ctx context.Context, entities []*parent.Thoroughfare) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare (type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.DependentThoroughfares,
			entity.DependentThoroughfaresIndicator,
			entity.DependentThoroughfaresConnector,
			entity.DependentThoroughfaresType,
			entity.ThoroughfarePreDirectionID,
			entity.ThoroughfareLeadingTypeID,
			entity.ThoroughfareTrailingTypeID,
			entity.ThoroughfarePostDirectionID,
			entity.DependentThoroughfare,
			entity.ThoroughfareNumberRange,
			entity.DependentLocalityID,
			entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareRepository) GetByID(ctx context.Context, id int64) (*parent.Thoroughfare, error) {
	query := "SELECT id, type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id FROM thoroughfare WHERE id = ?"

	entity := &parent.Thoroughfare{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.DependentThoroughfares,
		&entity.DependentThoroughfaresIndicator,
		&entity.DependentThoroughfaresConnector,
		&entity.DependentThoroughfaresType,
		&entity.ThoroughfarePreDirectionID,
		&entity.ThoroughfareLeadingTypeID,
		&entity.ThoroughfareTrailingTypeID,
		&entity.ThoroughfarePostDirectionID,
		&entity.DependentThoroughfare,
		&entity.ThoroughfareNumberRange,
		&entity.DependentLocalityID,
		&entity.FirmID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Thoroughfare, error) {
	query := "SELECT id, type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id FROM thoroughfare LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Thoroughfare
	for rows.Next() {
		entity := &parent.Thoroughfare{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DependentThoroughfares,
			&entity.DependentThoroughfaresIndicator,
			&entity.DependentThoroughfaresConnector,
			&entity.DependentThoroughfaresType,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
			&entity.DependentThoroughfare,
			&entity.ThoroughfareNumberRange,
			&entity.DependentLocalityID,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareRepository) Update(ctx context.Context, entity *parent.Thoroughfare) error {
	query := "UPDATE thoroughfare SET type = ?, dependent_thoroughfares = ?, dependent_thoroughfares_indicator = ?, dependent_thoroughfares_connector = ?, dependent_thoroughfares_type = ?, thoroughfare_pre_direction_id = ?, thoroughfare_leading_type_id = ?, thoroughfare_trailing_type_id = ?, thoroughfare_post_direction_id = ?, dependent_thoroughfare = ?, thoroughfare_number_range = ?, dependent_locality_id = ?, firm_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.DependentThoroughfares,
		entity.DependentThoroughfaresIndicator,
		entity.DependentThoroughfaresConnector,
		entity.DependentThoroughfaresType,
		entity.ThoroughfarePreDirectionID,
		entity.ThoroughfareLeadingTypeID,
		entity.ThoroughfareTrailingTypeID,
		entity.ThoroughfarePostDirectionID,
		entity.DependentThoroughfare,
		entity.ThoroughfareNumberRange,
		entity.DependentLocalityID,
		entity.FirmID,
		entity.ID,
	)
	return err
}

func (r *thoroughfareRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareElementType() parent.ThoroughfareElementTypeRepository {
	return &thoroughfareElementTypeRepository{db: d.db}
}

type thoroughfareElementTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareElementTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareElementType) (int64, error) {
	query := "INSERT INTO thoroughfare_element_type (type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.DependentThoroughfares,
		entity.DependentThoroughfaresIndicator,
		entity.DependentThoroughfaresConnector,
		entity.DependentThoroughfaresType,
		entity.ThoroughfarePreDirectionID,
		entity.ThoroughfareLeadingTypeID,
		entity.ThoroughfareTrailingTypeID,
		entity.ThoroughfarePostDirectionID,
		entity.DependentThoroughfare,
		entity.ThoroughfareNumberRange,
		entity.DependentLocalityID,
		entity.FirmID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_element_type (type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.DependentThoroughfares,
			entity.DependentThoroughfaresIndicator,
			entity.DependentThoroughfaresConnector,
			entity.DependentThoroughfaresType,
			entity.ThoroughfarePreDirectionID,
			entity.ThoroughfareLeadingTypeID,
			entity.ThoroughfareTrailingTypeID,
			entity.ThoroughfarePostDirectionID,
			entity.DependentThoroughfare,
			entity.ThoroughfareNumberRange,
			entity.DependentLocalityID,
			entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareElementType, error) {
	query := "SELECT id, type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id FROM thoroughfare_element_type WHERE id = ?"

	entity := &parent.ThoroughfareElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.DependentThoroughfares,
		&entity.DependentThoroughfaresIndicator,
		&entity.DependentThoroughfaresConnector,
		&entity.DependentThoroughfaresType,
		&entity.ThoroughfarePreDirectionID,
		&entity.ThoroughfareLeadingTypeID,
		&entity.ThoroughfareTrailingTypeID,
		&entity.ThoroughfarePostDirectionID,
		&entity.DependentThoroughfare,
		&entity.ThoroughfareNumberRange,
		&entity.DependentLocalityID,
		&entity.FirmID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareElementType, error) {
	query := "SELECT id, type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id FROM thoroughfare_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareElementType
	for rows.Next() {
		entity := &parent.ThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DependentThoroughfares,
			&entity.DependentThoroughfaresIndicator,
			&entity.DependentThoroughfaresConnector,
			&entity.DependentThoroughfaresType,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
			&entity.DependentThoroughfare,
			&entity.ThoroughfareNumberRange,
			&entity.DependentLocalityID,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareElementTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareElementType) error {
	query := "UPDATE thoroughfare_element_type SET type = ?, dependent_thoroughfares = ?, dependent_thoroughfares_indicator = ?, dependent_thoroughfares_connector = ?, dependent_thoroughfares_type = ?, thoroughfare_pre_direction_id = ?, thoroughfare_leading_type_id = ?, thoroughfare_trailing_type_id = ?, thoroughfare_post_direction_id = ?, dependent_thoroughfare = ?, thoroughfare_number_range = ?, dependent_locality_id = ?, firm_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.DependentThoroughfares,
		entity.DependentThoroughfaresIndicator,
		entity.DependentThoroughfaresConnector,
		entity.DependentThoroughfaresType,
		entity.ThoroughfarePreDirectionID,
		entity.ThoroughfareLeadingTypeID,
		entity.ThoroughfareTrailingTypeID,
		entity.ThoroughfarePostDirectionID,
		entity.DependentThoroughfare,
		entity.ThoroughfareNumberRange,
		entity.DependentLocalityID,
		entity.FirmID,
		entity.ID,
	)
	return err
}

func (r *thoroughfareElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_element_type").Scan(&count)
	return count, err
}

func (r *thoroughfareElementTypeRepository) GetByThoroughfarePreDirectionType(ctx context.Context, thoroughfare_pre_direction_typeID int64) ([]*parent.ThoroughfareElementType, error) {
	query := "SELECT id, type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id FROM thoroughfare_element_type WHERE thoroughfare_pre_direction_id = ?"

	rows, err := r.db.QueryContext(ctx, query, thoroughfare_pre_direction_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareElementType
	for rows.Next() {
		entity := &parent.ThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DependentThoroughfares,
			&entity.DependentThoroughfaresIndicator,
			&entity.DependentThoroughfaresConnector,
			&entity.DependentThoroughfaresType,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
			&entity.DependentThoroughfare,
			&entity.ThoroughfareNumberRange,
			&entity.DependentLocalityID,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareElementTypeRepository) GetByThoroughfareLeadingTypeType(ctx context.Context, thoroughfare_leading_type_typeID int64) ([]*parent.ThoroughfareElementType, error) {
	query := "SELECT id, type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id FROM thoroughfare_element_type WHERE thoroughfare_leading_type_id = ?"

	rows, err := r.db.QueryContext(ctx, query, thoroughfare_leading_type_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareElementType
	for rows.Next() {
		entity := &parent.ThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DependentThoroughfares,
			&entity.DependentThoroughfaresIndicator,
			&entity.DependentThoroughfaresConnector,
			&entity.DependentThoroughfaresType,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
			&entity.DependentThoroughfare,
			&entity.ThoroughfareNumberRange,
			&entity.DependentLocalityID,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareElementTypeRepository) GetByThoroughfareTrailingTypeType(ctx context.Context, thoroughfare_trailing_type_typeID int64) ([]*parent.ThoroughfareElementType, error) {
	query := "SELECT id, type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id FROM thoroughfare_element_type WHERE thoroughfare_trailing_type_id = ?"

	rows, err := r.db.QueryContext(ctx, query, thoroughfare_trailing_type_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareElementType
	for rows.Next() {
		entity := &parent.ThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DependentThoroughfares,
			&entity.DependentThoroughfaresIndicator,
			&entity.DependentThoroughfaresConnector,
			&entity.DependentThoroughfaresType,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
			&entity.DependentThoroughfare,
			&entity.ThoroughfareNumberRange,
			&entity.DependentLocalityID,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareElementTypeRepository) GetByThoroughfarePostDirectionType(ctx context.Context, thoroughfare_post_direction_typeID int64) ([]*parent.ThoroughfareElementType, error) {
	query := "SELECT id, type, dependent_thoroughfares, dependent_thoroughfares_indicator, dependent_thoroughfares_connector, dependent_thoroughfares_type, thoroughfare_pre_direction_id, thoroughfare_leading_type_id, thoroughfare_trailing_type_id, thoroughfare_post_direction_id, dependent_thoroughfare, thoroughfare_number_range, dependent_locality_id, firm_id FROM thoroughfare_element_type WHERE thoroughfare_post_direction_id = ?"

	rows, err := r.db.QueryContext(ctx, query, thoroughfare_post_direction_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareElementType
	for rows.Next() {
		entity := &parent.ThoroughfareElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.DependentThoroughfares,
			&entity.DependentThoroughfaresIndicator,
			&entity.DependentThoroughfaresConnector,
			&entity.DependentThoroughfaresType,
			&entity.ThoroughfarePreDirectionID,
			&entity.ThoroughfareLeadingTypeID,
			&entity.ThoroughfareTrailingTypeID,
			&entity.ThoroughfarePostDirectionID,
			&entity.DependentThoroughfare,
			&entity.ThoroughfareNumberRange,
			&entity.DependentLocalityID,
			&entity.FirmID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) ThoroughfareLeadingTypeType() parent.ThoroughfareLeadingTypeTypeRepository {
	return &thoroughfareLeadingTypeTypeRepository{db: d.db}
}

type thoroughfareLeadingTypeTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareLeadingTypeTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareLeadingTypeType) (int64, error) {
	query := "INSERT INTO thoroughfare_leading_type_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareLeadingTypeTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareLeadingTypeType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_leading_type_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareLeadingTypeTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareLeadingTypeType, error) {
	query := "SELECT id, type FROM thoroughfare_leading_type_type WHERE id = ?"

	entity := &parent.ThoroughfareLeadingTypeType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareLeadingTypeTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareLeadingTypeType, error) {
	query := "SELECT id, type FROM thoroughfare_leading_type_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareLeadingTypeType
	for rows.Next() {
		entity := &parent.ThoroughfareLeadingTypeType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareLeadingTypeTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareLeadingTypeType) error {
	query := "UPDATE thoroughfare_leading_type_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfareLeadingTypeTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_leading_type_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareLeadingTypeTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_leading_type_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareLeadingTypeTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_leading_type_type").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNameType() parent.ThoroughfareNameTypeRepository {
	return &thoroughfareNameTypeRepository{db: d.db}
}

type thoroughfareNameTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareNameTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareNameType) (int64, error) {
	query := "INSERT INTO thoroughfare_name_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNameTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNameType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_name_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNameTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNameType, error) {
	query := "SELECT id, type FROM thoroughfare_name_type WHERE id = ?"

	entity := &parent.ThoroughfareNameType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNameTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNameType, error) {
	query := "SELECT id, type FROM thoroughfare_name_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNameType
	for rows.Next() {
		entity := &parent.ThoroughfareNameType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNameTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareNameType) error {
	query := "UPDATE thoroughfare_name_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfareNameTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_name_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNameTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_name_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNameTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_name_type").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumber() parent.ThoroughfareNumberRepository {
	return &thoroughfareNumberRepository{db: d.db}
}

type thoroughfareNumberRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumber) (int64, error) {
	query := "INSERT INTO thoroughfare_number (number_type, type, indicator, indicator_occurrence, number_occurrence) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberType,
		entity.Type,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumber) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_number (number_type, type, indicator, indicator_occurrence, number_occurrence) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberType,
			entity.Type,
			entity.Indicator,
			entity.IndicatorOccurrence,
			entity.NumberOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumber, error) {
	query := "SELECT id, number_type, type, indicator, indicator_occurrence, number_occurrence FROM thoroughfare_number WHERE id = ?"

	entity := &parent.ThoroughfareNumber{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberType,
		&entity.Type,
		&entity.Indicator,
		&entity.IndicatorOccurrence,
		&entity.NumberOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumber, error) {
	query := "SELECT id, number_type, type, indicator, indicator_occurrence, number_occurrence FROM thoroughfare_number LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumber
	for rows.Next() {
		entity := &parent.ThoroughfareNumber{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberType,
			&entity.Type,
			&entity.Indicator,
			&entity.IndicatorOccurrence,
			&entity.NumberOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumber) error {
	query := "UPDATE thoroughfare_number SET number_type = ?, type = ?, indicator = ?, indicator_occurrence = ?, number_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberType,
		entity.Type,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberOccurrence,
		entity.ID,
	)
	return err
}

func (r *thoroughfareNumberRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_number WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_number WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_number").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumberElementType() parent.ThoroughfareNumberElementTypeRepository {
	return &thoroughfareNumberElementTypeRepository{db: d.db}
}

type thoroughfareNumberElementTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberElementTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumberElementType) (int64, error) {
	query := "INSERT INTO thoroughfare_number_element_type (number_type, type, indicator, indicator_occurrence, number_occurrence) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberType,
		entity.Type,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberOccurrence,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumberElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_number_element_type (number_type, type, indicator, indicator_occurrence, number_occurrence) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberType,
			entity.Type,
			entity.Indicator,
			entity.IndicatorOccurrence,
			entity.NumberOccurrence,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumberElementType, error) {
	query := "SELECT id, number_type, type, indicator, indicator_occurrence, number_occurrence FROM thoroughfare_number_element_type WHERE id = ?"

	entity := &parent.ThoroughfareNumberElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberType,
		&entity.Type,
		&entity.Indicator,
		&entity.IndicatorOccurrence,
		&entity.NumberOccurrence,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumberElementType, error) {
	query := "SELECT id, number_type, type, indicator, indicator_occurrence, number_occurrence FROM thoroughfare_number_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumberElementType
	for rows.Next() {
		entity := &parent.ThoroughfareNumberElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberType,
			&entity.Type,
			&entity.Indicator,
			&entity.IndicatorOccurrence,
			&entity.NumberOccurrence,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberElementTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumberElementType) error {
	query := "UPDATE thoroughfare_number_element_type SET number_type = ?, type = ?, indicator = ?, indicator_occurrence = ?, number_occurrence = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberType,
		entity.Type,
		entity.Indicator,
		entity.IndicatorOccurrence,
		entity.NumberOccurrence,
		entity.ID,
	)
	return err
}

func (r *thoroughfareNumberElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_number_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_number_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_number_element_type").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumberFromElementType() parent.ThoroughfareNumberFromElementTypeRepository {
	return &thoroughfareNumberFromElementTypeRepository{db: d.db}
}

type thoroughfareNumberFromElementTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberFromElementTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumberFromElementType) (int64, error) {
	query := "INSERT INTO \"thoroughfare_number_from_element_type\" DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberFromElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumberFromElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"thoroughfare_number_from_element_type\" DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberFromElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumberFromElementType, error) {
	query := "SELECT id FROM \"thoroughfare_number_from_element_type\" WHERE id = ?"

	entity := &parent.ThoroughfareNumberFromElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberFromElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumberFromElementType, error) {
	query := "SELECT id FROM \"thoroughfare_number_from_element_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumberFromElementType
	for rows.Next() {
		entity := &parent.ThoroughfareNumberFromElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberFromElementTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumberFromElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *thoroughfareNumberFromElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"thoroughfare_number_from_element_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberFromElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"thoroughfare_number_from_element_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberFromElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"thoroughfare_number_from_element_type\"").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumberPrefix() parent.ThoroughfareNumberPrefixRepository {
	return &thoroughfareNumberPrefixRepository{db: d.db}
}

type thoroughfareNumberPrefixRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberPrefixRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumberPrefix) (int64, error) {
	query := "INSERT INTO thoroughfare_number_prefix (number_prefix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberPrefixRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumberPrefix) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_number_prefix (number_prefix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberPrefixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberPrefixRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumberPrefix, error) {
	query := "SELECT id, number_prefix_separator, type FROM thoroughfare_number_prefix WHERE id = ?"

	entity := &parent.ThoroughfareNumberPrefix{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberPrefixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberPrefixRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumberPrefix, error) {
	query := "SELECT id, number_prefix_separator, type FROM thoroughfare_number_prefix LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumberPrefix
	for rows.Next() {
		entity := &parent.ThoroughfareNumberPrefix{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberPrefixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberPrefixRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumberPrefix) error {
	query := "UPDATE thoroughfare_number_prefix SET number_prefix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfareNumberPrefixRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_number_prefix WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberPrefixRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_number_prefix WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberPrefixRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_number_prefix").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumberPrefixElementType() parent.ThoroughfareNumberPrefixElementTypeRepository {
	return &thoroughfareNumberPrefixElementTypeRepository{db: d.db}
}

type thoroughfareNumberPrefixElementTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberPrefixElementTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumberPrefixElementType) (int64, error) {
	query := "INSERT INTO thoroughfare_number_prefix_element_type (number_prefix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberPrefixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumberPrefixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_number_prefix_element_type (number_prefix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberPrefixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberPrefixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumberPrefixElementType, error) {
	query := "SELECT id, number_prefix_separator, type FROM thoroughfare_number_prefix_element_type WHERE id = ?"

	entity := &parent.ThoroughfareNumberPrefixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberPrefixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberPrefixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumberPrefixElementType, error) {
	query := "SELECT id, number_prefix_separator, type FROM thoroughfare_number_prefix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumberPrefixElementType
	for rows.Next() {
		entity := &parent.ThoroughfareNumberPrefixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberPrefixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberPrefixElementTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumberPrefixElementType) error {
	query := "UPDATE thoroughfare_number_prefix_element_type SET number_prefix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberPrefixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfareNumberPrefixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_number_prefix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberPrefixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_number_prefix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberPrefixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_number_prefix_element_type").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumberRangeElementType() parent.ThoroughfareNumberRangeElementTypeRepository {
	return &thoroughfareNumberRangeElementTypeRepository{db: d.db}
}

type thoroughfareNumberRangeElementTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberRangeElementTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumberRangeElementType) (int64, error) {
	query := "INSERT INTO thoroughfare_number_range_element_type (range_type, indicator, separator, indicator_occurrence, number_range_occurrence, type, thoroughfare_number_from, thoroughfare_number_to) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.RangeType,
		entity.Indicator,
		entity.Separator,
		entity.IndicatorOccurrence,
		entity.NumberRangeOccurrence,
		entity.Type,
		entity.ThoroughfareNumberFrom,
		entity.ThoroughfareNumberTo,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberRangeElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumberRangeElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_number_range_element_type (range_type, indicator, separator, indicator_occurrence, number_range_occurrence, type, thoroughfare_number_from, thoroughfare_number_to) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.RangeType,
			entity.Indicator,
			entity.Separator,
			entity.IndicatorOccurrence,
			entity.NumberRangeOccurrence,
			entity.Type,
			entity.ThoroughfareNumberFrom,
			entity.ThoroughfareNumberTo,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberRangeElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumberRangeElementType, error) {
	query := "SELECT id, range_type, indicator, separator, indicator_occurrence, number_range_occurrence, type, thoroughfare_number_from, thoroughfare_number_to FROM thoroughfare_number_range_element_type WHERE id = ?"

	entity := &parent.ThoroughfareNumberRangeElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.RangeType,
		&entity.Indicator,
		&entity.Separator,
		&entity.IndicatorOccurrence,
		&entity.NumberRangeOccurrence,
		&entity.Type,
		&entity.ThoroughfareNumberFrom,
		&entity.ThoroughfareNumberTo,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberRangeElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumberRangeElementType, error) {
	query := "SELECT id, range_type, indicator, separator, indicator_occurrence, number_range_occurrence, type, thoroughfare_number_from, thoroughfare_number_to FROM thoroughfare_number_range_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumberRangeElementType
	for rows.Next() {
		entity := &parent.ThoroughfareNumberRangeElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.RangeType,
			&entity.Indicator,
			&entity.Separator,
			&entity.IndicatorOccurrence,
			&entity.NumberRangeOccurrence,
			&entity.Type,
			&entity.ThoroughfareNumberFrom,
			&entity.ThoroughfareNumberTo,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberRangeElementTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumberRangeElementType) error {
	query := "UPDATE thoroughfare_number_range_element_type SET range_type = ?, indicator = ?, separator = ?, indicator_occurrence = ?, number_range_occurrence = ?, type = ?, thoroughfare_number_from = ?, thoroughfare_number_to = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.RangeType,
		entity.Indicator,
		entity.Separator,
		entity.IndicatorOccurrence,
		entity.NumberRangeOccurrence,
		entity.Type,
		entity.ThoroughfareNumberFrom,
		entity.ThoroughfareNumberTo,
		entity.ID,
	)
	return err
}

func (r *thoroughfareNumberRangeElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_number_range_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberRangeElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_number_range_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberRangeElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_number_range_element_type").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumberSuffix() parent.ThoroughfareNumberSuffixRepository {
	return &thoroughfareNumberSuffixRepository{db: d.db}
}

type thoroughfareNumberSuffixRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberSuffixRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumberSuffix) (int64, error) {
	query := "INSERT INTO thoroughfare_number_suffix (number_suffix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberSuffixRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumberSuffix) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_number_suffix (number_suffix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberSuffixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberSuffixRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumberSuffix, error) {
	query := "SELECT id, number_suffix_separator, type FROM thoroughfare_number_suffix WHERE id = ?"

	entity := &parent.ThoroughfareNumberSuffix{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberSuffixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberSuffixRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumberSuffix, error) {
	query := "SELECT id, number_suffix_separator, type FROM thoroughfare_number_suffix LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumberSuffix
	for rows.Next() {
		entity := &parent.ThoroughfareNumberSuffix{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberSuffixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberSuffixRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumberSuffix) error {
	query := "UPDATE thoroughfare_number_suffix SET number_suffix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfareNumberSuffixRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_number_suffix WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberSuffixRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_number_suffix WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberSuffixRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_number_suffix").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumberSuffixElementType() parent.ThoroughfareNumberSuffixElementTypeRepository {
	return &thoroughfareNumberSuffixElementTypeRepository{db: d.db}
}

type thoroughfareNumberSuffixElementTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberSuffixElementTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumberSuffixElementType) (int64, error) {
	query := "INSERT INTO thoroughfare_number_suffix_element_type (number_suffix_separator, type) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberSuffixElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumberSuffixElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_number_suffix_element_type (number_suffix_separator, type) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.NumberSuffixSeparator,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberSuffixElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumberSuffixElementType, error) {
	query := "SELECT id, number_suffix_separator, type FROM thoroughfare_number_suffix_element_type WHERE id = ?"

	entity := &parent.ThoroughfareNumberSuffixElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.NumberSuffixSeparator,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberSuffixElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumberSuffixElementType, error) {
	query := "SELECT id, number_suffix_separator, type FROM thoroughfare_number_suffix_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumberSuffixElementType
	for rows.Next() {
		entity := &parent.ThoroughfareNumberSuffixElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.NumberSuffixSeparator,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberSuffixElementTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumberSuffixElementType) error {
	query := "UPDATE thoroughfare_number_suffix_element_type SET number_suffix_separator = ?, type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.NumberSuffixSeparator,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfareNumberSuffixElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_number_suffix_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberSuffixElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_number_suffix_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberSuffixElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_number_suffix_element_type").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareNumberToElementType() parent.ThoroughfareNumberToElementTypeRepository {
	return &thoroughfareNumberToElementTypeRepository{db: d.db}
}

type thoroughfareNumberToElementTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareNumberToElementTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareNumberToElementType) (int64, error) {
	query := "INSERT INTO \"thoroughfare_number_to_element_type\" DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareNumberToElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareNumberToElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"thoroughfare_number_to_element_type\" DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareNumberToElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareNumberToElementType, error) {
	query := "SELECT id FROM \"thoroughfare_number_to_element_type\" WHERE id = ?"

	entity := &parent.ThoroughfareNumberToElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareNumberToElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareNumberToElementType, error) {
	query := "SELECT id FROM \"thoroughfare_number_to_element_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareNumberToElementType
	for rows.Next() {
		entity := &parent.ThoroughfareNumberToElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareNumberToElementTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareNumberToElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *thoroughfareNumberToElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"thoroughfare_number_to_element_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareNumberToElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"thoroughfare_number_to_element_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareNumberToElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"thoroughfare_number_to_element_type\"").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfarePostDirectionType() parent.ThoroughfarePostDirectionTypeRepository {
	return &thoroughfarePostDirectionTypeRepository{db: d.db}
}

type thoroughfarePostDirectionTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfarePostDirectionTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfarePostDirectionType) (int64, error) {
	query := "INSERT INTO thoroughfare_post_direction_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfarePostDirectionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfarePostDirectionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_post_direction_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfarePostDirectionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfarePostDirectionType, error) {
	query := "SELECT id, type FROM thoroughfare_post_direction_type WHERE id = ?"

	entity := &parent.ThoroughfarePostDirectionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfarePostDirectionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfarePostDirectionType, error) {
	query := "SELECT id, type FROM thoroughfare_post_direction_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfarePostDirectionType
	for rows.Next() {
		entity := &parent.ThoroughfarePostDirectionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfarePostDirectionTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfarePostDirectionType) error {
	query := "UPDATE thoroughfare_post_direction_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfarePostDirectionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_post_direction_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfarePostDirectionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_post_direction_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfarePostDirectionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_post_direction_type").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfarePreDirectionType() parent.ThoroughfarePreDirectionTypeRepository {
	return &thoroughfarePreDirectionTypeRepository{db: d.db}
}

type thoroughfarePreDirectionTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfarePreDirectionTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfarePreDirectionType) (int64, error) {
	query := "INSERT INTO thoroughfare_pre_direction_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfarePreDirectionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfarePreDirectionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_pre_direction_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfarePreDirectionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfarePreDirectionType, error) {
	query := "SELECT id, type FROM thoroughfare_pre_direction_type WHERE id = ?"

	entity := &parent.ThoroughfarePreDirectionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfarePreDirectionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfarePreDirectionType, error) {
	query := "SELECT id, type FROM thoroughfare_pre_direction_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfarePreDirectionType
	for rows.Next() {
		entity := &parent.ThoroughfarePreDirectionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfarePreDirectionTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfarePreDirectionType) error {
	query := "UPDATE thoroughfare_pre_direction_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfarePreDirectionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_pre_direction_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfarePreDirectionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_pre_direction_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfarePreDirectionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_pre_direction_type").Scan(&count)
	return count, err
}

func (d *dal) ThoroughfareTrailingTypeType() parent.ThoroughfareTrailingTypeTypeRepository {
	return &thoroughfareTrailingTypeTypeRepository{db: d.db}
}

type thoroughfareTrailingTypeTypeRepository struct {
	db *sql.DB
}

func (r *thoroughfareTrailingTypeTypeRepository) Create(ctx context.Context, entity *parent.ThoroughfareTrailingTypeType) (int64, error) {
	query := "INSERT INTO thoroughfare_trailing_type_type (type) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *thoroughfareTrailingTypeTypeRepository) CreateBatch(ctx context.Context, entities []*parent.ThoroughfareTrailingTypeType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO thoroughfare_trailing_type_type (type) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *thoroughfareTrailingTypeTypeRepository) GetByID(ctx context.Context, id int64) (*parent.ThoroughfareTrailingTypeType, error) {
	query := "SELECT id, type FROM thoroughfare_trailing_type_type WHERE id = ?"

	entity := &parent.ThoroughfareTrailingTypeType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *thoroughfareTrailingTypeTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.ThoroughfareTrailingTypeType, error) {
	query := "SELECT id, type FROM thoroughfare_trailing_type_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.ThoroughfareTrailingTypeType
	for rows.Next() {
		entity := &parent.ThoroughfareTrailingTypeType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *thoroughfareTrailingTypeTypeRepository) Update(ctx context.Context, entity *parent.ThoroughfareTrailingTypeType) error {
	query := "UPDATE thoroughfare_trailing_type_type SET type = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.ID,
	)
	return err
}

func (r *thoroughfareTrailingTypeTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM thoroughfare_trailing_type_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *thoroughfareTrailingTypeTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM thoroughfare_trailing_type_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *thoroughfareTrailingTypeTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM thoroughfare_trailing_type_type").Scan(&count)
	return count, err
}

func (d *dal) TimeDifferenceFunctionType() parent.TimeDifferenceFunctionTypeRepository {
	return &timeDifferenceFunctionTypeRepository{db: d.db}
}

type timeDifferenceFunctionTypeRepository struct {
	db *sql.DB
}

func (r *timeDifferenceFunctionTypeRepository) Create(ctx context.Context, entity *parent.TimeDifferenceFunctionType) (int64, error) {
	query := "INSERT INTO time_difference_function_type (format_1, format_2) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Format_1,
		entity.Format_2,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *timeDifferenceFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TimeDifferenceFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO time_difference_function_type (format_1, format_2) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Format_1,
			entity.Format_2,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *timeDifferenceFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TimeDifferenceFunctionType, error) {
	query := "SELECT id, format_1, format_2 FROM time_difference_function_type WHERE id = ?"

	entity := &parent.TimeDifferenceFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Format_1,
		&entity.Format_2,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *timeDifferenceFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TimeDifferenceFunctionType, error) {
	query := "SELECT id, format_1, format_2 FROM time_difference_function_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TimeDifferenceFunctionType
	for rows.Next() {
		entity := &parent.TimeDifferenceFunctionType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Format_1,
			&entity.Format_2,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *timeDifferenceFunctionTypeRepository) Update(ctx context.Context, entity *parent.TimeDifferenceFunctionType) error {
	query := "UPDATE time_difference_function_type SET format_1 = ?, format_2 = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Format_1,
		entity.Format_2,
		entity.ID,
	)
	return err
}

func (r *timeDifferenceFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM time_difference_function_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *timeDifferenceFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM time_difference_function_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *timeDifferenceFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM time_difference_function_type").Scan(&count)
	return count, err
}

func (d *dal) TitleElementType() parent.TitleElementTypeRepository {
	return &titleElementTypeRepository{db: d.db}
}

type titleElementTypeRepository struct {
	db *sql.DB
}

func (r *titleElementTypeRepository) Create(ctx context.Context, entity *parent.TitleElementType) (int64, error) {
	query := "INSERT INTO title_element_type (type, code) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *titleElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TitleElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO title_element_type (type, code) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Type,
			entity.Code,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *titleElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TitleElementType, error) {
	query := "SELECT id, type, code FROM title_element_type WHERE id = ?"

	entity := &parent.TitleElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Type,
		&entity.Code,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *titleElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TitleElementType, error) {
	query := "SELECT id, type, code FROM title_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TitleElementType
	for rows.Next() {
		entity := &parent.TitleElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Type,
			&entity.Code,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *titleElementTypeRepository) Update(ctx context.Context, entity *parent.TitleElementType) error {
	query := "UPDATE title_element_type SET type = ?, code = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Type,
		entity.Code,
		entity.ID,
	)
	return err
}

func (r *titleElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM title_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *titleElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM title_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *titleElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM title_element_type").Scan(&count)
	return count, err
}

func (d *dal) TitleEltType() parent.TitleEltTypeRepository {
	return &titleEltTypeRepository{db: d.db}
}

type titleEltTypeRepository struct {
	db *sql.DB
}

func (r *titleEltTypeRepository) Create(ctx context.Context, entity *parent.TitleEltType) (int64, error) {
	query := "INSERT INTO title_elt_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *titleEltTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TitleEltType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO title_elt_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *titleEltTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TitleEltType, error) {
	query := "SELECT id FROM title_elt_type WHERE id = ?"

	entity := &parent.TitleEltType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *titleEltTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TitleEltType, error) {
	query := "SELECT id FROM title_elt_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TitleEltType
	for rows.Next() {
		entity := &parent.TitleEltType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *titleEltTypeRepository) Update(ctx context.Context, entity *parent.TitleEltType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *titleEltTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM title_elt_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *titleEltTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM title_elt_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *titleEltTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM title_elt_type").Scan(&count)
	return count, err
}

func (d *dal) TransformType() parent.TransformTypeRepository {
	return &transformTypeRepository{db: d.db}
}

type transformTypeRepository struct {
	db *sql.DB
}

func (r *transformTypeRepository) Create(ctx context.Context, entity *parent.TransformType) (int64, error) {
	query := "INSERT INTO transform_type (algorithm, x_path) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Algorithm,
		entity.XPath,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *transformTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TransformType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO transform_type (algorithm, x_path) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Algorithm,
			entity.XPath,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *transformTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TransformType, error) {
	query := "SELECT id, algorithm, x_path FROM transform_type WHERE id = ?"

	entity := &parent.TransformType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Algorithm,
		&entity.XPath,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *transformTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TransformType, error) {
	query := "SELECT id, algorithm, x_path FROM transform_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TransformType
	for rows.Next() {
		entity := &parent.TransformType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Algorithm,
			&entity.XPath,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *transformTypeRepository) Update(ctx context.Context, entity *parent.TransformType) error {
	query := "UPDATE transform_type SET algorithm = ?, x_path = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Algorithm,
		entity.XPath,
		entity.ID,
	)
	return err
}

func (r *transformTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM transform_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *transformTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM transform_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *transformTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM transform_type").Scan(&count)
	return count, err
}

func (d *dal) TransformsType() parent.TransformsTypeRepository {
	return &transformsTypeRepository{db: d.db}
}

type transformsTypeRepository struct {
	db *sql.DB
}

func (r *transformsTypeRepository) Create(ctx context.Context, entity *parent.TransformsType) (int64, error) {
	query := "INSERT INTO transforms_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *transformsTypeRepository) CreateBatch(ctx context.Context, entities []*parent.TransformsType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO transforms_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *transformsTypeRepository) GetByID(ctx context.Context, id int64) (*parent.TransformsType, error) {
	query := "SELECT id FROM transforms_type WHERE id = ?"

	entity := &parent.TransformsType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *transformsTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.TransformsType, error) {
	query := "SELECT id FROM transforms_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.TransformsType
	for rows.Next() {
		entity := &parent.TransformsType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *transformsTypeRepository) Update(ctx context.Context, entity *parent.TransformsType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *transformsTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM transforms_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *transformsTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM transforms_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *transformsTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM transforms_type").Scan(&count)
	return count, err
}

func (d *dal) UniqueFunctionType() parent.UniqueFunctionTypeRepository {
	return &uniqueFunctionTypeRepository{db: d.db}
}

type uniqueFunctionTypeRepository struct {
	db *sql.DB
}

func (r *uniqueFunctionTypeRepository) Create(ctx context.Context, entity *parent.UniqueFunctionType) (int64, error) {
	query := "INSERT INTO \"unique_function_type\" DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *uniqueFunctionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.UniqueFunctionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"unique_function_type\" DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *uniqueFunctionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.UniqueFunctionType, error) {
	query := "SELECT id FROM \"unique_function_type\" WHERE id = ?"

	entity := &parent.UniqueFunctionType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *uniqueFunctionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.UniqueFunctionType, error) {
	query := "SELECT id FROM \"unique_function_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.UniqueFunctionType
	for rows.Next() {
		entity := &parent.UniqueFunctionType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *uniqueFunctionTypeRepository) Update(ctx context.Context, entity *parent.UniqueFunctionType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *uniqueFunctionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"unique_function_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *uniqueFunctionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"unique_function_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *uniqueFunctionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"unique_function_type\"").Scan(&count)
	return count, err
}

func (d *dal) UriRefType() parent.UriRefTypeRepository {
	return &uriRefTypeRepository{db: d.db}
}

type uriRefTypeRepository struct {
	db *sql.DB
}

func (r *uriRefTypeRepository) Create(ctx context.Context, entity *parent.UriRefType) (int64, error) {
	query := "INSERT INTO uri_ref_type (uri) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Uri,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *uriRefTypeRepository) CreateBatch(ctx context.Context, entities []*parent.UriRefType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO uri_ref_type (uri) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Uri,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *uriRefTypeRepository) GetByID(ctx context.Context, id int64) (*parent.UriRefType, error) {
	query := "SELECT id, uri FROM uri_ref_type WHERE id = ?"

	entity := &parent.UriRefType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Uri,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *uriRefTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.UriRefType, error) {
	query := "SELECT id, uri FROM uri_ref_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.UriRefType
	for rows.Next() {
		entity := &parent.UriRefType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Uri,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *uriRefTypeRepository) Update(ctx context.Context, entity *parent.UriRefType) error {
	query := "UPDATE uri_ref_type SET uri = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Uri,
		entity.ID,
	)
	return err
}

func (r *uriRefTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM uri_ref_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *uriRefTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM uri_ref_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *uriRefTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM uri_ref_type").Scan(&count)
	return count, err
}

func (d *dal) UrlElementType() parent.UrlElementTypeRepository {
	return &urlElementTypeRepository{db: d.db}
}

type urlElementTypeRepository struct {
	db *sql.DB
}

func (r *urlElementTypeRepository) Create(ctx context.Context, entity *parent.UrlElementType) (int64, error) {
	query := "INSERT INTO url_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *urlElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.UrlElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO url_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *urlElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.UrlElementType, error) {
	query := "SELECT id FROM url_element_type WHERE id = ?"

	entity := &parent.UrlElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *urlElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.UrlElementType, error) {
	query := "SELECT id FROM url_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.UrlElementType
	for rows.Next() {
		entity := &parent.UrlElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *urlElementTypeRepository) Update(ctx context.Context, entity *parent.UrlElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *urlElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM url_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *urlElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM url_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *urlElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM url_element_type").Scan(&count)
	return count, err
}

func (d *dal) VariableComponentType() parent.VariableComponentTypeRepository {
	return &variableComponentTypeRepository{db: d.db}
}

type variableComponentTypeRepository struct {
	db *sql.DB
}

func (r *variableComponentTypeRepository) Create(ctx context.Context, entity *parent.VariableComponentType) (int64, error) {
	query := "INSERT INTO variable_component_type (var_ref) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Var_ref,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *variableComponentTypeRepository) CreateBatch(ctx context.Context, entities []*parent.VariableComponentType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO variable_component_type (var_ref) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Var_ref,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *variableComponentTypeRepository) GetByID(ctx context.Context, id int64) (*parent.VariableComponentType, error) {
	query := "SELECT id, var_ref FROM variable_component_type WHERE id = ?"

	entity := &parent.VariableComponentType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Var_ref,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *variableComponentTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.VariableComponentType, error) {
	query := "SELECT id, var_ref FROM variable_component_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.VariableComponentType
	for rows.Next() {
		entity := &parent.VariableComponentType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Var_ref,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *variableComponentTypeRepository) Update(ctx context.Context, entity *parent.VariableComponentType) error {
	query := "UPDATE variable_component_type SET var_ref = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Var_ref,
		entity.ID,
	)
	return err
}

func (r *variableComponentTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM variable_component_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *variableComponentTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM variable_component_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *variableComponentTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM variable_component_type").Scan(&count)
	return count, err
}

func (d *dal) VariableType() parent.VariableTypeRepository {
	return &variableTypeRepository{db: d.db}
}

type variableTypeRepository struct {
	db *sql.DB
}

func (r *variableTypeRepository) Create(ctx context.Context, entity *parent.VariableType) (int64, error) {
	query := "INSERT INTO variable_type (xsd_id, version, datatype, comment, deprecated) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Datatype,
		entity.Comment,
		entity.Deprecated,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *variableTypeRepository) CreateBatch(ctx context.Context, entities []*parent.VariableType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO variable_type (xsd_id, version, datatype, comment, deprecated) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Version,
			entity.Datatype,
			entity.Comment,
			entity.Deprecated,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *variableTypeRepository) GetByID(ctx context.Context, id int64) (*parent.VariableType, error) {
	query := "SELECT id, xsd_id, version, datatype, comment, deprecated FROM variable_type WHERE id = ?"

	entity := &parent.VariableType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Version,
		&entity.Datatype,
		&entity.Comment,
		&entity.Deprecated,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *variableTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.VariableType, error) {
	query := "SELECT id, xsd_id, version, datatype, comment, deprecated FROM variable_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.VariableType
	for rows.Next() {
		entity := &parent.VariableType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Version,
			&entity.Datatype,
			&entity.Comment,
			&entity.Deprecated,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *variableTypeRepository) Update(ctx context.Context, entity *parent.VariableType) error {
	query := "UPDATE variable_type SET xsd_id = ?, version = ?, datatype = ?, comment = ?, deprecated = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Version,
		entity.Datatype,
		entity.Comment,
		entity.Deprecated,
		entity.ID,
	)
	return err
}

func (r *variableTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM variable_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *variableTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM variable_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *variableTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM variable_type").Scan(&count)
	return count, err
}

func (d *dal) VariablesType() parent.VariablesTypeRepository {
	return &variablesTypeRepository{db: d.db}
}

type variablesTypeRepository struct {
	db *sql.DB
}

func (r *variablesTypeRepository) Create(ctx context.Context, entity *parent.VariablesType) (int64, error) {
	query := "INSERT INTO variables_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *variablesTypeRepository) CreateBatch(ctx context.Context, entities []*parent.VariablesType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO variables_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *variablesTypeRepository) GetByID(ctx context.Context, id int64) (*parent.VariablesType, error) {
	query := "SELECT id FROM variables_type WHERE id = ?"

	entity := &parent.VariablesType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *variablesTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.VariablesType, error) {
	query := "SELECT id FROM variables_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.VariablesType
	for rows.Next() {
		entity := &parent.VariablesType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *variablesTypeRepository) Update(ctx context.Context, entity *parent.VariablesType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *variablesTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM variables_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *variablesTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM variables_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *variablesTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM variables_type").Scan(&count)
	return count, err
}

func (d *dal) VersionElementType() parent.VersionElementTypeRepository {
	return &versionElementTypeRepository{db: d.db}
}

type versionElementTypeRepository struct {
	db *sql.DB
}

func (r *versionElementTypeRepository) Create(ctx context.Context, entity *parent.VersionElementType) (int64, error) {
	query := "INSERT INTO version_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *versionElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.VersionElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO version_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *versionElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.VersionElementType, error) {
	query := "SELECT id FROM version_element_type WHERE id = ?"

	entity := &parent.VersionElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *versionElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.VersionElementType, error) {
	query := "SELECT id FROM version_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.VersionElementType
	for rows.Next() {
		entity := &parent.VersionElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *versionElementTypeRepository) Update(ctx context.Context, entity *parent.VersionElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *versionElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM version_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *versionElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM version_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *versionElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM version_element_type").Scan(&count)
	return count, err
}

func (d *dal) VersionType() parent.VersionTypeRepository {
	return &versionTypeRepository{db: d.db}
}

type versionTypeRepository struct {
	db *sql.DB
}

func (r *versionTypeRepository) Create(ctx context.Context, entity *parent.VersionType) (int64, error) {
	query := "INSERT INTO version_type (time, \"update\") VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Time,
		entity.Update,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *versionTypeRepository) CreateBatch(ctx context.Context, entities []*parent.VersionType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO version_type (time, \"update\") VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Time,
			entity.Update,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *versionTypeRepository) GetByID(ctx context.Context, id int64) (*parent.VersionType, error) {
	query := "SELECT id, time, \"update\" FROM version_type WHERE id = ?"

	entity := &parent.VersionType{}
	var timeTime NullTime
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&timeTime,
		&entity.Update,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	entity.Time = timeTime.ToTimePtr()

	return entity, nil
}

func (r *versionTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.VersionType, error) {
	query := "SELECT id, time, \"update\" FROM version_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.VersionType
	for rows.Next() {
		entity := &parent.VersionType{}
		var timeTime NullTime
		err := rows.Scan(
			&entity.ID,
			&timeTime,
			&entity.Update,
		)
		if err != nil {
			return nil, err
		}
		entity.Time = timeTime.ToTimePtr()
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *versionTypeRepository) Update(ctx context.Context, entity *parent.VersionType) error {
	query := "UPDATE version_type SET time = ?, \"update\" = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Time,
		entity.Update,
		entity.ID,
	)
	return err
}

func (r *versionTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM version_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *versionTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM version_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *versionTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM version_type").Scan(&count)
	return count, err
}

func (d *dal) WarningType() parent.WarningTypeRepository {
	return &warningTypeRepository{db: d.db}
}

type warningTypeRepository struct {
	db *sql.DB
}

func (r *warningTypeRepository) Create(ctx context.Context, entity *parent.WarningType) (int64, error) {
	query := "INSERT INTO warning_type (category, parent_id) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Category,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *warningTypeRepository) CreateBatch(ctx context.Context, entities []*parent.WarningType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO warning_type (category, parent_id) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Category,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *warningTypeRepository) GetByID(ctx context.Context, id int64) (*parent.WarningType, error) {
	query := "SELECT id, category, parent_id FROM warning_type WHERE id = ?"

	entity := &parent.WarningType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Category,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *warningTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.WarningType, error) {
	query := "SELECT id, category, parent_id FROM warning_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.WarningType
	for rows.Next() {
		entity := &parent.WarningType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Category,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *warningTypeRepository) Update(ctx context.Context, entity *parent.WarningType) error {
	query := "UPDATE warning_type SET category = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Category,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *warningTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM warning_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *warningTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM warning_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *warningTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM warning_type").Scan(&count)
	return count, err
}

func (r *warningTypeRepository) GetByHtmlTextWithSubType(ctx context.Context, html_text_with_sub_typeID int64) ([]*parent.WarningType, error) {
	query := "SELECT id, category, parent_id FROM warning_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, html_text_with_sub_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.WarningType
	for rows.Next() {
		entity := &parent.WarningType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Category,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) WebsiteType() parent.WebsiteTypeRepository {
	return &websiteTypeRepository{db: d.db}
}

type websiteTypeRepository struct {
	db *sql.DB
}

func (r *websiteTypeRepository) Create(ctx context.Context, entity *parent.WebsiteType) (int64, error) {
	query := "INSERT INTO website_type (document_root, locale, parent_id) VALUES (?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.DocumentRoot,
		entity.Locale,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *websiteTypeRepository) CreateBatch(ctx context.Context, entities []*parent.WebsiteType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO website_type (document_root, locale, parent_id) VALUES (?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.DocumentRoot,
			entity.Locale,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *websiteTypeRepository) GetByID(ctx context.Context, id int64) (*parent.WebsiteType, error) {
	query := "SELECT id, document_root, locale, parent_id FROM website_type WHERE id = ?"

	entity := &parent.WebsiteType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.DocumentRoot,
		&entity.Locale,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *websiteTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.WebsiteType, error) {
	query := "SELECT id, document_root, locale, parent_id FROM website_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.WebsiteType
	for rows.Next() {
		entity := &parent.WebsiteType{}
		err := rows.Scan(
			&entity.ID,
			&entity.DocumentRoot,
			&entity.Locale,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *websiteTypeRepository) Update(ctx context.Context, entity *parent.WebsiteType) error {
	query := "UPDATE website_type SET document_root = ?, locale = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.DocumentRoot,
		entity.Locale,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *websiteTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM website_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *websiteTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM website_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *websiteTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM website_type").Scan(&count)
	return count, err
}

func (r *websiteTypeRepository) GetByItAssetType(ctx context.Context, it_asset_typeID int64) ([]*parent.WebsiteType, error) {
	query := "SELECT id, document_root, locale, parent_id FROM website_type WHERE parent_id = ?"

	rows, err := r.db.QueryContext(ctx, query, it_asset_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.WebsiteType
	for rows.Next() {
		entity := &parent.WebsiteType{}
		err := rows.Scan(
			&entity.ID,
			&entity.DocumentRoot,
			&entity.Locale,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) WebsiteUrl() parent.WebsiteUrlRepository {
	return &websiteUrlRepository{db: d.db}
}

type websiteUrlRepository struct {
	db *sql.DB
}

func (r *websiteUrlRepository) Create(ctx context.Context, entity *parent.WebsiteUrl) (int64, error) {
	query := "INSERT INTO website_url DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *websiteUrlRepository) CreateBatch(ctx context.Context, entities []*parent.WebsiteUrl) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO website_url DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *websiteUrlRepository) GetByID(ctx context.Context, id int64) (*parent.WebsiteUrl, error) {
	query := "SELECT id FROM website_url WHERE id = ?"

	entity := &parent.WebsiteUrl{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *websiteUrlRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.WebsiteUrl, error) {
	query := "SELECT id FROM website_url LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.WebsiteUrl
	for rows.Next() {
		entity := &parent.WebsiteUrl{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *websiteUrlRepository) Update(ctx context.Context, entity *parent.WebsiteUrl) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *websiteUrlRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM website_url WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *websiteUrlRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM website_url WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *websiteUrlRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM website_url").Scan(&count)
	return count, err
}

func (d *dal) WebsiteUrlElementType() parent.WebsiteUrlElementTypeRepository {
	return &websiteUrlElementTypeRepository{db: d.db}
}

type websiteUrlElementTypeRepository struct {
	db *sql.DB
}

func (r *websiteUrlElementTypeRepository) Create(ctx context.Context, entity *parent.WebsiteUrlElementType) (int64, error) {
	query := "INSERT INTO website_url_element_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *websiteUrlElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.WebsiteUrlElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO website_url_element_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *websiteUrlElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.WebsiteUrlElementType, error) {
	query := "SELECT id FROM website_url_element_type WHERE id = ?"

	entity := &parent.WebsiteUrlElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *websiteUrlElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.WebsiteUrlElementType, error) {
	query := "SELECT id FROM website_url_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.WebsiteUrlElementType
	for rows.Next() {
		entity := &parent.WebsiteUrlElementType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *websiteUrlElementTypeRepository) Update(ctx context.Context, entity *parent.WebsiteUrlElementType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *websiteUrlElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM website_url_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *websiteUrlElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM website_url_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *websiteUrlElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM website_url_element_type").Scan(&count)
	return count, err
}

func (d *dal) X509DataType() parent.X509DataTypeRepository {
	return &x509DataTypeRepository{db: d.db}
}

type x509DataTypeRepository struct {
	db *sql.DB
}

func (r *x509DataTypeRepository) Create(ctx context.Context, entity *parent.X509DataType) (int64, error) {
	query := "INSERT INTO x509_data_type (x509_issuer_serial_id, x509_s_k_i, x509_subject_name, x509_certificate, x509_c_r_l) VALUES (?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.X509IssuerSerialID,
		entity.X509SKI,
		entity.X509SubjectName,
		entity.X509Certificate,
		entity.X509CRL,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *x509DataTypeRepository) CreateBatch(ctx context.Context, entities []*parent.X509DataType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO x509_data_type (x509_issuer_serial_id, x509_s_k_i, x509_subject_name, x509_certificate, x509_c_r_l) VALUES (?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.X509IssuerSerialID,
			entity.X509SKI,
			entity.X509SubjectName,
			entity.X509Certificate,
			entity.X509CRL,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *x509DataTypeRepository) GetByID(ctx context.Context, id int64) (*parent.X509DataType, error) {
	query := "SELECT id, x509_issuer_serial_id, x509_s_k_i, x509_subject_name, x509_certificate, x509_c_r_l FROM x509_data_type WHERE id = ?"

	entity := &parent.X509DataType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.X509IssuerSerialID,
		&entity.X509SKI,
		&entity.X509SubjectName,
		&entity.X509Certificate,
		&entity.X509CRL,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *x509DataTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.X509DataType, error) {
	query := "SELECT id, x509_issuer_serial_id, x509_s_k_i, x509_subject_name, x509_certificate, x509_c_r_l FROM x509_data_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.X509DataType
	for rows.Next() {
		entity := &parent.X509DataType{}
		err := rows.Scan(
			&entity.ID,
			&entity.X509IssuerSerialID,
			&entity.X509SKI,
			&entity.X509SubjectName,
			&entity.X509Certificate,
			&entity.X509CRL,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *x509DataTypeRepository) Update(ctx context.Context, entity *parent.X509DataType) error {
	query := "UPDATE x509_data_type SET x509_issuer_serial_id = ?, x509_s_k_i = ?, x509_subject_name = ?, x509_certificate = ?, x509_c_r_l = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.X509IssuerSerialID,
		entity.X509SKI,
		entity.X509SubjectName,
		entity.X509Certificate,
		entity.X509CRL,
		entity.ID,
	)
	return err
}

func (r *x509DataTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM x509_data_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *x509DataTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM x509_data_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *x509DataTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM x509_data_type").Scan(&count)
	return count, err
}

func (d *dal) X509IssuerSerialType() parent.X509IssuerSerialTypeRepository {
	return &x509IssuerSerialTypeRepository{db: d.db}
}

type x509IssuerSerialTypeRepository struct {
	db *sql.DB
}

func (r *x509IssuerSerialTypeRepository) Create(ctx context.Context, entity *parent.X509IssuerSerialType) (int64, error) {
	query := "INSERT INTO x509_issuer_serial_type (x509_issuer_name, x509_serial_number) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.X509IssuerName,
		entity.X509SerialNumber,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *x509IssuerSerialTypeRepository) CreateBatch(ctx context.Context, entities []*parent.X509IssuerSerialType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO x509_issuer_serial_type (x509_issuer_name, x509_serial_number) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.X509IssuerName,
			entity.X509SerialNumber,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *x509IssuerSerialTypeRepository) GetByID(ctx context.Context, id int64) (*parent.X509IssuerSerialType, error) {
	query := "SELECT id, x509_issuer_name, x509_serial_number FROM x509_issuer_serial_type WHERE id = ?"

	entity := &parent.X509IssuerSerialType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.X509IssuerName,
		&entity.X509SerialNumber,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *x509IssuerSerialTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.X509IssuerSerialType, error) {
	query := "SELECT id, x509_issuer_name, x509_serial_number FROM x509_issuer_serial_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.X509IssuerSerialType
	for rows.Next() {
		entity := &parent.X509IssuerSerialType{}
		err := rows.Scan(
			&entity.ID,
			&entity.X509IssuerName,
			&entity.X509SerialNumber,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *x509IssuerSerialTypeRepository) Update(ctx context.Context, entity *parent.X509IssuerSerialType) error {
	query := "UPDATE x509_issuer_serial_type SET x509_issuer_name = ?, x509_serial_number = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.X509IssuerName,
		entity.X509SerialNumber,
		entity.ID,
	)
	return err
}

func (r *x509IssuerSerialTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM x509_issuer_serial_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *x509IssuerSerialTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM x509_issuer_serial_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *x509IssuerSerialTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM x509_issuer_serial_type").Scan(&count)
	return count, err
}

func (d *dal) XAL() parent.XALRepository {
	return &xALRepository{db: d.db}
}

type xALRepository struct {
	db *sql.DB
}

func (r *xALRepository) Create(ctx context.Context, entity *parent.XAL) (int64, error) {
	query := "INSERT INTO x_a_l (version) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Version,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xALRepository) CreateBatch(ctx context.Context, entities []*parent.XAL) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO x_a_l (version) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Version,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xALRepository) GetByID(ctx context.Context, id int64) (*parent.XAL, error) {
	query := "SELECT id, version FROM x_a_l WHERE id = ?"

	entity := &parent.XAL{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Version,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xALRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.XAL, error) {
	query := "SELECT id, version FROM x_a_l LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.XAL
	for rows.Next() {
		entity := &parent.XAL{}
		err := rows.Scan(
			&entity.ID,
			&entity.Version,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xALRepository) Update(ctx context.Context, entity *parent.XAL) error {
	query := "UPDATE x_a_l SET version = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Version,
		entity.ID,
	)
	return err
}

func (r *xALRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM x_a_l WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xALRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM x_a_l WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xALRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM x_a_l").Scan(&count)
	return count, err
}

func (d *dal) XALElementType() parent.XALElementTypeRepository {
	return &xALElementTypeRepository{db: d.db}
}

type xALElementTypeRepository struct {
	db *sql.DB
}

func (r *xALElementTypeRepository) Create(ctx context.Context, entity *parent.XALElementType) (int64, error) {
	query := "INSERT INTO x_a_l_element_type (version) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Version,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xALElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.XALElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO x_a_l_element_type (version) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Version,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xALElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.XALElementType, error) {
	query := "SELECT id, version FROM x_a_l_element_type WHERE id = ?"

	entity := &parent.XALElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Version,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xALElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.XALElementType, error) {
	query := "SELECT id, version FROM x_a_l_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.XALElementType
	for rows.Next() {
		entity := &parent.XALElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Version,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xALElementTypeRepository) Update(ctx context.Context, entity *parent.XALElementType) error {
	query := "UPDATE x_a_l_element_type SET version = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Version,
		entity.ID,
	)
	return err
}

func (r *xALElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM x_a_l_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xALElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM x_a_l_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xALElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM x_a_l_element_type").Scan(&count)
	return count, err
}

func (d *dal) XNL() parent.XNLRepository {
	return &xNLRepository{db: d.db}
}

type xNLRepository struct {
	db *sql.DB
}

func (r *xNLRepository) Create(ctx context.Context, entity *parent.XNL) (int64, error) {
	query := "INSERT INTO x_n_l (version) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Version,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xNLRepository) CreateBatch(ctx context.Context, entities []*parent.XNL) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO x_n_l (version) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Version,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xNLRepository) GetByID(ctx context.Context, id int64) (*parent.XNL, error) {
	query := "SELECT id, version FROM x_n_l WHERE id = ?"

	entity := &parent.XNL{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Version,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xNLRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.XNL, error) {
	query := "SELECT id, version FROM x_n_l LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.XNL
	for rows.Next() {
		entity := &parent.XNL{}
		err := rows.Scan(
			&entity.ID,
			&entity.Version,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xNLRepository) Update(ctx context.Context, entity *parent.XNL) error {
	query := "UPDATE x_n_l SET version = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Version,
		entity.ID,
	)
	return err
}

func (r *xNLRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM x_n_l WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xNLRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM x_n_l WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xNLRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM x_n_l").Scan(&count)
	return count, err
}

func (d *dal) XNLElementType() parent.XNLElementTypeRepository {
	return &xNLElementTypeRepository{db: d.db}
}

type xNLElementTypeRepository struct {
	db *sql.DB
}

func (r *xNLElementTypeRepository) Create(ctx context.Context, entity *parent.XNLElementType) (int64, error) {
	query := "INSERT INTO x_n_l_element_type (version) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Version,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xNLElementTypeRepository) CreateBatch(ctx context.Context, entities []*parent.XNLElementType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO x_n_l_element_type (version) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Version,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xNLElementTypeRepository) GetByID(ctx context.Context, id int64) (*parent.XNLElementType, error) {
	query := "SELECT id, version FROM x_n_l_element_type WHERE id = ?"

	entity := &parent.XNLElementType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Version,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xNLElementTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.XNLElementType, error) {
	query := "SELECT id, version FROM x_n_l_element_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.XNLElementType
	for rows.Next() {
		entity := &parent.XNLElementType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Version,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xNLElementTypeRepository) Update(ctx context.Context, entity *parent.XNLElementType) error {
	query := "UPDATE x_n_l_element_type SET version = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Version,
		entity.ID,
	)
	return err
}

func (r *xNLElementTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM x_n_l_element_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xNLElementTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM x_n_l_element_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xNLElementTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM x_n_l_element_type").Scan(&count)
	return count, err
}

func (d *dal) Xccdf12CheckType() parent.Xccdf12CheckTypeRepository {
	return &xccdf12CheckTypeRepository{db: d.db}
}

type xccdf12CheckTypeRepository struct {
	db *sql.DB
}

func (r *xccdf12CheckTypeRepository) Create(ctx context.Context, entity *parent.Xccdf12CheckType) (int64, error) {
	query := "INSERT INTO \"xccdf_1_2_check_type\" (system, negate, xsd_id, selector, multi_check, check_content_id) VALUES (?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.Negate,
		entity.XsdId,
		entity.Selector,
		entity.MultiCheck,
		entity.CheckContentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xccdf12CheckTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Xccdf12CheckType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO \"xccdf_1_2_check_type\" (system, negate, xsd_id, selector, multi_check, check_content_id) VALUES (?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.System,
			entity.Negate,
			entity.XsdId,
			entity.Selector,
			entity.MultiCheck,
			entity.CheckContentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xccdf12CheckTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Xccdf12CheckType, error) {
	query := "SELECT id, system, negate, xsd_id, selector, multi_check, check_content_id FROM \"xccdf_1_2_check_type\" WHERE id = ?"

	entity := &parent.Xccdf12CheckType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.System,
		&entity.Negate,
		&entity.XsdId,
		&entity.Selector,
		&entity.MultiCheck,
		&entity.CheckContentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xccdf12CheckTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Xccdf12CheckType, error) {
	query := "SELECT id, system, negate, xsd_id, selector, multi_check, check_content_id FROM \"xccdf_1_2_check_type\" LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Xccdf12CheckType
	for rows.Next() {
		entity := &parent.Xccdf12CheckType{}
		err := rows.Scan(
			&entity.ID,
			&entity.System,
			&entity.Negate,
			&entity.XsdId,
			&entity.Selector,
			&entity.MultiCheck,
			&entity.CheckContentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xccdf12CheckTypeRepository) Update(ctx context.Context, entity *parent.Xccdf12CheckType) error {
	query := "UPDATE \"xccdf_1_2_check_type\" SET system = ?, negate = ?, xsd_id = ?, selector = ?, multi_check = ?, check_content_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.System,
		entity.Negate,
		entity.XsdId,
		entity.Selector,
		entity.MultiCheck,
		entity.CheckContentID,
		entity.ID,
	)
	return err
}

func (r *xccdf12CheckTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM \"xccdf_1_2_check_type\" WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xccdf12CheckTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM \"xccdf_1_2_check_type\" WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xccdf12CheckTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM \"xccdf_1_2_check_type\"").Scan(&count)
	return count, err
}

func (r *xccdf12CheckTypeRepository) GetByCheckContentType(ctx context.Context, check_content_typeID int64) ([]*parent.Xccdf12CheckType, error) {
	query := "SELECT id, system, negate, xsd_id, selector, multi_check, check_content_id FROM \"xccdf_1_2_check_type\" WHERE check_content_id = ?"

	rows, err := r.db.QueryContext(ctx, query, check_content_typeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Xccdf12CheckType
	for rows.Next() {
		entity := &parent.Xccdf12CheckType{}
		err := rows.Scan(
			&entity.ID,
			&entity.System,
			&entity.Negate,
			&entity.XsdId,
			&entity.Selector,
			&entity.MultiCheck,
			&entity.CheckContentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (d *dal) Xccdf12MessageType() parent.Xccdf12MessageTypeRepository {
	return &xccdf12MessageTypeRepository{db: d.db}
}

type xccdf12MessageTypeRepository struct {
	db *sql.DB
}

func (r *xccdf12MessageTypeRepository) Create(ctx context.Context, entity *parent.Xccdf12MessageType) (int64, error) {
	query := "INSERT INTO xccdf_1_2_message_type (severity) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Severity,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xccdf12MessageTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Xccdf12MessageType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO xccdf_1_2_message_type (severity) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Severity,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xccdf12MessageTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Xccdf12MessageType, error) {
	query := "SELECT id, severity FROM xccdf_1_2_message_type WHERE id = ?"

	entity := &parent.Xccdf12MessageType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Severity,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xccdf12MessageTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Xccdf12MessageType, error) {
	query := "SELECT id, severity FROM xccdf_1_2_message_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Xccdf12MessageType
	for rows.Next() {
		entity := &parent.Xccdf12MessageType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Severity,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xccdf12MessageTypeRepository) Update(ctx context.Context, entity *parent.Xccdf12MessageType) error {
	query := "UPDATE xccdf_1_2_message_type SET severity = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Severity,
		entity.ID,
	)
	return err
}

func (r *xccdf12MessageTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM xccdf_1_2_message_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xccdf12MessageTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM xccdf_1_2_message_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xccdf12MessageTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM xccdf_1_2_message_type").Scan(&count)
	return count, err
}

func (d *dal) Xccdf12MetadataType() parent.Xccdf12MetadataTypeRepository {
	return &xccdf12MetadataTypeRepository{db: d.db}
}

type xccdf12MetadataTypeRepository struct {
	db *sql.DB
}

func (r *xccdf12MetadataTypeRepository) Create(ctx context.Context, entity *parent.Xccdf12MetadataType) (int64, error) {
	query := "INSERT INTO xccdf_1_2_metadata_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xccdf12MetadataTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Xccdf12MetadataType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO xccdf_1_2_metadata_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xccdf12MetadataTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Xccdf12MetadataType, error) {
	query := "SELECT id FROM xccdf_1_2_metadata_type WHERE id = ?"

	entity := &parent.Xccdf12MetadataType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xccdf12MetadataTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Xccdf12MetadataType, error) {
	query := "SELECT id FROM xccdf_1_2_metadata_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Xccdf12MetadataType
	for rows.Next() {
		entity := &parent.Xccdf12MetadataType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xccdf12MetadataTypeRepository) Update(ctx context.Context, entity *parent.Xccdf12MetadataType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *xccdf12MetadataTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM xccdf_1_2_metadata_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xccdf12MetadataTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM xccdf_1_2_metadata_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xccdf12MetadataTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM xccdf_1_2_metadata_type").Scan(&count)
	return count, err
}

func (d *dal) Xccdf12ReferenceType() parent.Xccdf12ReferenceTypeRepository {
	return &xccdf12ReferenceTypeRepository{db: d.db}
}

type xccdf12ReferenceTypeRepository struct {
	db *sql.DB
}

func (r *xccdf12ReferenceTypeRepository) Create(ctx context.Context, entity *parent.Xccdf12ReferenceType) (int64, error) {
	query := "INSERT INTO xccdf_1_2_reference_type (href, override) VALUES (?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.Override,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xccdf12ReferenceTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Xccdf12ReferenceType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO xccdf_1_2_reference_type (href, override) VALUES (?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Href,
			entity.Override,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xccdf12ReferenceTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Xccdf12ReferenceType, error) {
	query := "SELECT id, href, override FROM xccdf_1_2_reference_type WHERE id = ?"

	entity := &parent.Xccdf12ReferenceType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Href,
		&entity.Override,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xccdf12ReferenceTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Xccdf12ReferenceType, error) {
	query := "SELECT id, href, override FROM xccdf_1_2_reference_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Xccdf12ReferenceType
	for rows.Next() {
		entity := &parent.Xccdf12ReferenceType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Href,
			&entity.Override,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xccdf12ReferenceTypeRepository) Update(ctx context.Context, entity *parent.Xccdf12ReferenceType) error {
	query := "UPDATE xccdf_1_2_reference_type SET href = ?, override = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Href,
		entity.Override,
		entity.ID,
	)
	return err
}

func (r *xccdf12ReferenceTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM xccdf_1_2_reference_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xccdf12ReferenceTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM xccdf_1_2_reference_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xccdf12ReferenceTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM xccdf_1_2_reference_type").Scan(&count)
	return count, err
}

func (d *dal) Xccdf12SignatureType() parent.Xccdf12SignatureTypeRepository {
	return &xccdf12SignatureTypeRepository{db: d.db}
}

type xccdf12SignatureTypeRepository struct {
	db *sql.DB
}

func (r *xccdf12SignatureTypeRepository) Create(ctx context.Context, entity *parent.Xccdf12SignatureType) (int64, error) {
	query := "INSERT INTO xccdf_1_2_signature_type DEFAULT VALUES"

	result, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xccdf12SignatureTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Xccdf12SignatureType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO xccdf_1_2_signature_type DEFAULT VALUES"
	for range entities {
		result, err := tx.ExecContext(ctx, query)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xccdf12SignatureTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Xccdf12SignatureType, error) {
	query := "SELECT id FROM xccdf_1_2_signature_type WHERE id = ?"

	entity := &parent.Xccdf12SignatureType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xccdf12SignatureTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Xccdf12SignatureType, error) {
	query := "SELECT id FROM xccdf_1_2_signature_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Xccdf12SignatureType
	for rows.Next() {
		entity := &parent.Xccdf12SignatureType{}
		err := rows.Scan(
			&entity.ID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xccdf12SignatureTypeRepository) Update(ctx context.Context, entity *parent.Xccdf12SignatureType) error {
	// Table has only ID column, nothing to update
	return nil
}

func (r *xccdf12SignatureTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM xccdf_1_2_signature_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xccdf12SignatureTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM xccdf_1_2_signature_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xccdf12SignatureTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM xccdf_1_2_signature_type").Scan(&count)
	return count, err
}

func (d *dal) Xccdf12TextType() parent.Xccdf12TextTypeRepository {
	return &xccdf12TextTypeRepository{db: d.db}
}

type xccdf12TextTypeRepository struct {
	db *sql.DB
}

func (r *xccdf12TextTypeRepository) Create(ctx context.Context, entity *parent.Xccdf12TextType) (int64, error) {
	query := "INSERT INTO xccdf_1_2_text_type (override) VALUES (?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.Override,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xccdf12TextTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Xccdf12TextType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO xccdf_1_2_text_type (override) VALUES (?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.Override,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xccdf12TextTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Xccdf12TextType, error) {
	query := "SELECT id, override FROM xccdf_1_2_text_type WHERE id = ?"

	entity := &parent.Xccdf12TextType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.Override,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xccdf12TextTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Xccdf12TextType, error) {
	query := "SELECT id, override FROM xccdf_1_2_text_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Xccdf12TextType
	for rows.Next() {
		entity := &parent.Xccdf12TextType{}
		err := rows.Scan(
			&entity.ID,
			&entity.Override,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xccdf12TextTypeRepository) Update(ctx context.Context, entity *parent.Xccdf12TextType) error {
	query := "UPDATE xccdf_1_2_text_type SET override = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.Override,
		entity.ID,
	)
	return err
}

func (r *xccdf12TextTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM xccdf_1_2_text_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xccdf12TextTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM xccdf_1_2_text_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xccdf12TextTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM xccdf_1_2_text_type").Scan(&count)
	return count, err
}

func (d *dal) Xccdf12ValueType() parent.Xccdf12ValueTypeRepository {
	return &xccdf12ValueTypeRepository{db: d.db}
}

type xccdf12ValueTypeRepository struct {
	db *sql.DB
}

func (r *xccdf12ValueTypeRepository) Create(ctx context.Context, entity *parent.Xccdf12ValueType) (int64, error) {
	query := "INSERT INTO xccdf_1_2_value_type (xsd_id, type, operator, interactive, interface_hint, signature_id, value_id, complex_value_id, default_id, complex_default_id, parent_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

	result, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Type,
		entity.Operator,
		entity.Interactive,
		entity.InterfaceHint,
		entity.SignatureID,
		entity.ValueID,
		entity.ComplexValueID,
		entity.DefaultID,
		entity.ComplexDefaultID,
		entity.ParentID,
	)
	if err != nil {
		return 0, err
	}

	return result.LastInsertId()
}

func (r *xccdf12ValueTypeRepository) CreateBatch(ctx context.Context, entities []*parent.Xccdf12ValueType) ([]int64, error) {
	ids := make([]int64, 0, len(entities))
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	
	query := "INSERT INTO xccdf_1_2_value_type (xsd_id, type, operator, interactive, interface_hint, signature_id, value_id, complex_value_id, default_id, complex_default_id, parent_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
	for _, entity := range entities {
		result, err := tx.ExecContext(ctx, query,
			entity.XsdId,
			entity.Type,
			entity.Operator,
			entity.Interactive,
			entity.InterfaceHint,
			entity.SignatureID,
			entity.ValueID,
			entity.ComplexValueID,
			entity.DefaultID,
			entity.ComplexDefaultID,
			entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		id, err := result.LastInsertId()
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	
	if err := tx.Commit(); err != nil {
		return nil, err
	}
	
	return ids, nil
}

func (r *xccdf12ValueTypeRepository) GetByID(ctx context.Context, id int64) (*parent.Xccdf12ValueType, error) {
	query := "SELECT id, xsd_id, type, operator, interactive, interface_hint, signature_id, value_id, complex_value_id, default_id, complex_default_id, parent_id FROM xccdf_1_2_value_type WHERE id = ?"

	entity := &parent.Xccdf12ValueType{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&entity.ID,
		&entity.XsdId,
		&entity.Type,
		&entity.Operator,
		&entity.Interactive,
		&entity.InterfaceHint,
		&entity.SignatureID,
		&entity.ValueID,
		&entity.ComplexValueID,
		&entity.DefaultID,
		&entity.ComplexDefaultID,
		&entity.ParentID,
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}

	return entity, nil
}

func (r *xccdf12ValueTypeRepository) GetAll(ctx context.Context, limit, offset int) ([]*parent.Xccdf12ValueType, error) {
	query := "SELECT id, xsd_id, type, operator, interactive, interface_hint, signature_id, value_id, complex_value_id, default_id, complex_default_id, parent_id FROM xccdf_1_2_value_type LIMIT ? OFFSET ?"

	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var entities []*parent.Xccdf12ValueType
	for rows.Next() {
		entity := &parent.Xccdf12ValueType{}
		err := rows.Scan(
			&entity.ID,
			&entity.XsdId,
			&entity.Type,
			&entity.Operator,
			&entity.Interactive,
			&entity.InterfaceHint,
			&entity.SignatureID,
			&entity.ValueID,
			&entity.ComplexValueID,
			&entity.DefaultID,
			&entity.ComplexDefaultID,
			&entity.ParentID,
		)
		if err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

func (r *xccdf12ValueTypeRepository) Update(ctx context.Context, entity *parent.Xccdf12ValueType) error {
	query := "UPDATE xccdf_1_2_value_type SET xsd_id = ?, type = ?, operator = ?, interactive = ?, interface_hint = ?, signature_id = ?, value_id = ?, complex_value_id = ?, default_id = ?, complex_default_id = ?, parent_id = ? WHERE id = ?"
	
	_, err := r.db.ExecContext(ctx, query,
		entity.XsdId,
		entity.Type,
		entity.Operator,
		entity.Interactive,
		entity.InterfaceHint,
		entity.SignatureID,
		entity.ValueID,
		entity.ComplexValueID,
		entity.DefaultID,
		entity.ComplexDefaultID,
		entity.ParentID,
		entity.ID,
	)
	return err
}

func (r *xccdf12ValueTypeRepository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM xccdf_1_2_value_type WHERE id = ?"
	_, err := r.db.ExecContext(ctx, query, id)
	return err
}

func (r *xccdf12ValueTypeRepository) DeleteBatch(ctx context.Context, ids []int64) error {
	if len(ids) == 0 {
		return nil
	}
	
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	
	for _, id := range ids {
		if _, err := tx.ExecContext(ctx, "DELETE FROM xccdf_1_2_value_type WHERE id = ?", id); err != nil {
			return err
		}
	}
	
	return tx.Commit()
}

func (r *xccdf12ValueTypeRepository) Count(ctx context.Context) (int64, error) {
	var count int64
	err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM xccdf_1_2_value_type").Scan(&count)
	return count, err
}


// graphSaver implements parent.GraphSaver interface
type graphSaver struct {
	dal *dal
}

// NewGraphSaver creates a new GraphSaver instance
func (d *dal) NewGraphSaver() parent.GraphSaver {
	return &graphSaver{dal: d}
}

// SaveGraph saves an entity and all its children recursively
// It uses reflection to walk the struct and save parent-child relationships
func (gs *graphSaver) SaveGraph(ctx context.Context, entity interface{}) error {
	tx, err := gs.dal.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	if err := gs.saveEntityGraph(ctx, tx, entity, 0); err != nil {
		return err
	}

	return tx.Commit()
}

// saveEntityGraph recursively saves an entity and its children
func (gs *graphSaver) saveEntityGraph(ctx context.Context, tx *sql.Tx, entity interface{}, parentID int64) error {
	if entity == nil {
		return nil
	}

	v := reflect.ValueOf(entity)
	if v.Kind() == reflect.Ptr {
		if v.IsNil() {
			return nil
		}
		v = v.Elem()
	}

	if v.Kind() != reflect.Struct {
		return fmt.Errorf("entity must be a struct, got %v", v.Kind())
	}

	t := v.Type()
	typeName := t.Name()

	// Get the repository for this type
	repoMethod := reflect.ValueOf(gs.dal).MethodByName(typeName)
	if !repoMethod.IsValid() {
		// Try without "Type" suffix or with "Element" variations
		variations := []string{
			typeName,
			strings.TrimSuffix(typeName, "Type"),
			strings.TrimSuffix(typeName, "ElementType"),
			typeName + "Type",
		}
		for _, name := range variations {
			repoMethod = reflect.ValueOf(gs.dal).MethodByName(name)
			if repoMethod.IsValid() {
				break
			}
		}
	}

	if !repoMethod.IsValid() {
		// No repository for this type, skip
		return nil
	}

	// Get the repository
	repoResults := repoMethod.Call(nil)
	if len(repoResults) == 0 {
		return nil
	}
	repo := repoResults[0]

	// Set parent_id if this entity has one and parentID > 0
	if parentID > 0 {
		parentIDField := v.FieldByName("ParentID")
		if parentIDField.IsValid() && parentIDField.CanSet() {
			if parentIDField.Kind() == reflect.Ptr {
				pid := parentID
				parentIDField.Set(reflect.ValueOf(&pid))
			} else {
				parentIDField.SetInt(parentID)
			}
		}
	}

	// Call Create method on the repository
	createMethod := repo.MethodByName("Create")
	if !createMethod.IsValid() {
		return nil
	}

	// Create the entity
	entityPtr := v.Addr().Interface()
	createResults := createMethod.Call([]reflect.Value{
		reflect.ValueOf(ctx),
		reflect.ValueOf(entityPtr),
	})

	if len(createResults) != 2 {
		return fmt.Errorf("unexpected Create return values")
	}

	// Check for error
	if !createResults[1].IsNil() {
		return createResults[1].Interface().(error)
	}

	// Get the new ID
	newID := createResults[0].Int()

	// Set the ID on the entity
	idField := v.FieldByName("ID")
	if idField.IsValid() && idField.CanSet() {
		idField.SetInt(newID)
	}

	// Now recursively save child slices
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := t.Field(i)

		// Skip unexported fields
		if !field.CanInterface() {
			continue
		}

		// Handle slice fields (children)
		if field.Kind() == reflect.Slice {
			elemType := fieldType.Type.Elem()
			// Skip primitive slices
			if elemType.Kind() != reflect.Struct && 
			   (elemType.Kind() != reflect.Ptr || elemType.Elem().Kind() != reflect.Struct) {
				continue
			}

			for j := 0; j < field.Len(); j++ {
				child := field.Index(j)
				if err := gs.saveEntityGraph(ctx, tx, child.Interface(), newID); err != nil {
					return fmt.Errorf("failed to save child %s[%d]: %w", fieldType.Name, j, err)
				}
			}
		}

		// Handle pointer to struct fields (single child)
		if field.Kind() == reflect.Ptr && !field.IsNil() {
			elem := field.Elem()
			if elem.Kind() == reflect.Struct {
				if err := gs.saveEntityGraph(ctx, tx, field.Interface(), newID); err != nil {
					return fmt.Errorf("failed to save child %s: %w", fieldType.Name, err)
				}
			}
		}
	}

	return nil
}

// LoadGraph loads an entity by type name and ID, populating all child relationships
func (gs *graphSaver) LoadGraph(ctx context.Context, entityType string, id int64) (interface{}, error) {
	// Get the repository for this type
	repoMethod := reflect.ValueOf(gs.dal).MethodByName(entityType)
	if !repoMethod.IsValid() {
		return nil, fmt.Errorf("no repository found for type: %s", entityType)
	}

	// Get the repository
	repoResults := repoMethod.Call(nil)
	if len(repoResults) == 0 {
		return nil, fmt.Errorf("repository method returned no results")
	}
	repo := repoResults[0]

	// Call GetByID method
	getByIDMethod := repo.MethodByName("GetByID")
	if !getByIDMethod.IsValid() {
		return nil, fmt.Errorf("GetByID method not found on repository")
	}

	results := getByIDMethod.Call([]reflect.Value{
		reflect.ValueOf(ctx),
		reflect.ValueOf(id),
	})

	if len(results) != 2 {
		return nil, fmt.Errorf("unexpected GetByID return values")
	}

	// Check for error
	if !results[1].IsNil() {
		return nil, results[1].Interface().(error)
	}

	entity := results[0].Interface()
	if entity == nil {
		return nil, nil
	}

	// Load children recursively
	if err := gs.loadChildren(ctx, entity); err != nil {
		return nil, err
	}

	return entity, nil
}

// loadChildren populates child slices for an entity using FK queries
func (gs *graphSaver) loadChildren(ctx context.Context, entity interface{}) error {
	if entity == nil {
		return nil
	}

	v := reflect.ValueOf(entity)
	if v.Kind() == reflect.Ptr {
		if v.IsNil() {
			return nil
		}
		v = v.Elem()
	}

	if v.Kind() != reflect.Struct {
		return nil
	}

	// Get entity ID
	idField := v.FieldByName("ID")
	if !idField.IsValid() {
		return nil
	}
	parentID := idField.Int()
	if parentID == 0 {
		return nil
	}

	t := v.Type()
	parentTypeName := t.Name()

	// For each slice field, try to load children
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := t.Field(i)

		if !field.CanSet() {
			continue
		}

		if field.Kind() != reflect.Slice {
			continue
		}

		elemType := fieldType.Type.Elem()
		var childTypeName string
		if elemType.Kind() == reflect.Ptr {
			childTypeName = elemType.Elem().Name()
		} else if elemType.Kind() == reflect.Struct {
			childTypeName = elemType.Name()
		} else {
			continue
		}

		// Get repository for child type
		repoMethod := reflect.ValueOf(gs.dal).MethodByName(childTypeName)
		if !repoMethod.IsValid() {
			continue
		}

		repoResults := repoMethod.Call(nil)
		if len(repoResults) == 0 {
			continue
		}
		repo := repoResults[0]

		// Try to find GetByParentType method
		getByParentMethod := repo.MethodByName("GetBy" + parentTypeName)
		if !getByParentMethod.IsValid() {
			// Try without "Type" suffix
			getByParentMethod = repo.MethodByName("GetBy" + strings.TrimSuffix(parentTypeName, "Type"))
		}
		if !getByParentMethod.IsValid() {
			continue
		}

		// Call the method
		results := getByParentMethod.Call([]reflect.Value{
			reflect.ValueOf(ctx),
			reflect.ValueOf(parentID),
		})

		if len(results) != 2 || !results[1].IsNil() {
			continue
		}

		children := results[0]
		if children.IsNil() || children.Len() == 0 {
			continue
		}

		// Set the children on the field
		field.Set(children)

		// Recursively load grandchildren
		for j := 0; j < children.Len(); j++ {
			child := children.Index(j).Interface()
			if err := gs.loadChildren(ctx, child); err != nil {
				return err
			}
		}
	}

	return nil
}
